%
% This file was generated from the LISP module `lisp-doc' by extracting
% the LISP documentation strings of the files
%
%   PLOB:EXAMPLE;plob-example.lisp
%
% as of 1998/12/02 11:04    (year/mm/dd hh:mm)
% Changes done here will be lost.
%
% lisp-doc (C) 1994,1997 Heiko Kirschke
%
\let\tempa\relax%
\ifx\flabel\undefined%
 \let\tempa\endinput%
 Missing document substyle {\tt `crossref.sty'}; ending input.
 \message{^^J^^JMissing document substyle `crossref.sty'; ending input.^^J^^J}%
\fi%
\ifx\Seealsolabel\undefined%
 \let\tempa\endinput%
 Missing document substyle {\tt `lispdoc.sty'}; ending input.
 \message{^^J^^JMissing document substyle `lispdoc.sty'; ending input.^^J^^J}%
\fi%
\tempa\def\tempa{}%

\beginfncom[Internal]{clear-people}

\Syntaxlabel
\Defun {clear-people} {}

Deletes all person data.


\endcom

\begingfcom[External]{close-heap}

\Syntaxlabel
\Defgen {close-heap} {{\opt} {\funarg{with-garbage-collection}}}

\IfFLabelExists{close-heap}
{\SeeAt\ \fcite{close-heap}.}
{\message{^^JUndocumented generic function close-heap.^^J}
\nodefgeneric}


\Methodslabel

\flabel{\protect\mtd}{close-heap :before nil}{}
{\Defmethb {close-heap} {{\opt} {\funarg{with-garbage-collection}}}}

\Purposelabel
 De-initialization: Invalidate the cached value of
 \fcite{*last-name->person-list*}.


\endcom

\beginclcom[Internal]{count-instances}

\Purposelabel
 This is a persistent class for counting its generated instances.

 The class is made persistent by the class option \lisp{(:metaclass
 persistent-metaclass)}; this tells \clos\ to select the
 \plob\ \clsmc\ \class{persistent-metaclass}\ as \cls\ for the
 \clsmo\ which represents the \cls\ \class{count-instances}.
\Seealsolabel
 \Fcite{persistent-metaclass};
 \fcite{(setf slot-extent)}.


\Directslotslabel

\Defdslot {instances} {:accessor instance-count\newline :allocation :class\newline :initform 0\newline :type fixnum}


 The value in this slot is persistent. It is incremented for each
 transient instance created.


\Metaclasslabel
\Defmethod{}{\tt}{\ObjectWithRef{persistent-metaclass}}{}


\endcom

\beginfncom[Internal]{find-people-from-soc-sec-#}

\Syntaxlabel
\Defun {find-people-from-soc-sec-#} {{\funarg{from-soc-sec-#}} {\opt} {\funarg{to-soc-sec-#}}}


\Argumentslabel
 \isa{\funarg{from-soc-sec-\#}\ resp.\ \funarg{to-soc-sec-\#}}
      {an instance of class \class{fixnum}}
\Purposelabel
 Search all persons with their social security numbers being in the range
 \funarg{from-soc-sec-#}\ to (exclusive) \funarg{to-soc-sec-#}.
\Seealsolabel
 \Fcite{p-select}.


\endcom

\beginfncom[Internal]{find-people-with-last-name}

\Syntaxlabel
\Defun {find-people-with-last-name} {{\funarg{last-name}}}


\Argumentslabel
 \isa{\funarg{last-name}}
      {a string}
\Purposelabel
 Search all persons with its last name being \funarg{last-name}.


\endcom

\beginfncom[Internal]{find-person-with-soc-sec-#}

\Syntaxlabel
\Defun {find-person-with-soc-sec-#} {{\funarg{soc-sec-#}}}


\Argumentslabel
 \isa{\funarg{soc-sec-\#}}
      {an instance of class \class{fixnum}}
\Purposelabel
 Search a person by its social security number.
\Seealsolabel
 \Fcite{p-select}.


\endcom

\beginpmcom[Internal]{*first-names*}

\Initialvaluelabel
\begin{CompactCode}
'(("Alan" . m) ("Abraham" . m) ("Andrew" . m) ("Alice" . f) ("Susan" . f)
  ("Bob" . m) ("Hillary" . f) ("Joe" . m) ("Bill" . m) ("Matthew" . m)
  ("Gail" . f) ("Gary" . m) ("Doug" . m) ("Christie" . f) ("Steve" . m)
  ("Elizabeth" . f) ("Melissa" . f) ("Karla" . f) ("Dan" . m) ("Irving" . m))
\end{CompactCode}

\Purposelabel
A list with first names used to create random persons.


\endcom

\begingfcom[External]{initialize-instance}

\Syntaxlabel
\Defgen {initialize-instance} {{\funarg{instance}} {\rest} {\funarg{initargs}}}


 See \fcite{initialize-instance}.


\Methodslabel

\flabel{\protect\mtd}{initialize-instance :after (count-instances)}{}
{\Defmetha {initialize-instance} {(\funarg{object}\ \ObjectWithRef{count-instances}) {\rest} {\funarg{initargs}} \key {\keyarg{objid}}}}

 Increment the number of instances stored in \funarg{object}.

 When the \keyarg{objid}\ argument is given within the object's
 initialization, the object is not really new created but loaded from
 persistent memory.

\flabel{\protect\mtd}{initialize-instance :after (person)}{}
{\Defmetha {initialize-instance} {(\funarg{object}\ \ObjectWithRef{person}) {\rest} {\funarg{all-keys}}}}
Method to maintain the value of \fcite{*last-name->person-list*}.


\endcom

\message{^^JGeneric function instance-count has no methods.^^J}
\message{^^JGeneric function (setf instance-count) has no methods.^^J}
\beginvrcom[Internal]{*last-name->person-list*}

\Initialvaluelabel
\begin{CompactCode}
nil
\end{CompactCode}

\Purposelabel
 A transient \cl\ variable holding a BTree mapping a last name to a
 list of persons with the same last name. The BTree itself is stored
 in the value cell of the persistent symbol
 \lisp{*last-name->person-list*}; its value can be `loaded'
 by the \cl\ macro reader \lisp{\#!*last-name->person-list*}.


\endcom

\beginpmcom[Internal]{*last-names*}

\Initialvaluelabel
\begin{CompactCode}
'("Smith" "Jones" "Peterson" "Williams" "Kennedy" "Johnson" "Riley"
  "Sylversteen" "Wilson" "Cranshaw" "Ryan" "O'Neil" "McAllister")
\end{CompactCode}

\Purposelabel
A list with last names used to create random persons.


\endcom

\beginpmcom[Internal]{*occupations*}

\Initialvaluelabel
\begin{CompactCode}
'("Student" "Baker" "Candlestick Maker" "Engineer" "Hacker" "Tailor" "Cop"
  "Lawyer" "Doctor" "Dentist" "Politician" "Cashier" "Insurance Sales"
  "Advertising")
\end{CompactCode}

\Purposelabel
A list with occupations used to create random persons.


\endcom

\begingfcom[External]{open-heap}

\Syntaxlabel
\Defgen {open-heap} {{\opt} {\funarg{url}}}

\IfFLabelExists{open-heap}
{\SeeAt\ \fcite{open-heap}.}
{\message{^^JUndocumented generic function open-heap.^^J}
\nodefgeneric}


\Methodslabel

\flabel{\protect\mtd}{open-heap :after nil}{}
{\Defmetha {open-heap} {{\opt} {\funarg{url}}}}

\Purposelabel
 Initialization: if the persistent symbol
 \lisp{*last-name->person-list*}\ is not bound,
 it is set to a new persistent btree.


\endcom

\beginclcom[Internal]{person}

\Purposelabel
 A class for persistent person data.
\Seealsolabel
 \Fcite{count-instances}.


\Directsuperclasseslabel
\Defmethod{}{\tt}{(\ObjectWithRef{count-instances})}{}


\Directslotslabel

\Defdslot {first-name} {:initarg :first-name\newline :accessor person-first-name\newline :extent :cached}


 A \slt\ with \lisp{:extent :cached}.
 This means that the \slt\ is represented in both transient and
 persistent memory but its transient state is only saved to persistent
 memory
 \begin{enumerate}
 \item At object initialization (i.e.\ when the object is created and
   \slt[s]\ are initialized with \keyarg{initarg}\ arguments).
 \item By calls to the \fcite{store-object}\ with the object
   (a \class{person}\ instance in this case) to store as argument.
 \end{enumerate}

\Defdslot {last-name} {:initarg :last-name\newline :accessor person-last-name\newline :extent :cached}

\Defdslot {age} {:initarg :age\newline :accessor person-age\newline :extent :cached}


 A \slt\ which once had an \lisp{:extent :persistent}.
 This means that the \slt\ would only be represented in persistent
 memory; each read or write access would be promoted immediately to
 persistent memory (`once' means the
 earlier-non-client/server-version of \plob).

 Since such a representation implies a heavy overhead for each slot
 access, its usage is strongly discouraged now (`now' means compared
 to the earlier-non-client/server-version of \plob).

\Defdslot {sex} {:initarg :sex\newline :accessor person-sex}

\Defdslot {occupation} {:initarg :occupation\newline :accessor person-occupation\newline :extent :cached}

\Defdslot {soc-sec-#} {:initarg :|SOC-SEC-#|\newline :accessor |PERSON-SOC-SEC-#|\newline :extent :cached-write-through\newline :index (btree :test equal :pagesize 32)}


 This slot holds the social security number of a person.

 This is an \lisp{:extent :cached-write-through}\ \slt\ with a BTree
 index defined on it; the \lisp{:test equal}\ option tells the
 BTree to use \lisp{equal}\ testing for key compares. Each write
 access on this \slt\ will insert the new value into a BTree;
 instances can be selected by the \fcite{p-select}.

 The \lisp{:cached-write-through}\ extent is the default
 \slt\ extent for slots of \clos\ objects with
 \lisp{:metaclass persistent-metaclass}\ if no
 \lisp{:extent}\ \slt\ option and no \lisp{:extent}\ class
 option is specified.


\Metaclasslabel
\Defmethod{}{\tt}{\ObjectWithRef{persistent-metaclass}}{}


\Classoptionslabel
\Defmethod{}{\tt}{:extent :cached}{}


\endcom

\message{^^JGeneric function person-age has no methods.^^J}
\message{^^JGeneric function (setf person-age) has no methods.^^J}
\message{^^JGeneric function person-first-name has no methods.^^J}
\message{^^JGeneric function (setf person-first-name) has no methods.^^J}
\message{^^JGeneric function person-last-name has no methods.^^J}
\message{^^JGeneric function (setf person-last-name) has no methods.^^J}
\message{^^JGeneric function person-occupation has no methods.^^J}
\message{^^JGeneric function (setf person-occupation) has no methods.^^J}
\message{^^JGeneric function person-sex has no methods.^^J}
\message{^^JGeneric function (setf person-sex) has no methods.^^J}
\message{^^JGeneric function |PERSON-SOC-SEC-#| has no methods.^^J}
\message{^^JGeneric function (setf |PERSON-SOC-SEC-#|) has no methods.^^J}
\begingfcom[External]{print-object}

\Syntaxlabel
\Defgen {print-object} {{\funarg{instance}} {\funarg{stream}}}


 See \fcite{print-object}.


\Methodslabel

\flabel{\protect\mtd}{print-object (person t)}{}
{\Defmeth {print-object} {(\funarg{object}\ \ObjectWithRef{person}) {\funarg{stream}}}}
%
% No behavior is specified for this method beyond that which is specified
% for the generic function.


\endcom

\beginfncom[Internal]{print-people-by-last-name}

\Syntaxlabel
\Defun {print-people-by-last-name} {}

Print all people stored so far ordered by their last name.


\endcom

\beginfncom[Internal]{print-people-by-soc-sec-#}

\Syntaxlabel
\Defun {print-people-by-soc-sec-#} {}

Print all people stored so far ordered by their social security number.


\endcom

\beginfncom[Internal]{random-element}

\Syntaxlabel
\Defun {random-element} {{\funarg{sequence}}}


\Argumentslabel
 \isa{\funarg{sequence}}
      {a sequence}
\Purposelabel
 Return a random element of \funarg{sequence}.


\endcom

\beginfncom[Internal]{random-name}

\Syntaxlabel
\Defun {random-name} {}


\Valueslabel
 Three values are returned: A first name, a last name and the sex of
 the first name.
\Purposelabel
 Generate a random name.


\endcom

\beginfncom[Internal]{random-person}

\Syntaxlabel
\Defun {random-person} {}

Generate a random persistent person.


\endcom

\beginfncom[Internal]{random-soc-sec-#}

\Syntaxlabel
\Defun {random-soc-sec-#} {}

Generate a random social security number.


\endcom

\beginfncom[Internal]{setup-last-name->person-list}

\Syntaxlabel
\Defun {setup-last-name->person-list} {{\opt} {\funarg{force}}}


\Purposelabel
 Set up a proper persistent object mapping last names to persons.


\endcom

\beginfncom[Internal]{show-transaction}

\Syntaxlabel
\Defun {show-transaction} {}


 Show the usage of transactions.


\endcom

\beginfncom[Internal]{store-n-random-people}

\Syntaxlabel
\Defun {store-n-random-people} {{\funarg{n}}}


\Argumentslabel
 \isa{\funarg{n}}
      {an instance of class \class{fixnum}}
\Purposelabel
 Store \funarg{n}\ random-generated people.


\endcom

