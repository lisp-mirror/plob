%
% This file was generated from the LISP module `lisp-doc' by extracting
% the LISP documentation strings of the files
%
%   PLOB:SOURCE;plob-extra-doc.lisp
%   PLOB:SOURCE;plob-url.lisp
%   PLOB:SOURCE;plob-defaults.lisp
%   PLOB:SOURCE;plob-error.lisp
%   PLOB:SOURCE;plob-extent.lisp
%   PLOB:SOURCE;plob-evolution.lisp
%   PLOB:SOURCE;plob-sysdep.lisp
%   PLOB:SOURCE;plob-metaclass-1.lisp
%   PLOB:SOURCE;plob-metaclass-2.lisp
%   PLOB:SOURCE;plob-metaclass-3.lisp
%   PLOB:SOURCE;plob-defines.lisp
%   PLOB:SOURCE;plob-int.lisp
%   PLOB:SOURCE;plob-low.lisp
%   PLOB:SOURCE;plob-objid-buffer.lisp
%   PLOB:SOURCE;plob-writers.lisp
%   PLOB:SOURCE;plob-heap.lisp
%   PLOB:SOURCE;plob-btree.lisp
%   PLOB:SOURCE;plob-btree-mapper.lisp
%   PLOB:SOURCE;plob-session.lisp
%   PLOB:SOURCE;plob-machine.lisp
%   PLOB:SOURCE;plob-misc.lisp
%   PLOB:SOURCE;plob-cons.lisp
%   PLOB:SOURCE;plob-symbol.lisp
%   PLOB:SOURCE;plob-function.lisp
%   PLOB:SOURCE;plob-vector.lisp
%   PLOB:SOURCE;plob-array.lisp
%   PLOB:SOURCE;plob-string.lisp
%   PLOB:SOURCE;plob-bit-vector.lisp
%   PLOB:SOURCE;plob-numeric.lisp
%   PLOB:SOURCE;plob-struct-descr.lisp
%   PLOB:SOURCE;plob-struct.lisp
%   PLOB:SOURCE;plob-struct-slot-descr.lisp
%   PLOB:SOURCE;plob-struct-hash-table.lisp
%   PLOB:SOURCE;plob-struct-package.lisp
%   PLOB:SOURCE;plob-struct-root.lisp
%   PLOB:SOURCE;plob-clos-descr.lisp
%   PLOB:SOURCE;plob-clos.lisp
%   PLOB:SOURCE;plob-clos-slot-descr.lisp
%   PLOB:SOURCE;plob-clos-slot-value.lisp
%   PLOB:SOURCE;plob-method-descr.lisp
%   PLOB:SOURCE;plob-database.lisp
%   PLOB:SOURCE;plob-builtin.lisp
%   PLOB:SOURCE;plob-inspect.lisp
%   PLOB:SOURCE;plob-bootstrap.lisp
%   PLOB:UTIL;plob-sexpr.lisp
%
% as of 1998/12/02 11:04    (year/mm/dd hh:mm)
% Changes done here will be lost.
%
% lisp-doc (C) 1994,1997 Heiko Kirschke
%
\let\tempa\relax%
\ifx\flabel\undefined%
 \let\tempa\endinput%
 Missing document substyle {\tt `crossref.sty'}; ending input.
 \message{^^J^^JMissing document substyle `crossref.sty'; ending input.^^J^^J}%
\fi%
\ifx\Seealsolabel\undefined%
 \let\tempa\endinput%
 Missing document substyle {\tt `lispdoc.sty'}; ending input.
 \message{^^J^^JMissing document substyle `lispdoc.sty'; ending input.^^J^^J}%
\fi%
\tempa\def\tempa{}%

\begindccom[Class Hierarchy]{Structure Class Hierarchy}

\ClassHierarchyLine{0}{External Structure Class}{t}
\ClassHierarchyLine{1}{External Structure Class}{persistent-object}
\ClassHierarchyLine{2}{External Structure Class}{persistent-heap}
\ClassHierarchyLine{2}{External Structure Class}{persistent-structure}
\ClassHierarchyLine{1}{External Structure Class}{stableheap-configuration}
\ClassHierarchyLine{1}{External Structure Class}{stableheap-statistics}



\endcom

\begindccom[Class Hierarchy]{CLOS Class Hierarchy}

\ClassHierarchyLine{0}{External CLOS Class}{t}
\ClassHierarchyLine{1}{External CLOS Class}{standard-object}
\ClassHierarchyLine{2}{External CLOS Class}{class-description}
\ClassHierarchyLine{2}{External CLOS Class}{metaobject}
\ClassHierarchyLine{3}{External CLOS Class}{class}
\ClassHierarchyLine{4}{External CLOS Class}{standard-class}
\ClassHierarchyLine{5}{External CLOS Class}{persistent-metaclass}
\ClassHierarchyLine{2}{External CLOS Class}{persistent-s-expression}
\ClassHierarchyLine{2}{External CLOS Class}{slot-description}



\endcom

\beginfncom[External]{begin-transaction}

\Syntaxlabel
\Defun {begin-transaction} {{\opt} {\funarg{ignore-error}} {\funarg{p-heap}}}


\Argumentslabel
 \isabool{\funarg{ignore-error}}
\Valueslabel
 Returns a numeric transaction ID iff a transaction was started
 on \funarg{p-heap}, \lispnil\ otherwise.
\Purposelabel
 Start a transaction on \funarg{p-heap}.

 All subsequent lock requests and state changes done on persistent
 objects in the `scope' (i.e.\ \cl\ session, see
 \fcite{*default-persistent-heap*}) of \funarg{p-heap}\ are
 written to the transaction log of \funarg{p-heap}. When the transaction
 on \funarg{p-heap}\ is cancelled, all changed objects are
 brought back to their states at the start of the transaction. When
 the transaction on \funarg{p-heap}\ is cancelled or ended,
 all lock requests are removed from the objects locked in the
 `scope' of \funarg{p-heap}.
\Remarkslabel
 If there is already an active transaction and
 \funarg{ignore-error}\ is \lispnil, an error is signalled;
 if there is already an active transaction and
 \funarg{ignore-error}\ is \nonnil, {\bf begin-transaction}
 simply returns \lispnil.
\Seealsolabel
 \Fcite{with-transaction};
 \fcite{cancel-transaction};
 \fcite{end-transaction};
 \fcite{in-transaction-p};
 \fcite{*default-persistent-heap*};
 \fcite{sh-begin-transaction}.


\endcom

\begindccom[Bootstrap Issues]{bootstrap ...}

 \subsubsection*{Why Bootstrapping at all?}

 %% Hmpf, this sentence is perhaps too silly ...
 % Of course, the \cl\ system and \clos\ are already bootstrapped
 % when \plob\ is started.
 The bootstrap meant here concerns the
 persistent objects contained in the \sh. The class of each persistent
 object in the \sh\ is either built-in or it is represented by its
 {\sl structure} resp.\ {\sl class description object}, analogous to
 \cl\ and \clos\ where each object's class is either built-in or
 represented by its \clsmo.\footnote{\cl\ structure classes are also
 represented, but there is no standard defined for them; so they are more
 ore less hidden in one of the system packages.}

 The bootstrap problems arise from the fact that the description objects
 are either described by themself or contain references to
 other objects whose transitive closure w.r.t.\ contained references
 to other objects leads again to themself,
 e.g.\
 \begin{itemize}

 \item Persistent structures are described by persistent objects
  of \fcite{structure-description}, i.e.\ the description of the
  object representing the \fcite{structure-description}\ points
  to itself.

 \item The names of the structures (and of its slots too) are
  persistent symbols (these are built-in to \plob\ and therefore
  need no special bootstrap handling therefore) which belong
  to persistent packages which are in turn persistent structures.

 \item The slots of structures are described by persistent
  structure objects of \fcite{structure-slot-description}.

 \end{itemize}
 The way to break this circularity of self-describing
 resp.\ -referencing objects for bootstrapping is to use
 `low-level' functions:
 \begin{description}

 \item [Object creation]
  This is done by directly calling the class-specific allocation
  function; since I know exactly what objects have to be created
  to get the system up, there is no need to use the description
  of the object for its creation.

 \item [Object access]
  Similary, object access is done by directly calling the
  class-specific accessor functions.

 \end{description}
 The bootstrap has to be done only for very special objects like
 the \clsdo[s]\ of the \clsdc[es]\ themself.

 \subsubsection*{Storing the description objects themself}

 The very first step to be done for using the \sh\ at all is to store
 the descriptions of the describing objects themself in the initially empty
 \sh; this process is called `formatting the root' and is accomplished
 by the \fcite{format-plob-root}.
 The problems which occure in formatting
 are the above mentioned typical bootstrap problems and are solved
 as indicated:\ the description objects are build up as transient
 objects; afterwards, they are dumped out to the \sh\ by creating
 the persistent objects by calling low-level allocation functions
 and saving their states by calling low-level writer functions.
 The formatting proceeds in phases, where each phase adds a more
 complicated type description to the \sh, e.g.\ in the first phase
 only immediate or simple objects can be stored (since no description
 objects are in the \sh\ in the first phase) whereas after finishing
 the last phase all objects can be saved to the \sh\ (since all
 description objects are in the \sh\ after the last phase).

 This formatting is done exactly once (except the \sh\ is in an
 inconsistent state which makes a re-formatting necessary by calling
 the \fcite{format-plob-root}\ again).

 \subsubsection*{Loading the description objects}

 After the root is formatted, the \sh\ must be opened for using
 it; this process is called `loading the root' and is accomplished
 by the \fcite{open-heap}. Since the transient description
 objects should match exactly their persistent description objects
 found in the
 \sh\ (and not the other way round), there is again a bootstrap
 problem. This is solved by reading the description objects from
 the \sh\ in phases by using low-level read functions.
 Similar to the formatting process, each phase enables reading of more
 complicated persistent objects, e.g.\ in the first phase only
 immediate or simple objects can be read whereas after finishing the
 last phase all objects can be read from the \sh.

 After the bootstrap is done, the objects loaded in the bootstrap
 behave like `normal' objects, i.e.\ they are now accessed using
 their descriptions.
\Seealsolabel
 \Fcite{format-plob-root};
 \fcite{open-heap};
 section \fcite{p-structure-description- ...};
 section \fcite{p-structure-slot-description- ...};
 section \fcite{p-package- ...};
 section \fcite{p-lisproot- ...};
 section \fcite{p-class-description- ...};
 section \fcite{p-slot-description- ...};
 section \fcite{p-method-description- ...};
 section Bootstrap Issues \amopcite{270}.


\endcom

\beginfncom[External]{btree-cached-p}

\Syntaxlabel
\Defun {btree-cached-p} {{\funarg{p-btree}} {\opt} {\funarg{depth}} {\funarg{p-heap}}}


\Argumentslabel
 \isabtree{\funarg{p-btree}}
\Purposelabel
 Returns \nonnil\ if \funarg{p-btree}\ is a
 cached persistent BTree, \lispnil\ otherwise.
\Seealsolabel
 \Fcite{(setf btree-cached-p)};
 argument \keyarg{cached}\ of \fcite{make-btree}.


\endcom

\beginfncom[External]{(setf btree-cached-p)}

\Syntaxlabel
\Defun {(setf btree-cached-p)} {{\funarg{t-cached}} {\funarg{p-btree}} {\opt} {\funarg{depth}} {\funarg{p-heap}}}


\Argumentslabel
 \isabool{\funarg{t-cached}}
 \isabtree{\funarg{p-btree}}
\Purposelabel
 Make \funarg{p-btree}\ a cached persistent BTree for
 \funarg{t-cached}\ \nonnil\, an uncached BTree otherwise.
 The cache becomes active resp.\ de-active next time when
 \funarg{p-btree}\ is loaded from the \sh.
\Seealsolabel
 \Fcite{btree-cached-p};
 argument \keyarg{t-cached}\ of \fcite{make-btree}.


\endcom

\beginfncom[External]{btree-count}

\Syntaxlabel
\Defun {btree-count} {{\funarg{p-btree}} {\opt} {\funarg{p-heap}}}


\Argumentslabel
 \isabtree{\funarg{p-btree}}
\Purposelabel
 Returns the current number of elements in \funarg{p-btree}.
\Seealsolabel
 \Fcite{hash-table-count}.


\endcom

\beginfncom[External]{btree-mapper-search}

\Syntaxlabel
\Defun {btree-mapper-search} {{\funarg{p-mapper}} \key {\keyarg{btree}} {\keyarg{<}} {\keyarg{<=}} {\keyarg{>}} {\keyarg{>=}} {\keyarg{descending}} {\keyarg{depth}} {\keyarg{p-heap}}}


\Argumentslabel
 \isabtree{\keyarg{btree}}
 \isakey{\keyarg{<}\ resp.\ \keyarg{<=}
          \keyarg{>}\ resp.\ \keyarg{>=}}{\keyarg{btree}}
\Purposelabel
 Set the search interval of a btree mapper. The \keyarg{btree}\ argument
 specifies the btree which should be mapped; if no btree is given here,
 the mapper will continue to use the btree it currently refers to.
 The \keyarg{>}\ or \keyarg{>=}\ argument specify the lower
 interval boundary. The \keyarg{<}\ or \keyarg{<=}\ argument
 specify the upper interval boundary.
\Seealsolabel
 \Fcite{make-btree-mapper}, \fcite{btree-mapper-seek}.


\endcom

\beginfncom[External]{btree-mapper-seek}

\Syntaxlabel
\Defun {btree-mapper-seek} {{\funarg{p-mapper}} {\opt} {\funarg{increment}} {\funarg{origin}} {\funarg{depth}} {\funarg{p-heap}}}


\Argumentslabel
 \isanumber{\funarg{increment}}
 \isakeyword{\funarg{origin}}
\Valueslabel
 If there was no key found matching the current search interval,
 \lispnil\ is returned. If there is at least one key within
 the current search interval, up to three values are returned:
 \begin{enumerate}
 \item As first value, the absolute number of the position
   increment is returned, that means, a number which is less
   or equal to \lisp{(abs \funarg{increment})}. A value of 0
   means that the mapper has not changed its current position.
   (Negative numbers are used internally as error conditions
   from the lower C layer.)
 \item If \funarg{depth}\ is \nonnil, the key object of the new
   position is loaded and returned as second value.
 \item If \funarg{depth}\ is \nonnil, the data object of the new
   position is loaded and returned as third value.
 \end{enumerate}
\Purposelabel
 Seek a new current position for \funarg{p-mapper}.
 The \funarg{origin}\ argument must be a symbol out of the set
 \{ \lisp{:set}, \lisp{:current}, \lisp{:end} \}. For \lisp{:set},
 the position in \funarg{increment}\ is searched relative to the
 start of the interval. For \lisp{:current}, the position in
 \funarg{increment}\ is searched relative to the current position
 in the interval. For \lisp{:end}, the position in
 \funarg{increment}\ is searched relative to the end of the interval.
 For getting the current key and data object the mapper refers to,
 call this function with \funarg{increment}\ set to 0. For doing
 only an increment of the mapper's current position, pass the
 \funarg{depth}\ argument as \lispnil.

 An \funarg{origin}\ of \lisp{:current}\ should be used whenever
 possible, since using an \funarg{origin}\ of \lisp{:set}\ or
 \lisp{:end}\ involves at most \funarg{increment}\ iterated
 position changes in the btree mapper.
\Seealsolabel
 \Fcite{make-btree-mapper}, \fcite{btree-mapper-search}.


\endcom

\beginfncom[External]{(setf btree-mapper-seek)}

\Syntaxlabel
\Defun {(setf btree-mapper-seek)} {{\funarg{new-value}} {\funarg{p-mapper}} {\opt} {\funarg{increment}} {\funarg{origin}} {\funarg{depth}} {\funarg{p-heap}}}


\Argumentslabel
 \isanumber{\funarg{increment}}
 \isakeyword{\funarg{origin}}
\Valueslabel
 \retarg{\funarg{new-value}}
\Purposelabel
 Seek a new current position for \funarg{p-mapper}\ and set the
 data entry to \funarg{new-value}.
\Seealsolabel
 \Fcite{btree-mapper-seek}, \fcite{make-btree-mapper}.


\endcom

\beginfncom[External]{btree-maxkey}

\Syntaxlabel
\Defun {btree-maxkey} {{\funarg{p-btree}} {\opt} {\funarg{depth}} {\funarg{p-heap}}}


\Purposelabel
 Get the maximum key contained in \funarg{p-btree}.
\Seealsolabel
 \Fcite{btree-minkey}.


\endcom

\beginfncom[External]{btree-minkey}

\Syntaxlabel
\Defun {btree-minkey} {{\funarg{p-btree}} {\opt} {\funarg{depth}} {\funarg{p-heap}}}


\Purposelabel
 Get the minimum key contained in \funarg{p-btree}.
\Seealsolabel
 \Fcite{btree-maxkey}.


\endcom

\beginfncom[External]{btree-pagesize}

\Syntaxlabel
\Defun {btree-pagesize} {{\funarg{p-btree}} {\opt} {\funarg{p-heap}}}


\Purposelabel
 Return the btree's internal used page size. The page size is the number
 of objects hold on a single btree page.
\Seealsolabel
 \Fcite{(setf btree-pagesize)}.


\endcom

\beginfncom[External]{(setf btree-pagesize)}

\Syntaxlabel
\Defun {(setf btree-pagesize)} {{\funarg{new-value}} {\funarg{p-btree}} {\opt} {\funarg{p-heap}}}


\Purposelabel
 Set the btree's internal used page size. It can only be set for empty
 btrees. The passed size must be an even number between 4 and 2712. 
\Seealsolabel
 \Fcite{btree-pagesize}.


\endcom

\beginfncom[External]{btree-size}

\Syntaxlabel
\Defun {btree-size} {{\funarg{p-btree}} {\opt} {\funarg{p-heap}}}


\Argumentslabel
 \isabtree{\funarg{p-btree}}
\Purposelabel
 Returns the current size of \funarg{p-btree},
 i.e.\ the maximum number of elements
 \funarg{p-btree}\ can hold before a re-size will occure.
\Seealsolabel
 \Fcite{hash-table-size}.


\endcom

\begingfcom[External]{btree-test}

\Syntaxlabel
\Defgen {btree-test} {{\funarg{p-btree}} {\opt} {\funarg{p-heap}}}


\Argumentslabel
 \isabtree{\funarg{p-btree}}
\Purposelabel
 Returns the current test mode for the persistent BTree \funarg{p-btree}.
\Seealsolabel
 \Fcite{(setf btree-test)};
 argument \keyarg{test}\ of \fcite{make-btree}.


\Methodslabel

\flabel{\protect\mtd}{btree-test (t)}{}
{\Defmeth {btree-test} {{\funarg{p-btree}} {\opt} {\funarg{p-heap}}}}
Does a low-level read of the current test mode.


\endcom

\begingfcom[External]{(setf btree-test)}

\Syntaxlabel
\Defgen {(setf btree-test)} {{\funarg{new-test-mode}} {\funarg{p-btree}} {\opt} {\funarg{p-heap}}}


\Argumentslabel
 \isa{\funarg{new-test-mode}}
      {one of the symbols \lisp{eq}, \lisp{eql}\ or \lisp{equal}}
 \isabtree{\funarg{p-btree}}
\Purposelabel
 Sets the test mode of the persistent BTree \funarg{p-btree}\ to
 \funarg{new-test-mode}. The test mode can only be chaged for empty
 BTrees; for non-empty BTrees the test mode is not changed.
\Seealsolabel
 \Fcite{btree-test};
 argument \keyarg{test}\ of \fcite{make-btree}.


\Methodslabel

\flabel{\protect\mtd}{(setf btree-test) :before (t cached-btree)}{}
{\Defmethb {(setf btree-test)} {{\funarg{new-test-mode}} (\funarg{p-btree}\ \ObjectWithRef{cached-btree}) {\opt} {\funarg{p-heap}}}}

Changes the test mode of the cache of the cached persistent BTree
\funarg{p-btree} too.

\flabel{\protect\mtd}{(setf btree-test) (t t)}{}
{\Defmeth {(setf btree-test)} {{\funarg{new-test-mode}} {\funarg{p-btree}} {\opt} {\funarg{p-heap}}}}
Does a low-level write of the current test mode.


\endcom

\beginfncom[External]{cancel-transaction}

\Syntaxlabel
\Defun {cancel-transaction} {{\opt} {\funarg{ignore-error}} {\funarg{p-heap}}}


\Argumentslabel
 \isabool{\funarg{ignore-error}}
\Valueslabel
 Returns the numeric transaction ID of the cancelled transaction
 of \funarg{p-heap}\ iff it was cancelled, \lispnil\ otherwise.
\Purposelabel
 Cancel the current transaction and initiates a rollback.
\Remarkslabel
 If there is no active transaction and
 \funarg{ignore-error}\ is \lispnil, an error is signalled;
 if there is no active transaction and
 \funarg{ignore-error}\ is \nonnil, {\bf cancel-transaction}
 simply returns \lispnil.

 Since cancelling a transaction sets the involved persistent
 objects back to its state at the start of the transaction,
 the transient representations of the persistent objects
 should be rolled-back too; this is not yet implemented.
 Instead, the root caches are cleared by a call to
 \fcite{clear-cache}\ which will cause a complete
 re-creation of the transient representations of the persistent
 objects when referenced next time.
\Seealsolabel
 \Fcite{begin-transaction};
 \fcite{end-transaction};
 \fcite{in-transaction-p};
 \fcite{clear-cache};
 \fcite{sh-cancel-transaction}.


\endcom

\begingfcom[External]{class-constructor}

\Syntaxlabel
\Defgen {class-constructor} {{\funarg{the-class}}}


\Argumentslabel
 \isastrcls{\funarg{the-class}}
\Purposelabel
 Get the constructor function symbol of \funarg{the-class}.
\Seealsolabel
 \Fcite{(setf class-constructor)};
 section \fcite{structure ...};
 argument \keyarg{constructor}\ of \fcite{defstruct}.


\Methodslabel

\flabel{\protect\mtd}{class-constructor (structure-class)}{}
{\Defmeth {class-constructor} {(\funarg{the-class}\ \ObjectWithRef{structure-class})}}

 Return the constructor symbol either as the symbol stored by a top-level
 call to \fcite{(setf class-constructor)}\ or, if this call returned
 \lispnil, try to find the system-generated constructor symbol
 generated from the \lisp{defstruct}\ statement.
\Remarkslabel
 \sysdep{method}

\flabel{\protect\mtd}{class-constructor (structure-description)}{}
{\Defmeth {class-constructor} {(\funarg{class-description}\ \ObjectWithRef{structure-description})}}
Calls to this method are trapped to the system-generated
 structure reader function
 {\bf structure-description-p-constructor}; see also
 \fcite{structure-description}.

\flabel{\protect\mtd}{class-constructor (t)}{}
{\Defmeth {class-constructor} {{\funarg{the-class}}}}
%
% No behavior is specified for this method beyond that which is specified
% for the generic function.


\endcom

\begingfcom[External]{(setf class-constructor)}

\Syntaxlabel
\Defgen {(setf class-constructor)} {{\funarg{new-constructor}} {\funarg{the-class}}}


\Argumentslabel
 \isa{\funarg{new-constructor}}
      {a symbol bound to a function which generates an instance of
       class \funarg{the-class}}
 \isastrcls{\funarg{the-class}}
\Valueslabel
 \retarg{\funarg{new-constructor}}
\Purposelabel
 Set the constructor function of \funarg{the-class}\ to
 \funarg{new-constructor}. The function bound to
 \funarg{new-constructor}\ will be called each time \plob\ loads
 an instance of \funarg{the-class}\ from the persistent
 heap into the transient \cl\ system and must therefore create
 a transient instance of \funarg{the-class}. For each slot of
 \funarg{the-class}, a {\key{}} argument with the keyword being
 the slot name interned to package \lisp{:keyword}\ is passed.

 This function {\bf (setf class-constructor)} is meant to be called
 from top-level to declare the
 constructor function of predefined structure classes found in the
 \cl\ system packages which should be handled by \plob\ and
 whose instances cannot be created by the default constructor function; 
 e.g.\ some structure classes need  a very special handling for
 creating their instances (like mandatory initialization arguments,
 initialization arguments which depend of each other etc.).
\Exampleslabel
 The function {\bf make-logical-pathname-by-plob} should be called by
 \plob\ to create transient instances of class
 \class{logical-pathname}\ instead of the default constructor function
 {\bf make-logical-pathname}\ provided by the transient \cl\ system at
 evaluating the \lisp{defstruct}\ statement:
 \begin{lispcode}
(defun make-logical-pathname-by-plob
     (&key host directory name type version)
  (system::make-logical-pathname-from-components
   host directory name type version))
underline{(setf (class-constructor (find-class 'logical-pathname))
      'make-logical-pathname-by-plob)}
 \end{lispcode}
\Seealsolabel
 \Fcite{class-constructor};
 section \fcite{structure ...};
 argument \keyarg{constructor}\ of \fcite{defstruct}.


\Methodslabel

\flabel{\protect\mtd}{(setf class-constructor) (t t)}{}
{\Defmeth {(setf class-constructor)} {{\funarg{constructor}} {\funarg{the-class}}}}
%
% No behavior is specified for this method beyond that which is specified
% for the generic function.


\endcom

\begingfcom[External]{class-dependent}

\Syntaxlabel
\Defgen {class-dependent} {{\funarg{the-class}}}


\Argumentslabel
 \isastrcls{\funarg{the-class}}
\Purposelabel
 Get the dependent flag of \funarg{the-class}.
\Seealsolabel
 \Fcite{(setf class-dependent)}.


\Methodslabel

\flabel{\protect\mtd}{class-dependent (structure-description)}{}
{\Defmeth {class-dependent} {(\funarg{class-description}\ \ObjectWithRef{structure-description})}}
Calls to this method are trapped to the system-generated
 structure reader function
 {\bf structure-description-p-dependent}; see also
 \fcite{structure-description}.

\flabel{\protect\mtd}{class-dependent (t)}{}
{\Defmeth {class-dependent} {{\funarg{the-class}}}}
%
% No behavior is specified for this method beyond that which is specified
% for the generic function.


\endcom

\begingfcom[External]{(setf class-dependent)}

\Syntaxlabel
\Defgen {(setf class-dependent)} {{\funarg{dependent-flag}} {\funarg{the-class}}}


\Argumentslabel
 \isa{\funarg{dependent-flag}}
      {one of the symbols \lisp{nil}, \lisp{:read},
       \lisp{:write}\ or \lisp{:read-write}}
 \isacls{\funarg{the-class}}
\Valueslabel
 \retarg{\funarg{dependent-flag}}
\Purposelabel
 Set the dependent flag of \funarg{the-class}\ to
 \funarg{dependent-flag}. The dependent flag influences what happens
 if an object references another object which is marked as being
 dependent. When an instance of a class is marked as \lisp{:read}\ and
 another object referencing the marked object is to be transferred from
 the server to the client upon a read request from the client, the marked
 object will be transferred too. This reduces the time necessary for
 transmitting an object state and the state of the objects it references.
 The dependent
 flag is evaluated on object locking, the \lisp{:read}\ flag on
 lock for reading, the \lisp{:write}\ flag on lock for writing,
 \lisp{:read-write}\ on lock for reading or writing. Using the
 \lisp{:read}\ flag might speed up loading of objects which have
 a value-like character with few slots, e.g.\ instances of classes
 representing (goemetric) points. Too exhaustive use of the dependent
 flag might result in big transitive closures being transmitted.

 To Do:
 A better idea would be to do some more bookkeeping on the server side
 on objects cached by the client. The server marks each object which
 has been cached already by the client to avoid a re-transmit. The
 client would request an object not found in its internal cache; it
 sends the request to the server. When the server knows which objects
 are in the client's cache, the server can decide on its own what
 objects in the transitive closure of the requested object are still
 missing at the client.
\Seealsolabel
 \Fcite{class-dependent}.


\Methodslabel

\flabel{\protect\mtd}{(setf class-dependent) (t t)}{}
{\Defmeth {(setf class-dependent)} {{\funarg{dependent}} {\funarg{the-class}}}}
%
% No behavior is specified for this method beyond that which is specified
% for the generic function.

\flabel{\protect\mtd}{(setf class-dependent) :after (t t)}{}
{\Defmetha {(setf class-dependent)} {{\funarg{dependent}} {\funarg{the-class}}}}
%
% No behavior is specified for this method beyond that which is specified
% for the generic function.


\endcom

\beginclcom[External]{class-description}


\Purposelabel
 A class for describing classes in the stable heap.
 It holds only enough information to check if the persistent and transient
 class definitions are equal.
 In the sense of \clos, this class corresponds roughly to the
 \std\ \clsmc\ \class{standard-class}.
\Remarkslabel
 \basecls{class-description}

 Close the persistent heap by calling
 \fcite{close-heap}\ before evaluating this class definition;
 otherwise an infinite recursion will occure because of the
 self-descriptive property of class \class{class-description}.


\Directsuperclasseslabel
\Defmethod{}{\tt}{(\ObjectWithRef{plob-description})}{}


\Directslotslabel

\Defdslot {p-name} {:initform nil\newline :accessor class-description-name\newline :reader class-name\newline :type symbol\newline :location +class-description-location-name+}


 The name of the class as a symbol; comparable with the returned
 value from
 \fcite{class-name}.

\Defdslot {p-superclasses} {:initform nil\newline :accessor class-description-superclasses\newline :reader class-direct-superclasses\newline :type vector\newline :location +class-description-location-superclasses+}


 A vector of instances of \class{class-description}\ with the
 direct superclasses of the class described by this class
 description; comparable with the returned value from
 \fcite{class-direct-superclasses}.

\Defdslot {p-precedence-list} {:initform nil\newline :accessor class-description-precedence-list\newline :reader class-precedence-list\newline :type vector\newline :location +class-description-location-precedence-list+}


 A vector of instances of \class{class-description}\ containing
 the class precedence list of the class
 described by this class description; comparable with the
 returned value from
 \fcite{class-precedence-list}.

\Defdslot {p-metaclass} {:initform nil\newline :accessor class-description-metaclass\newline :location +class-description-location-metaclass+}


 The class as an instance of \class{class-description}\ of
 the class described by this class description;
 comparable with the returned value from
 \lisp{(class-of \textsl{\lt{}described class\gt}\/)}.

\Defdslot {p-version-number} {:initform 100\newline :type fixnum\newline :accessor class-description-version-number\newline :location +class-description-location-version+}


 A schema evolution version number; 100 means version 1.00.
 The number is incremented by 1 for each new version.

\Defdslot {p-time-stamp} {:initform (floor (get-universal-time) 60)\newline :accessor class-description-time-stamp\newline :location +class-description-location-time-stamp+}


 A time stamp when the class description was created. The time stamp
 is in \cl\ Universal Time divided by 60, i.e.\ the time is in
 minutes, not in seconds.

\Defdslot {p-schema-evolution} {:accessor class-description-schema-evolution\newline :initarg :schema-evolution\newline :initform *default-clos-schema-evolution*\newline :type symbol\newline :location +class-description-location-schema-evolution+}


 A symbol describing the type of schema evolution to use for the
 structure;
 see \fcite{schema-evolution}\ and
 \fcite{(setf schema-evolution)}.

\Defdslot {p-next-generation} {:accessor class-description-next-generation\newline :location +class-description-location-next-generation+}


 The next generation of the structure description;
 this is either \lispnil\ or a pointer to an instance of class
 \class{class-description}\ with a higher version number.

\Defdslot {p-direct-methods} {:accessor class-description-direct-methods\newline :reader class-direct-methods\newline :initform nil\newline :location +class-description-location-direct-methods+}


 A vector of instances of \class{method-description}\ containing
 the direct methods of the class
 described by this class description; comparable with the
 returned value from
 \fcite{class-direct-methods}.
 \note\ Although defined, \plob\ stores no method
 descriptions at the moment; see comment at
 \fcite{method-description}.

\Defdslot {p-persistent-slot-numbers} {:accessor class-description-persistent-slot-numbers\newline :initform 0\newline :location +class-description-location-persistent-slot-numbers+}


 The number of persistent slots of the described class.

\Defdslot {p-slot-numbers} {:accessor class-description-slot-numbers\newline :initform 0\newline :location +class-description-location-slot-numbers+}


 The total number of slots of the described structure, i.e.\ the sum
 of the number of persistent slots and the number of transient slots.

\Defdslot {p-direct-slots} {:accessor class-description-direct-slots\newline :reader class-direct-slots\newline :initform nil\newline :location +class-description-location-direct-slots+}


 A vector with instances of
 \fcite{direct-slot-description}\ for each direct slot of the
 described class; comparable with the
 returned value from
 \fcite{class-direct-slots}.

\Defdslot {p-effective-slots} {:accessor class-description-effective-slots\newline :reader class-slots\newline :initform nil\newline :location +class-description-location-effective-slots+}


 A vector with instances of
 \fcite{effective-slot-description}\ for each effective slot of the
 described class; comparable with the
 returned value from
 \fcite{class-slots}.

\Defdslot {p-constructor} {:accessor class-description-constructor\newline :reader class-constructor\newline :initform nil\newline :location +class-description-location-constructor+}


 The name of the instance constructor function as a symbol;
 see \fcite{class-constructor}\ and
 \fcite{(setf class-constructor)}.

\Defdslot {p-dependent} {:accessor class-description-dependent\newline :reader class-dependent\newline :initform nil\newline :location +class-description-location-dependent+}


 The instance dependent flag; see \fcite{class-dependent}\ and
 \fcite{(setf class-dependent)}.

\Defdslot {p-plist} {:accessor class-description-plist\newline :reader class-plist\newline :initform nil\newline :location +class-description-location-plist+}


 The class property list of the described class. For transient
 \clsmo{}s in \lw, it is used to store class-specific
 informations of variable length.

\Defdslot {p-prototype} {:accessor class-description-prototype\newline :initform nil\newline :location +class-description-location-prototype+}


 A persistent prototype object of the class
 described by this class description; comparable with the
 returned value from
 \fcite{class-prototype}.

\Defdslot {t-name->slot-cache} {:accessor class-description-name->slot-cache\newline :initform (make-hash-table :test #'eq)\newline :extent :transient}


 A transient slot with a hash table mapping slot names to
 instances of \fcite{effective-slot-description}.
 It is used for fast
 mapping of a slot name to its corresponding instance of
 \fcite{effective-slot-description}\ in various methods
 of \fcite{slot-value-using-class}\ and
 \fcite{(setf slot-value-using-class)}.

\Defdslot {t-class} {:accessor class-description-class\newline :extent :transient\newline :initform nil}


 A transient slot with the \clsmo\ of the class
 described by this class description.


\Metaclasslabel
\Defmethod{}{\tt}{\ObjectWithRef{persistent-metaclass}}{}


\Classoptionslabel
\Defmethod{}{\tt}{:extent :cached\newline :schema-evolution :no-evolution}{}


\endcom

\message{^^JGeneric function plob::class-description-class has no methods.^^J}
\message{^^JGeneric function (setf plob::class-description-class) has no methods.^^J}
\message{^^JGeneric function plob::class-description-constructor has no methods.^^J}
\message{^^JGeneric function (setf plob::class-description-constructor) has no methods.^^J}
\message{^^JGeneric function plob::class-description-dependent has no methods.^^J}
\message{^^JGeneric function (setf plob::class-description-dependent) has no methods.^^J}
\message{^^JGeneric function plob::class-description-direct-methods has no methods.^^J}
\message{^^JGeneric function (setf plob::class-description-direct-methods) has no methods.^^J}
\message{^^JGeneric function class-description-direct-slots has no methods.^^J}
\message{^^JGeneric function (setf class-description-direct-slots) has no methods.^^J}
\message{^^JGeneric function class-description-effective-slots has no methods.^^J}
\begingfcom[External]{(setf class-description-effective-slots)}

\Syntaxlabel
\Defgen {(setf class-description-effective-slots)} {{\funarg{slots}} {\funarg{class-description}}}


\Argumentslabel
 \isa{\funarg{slots}}
      {a list of instances of
       \fcite{structure-slot-description}\ resp.\ %
       \fcite{effective-slot-description}}
 \isa{\funarg{class-description}}
      {a structure-description or a class-description}
\Purposelabel
 Sets the slots of
 \funarg{class-description}\ to
 \funarg{slots}.
\Seealsolabel
 Slot {\bf p-slots} of \fcite{structure-description};
 slot {\bf p-effective-slots} of \fcite{class-description}.


\Methodslabel

\flabel{\protect\mtd}{(setf class-description-effective-slots) (t structure-description)}{}
{\Defmeth {(setf class-description-effective-slots)} {{\funarg{slots}} (\funarg{class-description}\ \ObjectWithRef{structure-description})}}
Calls to this method are trapped to the system-generated
 structure writer function
 {\bf (setf structure-description-p-slots)}; see also
 \fcite{structure-description}.


\endcom

\message{^^JGeneric function plob::class-description-finalized-p has no methods.^^J}
\message{^^JGeneric function (setf plob::class-description-finalized-p) has no methods.^^J}
\message{^^JGeneric function plob::class-description-metaclass has no methods.^^J}
\message{^^JGeneric function (setf plob::class-description-metaclass) has no methods.^^J}
\message{^^JGeneric function class-description-name has no methods.^^J}
\begingfcom[External]{(setf class-description-name)}

\Syntaxlabel
\Defgen {(setf class-description-name)} {{\funarg{name}} {\funarg{class-description}}}


\Argumentslabel
 \isa{\funarg{name}}
      {a symbol}
 \isa{\funarg{class-description}}
      {a structure-description or a class-description}
\Purposelabel
 Set the name of
 \funarg{class-description}\ to
 \funarg{name}.
\Seealsolabel
 Slot {\bf p-name} of
 \fcite{structure-description}\ resp.\ \fcite{class-description}.


\Methodslabel

\flabel{\protect\mtd}{(setf class-description-name) (t structure-description)}{}
{\Defmeth {(setf class-description-name)} {{\funarg{name}} (\funarg{class-description}\ \ObjectWithRef{structure-description})}}
Calls to this method are trapped to the system-generated
 structure writer function
 {\bf (setf structure-description-p-name)}; see also
 \fcite{structure-description}.


\endcom

\message{^^JGeneric function plob::class-description-name->slot-cache has no methods.^^J}
\message{^^JGeneric function (setf plob::class-description-name->slot-cache) has no methods.^^J}
\begingfcom[External]{class-description-next-generation}

\Syntaxlabel
\Defgen {class-description-next-generation} {{\funarg{class-description}}}


\Argumentslabel
 \isa{\funarg{class-description}}
      {a structure-description or a class-description}
\Purposelabel
 Return the next generation of \funarg{class-description}.
\Seealsolabel
 Slot {\bf p-next-generation} of
 \fcite{structure-description}\ resp.\ \fcite{class-description}.


\Methodslabel

\flabel{\protect\mtd}{class-description-next-generation (structure-description)}{}
{\Defmeth {class-description-next-generation} {(\funarg{class-description}\ \ObjectWithRef{structure-description})}}
Calls to this method are trapped to the system-generated
 structure reader function
 {\bf structure-description-p-next-generation}; see also
 \fcite{structure-description}.


\endcom

\begingfcom[External]{(setf class-description-next-generation)}

\Syntaxlabel
\Defgen {(setf class-description-next-generation)} {{\funarg{next-generation}} {\funarg{class-description}}}


\Argumentslabel
 \isa{\funarg{next-generation}\ resp.\ \funarg{class-description}}
      {a structure-description or a class-description}
\Purposelabel
 Set the next generation of
 \funarg{class-description}\ to
 \funarg{next-generation}.
\Seealsolabel
 Slot {\bf p-next-generation} of
 \fcite{structure-description}\ resp.\ \fcite{class-description}.


\Methodslabel

\flabel{\protect\mtd}{(setf class-description-next-generation) (t structure-description)}{}
{\Defmeth {(setf class-description-next-generation)} {{\funarg{next-generation}} (\funarg{class-description}\ \ObjectWithRef{structure-description})}}
Calls to this method are trapped to the system-generated
 structure writer function
 {\bf (setf structure-description-p-next-generation)}; see also
 \fcite{structure-description}.


\endcom

\message{^^JGeneric function plob::class-description-of has no methods.^^J}
\message{^^JGeneric function (setf plob::class-description-of) has no methods.^^J}
\begingfcom[External]{class-description-persistent-slot-numbers}

\Syntaxlabel
\Defgen {class-description-persistent-slot-numbers} {{\funarg{class-description}}}


\Argumentslabel
 \isa{\funarg{class-description}}
      {a structure-description or a class-description}
\Purposelabel
 Return the number of persistent slots of \funarg{class-description}.
\Seealsolabel
 Slot {\bf p-persistent-slot-numbers} of
 \fcite{structure-description}\ resp.\ \fcite{class-description}.


\Methodslabel

\flabel{\protect\mtd}{class-description-persistent-slot-numbers (structure-description)}{}
{\Defmeth {class-description-persistent-slot-numbers} {(\funarg{class-description}\ \ObjectWithRef{structure-description})}}
Calls to this method are trapped to the system-generated
 structure reader function
 {\bf structure-description-p-persistent-slot-numbers}; see also
 \fcite{structure-description}.


\endcom

\begingfcom[External]{(setf class-description-persistent-slot-numbers)}

\Syntaxlabel
\Defgen {(setf class-description-persistent-slot-numbers)} {{\funarg{persistent-slot-numbers}} {\funarg{class-description}}}


\Argumentslabel
 \isa{\funarg{persistent-slot-numbers}}
      {a fixnum}
 \isa{\funarg{class-description}}
      {a structure-description or a class-description}
\Purposelabel
 Set the number of persistent slots of
 \funarg{class-description}\ to
 \funarg{persistent-slot-numbers}.
\Seealsolabel
 Slot {\bf p-persistent-slot-numbers} of
 \fcite{structure-description}\ resp.\ \fcite{class-description}.


\Methodslabel

\flabel{\protect\mtd}{(setf class-description-persistent-slot-numbers) (t structure-description)}{}
{\Defmeth {(setf class-description-persistent-slot-numbers)} {{\funarg{persistent-slot-numbers}} (\funarg{class-description}\ \ObjectWithRef{structure-description})}}
Calls to this method are trapped to the system-generated
 structure writer function
 {\bf (setf structure-description-p-persistent-slot-numbers)}; see also
 \fcite{structure-description}.


\endcom

\message{^^JGeneric function plob::class-description-plist has no methods.^^J}
\message{^^JGeneric function (setf plob::class-description-plist) has no methods.^^J}
\message{^^JGeneric function plob::class-description-precedence-list has no methods.^^J}
\message{^^JGeneric function (setf plob::class-description-precedence-list) has no methods.^^J}
\message{^^JGeneric function plob::class-description-prototype has no methods.^^J}
\message{^^JGeneric function (setf plob::class-description-prototype) has no methods.^^J}
\begingfcom[External]{class-description-schema-evolution}

\Syntaxlabel
\Defgen {class-description-schema-evolution} {{\funarg{class-description}}}


\Argumentslabel
 \isa{\funarg{class-description}}
      {a structure-description or a class-description}
\Purposelabel
 Return the schema evolution of \funarg{class-description}.
\Seealsolabel
 Slot {\bf p-schema-evolution} of
 \fcite{structure-description}\ resp.\ \fcite{class-description}.


\Methodslabel

\flabel{\protect\mtd}{class-description-schema-evolution (structure-description)}{}
{\Defmeth {class-description-schema-evolution} {(\funarg{class-description}\ \ObjectWithRef{structure-description})}}
Calls to this method are trapped to the system-generated
 structure reader function
 {\bf structure-description-p-schema-evolution}; see also
 \fcite{structure-description}.


\endcom

\begingfcom[External]{(setf class-description-schema-evolution)}

\Syntaxlabel
\Defgen {(setf class-description-schema-evolution)} {{\funarg{schema-evolution}} {\funarg{class-description}}}


\Argumentslabel
 \isa{\funarg{schema-evolution}}
      {a keyword symbol}
 \isa{\funarg{class-description}}
      {a structure-description or a class-description}
\Purposelabel
 Set the schema evolution of
 \funarg{class-description}\ to
 \funarg{schema-evolution}.
\Seealsolabel
 Slot {\bf p-schema-evolution} of
 \fcite{structure-description}\ resp.\ \fcite{class-description}.


\Methodslabel

\flabel{\protect\mtd}{(setf class-description-schema-evolution) (t structure-description)}{}
{\Defmeth {(setf class-description-schema-evolution)} {{\funarg{schema-evolution}} (\funarg{class-description}\ \ObjectWithRef{structure-description})}}
Calls to this method are trapped to the system-generated
 structure writer function
 {\bf (setf structure-description-p-schema-evolution)}; see also
 \fcite{structure-description}.


\endcom

\begingfcom[External]{class-description-slot-numbers}

\Syntaxlabel
\Defgen {class-description-slot-numbers} {{\funarg{class-description}}}


\Argumentslabel
 \isa{\funarg{class-description}}
      {a structure-description or a class-description}
\Purposelabel
 Return the total number of slots of \funarg{class-description}.
\Seealsolabel
 Slot {\bf p-slot-numbers} of
 \fcite{structure-description}\ resp.\ \fcite{class-description}.


\Methodslabel

\flabel{\protect\mtd}{class-description-slot-numbers (structure-description)}{}
{\Defmeth {class-description-slot-numbers} {(\funarg{class-description}\ \ObjectWithRef{structure-description})}}
Calls to this method are trapped to the system-generated
 structure reader function
 {\bf structure-description-p-slot-numbers}; see also
 \fcite{structure-description}.


\endcom

\begingfcom[External]{(setf class-description-slot-numbers)}

\Syntaxlabel
\Defgen {(setf class-description-slot-numbers)} {{\funarg{slot-numbers}} {\funarg{class-description}}}


\Argumentslabel
 \isa{\funarg{slot-numbers}}
      {a fixnum}
 \isa{\funarg{class-description}}
      {a structure-description or a class-description}
\Purposelabel
 Set the number of total slots of
 \funarg{class-description}\ to
 \funarg{slot-numbers}.
\Seealsolabel
 Slot {\bf p-slot-numbers} of
 \fcite{structure-description}\ resp.\ \fcite{class-description}.


\Methodslabel

\flabel{\protect\mtd}{(setf class-description-slot-numbers) (t structure-description)}{}
{\Defmeth {(setf class-description-slot-numbers)} {{\funarg{slot-numbers}} (\funarg{class-description}\ \ObjectWithRef{structure-description})}}
Calls to this method are trapped to the system-generated
 structure writer function
 {\bf (setf structure-description-p-slot-numbers)}; see also
 \fcite{structure-description}.


\endcom

\message{^^JGeneric function plob::class-description-superclasses has no methods.^^J}
\message{^^JGeneric function (setf plob::class-description-superclasses) has no methods.^^J}
\begingfcom[External]{class-description-time-stamp}

\Syntaxlabel
\Defgen {class-description-time-stamp} {{\funarg{class-description}}}


\Argumentslabel
 \isa{\funarg{class-description}}
      {a structure-description or a class-description}
\Purposelabel
 Return the time stamp of \funarg{class-description}.
\Seealsolabel
 Slot {\bf p-time-stamp} of
 \fcite{structure-description}\ resp.\ \fcite{class-description}.


\Methodslabel

\flabel{\protect\mtd}{class-description-time-stamp (structure-description)}{}
{\Defmeth {class-description-time-stamp} {(\funarg{class-description}\ \ObjectWithRef{structure-description})}}
Calls to this method are trapped to the system-generated
 structure reader function
 {\bf structure-description-p-time-stamp}; see also
 \fcite{structure-description}.


\endcom

\begingfcom[External]{(setf class-description-time-stamp)}

\Syntaxlabel
\Defgen {(setf class-description-time-stamp)} {{\funarg{time-stamp}} {\funarg{class-description}}}


\Argumentslabel
 \isa{\funarg{time-stamp}}
      {an integer}
 \isa{\funarg{class-description}}
      {a structure-description or a class-description}
\Purposelabel
 Sets the time stamp of
 \funarg{class-description}\ to
 \funarg{time-stamp}.
\Seealsolabel
 Slot {\bf p-time-stamp} of
 \fcite{structure-description}\ resp.\ \fcite{class-description}.


\Methodslabel

\flabel{\protect\mtd}{(setf class-description-time-stamp) (t structure-description)}{}
{\Defmeth {(setf class-description-time-stamp)} {{\funarg{time-stamp}} (\funarg{class-description}\ \ObjectWithRef{structure-description})}}
Calls to this method are trapped to the system-generated
 structure writer function
 {\bf (setf structure-description-p-time-stamp)}; see also
 \fcite{structure-description}.


\endcom

\begingfcom[External]{class-description-version-number}

\Syntaxlabel
\Defgen {class-description-version-number} {{\funarg{class-description}}}


\Argumentslabel
 \isa{\funarg{class-description}}
      {a structure-description or a class-description}
\Purposelabel
 Returns the version number of \funarg{class-description}.
\Seealsolabel
 Slot {\bf p-version-number} of
 \fcite{structure-description}\ resp.\ \fcite{class-description}.


\Methodslabel

\flabel{\protect\mtd}{class-description-version-number (structure-description)}{}
{\Defmeth {class-description-version-number} {(\funarg{class-description}\ \ObjectWithRef{structure-description})}}
Calls to this method are trapped to the system-generated
 structure reader function
 {\bf structure-description-p-version-number}; see also
 \fcite{structure-description}.


\endcom

\begingfcom[External]{(setf class-description-version-number)}

\Syntaxlabel
\Defgen {(setf class-description-version-number)} {{\funarg{version-number}} {\funarg{class-description}}}


\Argumentslabel
 \isa{\funarg{version-number}}
      {a fixnum}
 \isa{\funarg{class-description}}
      {a structure-description or a class-description}
\Purposelabel
 Set the version number of
 \funarg{class-description}\ to
 \funarg{version-number}.
\Seealsolabel
 Slot {\bf p-version-number} of
 \fcite{structure-description}\ resp.\ \fcite{class-description}.


\Methodslabel

\flabel{\protect\mtd}{(setf class-description-version-number) (t structure-description)}{}
{\Defmeth {(setf class-description-version-number)} {{\funarg{version-number}} (\funarg{class-description}\ \ObjectWithRef{structure-description})}}
Calls to this method are trapped to the system-generated
 structure writer function
 {\bf (setf structure-description-p-version-number)}; see also
 \fcite{structure-description}.


\endcom

\message{^^JGeneric function plob::class-direct-methods has no methods.^^J}
\message{^^JGeneric function clos:class-direct-slots has no methods.^^J}
\message{^^JGeneric function clos:class-direct-superclasses has no methods.^^J}
\begingfcom[External]{class-extent}

\Syntaxlabel
\Defgen {class-extent} {{\funarg{the-class}}}


\Argumentslabel
 \isacls{\funarg{the-class}}
\Purposelabel
 Returns the extent of \funarg{the-class}.
 For \clsmo{}s which are instances of [a subclass of]
 \class{persistent-metaclass}\ (i.e.\ for classes with
 direct \plob\ support),
 the value of the \lisp{:extent}\ class option which was given in
 the \lisp{defclass}-statement of \funarg{the-class}\ is returned.
 For all other \clsmo{}s it is checked if either a class extent is
 given (by a prior call to \fcite{(setf class-extent)}) or
 if all slots of \funarg{the-class}\ have the same extent.
\Seealsolabel
 \Fcite{(setf class-extent)};
 \fcite{slot-extent}.


\Methodslabel

\flabel{\protect\mtd}{class-extent (t)}{}
{\Defmeth {class-extent} {{\funarg{the-class}}}}
%
% No behavior is specified for this method beyond that which is specified
% for the generic function.


\endcom

\begingfcom[External]{(setf class-extent)}

\Syntaxlabel
\Defgen {(setf class-extent)} {{\funarg{extent}} {\funarg{the-class}}}


\Argumentslabel
 For the \funarg{extent}\ argument see \fcite{(setf slot-extent)}.
 \isacls{\funarg{the-class}}
\Valueslabel
 \retarg{\funarg{extent}}
\Purposelabel
 Sets the extent of \funarg{the-class}\ to \funarg{extent}. The extent
 of all slots of \funarg{the-class}\ is set to \funarg{extent},
 i.e.\ {\bf (setf slot-extent)} is called for each slot of
 \funarg{the-class}; for further explanations see
 \fcite{(setf slot-extent)}.

 If a slot extent is specified for a slot of a class, this extent takes
 precedence over an eventually specified class extent for that slot.

 This functions is meant to be called from top-level to declare the extent
 of predefined \cl\ system classes, e.g.\ some predefined classes should
 never become persistent; or a class which was made transient by setting
 the package extent of the class naming symbol to
 \lisp{:transient}\ (see \fcite{(setf package-extent)})
 should become persistent.
\Exampleslabel
 In the first line, the extent of the package \lisp{:system}\ is set to
 \lisp{:transient}; since the symbol \lisp{logical-pathname}\ is
 defined in the \lisp{:system}\ package, all instances of the class
 \class{logical-pathname}\ would be transient too; the second line
 declares instances of the class \class{logical-pathname}\ as being
 persistent with an extent of \lisp{:cached}:
 \begin{lispcode}
(setf (package-extent (find-package :system)) :transient)
{\bf(setf (class-extent (find-class 'logical-pathname)) :cached)}
 \end{lispcode}

\Seealsolabel

 \Fcite{package-extent}; \fcite{(setf package-extent)};
 example at \fcite{(setf slot-extent)}.


\Methodslabel

\flabel{\protect\mtd}{(setf class-extent) (t t)}{}
{\Defmeth {(setf class-extent)} {{\funarg{extent}} {\funarg{the-class}}}}
%
% No behavior is specified for this method beyond that which is specified
% for the generic function.

\flabel{\protect\mtd}{(setf class-extent) :after (t t)}{}
{\Defmetha {(setf class-extent)} {{\funarg{extent}} {\funarg{the-class}}}}
%
% No behavior is specified for this method beyond that which is specified
% for the generic function.


\endcom

\begingfcom[External]{class-name}

\Syntaxlabel
\Defgen {class-name} {{\funarg{class}}}


 See \fcite{class-name}.


\Methodslabel

\flabel{\protect\mtd}{class-name (structure-description)}{}
{\Defmeth {class-name} {(\funarg{class-description}\ \ObjectWithRef{structure-description})}}
Calls to this method are trapped to the system-generated
 structure reader function
 {\bf structure-description-p-name}; see also
 \fcite{structure-description}.


\endcom

\message{^^JGeneric function plob::class-plist has no methods.^^J}
\message{^^JGeneric function clos:class-precedence-list has no methods.^^J}
\begingfcom[External]{class-prototype}

\Syntaxlabel
\Defgen {class-prototype} {{\funarg{class}}}


 See \fcite{class-prototype}.


\Methodslabel

\flabel{\protect\mtd}{class-prototype (class-description)}{}
{\Defmeth {class-prototype} {(\funarg{class-descr}\ \ObjectWithRef{class-description})}}
The returned prototype is a persistent object.


\endcom

\begingfcom[External]{class-slots}

\Syntaxlabel
\Defgen {class-slots} {{\funarg{class}}}


 See \fcite{class-slots}.


\Methodslabel

\flabel{\protect\mtd}{class-slots (structure-description)}{}
{\Defmeth {class-slots} {(\funarg{class-description}\ \ObjectWithRef{structure-description})}}
Calls to this method are trapped to the system-generated
 structure reader function
 {\bf structure-description-p-slots}; see also
 \fcite{structure-description}.


\endcom

\beginfncom[External]{clear-cache}

\Syntaxlabel
\Defun {clear-cache} {}


\Purposelabel
 Clear the root caches;
 only the base objects remain in the root caches.

 This clearing removes the associations done with
 {\bf register-to-cache} from an \objid\ to its transient
 representation and vice versa; so re-loading a persistent
 object will force a creation of a new transient representation
 compared to the one before the caches were cleared,
 i.e.\ in this case the identity of the transient representation
 will change.
\Seealsolabel
 \Fcite{register-to-cache};
 \fcite{register-to-base-cache}.


\endcom

\begingfcom[External]{close-heap}

\Syntaxlabel
\Defgen {close-heap} {{\opt} {\funarg{with-garbage-collection}}}


\Purposelabel
 Close the \sh.
 Its purpose is also to have specialised
 \lisp{:after}\ methods on \textbf{open-heap}\ to invalidate
 the transient representation of cached persistent objects.
\Remarkslabel
 This still needs some more work to be done, because there can be
 only one \lisp{:after}\ method on generic functions without
 arguments which could be specialised any further.


\Methodslabel

\flabel{\protect\mtd}{close-heap nil}{}
{\Defmeth {close-heap} {{\opt} {\funarg{with-garbage-collection}}}}
%
% No behavior is specified for this method beyond that which is specified
% for the generic function.


\endcom

\beginfncom[External]{close-my-session}

\Syntaxlabel
\Defun {close-my-session} {{\opt} {\funarg{p-heap}}}


 A more comfortable user front end function for \fcite{close-session}.


\endcom

\begingfcom[External]{close-session}

\Syntaxlabel
\Defgen {close-session} {{\funarg{p-heap}} {\opt} {\funarg{with-garbage-collection}}}


\Purposelabel
 Close the session of \funarg{p-heap}.
\Remarkslabel
 The session will be opened again if necessary.
\Seealsolabel
 \Fcite{open-session};
 \fcite{*default-persistent-heap*}.


\Methodslabel

\flabel{\protect\mtd}{close-session (t)}{}
{\Defmeth {close-session} {{\funarg{p-heap}} {\opt} {\funarg{with-garbage-collection}}}}
%
% No behavior is specified for this method beyond that which is specified
% for the generic function.


\endcom

\begingfcom[External]{clrbtree}

\Syntaxlabel
\Defgen {clrbtree} {{\funarg{p-btree}} {\opt} {\funarg{p-heap}}}


\Argumentslabel
 \isabtree{\funarg{p-btree}}
\Valueslabel
 \retarg{\funarg{p-btree}}
\Purposelabel
 This generic function removes all entries from
 \funarg{p-btree}\ and returns the empty persistent BTree
 \funarg{p-btree}.
\Seealsolabel
 \Fcite{sh-btree-clear};
 \fcite{clrhash}.


\Methodslabel

\flabel{\protect\mtd}{clrbtree :before (cached-btree)}{}
{\Defmethb {clrbtree} {(\funarg{p-btree}\ \ObjectWithRef{cached-btree}) {\opt} {\funarg{p-heap}}}}

 Clears the cache of the cached persistent BTree \funarg{p-btree}\ too.

\flabel{\protect\mtd}{clrbtree (t)}{}
{\Defmeth {clrbtree} {{\funarg{p-btree}} {\opt} {\funarg{p-heap}}}}
Calls the low-level function \fcite{sh-btree-clear}.


\endcom

\begingfcom[External]{compute-effective-slot-definition}

\Syntaxlabel
\Defgen {compute-effective-slot-definition} {{\funarg{class}} {\funarg{name}} {\funarg{direct-slot-definitions}}}


 See \fcite{compute-effective-slot-definition}.


\Methodslabel

\flabel{\protect\mtd}{compute-effective-slot-definition :around (persistent-metaclass t t)}{}
{\Defmetharound {compute-effective-slot-definition} {(\funarg{the-class}\ \ObjectWithRef{persistent-metaclass}) {\funarg{slot-name}} {\funarg{direct-slot-definitions}}}}
Handles the extra allowed slot options.


\endcom

\beginpmcom[External]{*database-url*}

\Initialvaluelabel
\begin{CompactCode}
""
\end{CompactCode}

\Purposelabel
 The URL naming the actual database.
 At opening, the values of \fcite{*database-url*}\ and
 \fcite{*default-database-url*}\ are merged by a call to
 \fcite{merge-urls}\ to form the effective database URL.
 So, if you want to open another database instead of the default one,
 it is a good idea to set \fcite{*database-url*}\ to the URL
 of this database.
\Seealsolabel
  \Fcite{*default-database-url*}.


\endcom

\beginvrcom[External]{*default-persistent-heap*}

\Initialvaluelabel
\begin{CompactCode}
nil
\end{CompactCode}

\Purposelabel
 The persistent heap object which is used as default.
 The variable {\bf *default-persistent-heap*} is a session-local variable.
 For all \plob\ `high-level' functions, the value of
 {\bf *default-persistent-heap*} is passed as an {\opt} parameter and
 serves for the purposes explained at \fcite{persistent-heap}.
\Seealsolabel
 \Fcite{persistent-heap};
 \fcite{make-process-variable}.


\endcom

\begingfcom[External]{direct-slot-definition-class}

\Syntaxlabel
\Defgen {direct-slot-definition-class} {{\funarg{class}} {\rest} {\funarg{initargs}}}


 See \fcite{direct-slot-definition-class}.


\Methodslabel

\flabel{\protect\mtd}{direct-slot-definition-class (persistent-metaclass)}{}
{\Defmeth {direct-slot-definition-class} {(\funarg{class}\ \ObjectWithRef{persistent-metaclass}) {\rest} {\funarg{initargs}}}}
Returns \fcite{persistent-direct-slot-definition}.


\endcom

\begingfcom[External]{effective-slot-definition-class}

\Syntaxlabel
\Defgen {effective-slot-definition-class} {{\funarg{class}} {\rest} {\funarg{initargs}}}


 See \fcite{effective-slot-definition-class}.


\Methodslabel

\flabel{\protect\mtd}{effective-slot-definition-class (persistent-metaclass)}{}
{\Defmeth {effective-slot-definition-class} {(\funarg{class}\ \ObjectWithRef{persistent-metaclass}) {\rest} {\funarg{initargs}}}}
Returns \fcite{persistent-effective-slot-definition}.


\endcom

\beginfncom[External]{end-transaction}

\Syntaxlabel
\Defun {end-transaction} {{\opt} {\funarg{ignore-error}} {\funarg{p-heap}}}


\Argumentslabel
 \isabool{\funarg{ignore-error}}
\Valueslabel
 Returns the numeric transaction ID of the ended transaction
 of \funarg{p-heap}\ iff it was ended, \lispnil\ otherwise.
\Purposelabel
 End a transaction on \funarg{p-heap}; commit all changes done
 since the start of the transaction.
\Remarkslabel
 If there is no active transaction and
 \funarg{ignore-error}\ is \lispnil, an error is signalled;
 if there is no active transaction and
 \funarg{ignore-error}\ is \nonnil, {\bf end-transaction}
 simply returns \lispnil.
\Seealsolabel
 \Fcite{begin-transaction};
 \fcite{cancel-transaction};
 \fcite{in-transaction-p};
 \fcite{sh-end-transaction}.


\endcom

\begingfcom[External]{finalize-inheritance}

\Syntaxlabel
\Defgen {finalize-inheritance} {{\funarg{class}}}


 See \fcite{finalize-inheritance}.


\Methodslabel

\flabel{\protect\mtd}{finalize-inheritance :after (persistent-metaclass)}{}
{\Defmetha {finalize-inheritance} {(\funarg{the-class}\ \ObjectWithRef{persistent-metaclass})}}
Mark the class description of \funarg{the-class}\ as
 being not finalized.


\endcom

\beginfncom[External]{flush-mode}

\Syntaxlabel
\Defun {flush-mode} {{\opt} {\funarg{mode}} {\funarg{p-heap}}}


 \Argumentslabel
  \isa{\keyarg{mode}}
       {one of the keyword symbols
        \lisp{:never}, \lisp{:seldom},
        \lisp{:sometimes}, \lisp{:often}\ or \lisp{:always}}
  \isabool{\keyarg{idle}}
 \Valueslabel
  Returns two values:
  \begin{enumerate}

  \item The current flush mode.

  \item A second value of \nonnil\ indicates that idle flushing
   is switched on, otherwise idle flushing is switched off.

  \end{enumerate}
 \Purposelabel
  This function serves two purposes:
  \begin{enumerate}

  \item Set resp.\ request the implicit flushing done in
   the \plob\ C level (argument \keyarg{mode}).
   If \keyarg{mode}\ is passed, the flush mode is set to
   \keyarg{mode}. A mode of \lisp{:never}\ causes the
   \plob\ C level never to flush implicitly whereas a mode of
   \lisp{:always}\ will cause the C level to flush always
   after any changes done to a persistent object.
   If \keyarg{mode}\ is not passed, the current flush mode keeps
   unchanged.

  \item Set resp.\ request if the \sh\ is flushed when the
   system goes idle (argument \keyarg{idle}).
   If \keyarg{idle}\ is passed and \nonnil, each time
   \lw\ goes idle a flush of the \sh\ is performed;
   the flushing is triggered from the \cl\ code, so the
   \plob\ C level flush mode passed in \keyarg{mode}\ should
   be set to \lisp{:never}\ when \keyarg{idle} is \nonnil.
   If \keyarg{idle}\ is passed and \lispnil, flushing
   is never triggered from the \cl\ code.
   If \keyarg{idle}\ is not passed, the idle flushing keeps
   unchanged.

  \end{enumerate}
 \Remarkslabel
  The mode \lisp{:always}\ will slow down the \cl\ system awfully,
  i.e.\ it will no longer be usable. If at least some automatic
  flushing is wanted, try it with
  \keyarg{mode}\ \lisp{:never}\ and \keyarg{idle}\ \lispt.

  For maximum speed, no implicit and no idle flushing should be done;
  in this case, the user must call the \fcite{plob-flush}\ from time
  to time. When implicit and idle flushing is switched off, the
  \fcite{close-heap}\ or the \fcite{plob-flush}\ {\sl must}
  be called by the user before exiting \lw; otherwise the
  \sh\ might be in an inconsistent state next time it is opened.

  In the current \plob\ RPC-based version, flushing initiated by the
  client doesn't make much sense, so no client-initiated flushing will
  be done.
 \Exampleslabel
  Do no implicit flushing in the \plob\ C level and also never when
  the system goes idle (this is the recommened default case).
  In this case, before exiting \lw\ a call to \fcite{close-heap}\ or
  to \fcite{plob-flush}\ must be done:
  \begin{lispcode}
 (flush-mode :mode :never :idle nil)
  \end{lispcode}

  Do no implicit flushing in the \plob\ C level but when the system
  goes idle (the other reasonable setting).
  In this case, before exiting \lw\ a call to \fcite{close-heap}\ or
  to \fcite{plob-flush}\ should be done:
  \begin{lispcode}
 (flush-mode :mode :never :idle t)
  \end{lispcode}
 \Seealsolabel
  \Fcite{flush-if-idle-mode};
  \fcite{+flush-mode->keyword+}.


\endcom

\begingfcom[External]{get-index-table}

\Syntaxlabel
\Defgen {get-index-table} {{\funarg{class}} {\funarg{name}}}



\Argumentslabel
 \isa{\funarg{class}}
      {either a \clsmo\ with persistent instances or a symbol
       naming such a class}
 \isa{\funarg{name}}
      {a symbol naming a slot of \funarg{class}\ which has an
       index defined on it, i.e.\ whose slot definition in the
       \lisp{defclass}\ statement had an \lisp{:index}\ slot
       option}
\Purposelabel
  Return the object representing the index table of the slot named
  \funarg{name}\ in \funarg{class}. If no index has been declared
  on the slot, \lispnil\ is returned.
\Seealsolabel
 Section \fcite{index ...}.


\Methodslabel

\flabel{\protect\mtd}{get-index-table (persistent-clos-object t)}{}
{\Defmeth {get-index-table} {(\funarg{class}\ \ObjectWithRef{persistent-clos-object}) {\funarg{name}}}}
%
% No behavior is specified for this method beyond that which is specified
% for the generic function.

\flabel{\protect\mtd}{get-index-table (symbol symbol)}{}
{\Defmeth {get-index-table} {(\funarg{class}\ \ObjectWithRef{symbol}) (\funarg{name}\ \ObjectWithRef{symbol})}}
%
% No behavior is specified for this method beyond that which is specified
% for the generic function.


\endcom

\beginfncom[External]{getbtree}

\Syntaxlabel
\Defun {getbtree} {{\funarg{key}} {\funarg{p-btree}} {\opt} {\funarg{depth}} {\funarg{p-heap}}}


\Argumentslabel
 \isakey{\funarg{key}}{\funarg{p-btree}}
 \isabtree{\funarg{p-btree}}
\Valueslabel
 Two values are returned:
 \begin{enumerate}
 \item The transient representation of the persistent object
  found under \funarg{key}\ in \funarg{p-btree}.
 \item A flag indicating if the \funarg{key}\ was found in
  \funarg{p-btree}.
 \end{enumerate}
\Purposelabel
 Search \funarg{key}\ in \funarg{p-btree}; if \funarg{key}\ is
 found, the transient representation of the found \obj\ is returned.

 The kind of search performed depends on the \keyarg{test}\ mode
 of the persistent BTree; see \fcite{make-btree}, argument
 \keyarg{test}\ for details.

 The function {\bf getbtree} calls \fcite{getbtree-with-data}.
\Seealsolabel
 \Fcite{getbtree-with-data}; \fcite{make-btree};
 \fcite{gethash}.


\endcom

\beginfncom[External]{(setf getbtree)}

\Syntaxlabel
\Defun {(setf getbtree)} {{\funarg{data}} {\funarg{key}} {\funarg{p-btree}} {\opt} {\funarg{depth}} {\funarg{p-heap}}}


\Argumentslabel
 \isanobject{\funarg{data}}
 \isakey{\funarg{key}}{\funarg{p-btree}}
 \isabtree{\funarg{p-btree}}
\Valueslabel
 \retarg{\funarg{data}}
\Purposelabel
 Insert \funarg{data}\ associated to \funarg{key}\ into
 \funarg{p-btree}; if \funarg{data}\ or \funarg{key}\ are not
 yet persistent, they are made persistent before inserting them.
 Any old data found under \funarg{key}\ is removed before the
 new data is added.

 The function {\bf (setf getbtree)} stores \funarg{data}\ to
 the \sh\ and calls the
 \fcite{(setf getbtree-with-data)}\ with the \objid\ and
 \typetag\ obtained at storing \funarg{data}.
\Remarkslabel
 Not all \cl\ types are supported for \funarg{key}.

 Since BTrees store their elements ordered (in opposite to hash tables
 which store their elements unordered) when the \keyarg{test}\ mode
 is not \lisp{eq}\ (see \fcite{make-btree}, argument \keyarg{test}),
 it must be possible to impose an
 ordering relation on a new to-insert BTree key resp.\ to the keys
 already contained in the BTree. If \plob\ cannot impose such an ordering
 relation an error is raised when trying to insert an incompatible key,
 e.g.\ if there are stored only fixnum objects in a BTree,
 a key of type string cannot be inserted because there is no
 ordering relation defined between types fixnum and string.

 For BTrees with \keyarg{test}\ mode \lisp{eq}, numeric comparision
 of the objects \objid[s]\ is used for the ordering relation;
 so BTrees with \keyarg{test}\ mode \lisp{eq}\ can handle all
 key types.

 Currently, these ordering relations are hand-knitted into the
 \plob\ C code for efficency reasons;
 there is no possibility to define additional
 ordering relations from the \cl\ side.
\Seealsolabel
 \Fcite{(setf getbtree-with-data)}; \fcite{make-btree};
 \fcite{(setf gethash)}.


\endcom

\beginfncom[External]{getbtree-by-objid}

\Syntaxlabel
\Defun {getbtree-by-objid} {{\funarg{key}} {\funarg{p-btree}} {\opt} {\funarg{depth}} {\funarg{p-heap}}}


\Argumentslabel
 \isanobjid{\funarg{key}}
 For the \funarg{p-btree} argument see \fcite{getbtree}.
\Valueslabel
 See \fcite{getbtree}.
\Purposelabel
 At first see \fcite{getbtree}; this function differs from
 \fcite{getbtree}\ in the sense that the \funarg{key}\ argument
 has to be a persistent object's \objid; no transient \cl\ object
 may be passed directly as \funarg{key}\ argument.

 The function {\bf getbtree-by-objid} calls
 \fcite{getbtree-by-objid-with-data}.
\Seealsolabel
 \Fcite{getbtree-by-objid-with-data}.


\endcom

\beginfncom[External]{(setf getbtree-by-objid)}

\Syntaxlabel
\Defun {(setf getbtree-by-objid)} {{\funarg{data}} {\funarg{key}} {\funarg{p-btree}} {\opt} {\funarg{depth}} {\funarg{p-heap}}}


\Argumentslabel
 For the \funarg{data}\ and \funarg{p-btree}\ arguments see
 \fcite{(setf getbtree)}.
 \isanobjid{\funarg{key}}
\Valueslabel
 \retarg{\funarg{data}}
\Purposelabel
 At first see \fcite{(setf getbtree)}; this function differs
 from \fcite{(setf getbtree)} in the sense that the
 \funarg{key}\ argument has to be a persistent object's \objid;
 no transient \cl\ \obj\ may be passed directly as
 \funarg{key}\ argument.

 The function {\bf (setf getbtree-by-objid)} stores \funarg{data}\ to
 the \sh\ and calls the
 \fcite{(setf getbtree-by-objid-with-data)}\ with the \objid\ and
 \typetag\ obtained at storing \funarg{data}.
\Seealsolabel
 \Fcite{(setf getbtree-by-objid-with-data)}.


\endcom

\beginfncom[External]{in-transaction-p}

\Syntaxlabel
\Defun {in-transaction-p} {{\opt} {\funarg{p-heap}}}


\Valueslabel
 Returns the numeric transaction ID iff there is an active transaction
 on \funarg{p-heap}, \lispnil\ otherwise.
\Purposelabel
 Check if \funarg{p-heap}\ is in an active transaction.
\Seealsolabel
 \Fcite{begin-transaction};
 \fcite{cancel-transaction};
 \fcite{end-transaction};
 \fcite{sh-in-transaction-p}.


\endcom

\begindccom[Index Administration]{index ...}

\Purposelabel
 An index table maps a slot value to a persistent
 \clos\ instance which has that value in that slot. An index
 can be defined on a per-slot basis; the object used for
 maintaining the index is hold in the slot
 {\bf p-index} of the slot's effective-slot-description
 object.

 The index table management has interfaces to two sides:
 \begin{itemize}

 \item One interface is used for administrating the
  index-representing data. It consists of the generic functions
  {\bf clrindex}, {\bf getindex}, {\bf (setf getindex)},
  {\bf getindex-by-objid}, {\bf (setf getindex-by-objid)},
  {\bf remindex} and  {\bf mapindex}. With these generic functions
  the index table can be cleared, elements can be read,
  written or deleted and a mapping over the elements of an index
  table can be accomplished without having to know which
  class is used for representing the index table.

 \item The other interface consists of the functions
  {\bf getindex-by-tag} and {\bf remindex-by-tag}. These
  are called to insert a mapping from a slot value to its
  persistent \clos\ instance with that slot value
  resp.\ to remove the mapping; they are called from the
  \fcite{(setf slot-value-using-class) (t standard-class t %
effective-slot-description)}\ to insert resp.\ overwrite
  index table elements and from
  \fcite{slot-makunbound-using-class (standard-class t %
effective-slot-description)}\ to remove elements from the
  index table.

 \end{itemize}

\Seealsolabel
 \Fcite{clrindex};
 \fcite{getindex};
 \fcite{(setf getindex)};
 \fcite{getindex-by-objid};
 \fcite{(setf getindex-by-objid)};
 \fcite{remindex};
 \fcite{mapindex};
 \fcite{getindex-by-tag};
 \fcite{remindex-by-tag};
 \fcite{(setf slot-value-using-class) (t standard-class t %
effective-slot-description)};
 \fcite{slot-makunbound-using-class (standard-class t %
effective-slot-description)};
 \fcite{p-select};
 slot {\bf p-index} of \fcite{slot-description}.


\endcom

\begingfcom[External]{initialize-instance}

\Syntaxlabel
\Defgen {initialize-instance} {{\funarg{instance}} {\rest} {\funarg{initargs}}}


 See \fcite{initialize-instance}.


\Methodslabel

\flabel{\protect\mtd}{initialize-instance :around (persistent-clos-object)}{}
{\Defmetharound {initialize-instance} {(\funarg{object}\ \ObjectWithRef{persistent-clos-object}) {\rest} {\funarg{all-keys}} \key {\keyarg{suppress-initialization}}}}
Do not call next method if no initialization should be done at all,
 i.e.\ if the \keyarg{suppress-initialization}\ argument was passed as
 \lispnil.

\flabel{\protect\mtd}{initialize-instance :around (persistent-direct-slot-definition)}{}
{\Defmetharound {initialize-instance} {(\funarg{slot}\ \ObjectWithRef{persistent-direct-slot-definition}) {\rest} {\funarg{initargs}} \key {\keyarg{extent}} {\keyarg{deferred}} {\keyarg{index}} {\keyarg{location}}}}
Stores the values of the extra slot options.

\flabel{\protect\mtd}{initialize-instance :around (persistent-metaclass)}{}
{\Defmetharound {initialize-instance} {(\funarg{class}\ \ObjectWithRef{persistent-metaclass}) {\rest} {\funarg{all-keys}} \key {\keyarg{direct-superclasses}} {\keyarg{constructor}} {\keyarg{dependent}} {\keyarg{extent}} {\keyarg{schema-evolution}}}}
Trapped to \fcite{re-and-initialize-persistent-metaclass-instance}.

\flabel{\protect\mtd}{initialize-instance :before (standard-class)}{}
{\Defmethb {initialize-instance} {(\funarg{class}\ \ObjectWithRef{standard-class}) {\rest} {\funarg{all-keys}}}}
Marks \funarg{class}\ as being (perhaps) mismatched;
 see \fcite{(setf mismatch-p)}.


\endcom

\beginfncom[External]{load-object}

\Syntaxlabel
\Defun {load-object} {{\funarg{p-object}} {\opt} {\funarg{depth}} {\funarg{p-heap}}}


\Argumentslabel
 \isanobjid{\funarg{p-object}}
 \isa{\funarg{depth}}
      {a keyword symbol}
\Valueslabel
 The transient representation of the persistent object referenced
 by \funarg{p-object}\ is returned.
\Purposelabel
 Load the persistent object referenced by
 \funarg{p-object}\ from the \sh.
 Argument \funarg{depth}\ determines how `deep' the object is
 loaded and can take one of the following values:
 \begin{description}

 \item[\lisp{:object}, \lisp{:objid}]
  Return a reference to persistent object \funarg{p-object}.

 \item[\lisp{:cached}]
  Load only new allocated or immediate sub-objects.

 \item[\lisp{:flat}]
  Load only the top level of \funarg{t-object}.

 \item[\lisp{:deep}]
  Load all subobjects.

 \end{description}
 The default value for \funarg{depth}\ is defined in the
 \fcite{*default-depth*}.
\Seealsolabel
 \Fcite{store-object}.


\endcom

\begindccom[Object Locking]{locking ...}

 \plob\ offers multi-level multi-mode locking. Locking an object
 means placing a lock with a certain level and a certain mode by a
 locking object onto a locked object; so at locking there are
 always two objects involved: the {\sl locking} persistent object
 and the {\sl locked} persistent object.

 Locking is implemented in the C level of \plob. The class of the
 locking and the locked object can in principle be any of the
 \plob\ built-in classes, but only instances of
 \fcite{persistent-heap}\ as locking object's class have
 specialized methods\footnote{Do not try to locate these in the
 \cl\ code; they are implemented in the C level.} to cope
 meaningful with locking another object:
 \begin{itemize}

 \item The lock request onto the locked persistent object is
  recorded in the transaction log of the locking
  \class{persistent-heap}\ instance; when the transaction is either
  ended or cancelled, the lock placed onto the locked persistent
  object will be released.

 \item When a write lock is placed onto the locked persistent
  object, its state is recorded in the transaction log of the
  locking \class{persistent-heap}\ instance too; in case of
  cancelling the transaction, this information is used to
  {\sl roll-back} the locked persistent object to its state
  when the transaction was started.

 \end{itemize}

 Multi-level locking means that a lock can be placed on one
 of the levels specified in figure~\ref{tab:lock-levels}.
 \begin{figure}[htbp]\centering%
 \begin{tabular}{|c|l|p{9cm}|}%
 \hline
 \tabularheader{Level}
        &\tabularheader{Constant}
                &\tabularheader{Description}\\
 \hline\hline
 ---
  & {\bf +lock-level-nothing+}
   & Lock nothing at all. This level can be used to suppress
     a lock request though one of the locking functions is
     called, i.e.\ calling one of the locking functions with
     level {\bf +lock-level-nothing+} does nothing.\\
 \hline
 Element
  & {\bf +lock-level-element+}
   & Lock one element of a persistent object. The element's
     position to lock is identified by an
     \funarg{index}\ parameter passed to the lock and unlock
     functions.\\
 \hline
 Vector
  & {\bf +lock-level-vector+}
   & Lock the whole persistent object.\\
 \hline
 Store
  & {\bf +lock-level-store+}
   & Lock the whole \sh.
     \note\ This mode is not yet tested since \plob\ does not
     need it up to now.\\
 \hline
 \end{tabular}
 \caption{Lock levels}\label{tab:lock-levels}%
 \end{figure}
 The possible modes of locks placed onto the locked object
 are shown in figure~\ref{tab:lock-modes}.
 \begin{figure}[htbp]\centering%
 \begin{tabular}{|c|l|p{8cm}|}
 \hline
 \tabularheader{Mode}
        &\tabularheader{Constant}
                &\tabularheader{Description}\\
 \hline\hline
 ---
  & {\bf +lock-mode-nothing+}
   & Set no lock on passed level; just return the current lock
     mode of the persistent object on the passed level.\\
 \hline
 Read-Only
  & {\bf +lock-mode-read-only+}
   & Mark the persistent object as read-only; all following attempts to
     set a write lock to the persistent oject will fail.
     \note\ To set resp.\ remove a read-only lock, use the
     \fcite{(setf p-read-only)}, because using the
     \fcite{p-set-lock}\ will result in a read-only lock which will
     be released at the end of the current transaction.\\
 \hline
 Read
  & {\bf +lock-mode-read+}
   & Set a read lock onto the persistent object for passed level.\\
 \hline
 Write
  & {\bf +lock-mode-write+}
   & Set a write lock onto the persistent object for passed level.\\
 \hline
 \end{tabular}
 \caption{Lock modes}\label{tab:lock-modes}%
 \end{figure}

 When a session tries to put its lock on an object locked by another
 session and the requested lock conflicts with the one already set,
 there is a lock conflict. The conflicts which may arise for incompatible
 locks are shown in the compatibility matrix in
 figure~\ref{tab:lock-conflicts}.
 \begin{figure}[htbp]\centering%
 \def\coliw{8em}%
 \def\pbox#1{\parbox{\coliw}{\centering#1}}%
 \def\vvbox{\pbox{\checked}}%
 \def\XXbox{\pbox{\crossed}}%
 \begin{tabular}{|c|p{\coliw}|p{\coliw}|p{\coliw}|}
 \cline{2-4}
 \multicolumn{1}{c|}{}
  &\pbox{\tabularheader{Read-Only granted}}
        &\pbox{\tabularheader{Read granted}}
                &\pbox{\tabularheader{Write granted}}\\ \hline
 %
 %                      RO       R        W
 \tabularheader{Read-Only requested}
        &\vvbox &\vvbox &\vvbox\\ \hline
 \tabularheader{Read requested}
        &\vvbox &\vvbox &\XXbox\\ \hline
 \tabularheader{Write requested}
        &\XXbox &\XXbox &\XXbox\\ \hline
 %
 \multicolumn{4}{r}{%
  \checked\ $\equiv$\ Compatible locks\quad
  \crossed\ $\equiv$\ Incompatible locks}
 \end{tabular}
 \caption{Compatibility Matrix}\label{tab:lock-conflicts}
 \end{figure}
 The session which tries to request a conflicting lock is suspended
 either until the lock conflict no longer exists, i.e.\ up to the
 moment when the other sessions release their locks or the session
 has been suspended for at least
 {\bf *suspend-timeout*} seconds. The timeout algorithm is used
 because there is no deadlock detection; if there would be no
 timeout, a deadlock would block the involved sessions
 {\sl ad infinitum}\/. When a suspended session reaches
 such a timeout condition, an error is raised with a message
 that a lock request failed. When there are multiple sessions
 waiting for a lock, the lock requests are put into a
 priority queue with read-only locks requests having the least
 and write locks having the highest priority, i.e.\ sessions
 waiting for read-only locks are waked up after sessions waiting
 for write locks. This is done to prevent waiting sessions from
 starvation.

 Since it is not possible to set in one call to
 one of the below specified locking functions more than one lock
 level and one lock mode per call, use
 {\sl exactly one} of the bitmask constants of
 figure~\ref{tab:lock-levels} bitwise-or'ed with {\sl exactly one}
 of the bitmask constants of figure~\ref{tab:lock-modes} as parameter
 \funarg{lock-mode}\ or use {\sl exactly one} of the
 shorthand bitmask constants explained in figure~\ref{tab:lock-shands}.
 \begin{figure}[htbp]\centering%
 \begin{tabular}{|l|l|}
 \hline
 \tabularheader{Constant}
        &\tabularheader{Description}\\
 \hline\hline
 {\bf +lock-element-read+}
  & Same as bitwise-or of {\bf +lock-level-element+} with
    {\bf +lock-mode-read+}.\\
 \hline
 {\bf +lock-vector-read+}
  & Same as bitwise-or of {\bf +lock-level-vector+} with
    {\bf +lock-mode-read+}.\\
 \hline
 {\bf +lock-element-write+}
  & Same as bitwise-or of {\bf +lock-level-element+} with
    {\bf +lock-mode-write+}.\\
 \hline
 {\bf +lock-vector-write+}
  & Same as bitwise-or of {\bf +lock-level-vector+} with
    {\bf +lock-mode-write+}.\\
 \hline
 \end{tabular}
 \caption{Lock level and mode shorthands}\label{tab:lock-shands}%
 \end{figure}
 Furthermore, zero to all of the values shown
 in figure~\ref{tab:lock-mods} can be bitwise-or'ed additionally into
 the \funarg{lock-mode}\ to modify the behavior of the called
 locking function.
 \begin{figure}[htbp]\centering%
 \begin{tabular}{|l|l|}
 \hline
 \tabularheader{Constant}
        &\tabularheader{Description}\\
 \hline\hline
 {\bf +lock-unlock+}
  & Do not set a lock but instead remove a lock with passed
    level and mode.\\
 \hline
 {\bf +lock-force+}
  & Try to ignore any errors which occure at the locking operation
    as far as possible.\\
 \hline
 \end{tabular}
 \caption{Lock modifier}\label{tab:lock-mods}%
 \end{figure} 

 There are also `intent' lock modes specified (constants
 {\bf *lock-mode-\ldots{}-intent*}), but these lock modes
 are used internally by \plob. An `intent' lock placed on
 a certain level onto a persistent object means that on one
 of the lower levels someone has placed a corresponding
 `real' lock, e.g.\ a mode of
 {\bf +lock-mode-read-intent+} on level
 {\bf +lock-level-vector+} means that anyone has placed a
 mode {\bf +lock-mode-read+} on the sub-level
 {\bf +lock-level-element+} of the persistent object.

\Remarkslabel

 \begin{itemize}

 \item
  When a persistent object is loaded into its transient
  representation, the object should be read locked by the
  persistent object contained in \fcite{*root-persistent-heap*}.
  The idea is that one \lw\ process (in the sense of a
  \unix\ process) represented just by {\bf *root-persistent-heap*}
  shares all transient representations of
  all persistent objects which have been loaded so far.
  Another session which wants to load the same (i.e.\ \lisp{eq})
  object too would then not load the object a second time
  (because there is already a read lock on the object, see
  \fcite{with-read-lock}).

  In the moment, this is not done; loading the same (i.e.\ \lisp{eq})
  transient object at the same time by more than one session can lead
  to creation of more than one object in transient memory and to
  unnecessary multiple read operations of the object's state.

 \item
  For multiuser handling, a non-conflicting lock mode `cached'
  should be defined; then, a session which placed a `cached' lock
  onto a persistent object should be notified when anyone
  changed the state of the persistent object so that the session
  holding the `cached' lock can update the transient representation
  of the persistent object in its cache.

\end{itemize}

\Seealsolabel

 \Fcite{with-read-lock};
 \fcite{with-write-lock};
 \fcite{read-lock};
 \fcite{write-lock};
 \fcite{p-insert-lock};
 \fcite{p-set-lock};
 \fcite{p-unlock};
 \fcite{p-unlock-all};
 \fcite{p-unlock-all-all};
 \fcite{*suspend-timeout*}.


\endcom

\beginfncom[External]{make-btree}

\Syntaxlabel
\Defun {make-btree} {\key {\keyarg{cached}} {\keyarg{objid}} {\keyarg{test}} {\keyarg{pagesize}} {\keyarg{p-heap}}}


\Argumentslabel
 \isabool{\keyarg{cached}}
 \isanobjid{\keyarg{objid}}
 \isa{\keyarg{test}}
      {one of the symbols \lisp{eq}, \lisp{eql}\ or \lisp{equal}}
\Valueslabel
 A structure representing the persistent BTree is returned.
\Purposelabel
 This function creates resp.\ gives access to an already existing
 cached or uncached persistent BTree.

 The \keyarg{cached}\ argument determines if the persistent BTree
 should have a transient cache.
 If its value is \lispnil, all operations on the returned BTree
 are done exclusively by the low-level C functions, i.e.\ each
 BTree access involves calls to the \plob\ C code.
 If its value is \nonnil\, all entries read from or written to
 the persistent BTree are cached. This speeds up access to BTree entries
 a lot since many calls to the low-level BTree access functions can
 be avoided\footnote{Not the \plob\ low-level access functions are
 slow but the foreign-language calls itself from \lw\ to C.};
 furthermore, reading from the cache does not need an active
 transaction. The cache is organized as a write-through cache.

 If the \keyarg{objid}\ argument is passed, its value must be an
 \objid\ referencing an already allocated persistent BTree; this
 \objid\ is used as the \objid\ of the return value,
 i.e.\ no new persistent BTree is allocated on the \sh.
 If no \keyarg{objid}\ is passed, a new persistent BTree is allocated
 on the \sh.

 The \keyarg{test}\ argument determines the kind of ordering which
 is to be imposed on the keys contained in the BTree. A value of
 \lisp{eq}\ or \lisp{eql}\ orders the keys in the BTree by their
 \objid[s], i.e.\ the ordering is done `by persistent
 {\sl identity}' of the key objects and not by the {\sl state}
 of the key objects. Since all \cl\ objects regardless
 of their type can be handled by \plob, a BTree with \keyarg{test}-mode
 \lisp{eq}\ or \lisp{eql}\ (actually, \lisp{eq}\ and
 \lisp{eql}\ mean the same) can contain any key objects independent of
 their type, but searching a key can be done only by the key's
 \objid\ and not by the key's state. In opposite, a
 \keyarg{test}-mode of \lisp{equal}\ orders the keys in the BTree
 by their state and makes it possible to search for values, but
 the low-level \plob\ BTree functions cannot handle all
 \cl\ types; a rule of thumb is that \plob\ can handle as keys
 for \lisp{equal}\ BTrees all built-in
 numeric types consisting of only one component and all other built-in
 types and all structures which contain only these built-in types
 (i.e.\ \plob\ can handle fixnums, short-floats, single-floats,
 strings and structures made up of these types, like conses or
 vectors containing only fixnums, short-floats, \ldots;
 \plob\ cannot handle as keys for \lisp{equal}\ BTrees
 bignums, double-floats, complex\footnote{Complex numbers would
 also require a two-dimensional indexing for searching them
 by their values; this cannot be accomplished principally by
 BTrees, since they handle one-dimensional keys.}\ and rational
 numbers).
\Exampleslabel
 Create a persistent BTree (line~1), insert (line~2-4) and search
 (line~5-6) some elements. Please note that objects of type
 \class{fixnum}\ and \class{short-float}\ can be handled by a
 single \lisp{equal}\ BTree:
 \begin{lispcode}
(setf *b* (make-btree :test 'equal))
        ==> #<btree equal 0/0 short-objid=8377610>

(setf (getbtree 1 *b*) "Value of key 1")
(setf (getbtree 2.0s0 *b*) "Value of key 2.0s0")
(setf (getbtree "error" *b*) 1) ==> raises an error

(getbtree 1 *b*) ==> "Value of key 1"
(getbtree 2 *b*) ==> "Value of key 2.0s0"
 \end{lispcode}
\Seealsolabel
 \Fcite{clrbtree};
 \fcite{getbtree};
 \fcite{getbtree-by-objid};
 \fcite{(setf getbtree)};
 \fcite{(setf getbtree-by-objid)};
 \fcite{mapbtree};
 \fcite{rembtree};
 \fcite{rembtree-by-objid};
 \fcite{p-apropos-btree};
 \fcite{make-hash-table}.


\endcom

\beginfncom[External]{make-btree-mapper}

\Syntaxlabel
\Defun {make-btree-mapper} {{\funarg{p-btree}} \key {\keyarg{objid}} {\keyarg{<}} {\keyarg{<=}} {\keyarg{>}} {\keyarg{>=}} {\keyarg{descending}} {\keyarg{depth}} {\keyarg{p-heap}}}


\Purposelabel
 Make a btree mapper.
\Seealsolabel
 \Fcite{btree-mapper-search}; \fcite{btree-mapper-seek}.


\endcom

\begingfcom[External]{make-instance}

\Syntaxlabel
\Defgen {make-instance} {{\funarg{class}} {\rest} {\funarg{initargs}}}


 See \fcite{make-instance}.


\Methodslabel

\flabel{\protect\mtd}{make-instance :around (persistent-metaclass)}{}
{\Defmetharound {make-instance} {(\funarg{the-class}\ \ObjectWithRef{persistent-metaclass}) {\rest} {\funarg{initargs}}}}

 Finalize the class-description of
 \funarg{the-class}\ and call the next method.


\endcom

\begingfcom[External]{make-method-lambda}

\Syntaxlabel
\Defgen {make-method-lambda} {{\funarg{generic-function}} {\funarg{method}} {\funarg{lambda-expression}} {\funarg{environment}}}


 See \fcite{make-method-lambda}. This \gfn\ has a non-\mop-conforming
 $\lambda$-list in \lw\ 3.1.1.


\Methodslabel

\flabel{\protect\mtd}{make-method-lambda (standard-generic-function persistent-reader-method t t t)}{}
{\Defmeth {make-method-lambda} {(\funarg{generic-function}\ \ObjectWithRef{standard-generic-function}) (\funarg{method}\ \ObjectWithRef{persistent-reader-method}) {\funarg{lambda-list}} {\funarg{declarations}} {\funarg{body}} {\opt} {\funarg{environment}}}}

 \allegro\ 4.3 and \lw\ 3.1.1 do not support this method for
 reader methods, i.e.\ this method will now never be called;
 it is left here for future expansion.

\flabel{\protect\mtd}{make-method-lambda (standard-generic-function persistent-writer-method t t t)}{}
{\Defmeth {make-method-lambda} {(\funarg{generic-function}\ \ObjectWithRef{standard-generic-function}) (\funarg{method}\ \ObjectWithRef{persistent-writer-method}) {\funarg{lambda-list}} {\funarg{declarations}} {\funarg{body}} {\opt} {\funarg{environment}}}}

 \allegro\ 4.3 and \lw\ 3.1.1 do not support this method for
 writer methods, i.e.\ this method will now never be called;
 it is left here for future expansion.


\endcom

\beginfncom[External]{make-persistent-object}

\Syntaxlabel
\Defun {make-persistent-object} {{\funarg{p-objid}} {\opt} {\funarg{type-tag}}}


\Argumentslabel
 \isanobjid{\funarg{p-objid}}
 \isatypetag{\funarg{type-tag}}
\Valueslabel
 If \funarg{type-tag}\ references an immediate type,
 \funarg{p-objid}\ is `loaded' and returned;
 otherwise, an instance of \fcite{persistent-object}\ with
 its \objid\ set to \funarg{p-objid}\ is returned.
\Purposelabel
 Converts \funarg{p-objid}\ into an instance of
 \fcite{persistent-object}\ for non-immediate objects,
 i.e.\ for \funarg{type-tag}\ referencing a non-immmediate
 \typetag;
 otherwise, the object itself is returned.

 The purpose of the returned object is to make it possible
 to recognize it as a persistent object by its type being
 \class{persistent-object}; this recognition
 is not possible directly for the (numeric)
 \funarg{p-objid}\ since its type is \class{fixnum}.
\Seealsolabel
 \Fcite{persistent-object}.


\endcom

\begingfcom[External]{mapbtree}

\Syntaxlabel
\Defgen {mapbtree} {{\funarg{map-function}} {\funarg{p-btree}} \key {\keyarg{<}} {\keyarg{<=}} {\keyarg{>}} {\keyarg{>=}} {\keyarg{descending}} {\keyarg{key-depth}} {\keyarg{data-depth}} {\keyarg{p-heap}}}


\Argumentslabel
 \isa{\funarg{map-function}}
      {a function which accepts two arguments}
 \isabtree{\funarg{p-btree}}
 \isakey{\keyarg{<}\ resp.\ \keyarg{<=}
          \keyarg{>}\ resp.\ \keyarg{>=}}{\funarg{p-btree}}
 \isa{\keyarg{key-depth}\ resp.\ \keyarg{data-depth}}
      {a keyword symbol}
\Valueslabel
 The number of mapped elements is returned, i.e.\ the number of times
 the \funarg{map-function}\ was called.
\Purposelabel
 For each entry in \funarg{p-btree}\ with a key in the range
 specified from \keyarg{>}\ resp.\ \keyarg{>=}\ to
 \keyarg{<}\ resp.\ \keyarg{<=}, {\bf mapbtree} calls
 \funarg{map-function}\ on
 two arguments: the key and associated data of the entry loaded
 to the depths specified by
 \keyarg{key-depth}\ resp.\ \keyarg{data-depth}. The called
 \funarg{map-function}\ has to return with \nonnil\ to
 continue the mapping; if
 \funarg{map-function}\ returns \lispnil, the mapping is stopped.

 If no \keyarg{start}-argument is passed, the iteration starts at
 the first element of \funarg{p-btree}.
 If no \keyarg{end}-argument is passed, the iteration stops {\sl after}
 the very last element of \funarg{p-btree}.
\Remarkslabel
 The keys of the elements in \funarg{p-btree}\ are ordered; the
 passed keys to \funarg{map-function}\ obey the order placed on the
 keys in \funarg{p-btree}.

 Insert- and delete-operations of any elements may be performed on
 \funarg{p-btree}\ by the called \funarg{map-function}; this is
 different to \cl\ hash tables where these operations have undefined
 effects.
\Seealsolabel
 \fcite{maphash}.


\Methodslabel

\flabel{\protect\mtd}{mapbtree (t t)}{}
{\Defmeth {mapbtree} {{\funarg{map-function}} {\funarg{p-btree}} \key {\keyarg{<}} {\keyarg{<=}} {\keyarg{>}} {\keyarg{>=}} {\keyarg{descending}} {\keyarg{key-depth}} {\keyarg{data-depth}} {\keyarg{p-heap}}}}
%
% No behavior is specified for this method beyond that which is specified
% for the generic function.


\endcom

\message{^^JGeneric function plob::mismatch-p has no methods.^^J}
\message{^^JGeneric function (setf plob::mismatch-p) has no methods.^^J}
\begingfcom[External]{open-heap}

\Syntaxlabel
\Defgen {open-heap} {{\opt} {\funarg{url}}}


\Purposelabel
 Open the \sh\ for usage. When the \sh\ is found to be empty
 (i.e.\ opened the very first time), {\bf format-plob-root}
 is called. The description objects (comparable to
 the \mo[s]\ of \clos) are loaded from the \sh.

 There is no need to call function {\bf open-heap} explicit
 (although this is possible); this will happen the first time the
 \sh\ is needed. Its main purpose is to specialise
 \lisp{:after}\ methods on \textbf{open-heap}\ to load persistent
 objects into a transient cache.
\Remarkslabel
 This still needs some more work to be done, because there can be
 only one \lisp{:after}\ method on generic functions without
 arguments which could be specialised any further.
\Seealsolabel
 \Fcite{close-heap};
 \fcite{open-session};
 \fcite{format-plob-root};
 section \fcite{bootstrap ...}.


\Methodslabel

\flabel{\protect\mtd}{open-heap nil}{}
{\Defmeth {open-heap} {{\opt} {\funarg{url}}}}
%
% No behavior is specified for this method beyond that which is specified
% for the generic function.


\endcom

\beginfncom[External]{open-my-session}

\Syntaxlabel
\Defun {open-my-session} {{\opt} {\funarg{url}} {\funarg{p-heap}}}


\Purposelabel
  A more comfortable user front end function for \fcite{open-session}.


\endcom

\begingfcom[External]{open-session}

\Syntaxlabel
\Defgen {open-session} {{\funarg{url}} {\funarg{p-heap}}}


\Valueslabel
 Returns a session-representing instance of
 \fcite{persistent-heap}.
\Purposelabel
 Open a session for \funarg{p-heap}.
 A session is viewed as a calling
 lisp-internal process by the C level of \plob\ and as a
 handle for a `logical' heap by the \cl\ level (see
 \fcite{persistent-heap}\ for details).
 A session is opened by one of the other \plob\ functions when necessary.
\Seealsolabel
 \Fcite{persistent-heap};
 \fcite{*default-persistent-heap*}.


\Methodslabel

\flabel{\protect\mtd}{open-session (t t)}{}
{\Defmeth {open-session} {{\funarg{url}} {\funarg{p-heap}}}}
%
% No behavior is specified for this method beyond that which is specified
% for the generic function.


\endcom

\beginfncom[External]{p-admin}

\Syntaxlabel
\Defun {p-admin} {{\funarg{command}} {\opt} {\funarg{url}} {\funarg{user-name}}}


\Argumentslabel
  \isa{\funarg{command}}
       {a symbol or a string naming a subcommand of script
        \lisp{plobdadmin}}
\Purposelabel
 Send \funarg{command}\ to script plobdadmin.
 In order for this command to work, the patched script
 \lisp{plobdadmin}\ found in the database root directory must be
 locatable in the current user's \lisp{\$\{HOME\}/bin}\ directory,
 for example by establishing a symbolic link.
 Furthermore, the \lisp{rsh}\ command must execute properly;
 here, that means, without reading a password. Please
 consult the \lisp{man rsh}\ pages on how to achieve this and how
 security constraints are affected by this.


\endcom

\beginfncom[External]{p-allocate-array}

\Syntaxlabel
\Defun {p-allocate-array} {{\funarg{t-array-rank}} {\opt} {\funarg{p-heap}}}


\Argumentslabel
 \isa{\funarg{t-array-rank}}
      {a fixnum}
\Purposelabel
 Returns the \objid\ of a new persistent
 array with rank \funarg{t-array-rank}\ allocated in the \sh.
\Seealsolabel
 \Fcite{p-allocate};
 \fcite{array-rank}.


\endcom

\beginfncom[External]{p-allocate-bignum}

\Syntaxlabel
\Defun {p-allocate-bignum} {{\funarg{number-of-bits}} {\opt} {\funarg{p-heap}}}


\Argumentslabel
 \isa{\funarg{number-of-bits}}
      {a fixnum}
\Purposelabel
 Returns the \objid\ of a new persistent
 bignum with \funarg{number-of-bits}\ bits
 allocated in the \sh.
\Seealsolabel
 \Fcite{p-allocate}.


\endcom

\beginfncom[External]{p-allocate-bit-vector}

\Syntaxlabel
\Defun {p-allocate-bit-vector} {{\funarg{number-of-bits}} {\opt} {\funarg{p-heap}}}


\Argumentslabel
 \isa{\funarg{number-of-bits}}
      {a fixnum}
\Purposelabel
 Returns the \objid\ of a new persistent
 bit vector with at least \funarg{number-of-bits}\ bits
 allocated in the \sh.
\Seealsolabel
 \Fcite{p-allocate}.


\endcom

\beginfncom[External]{p-allocate-complex}

\Syntaxlabel
\Defun {p-allocate-complex} {{\opt} {\funarg{p-heap}}}


\Purposelabel
 Returns the \objid\ of a new persistent
 complex number
 allocated in the \sh.
\Seealsolabel
 \Fcite{p-allocate}.


\endcom

\beginfncom[External]{p-allocate-cons}

\Syntaxlabel
\Defun {p-allocate-cons} {{\opt} {\funarg{p-heap}}}


\Purposelabel
 Returns the \objid\ of a new persistent
 cons cell
 allocated in the \sh.
\Seealsolabel
 \Fcite{p-allocate}.


\endcom

\beginfncom[External]{p-allocate-double-float}

\Syntaxlabel
\Defun {p-allocate-double-float} {{\opt} {\funarg{p-heap}}}


\Purposelabel
 Returns the \objid\ of a new persistent
 double float
 allocated in the \sh.
\Seealsolabel
 \Fcite{p-allocate}.


\endcom

\beginfncom[External]{p-allocate-function}

\Syntaxlabel
\Defun {p-allocate-function} {{\opt} {\funarg{p-heap}}}


\Purposelabel
 Returns the \objid\ of a new persistent
 function
 allocated in the \sh.
\Seealsolabel
 \Fcite{p-allocate}.


\endcom

\beginfncom[External]{p-allocate-ivector}

\Syntaxlabel
\Defun {p-allocate-ivector} {{\funarg{immediate-type}} {\funarg{number-of-elements}} {\opt} {\funarg{p-heap}}}


\Argumentslabel
 \isatypetag{\funarg{immediate-type}}
 \isa{\funarg{number-of-elements}}
      {a fixnum}
\Purposelabel
 Returns the \objid\ of a new persistent immediate vector
 allocated in the \sh\ with
 \funarg{number-of-elements}\ elements specialized to the type
 referenced by \funarg{immediate-type}.
\Remarkslabel
 An ivector is a vector whose element type is specialized to an
 immediate type, e.g.\ a vector which can only hold single floats
 is an ivector (of single floats). Transient ivector's are created
 by the \cl\ system for arrays with an element type being an
 immediate type, e.g.\ an ivector of single floats is created
 by the statement \lisp{(make-array \ldots\ :element-type
 'single-float)}.
\Seealsolabel
 \Fcite{p-allocate}.


\endcom

\beginfncom[External]{p-allocate-package}

\Syntaxlabel
\Defun {p-allocate-package} {{\opt} {\funarg{p-heap}}}


\Purposelabel
 Returns the \objid\ of a new persistent
 package
 allocated in the \sh.
\Seealsolabel
 \Fcite{persistent-package};
 \fcite{p-allocate}.


\endcom

\beginfncom[External]{p-allocate-ratio}

\Syntaxlabel
\Defun {p-allocate-ratio} {{\opt} {\funarg{p-heap}}}


\Purposelabel
 Returns the \objid\ of a new persistent
 ratio number
 allocated in the \sh.
\Seealsolabel
 \Fcite{p-allocate}.


\endcom

\beginfncom[External]{p-allocate-single-float}

\Syntaxlabel
\Defun {p-allocate-single-float} {{\opt} {\funarg{p-heap}}}


\Purposelabel
 Returns the \objid\ of a new persistent
 single float
 allocated in the \sh.
\Seealsolabel
 \Fcite{p-allocate}.


\endcom

\beginfncom[External]{p-allocate-string}

\Syntaxlabel
\Defun {p-allocate-string} {{\funarg{number-of-characters}} {\opt} {\funarg{p-heap}}}


\Argumentslabel
 \isa{\funarg{number-of-characters}}
      {a fixnum}
\Purposelabel
 Returns the \objid\ of a new persistent
 string with at least \funarg{number-of-characters}\ characters
 allocated in the \sh.
\Seealsolabel
 \Fcite{p-allocate}.


\endcom

\beginfncom[External]{p-allocate-structure}

\Syntaxlabel
\Defun {p-allocate-structure} {{\funarg{structure-description}} {\opt} {\funarg{p-heap}}}


\Argumentslabel
 \isa{\funarg{structure-description}}
      {a structure description}
\Purposelabel
 Returns the \objid\ of a new persistent
 structure described by \funarg{structure-description}\ allocated
 in the \sh.
\Seealsolabel
 \Fcite{p-allocate}.


\endcom

\beginfncom[External]{p-allocate-structure-description}

\Syntaxlabel
\Defun {p-allocate-structure-description} {{\opt} {\funarg{p-heap}}}


\Purposelabel
 Returns the \objid\ of a new persistent
 structure-description
 allocated in the \sh.
\Seealsolabel
 \Fcite{structure-description};
 \fcite{p-allocate}.


\endcom

\beginfncom[External]{p-allocate-structure-slot-description}

\Syntaxlabel
\Defun {p-allocate-structure-slot-description} {{\opt} {\funarg{p-heap}}}


\Purposelabel
 Returns the \objid\ of a new persistent
 structure-slot-description
 allocated in the \sh.
\Seealsolabel
 \Fcite{structure-slot-description};
 \fcite{p-allocate}.


\endcom

\beginfncom[External]{p-allocate-symbol}

\Syntaxlabel
\Defun {p-allocate-symbol} {{\opt} {\funarg{p-heap}}}


\Purposelabel
 Returns the \objid\ of a new persistent
 symbol
 allocated in the \sh.
\Seealsolabel
 \Fcite{p-allocate}.


\endcom

\beginfncom[External]{p-allocate-vector}

\Syntaxlabel
\Defun {p-allocate-vector} {{\funarg{number-of-elements}} {\opt} {\funarg{p-heap}}}


\Argumentslabel
 \isa{\funarg{number-of-elements}}
      {a fixnum}
\Purposelabel
 Returns the \objid\ of a new persistent
 vector with \funarg{number-of-elements}\ elements
 allocated in the \sh.
\Seealsolabel
 \Fcite{p-allocate}.


\endcom

\beginfncom[External]{p-apropos}

\Syntaxlabel
\Defun {p-apropos} {{\opt} {\funarg{search-string}} {\rest} {\funarg{packages}}}


\Argumentslabel
 \isa{\funarg{search-string}}
      {a string}
 \isa{\funarg{packages}}
      {a list of names of persistent packages}
\Purposelabel
 At first see \fcite{apropos}.

 The difference to {\bf apropos} is that the symbols printed
 are persistent symbols, i.e.\ symbols stored in the \sh.
\Seealsolabel
 Section \fcite{symbol ...};
 \fcite{p-apropos-classes};
 \fcite{p-apropos-packages};
 \fcite{apropos}.


\endcom

\beginfncom[External]{p-apropos-btree}

\Syntaxlabel
\Defun {p-apropos-btree} {{\funarg{btree}} {\opt} {\funarg{search-string}}}


\Argumentslabel
 \isabtree{\funarg{btree}}
 \isa{\funarg{search-string}}
      {a string}
\Purposelabel
 Print the contents of \funarg{btree}\ in a human-readable form.
 If \funarg{search-string}\ is passed, only BTree entries with
 \funarg{search-string}\ in their key are printed.
\Seealsolabel
 \Fcite{make-btree};
 \fcite{p-apropos}.


\endcom

\beginfncom[External]{p-apropos-classes}

\Syntaxlabel
\Defun {p-apropos-classes} {{\opt} {\funarg{class-name}}}


\Argumentslabel
 \isa{\funarg{class-name}}
      {a string}
\Purposelabel
 Print all defined persistent classes in a human-readable form.
 If \funarg{class-name}\ is passed, only persistent classes with
 \funarg{class-name}\ in their name are printed.
\Seealsolabel
 \Fcite{p-find-class};
 \fcite{p-apropos};
 \fcite{p-apropos-packages};
 \fcite{apropos}.


\endcom

\beginfncom[External]{p-apropos-packages}

\Syntaxlabel
\Defun {p-apropos-packages} {{\opt} {\funarg{package-name}}}


\Argumentslabel
 \isa{\funarg{package-name}}
      {a string}
\Purposelabel
 Print all defined persistent packages in a human-readable form.
 If \funarg{package-name}\ is passed, only persistent packages with
 \funarg{package-name}\ in their name are printed.
\Seealsolabel
 \Fcite{p-apropos};
 \fcite{p-apropos-classes};
 \fcite{apropos}.


\endcom

\beginfncom[External]{p-array}

\Syntaxlabel
\Defun {p-array} {{\funarg{p-objid}} {\opt} {\funarg{depth}} {\funarg{p-heap}}}


\Argumentslabel
 \isanobjid{\funarg{p-objid}}
\Purposelabel
 Return a transient representation for the persistent
 array
 referenced by \funarg{p-objid}.
\Seealsolabel
 \Fcite{(setf p-array)}.


\endcom

\beginfncom[External]{(setf p-array)}

\Syntaxlabel
\Defun {(setf p-array)} {{\funarg{t-array}} {\opt} {\funarg{p-objid}} {\funarg{depth}} {\funarg{p-heap}}}


\Argumentslabel
 \isa{\funarg{t-array}}
      {an array}
 \isanobjid{\funarg{p-objid}}
\Valueslabel
 \retarg{\funarg{t-array}}
\Purposelabel
 Store the transient array in \funarg{t-array}\ to the
 persistent array referenced by \funarg{p-objid}.
\Seealsolabel
 \Fcite{p-array}.


\endcom

\beginfncom[External]{p-array-adjustable}

\Syntaxlabel
\Defun {p-array-adjustable} {{\funarg{p-objid}} {\opt} {\funarg{depth}} {\funarg{p-heap}}}


\Argumentslabel
 \isanobjid{\funarg{p-objid}}
\Purposelabel
 See \fcite{adjustable-array-p}.


\endcom

\beginfncom[External]{p-array-data-vector}

\Syntaxlabel
\Defun {p-array-data-vector} {{\funarg{p-objid}} {\opt} {\funarg{depth}} {\funarg{p-heap}}}


\Argumentslabel
 \isanobjid{\funarg{p-objid}}
\Purposelabel
 Get the data vector of the persistent array referenced by
 \funarg{p-objid}.
\Seealsolabel
 \Fcite{array-data-vector}.


\endcom

\beginfncom[External]{p-array-dimensions}

\Syntaxlabel
\Defun {p-array-dimensions} {{\funarg{p-objid}} {\opt} {\funarg{depth}} {\funarg{p-heap}}}


\Argumentslabel
 \isanobjid{\funarg{p-objid}}
\Purposelabel
 See \fcite{array-dimensions}.


\endcom

\beginfncom[External]{p-array-displaced-offset}

\Syntaxlabel
\Defun {p-array-displaced-offset} {{\funarg{p-objid}} {\opt} {\funarg{depth}} {\funarg{p-heap}}}


\Argumentslabel
 \isanobjid{\funarg{p-objid}}
\Purposelabel
 Get the displaced offset of the persistent array referenced by
 \funarg{p-objid}.
\Seealsolabel
 \Fcite{array-displaced-offset}.


\endcom

\beginfncom[External]{p-array-element-type}

\Syntaxlabel
\Defun {p-array-element-type} {{\funarg{p-objid}} {\opt} {\funarg{p-heap}}}


\Argumentslabel
 \isanobjid{\funarg{p-objid}}
\Purposelabel
 See \fcite{array-element-type}.


\endcom

\beginfncom[External]{p-array-fill-pointer}

\Syntaxlabel
\Defun {p-array-fill-pointer} {{\funarg{p-objid}} {\opt} {\funarg{depth}} {\funarg{p-heap}}}


\Argumentslabel
 \isanobjid{\funarg{p-objid}}
\Purposelabel
 See \fcite{fill-pointer}.


\endcom

\beginfncom[External]{(setf p-array-fill-pointer)}

\Syntaxlabel
\Defun {(setf p-array-fill-pointer)} {{\funarg{t-array-fill-pointer}} {\funarg{p-objid}} {\opt} {\funarg{depth}} {\funarg{p-heap}}}


\Argumentslabel
 \isa{\funarg{t-array-fill-pointer}}
      {a fixnum}
 \isanobjid{\funarg{p-objid}}
\Purposelabel
 See \fcite{(setf fill-pointer)}.


\endcom

\beginfncom[External]{p-array-rank}

\Syntaxlabel
\Defun {p-array-rank} {{\funarg{p-objid}} {\opt} {\funarg{depth}} {\funarg{p-heap}}}


\Argumentslabel
 \isanobjid{\funarg{p-objid}}
\Purposelabel
 See \fcite{array-rank}.


\endcom

\beginfncom[External]{p-arrayp}

\Syntaxlabel
\Defun {p-arrayp} {{\funarg{p-objid}} {\opt} {\funarg{p-heap}}}


\Argumentslabel
 \isanobjid{\funarg{p-objid}}
\Purposelabel
 See \fcite{arrayp}.


\endcom

\beginfncom[External]{p-bignum}

\Syntaxlabel
\Defun {p-bignum} {{\funarg{p-objid}} {\opt} {\funarg{p-heap}}}


\Argumentslabel
 \isanobjid{\funarg{p-objid}}
\Purposelabel
 Return a transient representation for the persistent
 bignum
 referenced by \funarg{p-objid}.
\Seealsolabel
 \Fcite{(setf p-bignum)};
 \fcite{sh-read-bignum}.


\endcom

\beginfncom[External]{(setf p-bignum)}

\Syntaxlabel
\Defun {(setf p-bignum)} {{\funarg{the-bignum}} {\funarg{p-objid}} {\opt} {\funarg{p-heap}}}


\Argumentslabel
 \isa{\funarg{the-bignum}}
      {a bignum}
 \isanobjid{\funarg{p-objid}}
\Valueslabel
 \retarg{\funarg{the-bignum}}
\Purposelabel
 Store the transient bignum in \funarg{the-bignum}\ to the
 persistent bignum referenced by \funarg{p-objid}.
\Seealsolabel
 \Fcite{p-bignum};
 \fcite{sh-write-bignum}.


\endcom

\beginfncom[External]{p-bignum-p}

\Syntaxlabel
\Defun {p-bignum-p} {{\funarg{p-objid}} {\opt} {\funarg{p-heap}}}


\Argumentslabel
 \isanobjid{\funarg{p-objid}}
\Purposelabel
 See \fcite{integerp}.


\endcom

\beginfncom[External]{p-bit-vector}

\Syntaxlabel
\Defun {p-bit-vector} {{\funarg{p-objid}} {\opt} {\funarg{depth}} {\funarg{p-heap}}}


\Argumentslabel
 \isanobjid{\funarg{p-objid}}
\Purposelabel
 Return a transient representation for the persistent
 bit vector
 referenced by \funarg{p-objid}.
\Seealsolabel
 \Fcite{(setf p-bit-vector)}.


\endcom

\beginfncom[External]{(setf p-bit-vector)}

\Syntaxlabel
\Defun {(setf p-bit-vector)} {{\funarg{t-bit-vector}} {\opt} {\funarg{p-objid}} {\funarg{depth}} {\funarg{p-heap}}}


\Argumentslabel
 \isa{\funarg{t-bit-vector}}
      {a bit vector}
 \isanobjid{\funarg{p-objid}}
\Valueslabel
 \retarg{\funarg{t-bit-vector}}
\Purposelabel
 Store the transient bit vector in \funarg{t-bit-vector}\ to the
 persistent bit vector referenced by \funarg{p-objid}.
\Seealsolabel
 \Fcite{p-bit-vector}.


\endcom

\beginfncom[External]{p-bit-vector-length}

\Syntaxlabel
\Defun {p-bit-vector-length} {{\funarg{p-objid}} {\opt} {\funarg{p-heap}}}


\Argumentslabel

 \isanobjid{\funarg{p-objid}}

\Purposelabel

 See \fcite{array-total-size}.


\endcom

\beginfncom[External]{p-bit-vector-max-length}

\Syntaxlabel
\Defun {p-bit-vector-max-length} {{\funarg{p-objid}} {\opt} {\funarg{p-heap}}}


\Argumentslabel

 \isanobjid{\funarg{p-objid}}

\Purposelabel

 Get the maximum possible length of the persistent bit vector
 referenced by \funarg{p-objid}; this returns the total
 number of bits allocated for the bit vector including the
 space used for alignment.

\Seealsolabel

 \Fcite{p-bit-vector-length}.


\endcom

\beginfncom[External]{p-bit-vector-p}

\Syntaxlabel
\Defun {p-bit-vector-p} {{\funarg{p-objid}} {\opt} {\funarg{p-heap}}}


\Argumentslabel
 \isanobjid{\funarg{p-objid}}
\Purposelabel
 See \fcite{bit-vector-p}.


\endcom

\beginfncom[External]{p-boundp}

\Syntaxlabel
\Defun {p-boundp} {{\funarg{p-objid}} {\opt} {\funarg{p-heap}}}


\Argumentslabel
 \isanobjid{\funarg{p-objid}}
\Purposelabel
 See \fcite{boundp}.


\endcom

\beginfncom[External]{p-car}

\Syntaxlabel
\Defun {p-car} {{\funarg{p-objid}} {\opt} {\funarg{depth}} {\funarg{p-heap}}}


\Argumentslabel
 \isanobjid{\funarg{p-objid}}
\Purposelabel
 See \fcite{car}.


\endcom

\beginfncom[External]{(setf p-car)}

\Syntaxlabel
\Defun {(setf p-car)} {{\funarg{t-car}} {\funarg{p-objid}} {\opt} {\funarg{depth}} {\funarg{p-heap}}}


\Argumentslabel
 \isanobject{\funarg{t-car}}
 \isanobjid{\funarg{p-objid}}
\Purposelabel
 See \fcite{(setf car)}.


\endcom

\beginfncom[External]{p-cdr}

\Syntaxlabel
\Defun {p-cdr} {{\funarg{p-objid}} {\opt} {\funarg{depth}} {\funarg{p-heap}}}


\Argumentslabel
 \isanobjid{\funarg{p-objid}}
\Purposelabel
 See \fcite{cdr}.


\endcom

\beginfncom[External]{(setf p-cdr)}

\Syntaxlabel
\Defun {(setf p-cdr)} {{\funarg{t-cdr}} {\funarg{p-objid}} {\opt} {\funarg{depth}} {\funarg{p-heap}}}


\Argumentslabel
 \isanobject{\funarg{t-cdr}}
 \isanobjid{\funarg{p-objid}}
\Purposelabel
 See \fcite{(setf cdr)}.


\endcom

\beginfncom[External]{p-class-of}

\Syntaxlabel
\Defun {p-class-of} {{\funarg{p-objid}} {\opt} {\funarg{depth}} {\funarg{p-heap}}}


\Argumentslabel
 \isanobjid{\funarg{p-objid}}
\Valueslabel
 Either an instance of \fcite{structure-description}\ or
 an instance of \fcite{class-description}\ or
 a symbol.
\Purposelabel
 Returns a class description for \funarg{p-objid}\ if available.
 If the class of the object referenced by \funarg{p-objid}\ has
 no class description, its type tag converted to a symbol named
 by the string equivalent of the persistent object's type tag
 is returned.
\Remarkslabel
 1996/10/14 HK: Looks as if p-class-of crashes the server with a
 segmentation violation when working on description objects passed
 as p-objid.
\Seealsolabel
 \Fcite{structure-description};
 \fcite{class-description}.


\endcom

\beginfncom[External]{p-complex}

\Syntaxlabel
\Defun {p-complex} {{\funarg{p-objid}} {\opt} {\funarg{p-heap}}}


\Argumentslabel
 \isanobjid{\funarg{p-objid}}
\Purposelabel
 Return a transient representation for the persistent
 complex number
 referenced by \funarg{p-objid}.
\Seealsolabel
 \Fcite{(setf p-complex)}.


\endcom

\beginfncom[External]{(setf p-complex)}

\Syntaxlabel
\Defun {(setf p-complex)} {{\funarg{t-complex}} {\opt} {\funarg{p-objid}} {\funarg{p-heap}}}


\Argumentslabel
 \isa{\funarg{t-complex}}
      {a complex number}
 \isanobjid{\funarg{p-objid}}
\Valueslabel
 \retarg{\funarg{t-complex}}
\Purposelabel
 Store the transient complex number in \funarg{t-complex}\ to the
 persistent complex number referenced by \funarg{p-objid}.
\Seealsolabel
 \Fcite{p-complex}.


\endcom

\beginfncom[External]{p-complexp}

\Syntaxlabel
\Defun {p-complexp} {{\funarg{p-objid}} {\opt} {\funarg{p-heap}}}


\Argumentslabel
 \isanobjid{\funarg{p-objid}}
\Purposelabel
 See \fcite{complexp}.


\endcom

\beginfncom[External]{p-configuration}

\Syntaxlabel
\Defun {p-configuration} {{\opt} {\funarg{p-heap}}}

Get the Stable Heap configuration settings.


\endcom

\beginfncom[External]{p-cons}

\Syntaxlabel
\Defun {p-cons} {{\funarg{the-car}} {\funarg{the-cdr}} {\opt} {\funarg{depth}} {\funarg{p-heap}}}


\Purposelabel
 Allocate a persistent cons cell and fill it from
 \funarg{the-car}\ and \funarg{the-cdr}.
\Seealsolabel
 \Fcite{cons}.


\endcom

\beginfncom[External]{p-consp}

\Syntaxlabel
\Defun {p-consp} {{\funarg{p-objid}} {\opt} {\funarg{p-heap}}}


\Argumentslabel
 \isanobjid{\funarg{p-objid}}
\Purposelabel
 See \fcite{consp}.


\endcom

\beginfncom[External]{p-create-database}

\Syntaxlabel
\Defun {p-create-database} {{\funarg{url}}}


\Purposelabel
  Create a new database on \funarg{url}. For technical reasons,
  a currently opened database is closed before the new database
  is created. Please note that it may take some time until the database
  is created, since the server must start up a new daemon process
  for the fresh created database.


\endcom

\beginfncom[External]{p-create-machine}

\Syntaxlabel
\Defun {p-create-machine} {{\funarg{mach-name}} {\opt} {\funarg{loginp}} {\funarg{p-heap}}}


\Purposelabel
 Return an object representing the machine named \funarg{mach-name}.


\endcom

\beginfncom[External]{p-delete-class}

\Syntaxlabel
\Defun {p-delete-class} {{\funarg{name}} {\opt} {\funarg{p-heap}}}


\Argumentslabel
 \isa{\funarg{name}}
      {a string or a symbol}
\Valueslabel
 Returns \nonnil\ iff the class was found and removed,
 \lispnil\ otherwise.
\Purposelabel
 Remove the persistent class named \funarg{name}\ from
 the \sh.
\Remarkslabel
 If there are still instances of the deleted class reachable
 in the \sh, the persistent class will be put back into the
 class table contained in
 \fcite{*symbol->class-table*}\ next time when such an
 instance is loaded.


\endcom

\beginfncom[External]{p-delete-machine}

\Syntaxlabel
\Defun {p-delete-machine} {{\funarg{machine}} {\opt} {\funarg{p-heap}}}


\Purposelabel
 Delete \funarg{machine}\ from the internal list of known machines.
\Remarkslabel
 This function may only be called by the \plob\ administrator.


\endcom

\beginfncom[External]{p-delete-package}

\Syntaxlabel
\Defun {p-delete-package} {{\funarg{t-package}} {\opt} {\funarg{p-heap}}}


\Argumentslabel
 \isa{\funarg{t-package}}
      {either a string or a symbol or a package}
\Valueslabel
 Returns \nonnil\ iff the package was found and removed,
 \lispnil\ otherwise.
\Purposelabel
 Remove the persistent-package named \funarg{t-package}\ from
 the \sh.
\Remarkslabel
 If there are still symbols of the deleted package reachable
 in the \sh, the persistent-package will be put back into the
 package table contained in
 \fcite{*name->package-table*}\ next time when such a
 symbol is loaded.
\Seealsolabel
 \Fcite{p-find-package};
 \fcite{persistent-package};
 \fcite{delete-package}.


\endcom

\beginfncom[External]{p-denominator}

\Syntaxlabel
\Defun {p-denominator} {{\funarg{p-objid}} {\opt} {\funarg{p-heap}}}


\Argumentslabel
 \isanobjid{\funarg{p-objid}}
\Purposelabel
 See \fcite{denominator}.


\endcom

\beginfncom[External]{p-dependent}

\Syntaxlabel
\Defun {p-dependent} {{\funarg{p-objid}} {\opt} {\funarg{p-heap}}}

Get the dependent flag of \funarg{p-objid}.


\endcom

\beginfncom[External]{(setf p-dependent)}

\Syntaxlabel
\Defun {(setf p-dependent)} {{\funarg{symbolic-dependent-mode}} {\funarg{p-objid}} {\opt} {\funarg{p-heap}}}

Set the dependent flag of \funarg{p-objid}.


\endcom

\beginfncom[External]{p-double-float}

\Syntaxlabel
\Defun {p-double-float} {{\funarg{p-objid}} {\opt} {\funarg{p-heap}}}


\Argumentslabel
 \isanobjid{\funarg{p-objid}}
\Purposelabel
 Return a transient representation for the persistent
 double float
 referenced by \funarg{p-objid}.
\Seealsolabel
 \Fcite{(setf p-double-float)};
 \fcite{sh-read-double-float}.


\endcom

\beginfncom[External]{(setf p-double-float)}

\Syntaxlabel
\Defun {(setf p-double-float)} {{\funarg{the-double-float}} {\funarg{p-objid}} {\opt} {\funarg{p-heap}}}


\Argumentslabel
 \isa{\funarg{the-double-float}}
      {a double float}
 \isanobjid{\funarg{p-objid}}
\Valueslabel
 \retarg{\funarg{the-double-float}}
\Purposelabel
 Store the transient double float in \funarg{the-double-float}\ to the
 persistent double float referenced by \funarg{p-objid}.
\Seealsolabel
 \Fcite{p-double-float};
 \fcite{sh-write-double-float}.


\endcom

\beginfncom[External]{p-double-float-p}

\Syntaxlabel
\Defun {p-double-float-p} {{\funarg{p-objid}} {\opt} {\funarg{p-heap}}}


\Argumentslabel
 \isanobjid{\funarg{p-objid}}
\Purposelabel
 See \fcite{floatp}.


\endcom

\beginfncom[External]{p-exit}

\Syntaxlabel
\Defun {p-exit} {{\opt} {\funarg{force}} {\funarg{url}}}


\Argumentslabel
 \isabool{force}
\Purposelabel
 Try to exit the \plob\ server daemon. When \funarg{force}\ is
 \lispnil, the exit request is rejected when there are other active
 client sessions. Passing \nonnil\ for \funarg{force}\ will force
 a server exit which in turn will have unpredictable consequences for
 the other clients, since all clients states will be lost.

 After the daemon has exited, it can only be started again on the
 server host by the \plob\ administrator, e.g.\ by using the
 \lisp{plobdadmin}\ script with the \lisp{start}\ command on
 the server host.


\endcom

\beginfncom[External]{p-fboundp}

\Syntaxlabel
\Defun {p-fboundp} {{\funarg{p-objid}} {\opt} {\funarg{p-heap}}}


\Argumentslabel
 \isanobjid{\funarg{p-objid}}
\Purposelabel
 See \fcite{fboundp}.


\endcom

\beginfncom[External]{p-find-class}

\Syntaxlabel
\Defun {p-find-class} {{\funarg{name}} {\opt} {\funarg{depth}} {\funarg{p-heap}}}


\Argumentslabel
 \isa{\funarg{name}}
      {a string or a symbol}
\Valueslabel
 Returns a class description or \lispnil.
\Purposelabel
 Search for a persistent class named \funarg{name}; iff such a
 class is found, return its class description; otherwise, return
 \lispnil.
\Remarkslabel
 There's a problem with the different packages assigned to symbols
 across more than one LISP system in conjunction with the names
 of persistent classes and the missing \lisp{use-package}\ support
 for persistent packages in \plob. For example, in \lw\ the symbol
 \lisp{standard-class}\ belongs to the \lisp{clos}\ package; so,
 a \plob\ database formatted by a \lw\ system will put the name
 of the class \class{standard-class}\ into the persistent
 \lisp{CLOS}\ package. On the contrary, in \allegro\ the symbol
 \lisp{standard-class}\ belongs to the \lisp{common-lisp}\ package;
 consequently, an \allegro\ system won't find the symbol
 \lisp{standard-class}\ in a database formatted by \lw.

 The current fixup is to load all class name symbols from the
 persistent heap when an unknown class name is passed to
 \fcite{p-find-class}. This will put all class' names into
 the cache, where in turn they will be found by \fcite{p-find-symbol}.
\Seealsolabel
 \Fcite{class-description};
 \fcite{structure-description};
 \fcite{p-apropos-classes};
 \fcite{find-class}.


\endcom

\beginfncom[External]{p-find-package}

\Syntaxlabel
\Defun {p-find-package} {{\funarg{t-package}} {\opt} {\funarg{depth}} {\funarg{p-heap}}}


\Argumentslabel
 \isa{\funarg{t-package}}
      {either a string or a symbol or a package}
\Valueslabel
 Returns a persistent-package or \lispnil.
\Purposelabel
 Search for a persistent-package named \funarg{t-package}; iff such a
 package is found, return a package-representing instance of
 \fcite{persistent-package}; otherwise, return \lispnil.
\Seealsolabel
 \Fcite{p-delete-package};
 \fcite{persistent-package};
 \fcite{p-apropos-packages};
 \fcite{find-package}.


\endcom

\beginfncom[External]{p-find-symbol}

\Syntaxlabel
\Defun {p-find-symbol} {{\funarg{t-symbol}} \key {\keyarg{package}} {\keyarg{depth}} {\keyarg{p-heap}}}


\Argumentslabel
 \isa{\funarg{t-symbol}}
      {a transient string or a transient symbol}
 \isa{\keyarg{package}}
      {either a package object or a package name as a string or symbol}
\Valueslabel
 Returns two values:
 \begin{enumerate}

 \item Iff a persistent symbol named \funarg{t-symbol}\ was found,
  a transient representation of the persistent symbol (i.e.\ a
  transient symbol) is returned as the first value,
  \lispnil\ otherwise.

 \item The second value is \nonnil\ iff 
  a persistent symbol named \funarg{t-symbol}\ was found at all,
  \lispnil\ otherwise.

 \end{enumerate}
\Purposelabel
 Search for a persistent symbol named \funarg{t-symbol}.
 If \keyarg{package}\ is passed, the symbol is searched in the
 persistent-package named by \keyarg{package}.
\Seealsolabel
 \Fcite{find-symbol}.


\endcom

\beginfncom[External]{p-fmakunbound}

\Syntaxlabel
\Defun {p-fmakunbound} {{\funarg{t-symbol}} {\opt} {\funarg{p-heap}}}


\Argumentslabel
 \isa{\funarg{t-symbol}}
      {a (transient) symbol}
\Purposelabel
 Make the function cell of the persistent symbol named like
 \funarg{t-symbol}\ unbound.
\Seealsolabel
 \Fcite{fmakunbound}.


\endcom

\beginfncom[External]{p-function}

\Syntaxlabel
\Defun {p-function} {{\funarg{p-objid}} {\opt} {\funarg{depth}} {\funarg{p-heap}}}


\Argumentslabel
 \isanobjid{\funarg{p-objid}}
\Purposelabel
 Return a transient representation for the persistent
 function
 referenced by \funarg{p-objid}.
\Remarkslabel
 \plob\ cannot load code because of relocation and binder
 problems; instead, a function is stored by its name.
 At function load time \plob\ tries to find an \lisp{equal}\ named
 function in the \cl\ image.
\Seealsolabel
 \Fcite{(setf p-function)};
 \fcite{get-function-name}.


\endcom

\beginfncom[External]{(setf p-function)}

\Syntaxlabel
\Defun {(setf p-function)} {{\funarg{t-function}} {\opt} {\funarg{p-objid}} {\funarg{depth}} {\funarg{p-heap}}}


\Argumentslabel
 \isa{\funarg{t-function}}
      {a function}
 \isanobjid{\funarg{p-objid}}
\Valueslabel
 \retarg{\funarg{t-function}}
\Purposelabel
 Store the transient function in \funarg{t-function}\ to the
 persistent function referenced by \funarg{p-objid}.
\Remarkslabel
 \plob\ cannot store code because of relocation and binder
 problems which would occure when the code is subject to be
 loaded again; instead, a function is stored by its name.
 At function load time \plob\ tries to find an \lisp{equal}\ named
 function in the \cl\ image.
\Seealsolabel
 \Fcite{p-function};
 \fcite{get-function-name}.


\endcom

\beginfncom[External]{p-function-code}

\Syntaxlabel
\Defun {p-function-code} {{\funarg{p-objid}} {\opt} {\funarg{depth}} {\funarg{p-heap}}}


\Argumentslabel
 \isanobjid{\funarg{p-objid}}
\Purposelabel
 Get the code of the persistent function referenced by
 \funarg{p-objid}.
\Seealsolabel
 \Fcite{(setf p-function-code)}.


\endcom

\beginfncom[External]{(setf p-function-code)}

\Syntaxlabel
\Defun {(setf p-function-code)} {{\funarg{t-code}} {\funarg{p-objid}} {\opt} {\funarg{depth}} {\funarg{p-heap}}}


\Argumentslabel
 \isanobject{\funarg{t-code}}
 \isanobjid{\funarg{p-objid}}
\Purposelabel
 Set the code of the persistent function referenced by
 \funarg{p-objid} to \funarg{t-code}.
\Seealsolabel
 \Fcite{p-function-code}.


\endcom

\beginfncom[External]{p-function-language}

\Syntaxlabel
\Defun {p-function-language} {{\funarg{p-objid}} {\opt} {\funarg{depth}} {\funarg{p-heap}}}


\Argumentslabel
 \isanobjid{\funarg{p-objid}}
\Purposelabel
 Get the language of the persistent function referenced by
 \funarg{p-objid}.
\Seealsolabel
 \Fcite{(setf p-function-language)}.


\endcom

\beginfncom[External]{(setf p-function-language)}

\Syntaxlabel
\Defun {(setf p-function-language)} {{\funarg{t-language}} {\funarg{p-objid}} {\opt} {\funarg{depth}} {\funarg{p-heap}}}


\Argumentslabel
 \isa{\funarg{t-language}}
      {a keyword symbol}
 \isanobjid{\funarg{p-objid}}
\Purposelabel
 Set the language of the persistent function referenced by
 \funarg{p-objid} to \funarg{t-language}.
\Seealsolabel
 \Fcite{p-function-language};
 \fcite{+lisp-code-type+}.


\endcom

\beginfncom[External]{p-function-name}

\Syntaxlabel
\Defun {p-function-name} {{\funarg{p-objid}} {\opt} {\funarg{depth}} {\funarg{p-heap}}}


\Argumentslabel
 \isanobjid{\funarg{p-objid}}
\Purposelabel
 Get the name of the persistent function referenced by
 \funarg{p-objid}.
\Seealsolabel
 \Fcite{(setf p-function-name)};
 \fcite{get-function-name}.


\endcom

\beginfncom[External]{(setf p-function-name)}

\Syntaxlabel
\Defun {(setf p-function-name)} {{\funarg{t-name}} {\funarg{p-objid}} {\opt} {\funarg{depth}} {\funarg{p-heap}}}


\Argumentslabel
 \isa{\funarg{t-name}}
      {a symbol}
 \isanobjid{\funarg{p-objid}}
\Purposelabel
 Set the name of the persistent function referenced by
 \funarg{p-objid} to \funarg{t-name}.
\Seealsolabel
 \Fcite{p-function-name};
 \fcite{get-function-name}.


\endcom

\beginfncom[External]{p-functionp}

\Syntaxlabel
\Defun {p-functionp} {{\funarg{p-objid}} {\opt} {\funarg{p-heap}}}


\Argumentslabel
 \isanobjid{\funarg{p-objid}}
\Purposelabel
 See \fcite{functionp}.


\endcom

\beginfncom[External]{p-hash-table}

\Syntaxlabel
\Defun {p-hash-table} {{\funarg{p-objid}} {\opt} {\funarg{depth}} {\funarg{p-heap}}}


\Argumentslabel
 \isanobjid{\funarg{p-objid}}
\Purposelabel
 Create the transient representation of the persistent hash table
 referenced by \funarg{p-objid}.
 returned in its transient representation.
\Seealsolabel
 \stcite{435--441}.


\endcom

\beginfncom[External]{(setf p-hash-table)}

\Syntaxlabel
\Defun {(setf p-hash-table)} {{\funarg{t-hash-table}} {\opt} {\funarg{p-objid}} {\funarg{depth}} {\funarg{p-heap}}}


\Argumentslabel
 \isanobject{\funarg{t-hash-table}}
 \isanobjid{\funarg{p-objid}}
\Valueslabel
 \retarg{\funarg{t-hash-table}}
\Purposelabel
 Store the transient hash table \funarg{t-hash-table}\ to
 \funarg{p-objid}.
\Seealsolabel
 \stcite{435--441}.


\endcom

\beginfncom[External]{p-imagpart}

\Syntaxlabel
\Defun {p-imagpart} {{\funarg{p-objid}} {\opt} {\funarg{p-heap}}}


\Argumentslabel
 \isanobjid{\funarg{p-objid}}
\Purposelabel
 See \fcite{imagpart}.


\endcom

\beginfncom[External]{p-insert-machine}

\Syntaxlabel
\Defun {p-insert-machine} {{\funarg{machine}} {\opt} {\funarg{p-heap}}}


\Purposelabel
 Insert \funarg{machine}\ into the internal list of known machines.
\Remarkslabel
 This function may only be called by the \plob\ administrator.


\endcom

\beginfncom[External]{p-intern}

\Syntaxlabel
\Defun {p-intern} {{\funarg{t-symbol}} \key {\keyarg{package}} {\keyarg{p-heap}}}


\Argumentslabel
 \isa{\funarg{t-symbol}}
      {a transient string or a transient symbol}
 \isa{\keyarg{package}}
      {either a package object or a package name as a string or symbol}
\Purposelabel
 See \fcite{intern}.
\Seealsolabel
 \Fcite{p-find-symbol}.


\endcom

\beginfncom[External]{p-ivector}

\Syntaxlabel
\Defun {p-ivector} {{\funarg{p-objid}} {\opt} {\funarg{depth}} {\funarg{p-heap}}}


\Argumentslabel
 \isanobjid{\funarg{p-objid}}
\Purposelabel
 Return a transient representation for the persistent
 immediate vector
 referenced by \funarg{p-objid}.
\Seealsolabel
 \Fcite{(setf p-ivector)}.


\endcom

\beginfncom[External]{(setf p-ivector)}

\Syntaxlabel
\Defun {(setf p-ivector)} {{\funarg{t-ivector}} {\opt} {\funarg{p-objid}} {\funarg{depth}} {\funarg{p-heap}}}


\Argumentslabel
 \isa{\funarg{t-ivector}}
      {an immediate vector}
 \isanobjid{\funarg{p-objid}}
\Valueslabel
 \retarg{\funarg{t-vector}}
\Purposelabel
 Store the transient immmediate vector in \funarg{t-ivector}\ to the
 persistent immediate vector referenced by \funarg{p-objid}.
\Seealsolabel
 \Fcite{p-ivector}.


\endcom

\beginfncom[External]{p-ivector-length}

\Syntaxlabel
\Defun {p-ivector-length} {{\funarg{p-objid}} {\opt} {\funarg{p-heap}}}


\Argumentslabel
 \isanobjid{\funarg{p-objid}}
\Purposelabel
 See \fcite{array-total-size}.


\endcom

\beginfncom[External]{p-ivector-type}

\Syntaxlabel
\Defun {p-ivector-type} {{\funarg{p-objid}} {\opt} {\funarg{p-heap}}}


\Argumentslabel
 \isanobjid{\funarg{p-objid}}
\Valueslabel
 Returns a type specifier.
\Purposelabel
 Get the immediate type to which the elements of the persistent
 immediate vector referenced by \funarg{p-objid}\ are specialized to.
\Seealsolabel
 \Fcite{p-allocate-ivector};
 \fcite{p-upgraded-array-element-tag}.


\endcom

\beginfncom[External]{p-ivectorp}

\Syntaxlabel
\Defun {p-ivectorp} {{\funarg{p-objid}} {\opt} {\funarg{p-heap}}}


\Argumentslabel
 \isanobjid{\funarg{p-objid}}
\Purposelabel
 Returns \nonnil\ iff \funarg{p-objid}\ references a
 persistent object of type
 immediate vector,
 \lispnil\ otherwise.
\Seealsolabel
 \Fcite{t-ivectorp}.


\endcom

\beginfncom[External]{p-list}

\Syntaxlabel
\Defun {p-list} {{\funarg{p-objid}} {\opt} {\funarg{depth}} {\funarg{p-heap}}}


\Argumentslabel
 \isanobjid{\funarg{p-objid}}
\Purposelabel
 Return a transient cons cell with its car being the transient
 representation of the persistent object located in the car and
 its cdr being the transient representation of the persistent object
 located in the cdr of the persistent cons cell referenced by
 \funarg{p-objid}.
\Seealsolabel
 \Fcite{(setf p-list)}.


\endcom

\beginfncom[External]{(setf p-list)}

\Syntaxlabel
\Defun {(setf p-list)} {{\funarg{t-list}} {\opt} {\funarg{p-objid}} {\funarg{depth}} {\funarg{p-heap}}}


\Argumentslabel
 \isanobject{\funarg{t-list}}
 \isanobjid{\funarg{p-objid}}
\Valueslabel
 \retarg{\funarg{t-list}}
\Purposelabel
 Make \lisp{(car \funarg{t-list})}\ the car and
 \lisp{(cdr \funarg{t-list})}\ the cdr of
 the persistent cons cell referenced by \funarg{p-objid}.
\Seealsolabel
 \Fcite{p-list}.


\endcom

\beginfncom[External]{p-lookup-machine}

\Syntaxlabel
\Defun {p-lookup-machine} {{\funarg{mach-name}}}

Look up \funarg{mach-name}\ and return an Internet-address for it.


\endcom

\beginfncom[External]{p-machine-addr}

\Syntaxlabel
\Defun {p-machine-addr} {{\funarg{machine}} {\opt} {\funarg{p-heap}}}


\Purposelabel
 Get the Internet address of \funarg{machine}


\endcom

\beginfncom[External]{p-machine-loginp}

\Syntaxlabel
\Defun {p-machine-loginp} {{\funarg{machine}} {\opt} {\funarg{p-heap}}}


\Purposelabel
 Get the login allow/deny-flag for a machine.


\endcom

\beginfncom[External]{(setf p-machine-loginp)}

\Syntaxlabel
\Defun {(setf p-machine-loginp)} {{\funarg{new-value}} {\funarg{machine}} {\opt} {\funarg{p-heap}}}


\Purposelabel
 Set the login flag for a machine.
\Exampleslabel
 To deny a login from clients running on any machine and
 allow a login only from clients running on your localhost,
 evaluate:
\begin{lispcode}
(setf (p-machine-login "*") :deny)
(setf (p-machine-login "localhost") :allow)
\end{lispcode}
 To allow all clients whose Internet address begins with
 \lisp{134.100.12} \ a login to the stable heap, evaluate:
\begin{lispcode}
(setf (p-machine-login "134.100.12.*") :deny)
\end{lispcode}
\Remarkslabel
 The checking is done on basis of the Internet address which was used
 by the client for addressing the server, i.e.\ the value of the
 \fcite{*database-url*}.
 This function may only be called by the \plob\ administrator.
\Seealsolabel
 \Fcite{show-machines}


\endcom

\beginfncom[External]{p-machines}

\Syntaxlabel
\Defun {p-machines} {{\opt} {\funarg{p-heap}}}


\Purposelabel
 Return the object representing all machines seen so far.
\Remarkslabel
 This function may only be called by the \plob\ administrator.


\endcom

\beginfncom[External]{p-make-bignum}

\Syntaxlabel
\Defun {p-make-bignum} {{\funarg{from}} {\opt} {\funarg{p-heap}}}

Create a persistent double float.


\endcom

\beginfncom[External]{p-make-double-float}

\Syntaxlabel
\Defun {p-make-double-float} {{\funarg{from}} {\opt} {\funarg{p-heap}}}

Create a persistent double float.


\endcom

\beginfncom[External]{p-make-single-float}

\Syntaxlabel
\Defun {p-make-single-float} {{\funarg{from}} {\opt} {\funarg{p-heap}}}

Create a persistent single float.


\endcom

\beginfncom[External]{p-makunbound}

\Syntaxlabel
\Defun {p-makunbound} {{\funarg{t-symbol}} {\opt} {\funarg{p-heap}}}


\Argumentslabel
 \isa{\funarg{t-symbol}}
      {a (transient) symbol}
\Purposelabel
 Make the value cell of the persistent symbol named like
 \funarg{t-symbol}\ unbound.
\Seealsolabel
 \Fcite{makunbound}.


\endcom

\beginfncom[External]{p-null}

\Syntaxlabel
\Defun {p-null} {{\funarg{p-objid}} {\opt} {\funarg{p-heap}}}

Check if \funarg{p-objid}\ references either
 \lispnil\ or the persistent symbol \lispnil.


\endcom

\beginfncom[External]{p-numerator}

\Syntaxlabel
\Defun {p-numerator} {{\funarg{p-objid}} {\opt} {\funarg{p-heap}}}


\Argumentslabel
 \isanobjid{\funarg{p-objid}}
\Purposelabel
 See \fcite{numerator}.


\endcom

\beginfncom[External]{p-package}

\Syntaxlabel
\Defun {p-package} {{\funarg{p-objid}} {\opt} {\funarg{depth}} {\funarg{p-heap}}}


\Argumentslabel
 \isanobjid{\funarg{p-objid}}
\Purposelabel
 Return a transient representation for the persistent
 package
 referenced by \funarg{p-objid}.
\Seealsolabel
 \Fcite{(setf p-package)};
 \fcite{persistent-package}.


\endcom

\beginfncom[External]{(setf p-package)}

\Syntaxlabel
\Defun {(setf p-package)} {{\funarg{t-package}} {\opt} {\funarg{p-objid}} {\funarg{depth}} {\funarg{p-heap}}}


\Argumentslabel
 \isa{\funarg{t-package}}
      {a transient package}
 \isanobjid{\funarg{p-objid}}
\Valueslabel
 \retarg{\funarg{t-package}}
\Purposelabel
 Store the transient package in
 \funarg{t-package}\ to the
 persistent-package referenced by \funarg{p-objid}.
\Remarkslabel
 Only the package name is copied from \funarg{t-package}\ into
 the persistent-package; the symbol tables etc.\ are not copied.
\Seealsolabel
 \Fcite{p-package};
 \fcite{persistent-package}.


\endcom

\beginfncom[External]{p-package-externals}

\Syntaxlabel
\Defun {p-package-externals} {{\funarg{p-objid}} {\opt} {\funarg{depth}} {\funarg{p-heap}}}


\Argumentslabel
 \isanobjid{\funarg{p-objid}}
\Purposelabel
 Get the value of slot
 {\bf p-externals}
 of the persistent-package referenced by \funarg{p-objid}.
\Seealsolabel
 Section \fcite{p-package- ...}.


\endcom

\beginfncom[External]{(setf p-package-externals)}

\Syntaxlabel
\Defun {(setf p-package-externals)} {{\funarg{t-package-externals}} {\funarg{p-objid}} {\opt} {\funarg{depth}} {\funarg{p-heap}}}


\Argumentslabel
 \isabtree{\funarg{t-package-externals}}
 \isanobjid{\funarg{p-objid}}
\Purposelabel
 Set the value of slot
 {\bf p-externals}
 of the persistent-package referenced by
 \funarg{p-objid}\ to \funarg{t-package-externals}.
\Seealsolabel
 Section \fcite{p-package- ...}.


\endcom

\beginfncom[External]{p-package-internals}

\Syntaxlabel
\Defun {p-package-internals} {{\funarg{p-objid}} {\opt} {\funarg{depth}} {\funarg{p-heap}}}


\Argumentslabel
 \isanobjid{\funarg{p-objid}}
\Purposelabel
 Get the value of slot
 {\bf p-internals}
 of the persistent-package referenced by \funarg{p-objid}.
\Seealsolabel
 Section \fcite{p-package- ...}.


\endcom

\beginfncom[External]{(setf p-package-internals)}

\Syntaxlabel
\Defun {(setf p-package-internals)} {{\funarg{t-package-internals}} {\funarg{p-objid}} {\opt} {\funarg{depth}} {\funarg{p-heap}}}


\Argumentslabel
 \isabtree{\funarg{t-package-internals}}
 \isanobjid{\funarg{p-objid}}
\Purposelabel
 Set the value of slot
 {\bf p-internals}
 of the persistent-package referenced by
 \funarg{p-objid}\ to \funarg{t-package-internals}.
\Seealsolabel
 Section \fcite{p-package- ...}.


\endcom

\beginfncom[External]{p-package-name}

\Syntaxlabel
\Defun {p-package-name} {{\funarg{p-objid}} {\opt} {\funarg{depth}} {\funarg{p-heap}}}


\Argumentslabel
 \isanobjid{\funarg{p-objid}}
\Purposelabel
 Get the value of slot
 {\bf p-name}
 of the persistent-package referenced by \funarg{p-objid}.
\Seealsolabel
 Section \fcite{p-package- ...}.


\endcom

\beginfncom[External]{(setf p-package-name)}

\Syntaxlabel
\Defun {(setf p-package-name)} {{\funarg{t-package-name}} {\funarg{p-objid}} {\opt} {\funarg{depth}} {\funarg{p-heap}}}


\Argumentslabel
 \isa{\funarg{t-package-name}}
      {a string}
 \isanobjid{\funarg{p-objid}}
\Purposelabel
 Set the value of slot
 {\bf p-name}
 of the persistent-package referenced by
 \funarg{p-objid}\ to \funarg{t-package-name}.
\Seealsolabel
 \Fcite{persistent-package}.


\endcom

\beginfncom[External]{p-ratio}

\Syntaxlabel
\Defun {p-ratio} {{\funarg{p-objid}} {\opt} {\funarg{p-heap}}}


\Argumentslabel
 \isanobjid{\funarg{p-objid}}
\Purposelabel
 Return a transient representation for the persistent
 ratio number
 referenced by \funarg{p-objid}.
\Seealsolabel
 \Fcite{(setf p-ratio)}.


\endcom

\beginfncom[External]{(setf p-ratio)}

\Syntaxlabel
\Defun {(setf p-ratio)} {{\funarg{t-ratio}} {\opt} {\funarg{p-objid}} {\funarg{p-heap}}}


\Argumentslabel
 \isa{\funarg{t-ratio}}
      {a ratio number}
 \isanobjid{\funarg{p-objid}}
\Valueslabel
 \retarg{\funarg{t-ratio}}
\Purposelabel
 Store the transient ratio number in \funarg{t-ratio}\ to the
 persistent ratio number referenced by \funarg{p-objid}.
\Seealsolabel
 \Fcite{p-ratio}.


\endcom

\beginfncom[External]{p-ratiop}

\Syntaxlabel
\Defun {p-ratiop} {{\funarg{p-objid}} {\opt} {\funarg{p-heap}}}


\Argumentslabel
 \isanobjid{\funarg{p-objid}}
\Purposelabel
 See \fcite{rationalp}.


\endcom

\beginfncom[External]{p-read-only}

\Syntaxlabel
\Defun {p-read-only} {{\funarg{p-objid}} {\opt} {\funarg{p-heap}}}


\Argumentslabel
 \isanobjid{\funarg{p-objid}}
\Purposelabel
 Returns \nonnil\ if the persistent object referenced by
 \funarg{p-objid}\ is locked read-only; \lispt\ otherwise.
\Seealsolabel
 Section \fcite{locking ...};
 \fcite{(setf p-read-only)};
 \fcite{sh-read-only}.


\endcom

\beginfncom[External]{(setf p-read-only)}

\Syntaxlabel
\Defun {(setf p-read-only)} {{\funarg{read-only-p}} {\funarg{p-objid}} {\opt} {\funarg{p-heap}}}


\Argumentslabel
 \isabool{\funarg{read-only-p}}
 \isanobjid{\funarg{p-objid}}
\Valueslabel
 \retarg{\funarg{read-only-p}}
\Purposelabel
 For {\funarg{read-only-p}}\ being \lispnil, the read-only lock
 is removed from the persistent object referenced by \funarg{p-objid};
 otherwise, the persistent object referenced by \funarg{p-objid}\ is
 locked read-only.
\Seealsolabel
 Section \fcite{locking ...};
 \fcite{p-read-only};
 \fcite{sh-read-only}.


\endcom

\beginfncom[External]{p-realpart}

\Syntaxlabel
\Defun {p-realpart} {{\funarg{p-objid}} {\opt} {\funarg{p-heap}}}


\Argumentslabel
 \isanobjid{\funarg{p-objid}}
\Purposelabel
 See \fcite{realpart}.


\endcom

\beginfncom[External]{p-reset}

\Syntaxlabel
\Defun {p-reset} {{\opt} {\funarg{force}} {\funarg{url}}}


\Argumentslabel
 \isabool{force}
\Purposelabel
 Try to reset the \plob\ server daemon. When \funarg{force}\ is
 \lispnil, the reset request is rejected when there are other active
 client sessions.
\Remarkslabel
 The reset will clear the admin user; the next user which logs in
 is made the new admin user.


\endcom

\beginfncom[External]{p-restart}

\Syntaxlabel
\Defun {p-restart} {{\opt} {\funarg{force}} {\funarg{url}}}


\Argumentslabel
 \isabool{force}
\Purposelabel
 Try to restart the \plob\ server daemon. When \funarg{force}\ is
 \lispnil, the restart request is rejected when there are other active
 client sessions. Passing \nonnil\ for \funarg{force}\ will force a
 server restart which in turn will have unpredictable consequences for
 the other clients, since the client's state will be lost.
\Remarkslabel
 Restarting the server daemon is a good way to terminate all active
 sessions; after the restart, all sessions will be closed.


\endcom

\beginfncom[External]{p-search-machine}

\Syntaxlabel
\Defun {p-search-machine} {{\funarg{machine}} {\opt} {\funarg{p-heap}}}


\Purposelabel
 Search \funarg{machine}\ in the internal list of known machines.
\Remarkslabel
 This function may only be called by the \plob\ administrator.


\endcom

\beginfncom[External]{p-select}

\Syntaxlabel
\Defun {p-select} {{\funarg{the-class}} \key {\keyarg{where}} {\keyarg{<}} {\keyarg{<=}} {\keyarg{>}} {\keyarg{>=}} {\keyarg{=}} {\keyarg{depth}} {\keyarg{p-heap}}}


\Argumentslabel
 \isa{\funarg{the-class}}
      {either a \clsmo\ with persistent instances or a symbol
       naming such a class}
 \isa{\keyarg{where}}
      {a symbol naming a slot of \funarg{the-class}\ which has an
       index defined on it, i.e.\ whose slot definition in the
       \lisp{defclass}\ statement had an \lisp{:index}\ slot
       option}
 \isanobject{\keyarg{<}\ resp.\ \keyarg{<=}\ resp.\ %
              \keyarg{>}\ resp.\ \keyarg{>=}\ resp.\ %
              \keyarg{=}}
\Valueslabel
 Either \lispnil\ or
 one matching persistent \clos\ instance or
 a list with matching persistent \clos\ instances.
\Purposelabel
 Selects persistent \clos\ instances of \funarg{the-class}\ and
 its subclasses where the value of the slot named
 \keyarg{where}\ mets one of the following criterions:
 \begin{description}

 \item [If the \keyarg{=}\ argument is given,]
  a persistent \clos\ instance with that slot's value matching the
  value of the \keyarg{=}\ argument is searched; if such an instance
  was found, it is returned, \lispnil\ otherwise.

 \item [If the \keyarg{>=}\ argument is given,]
  all persistent \clos\ instances with that slot's value being equal
  or greater than the value of the \keyarg{>=}\ argument are returned,
  \lispnil\ if no persistent \clos\ instance matched.

 \item [If the \keyarg{>}\ argument is given,]
  all persistent \clos\ instances with that slot's value being greater
  than the value of the \keyarg{>}\ argument are returned,
  \lispnil\ if no persistent \clos\ instance matched.

 \item [If the \keyarg{<}\ argument is given,]
  all persistent \clos\ instances with that slot's value being
  less than the value of the \keyarg{<}\ argument are returned,
  \lispnil\ if no persistent \clos\ instance matched.

 \item [If the \keyarg{<=}\ argument is given,]
  all persistent \clos\ instances with that slot's value being
  less than or equal to the value of the \keyarg{<}\ argument
  are returned, \lispnil\ if no persistent \clos\ instance matched.

 \item [If none of these arguments is given,]
  all persistent \clos\ instances of \funarg{the-class}\ and
  its subclasses are returned.

 \end{description}
 For the index being a BTree (the one and only possibility for now),
 the kind of matching performed depends on the value of the
 \keyarg{test}\ argument which was passed in the
 \lisp{:index}\ slot option's value in the slot definition given
 in the \lisp{defclass}\ statement; see comment of
 \fcite{persistent-metaclass}, additional slot option
 \lisp{:index}, for details.
\Exampleslabel
 The class \class{person}\ has an index defined on slot {\bf soc-sec-\#}:
\begin{lispcode}
 (defclass person ()
  ((first-name :initarg :first-name)
   (last-name  :initarg :last-name)
   (soc-sec-\#  :initarg :soc-sec-\#
               {\bf:index (btree :test equal)}))
  (:metaclass persistent-metaclass))

 (defmethod print-object ...)    ; exact definition left as an exercise ;-)

 (make-instance 'person :first-name "John" :last-name "Cleese" :soc-sec-\# 123)
 (make-instance 'person :first-name "Dennis" :last-name "Moore" :soc-sec-\# 550)
 (make-instance 'person :first-name "Michael" :last-name "Palin" :soc-sec-\# 456)

 (p-select 'person :where 'soc-sec-\# := 123)
        ==> \#<person John Cleese 123>
 (p-select 'person :where 'soc-sec-\# :greater-equal 300 :less 500)
        ==> (\#<person Michael Palin 456>)
 (p-select 'person :where 'soc-sec-\#)
        ==> (\#<person John Cleese 123> \#<person Michael Palin 456>
             \#<person Dennis Moore 550>)
 \end{lispcode}
\Seealsolabel
 \Fcite{persistent-metaclass}; \fcite{pp-select};
 \fcite{mapbtree}; section \fcite{index ...}.


\endcom

\beginfncom[External]{p-sessions}

\Syntaxlabel
\Defun {p-sessions} {{\opt} {\funarg{p-heap}}}


\Purposelabel
 Return the object representing all active sessions.


\endcom

\beginmccom[External]{p-setq}

\Syntaxlabel
\Defmac {p-setq} {{\funarg{symbol}} {\funarg{value}} {\opt} {\funarg{depth}} {\funarg{p-heap}}}


\Purposelabel
 See \fcite{setq}.


\endcom

\beginfncom[External]{p-single-float}

\Syntaxlabel
\Defun {p-single-float} {{\funarg{p-objid}} {\opt} {\funarg{p-heap}}}


\Argumentslabel
 \isanobjid{\funarg{p-objid}}
\Purposelabel
 Return a transient representation for the persistent
 single float
 referenced by \funarg{p-objid}.
\Seealsolabel
 \Fcite{(setf p-single-float)};
 \fcite{sh-read-single-float}.


\endcom

\beginfncom[External]{(setf p-single-float)}

\Syntaxlabel
\Defun {(setf p-single-float)} {{\funarg{the-single-float}} {\funarg{p-objid}} {\opt} {\funarg{p-heap}}}


\Argumentslabel
 \isa{\funarg{the-single-float}}
      {a single float}
 \isanobjid{\funarg{p-objid}}
\Valueslabel
 \retarg{\funarg{the-single-float}}
\Purposelabel
 Store the transient single float in \funarg{the-single-float}\ to the
 persistent single float referenced by \funarg{p-objid}.
\Seealsolabel
 \Fcite{p-single-float};
 \fcite{sh-write-single-float}.


\endcom

\beginfncom[External]{p-single-float-p}

\Syntaxlabel
\Defun {p-single-float-p} {{\funarg{p-objid}} {\opt} {\funarg{p-heap}}}


\Argumentslabel
 \isanobjid{\funarg{p-objid}}
\Purposelabel
 See \fcite{floatp}.


\endcom

\beginfncom[External]{p-slot-boundp}

\Syntaxlabel
\Defun {p-slot-boundp} {{\funarg{instance}} {\funarg{slot-name}} {\opt} {\funarg{depth}} {\funarg{p-heap}}}


\Purposelabel
 Trivial implementation of \fcite{slot-boundp}.  Following
 explanations are valid for \fcite{(setf p-slot-value)},
 \fcite{p-slot-value}\ and \fcite{p-slot-makunbound}, too.

 For \lw, these \textbf{p-slot-\ldots} functions are not needed,
 since all of them do more or less what has been coded here.

 In \allegro, all \textbf{p-slot-\ldots} functions first search for
 the \sltmo\ representing the slot and do only call the
 \textbf{p-slot-\ldots-using-class} generic function if a slot was
 found in the class at all; if the slot was not found, an error is
 signalled.\footnote{\allegro takes the definition of
 \fcite{slot-missing}\ literally, which says that the
 \fcite{slot-missing}\ is only called on instances with a class
 being an instance of \fcite{standard-class}; the standard does not
 say anything about how \fcite{slot-value}\ and companions should
 proceed on other instances.  From a practical point of view, it would
 be better to call \fcite{slot-missing}\ for all missing slots.}
 Since the implementation of \allegro's
 \textbf{slot-\ldots}\ functions can't be changed, for
 non-\clos\ instances and for instances representing a reference to
 a persistent object, the \textbf{p-slot-\ldots} functions must be
 used. This is for example the case for objects returned from a call to
 \fcite{store-object}.
\Seealsolabel
 \Fcite{slot-boundp}, \fcite{slot-boundp-using-class}.


\endcom

\beginfncom[External]{p-slot-makunbound}

\Syntaxlabel
\Defun {p-slot-makunbound} {{\funarg{instance}} {\funarg{slot-name}} {\opt} {\funarg{depth}} {\funarg{p-heap}}}


\Purposelabel
 Trivial implementation of \fcite{slot-makunbound}.
 See \fcite{p-slot-boundp}\ on details
 why this function has been defined.
\Seealsolabel
 \Fcite{slot-makunbound}, \fcite{slot-makunbound-using-class}.


\endcom

\beginfncom[External]{p-slot-value}

\Syntaxlabel
\Defun {p-slot-value} {{\funarg{instance}} {\funarg{slot-name}} {\opt} {\funarg{depth}} {\funarg{p-heap}}}


\Purposelabel
 Trivial implementation of \fcite{slot-value}.
 See \fcite{p-slot-boundp}\ on details
 why this function has been defined.
\Seealsolabel
 \Fcite{slot-value}, \fcite{slot-value-using-class}.


\endcom

\beginfncom[External]{(setf p-slot-value)}

\Syntaxlabel
\Defun {(setf p-slot-value)} {{\funarg{new-value}} {\funarg{instance}} {\funarg{slot-name}} {\opt} {\funarg{depth}} {\funarg{p-heap}}}

\Purposelabel
 Trivial implementation of \fcite{(setf slot-value)}.
 See \fcite{p-slot-boundp}\ on details
 why this function has been defined.
\Seealsolabel
 \Fcite{(setf slot-value)}, \fcite{(setf slot-value-using-class)}.


\endcom

\beginfncom[External]{p-stabilise}

\Syntaxlabel
\Defun {p-stabilise} {{\opt} {\funarg{p-heap}}}

Stabilise (i.e. flush) the Stable Heap.


\endcom

\beginfncom[External]{p-statistics}

\Syntaxlabel
\Defun {p-statistics} {{\opt} {\funarg{p-heap}}}

Get the Stable Heap statistics.


\endcom

\beginfncom[External]{p-string}

\Syntaxlabel
\Defun {p-string} {{\funarg{p-objid}} {\opt} {\funarg{depth}} {\funarg{p-heap}}}


\Argumentslabel
 \isanobjid{\funarg{p-objid}}
\Purposelabel
 Return a transient representation for the persistent
 string
 referenced by \funarg{p-objid}.
\Seealsolabel
 \Fcite{(setf p-string)}.


\endcom

\beginfncom[External]{(setf p-string)}

\Syntaxlabel
\Defun {(setf p-string)} {{\funarg{t-string}} {\opt} {\funarg{p-objid}} {\funarg{depth}} {\funarg{p-heap}}}


\Argumentslabel
 \isa{\funarg{t-string}}
      {a string}
 \isanobjid{\funarg{p-objid}}
\Valueslabel
 \retarg{\funarg{t-string}}
\Purposelabel
 Store the transient string in \funarg{t-string}\ to the
 persistent string referenced by \funarg{p-objid}.
\Seealsolabel
 \Fcite{p-string}.


\endcom

\beginfncom[External]{p-string-length}

\Syntaxlabel
\Defun {p-string-length} {{\funarg{p-objid}} {\opt} {\funarg{p-heap}}}


\Argumentslabel
 \isanobjid{\funarg{p-objid}}
\Purposelabel
 See \fcite{array-total-size}.


\endcom

\beginfncom[External]{p-string-max-length}

\Syntaxlabel
\Defun {p-string-max-length} {{\funarg{p-objid}} {\opt} {\funarg{p-heap}}}


\Argumentslabel
 \isanobjid{\funarg{p-objid}}
\Purposelabel
 Get the maximum possible length of the persistent string
 referenced by \funarg{p-objid}; this returns the total
 number of bytes allocated for the string including the
 space used for alignment.
\Seealsolabel
 \Fcite{p-string-length}.


\endcom

\beginfncom[External]{p-stringp}

\Syntaxlabel
\Defun {p-stringp} {{\funarg{p-objid}} {\opt} {\funarg{p-heap}}}


\Argumentslabel
 \isanobjid{\funarg{p-objid}}
\Purposelabel
 See \fcite{stringp}.


\endcom

\beginfncom[External]{p-structure-description}

\Syntaxlabel
\Defun {p-structure-description} {{\funarg{p-objid}} {\opt} {\funarg{depth}} {\funarg{p-heap}}}


\Argumentslabel
 \isanobjid{\funarg{p-objid}}
\Purposelabel
 Return a transient representation for the persistent
 structure-description
 referenced by \funarg{p-objid}.
\Seealsolabel
 \Fcite{(setf p-structure-description)}.


\endcom

\beginfncom[External]{(setf p-structure-description)}

\Syntaxlabel
\Defun {(setf p-structure-description)} {{\funarg{t-descr}} {\opt} {\funarg{p-objid}} {\funarg{depth}} {\funarg{p-heap}}}


\Argumentslabel
 \isa{\funarg{t-descr}}
      {a structure-description}
 \isanobjid{\funarg{p-objid}}
\Valueslabel
 \retarg{\funarg{t-descr}}
\Purposelabel
 Store the transient structure-description in
 \funarg{t-descr}\ to the
 persistent structure-description referenced by \funarg{p-objid}.
\Seealsolabel
 \Fcite{p-structure-description}.


\endcom

\beginfncom[External]{p-structure-description-name}

\Syntaxlabel
\Defun {p-structure-description-name} {{\funarg{p-objid}} {\opt} {\funarg{depth}} {\funarg{p-heap}}}


\Argumentslabel
 \isanobjid{\funarg{p-objid}}
\Purposelabel
 Get the value of slot
 {\bf p-name}
 of the persistent structure-description referenced by \funarg{p-objid}.
\Seealsolabel
 Section \fcite{p-structure-description- ...}.


\endcom

\beginfncom[External]{(setf p-structure-description-name)}

\Syntaxlabel
\Defun {(setf p-structure-description-name)} {{\funarg{t-name}} {\funarg{p-objid}} {\opt} {\funarg{depth}} {\funarg{p-heap}}}


\Argumentslabel
 \isa{\funarg{t-name}}
      {a symbol}
 \isanobjid{\funarg{p-objid}}
\Purposelabel
 Set the value of slot
 {\bf p-name}
 of the persistent structure-description referenced by
 \funarg{p-objid}\ to \funarg{t-name}.
\Seealsolabel
 Section \fcite{p-structure-description- ...}.


\endcom

\beginfncom[External]{p-structure-description-p}

\Syntaxlabel
\Defun {p-structure-description-p} {{\funarg{p-objid}} {\opt} {\funarg{p-heap}}}


\Argumentslabel
 \isanobjid{\funarg{p-objid}}
\Purposelabel
 Returns \nonnil\ iff \funarg{p-objid}\ references a
 persistent object of class
 structure-description,
 \lispnil\ otherwise.
\Seealsolabel
 \Fcite{structure-description}.


\endcom

\beginfncom[External]{p-structure-description-slots}

\Syntaxlabel
\Defun {p-structure-description-slots} {{\funarg{p-objid}} {\opt} {\funarg{depth}} {\funarg{p-heap}}}


\Argumentslabel
 \isanobjid{\funarg{p-objid}}
\Purposelabel
 Get the value of slot
 {\bf p-slots}
 of the persistent structure-description referenced by \funarg{p-objid}.
\Seealsolabel
 Section \fcite{p-structure-description- ...}.


\endcom

\beginfncom[External]{(setf p-structure-description-slots)}

\Syntaxlabel
\Defun {(setf p-structure-description-slots)} {{\funarg{t-slots}} {\funarg{p-objid}} {\opt} {\funarg{depth}} {\funarg{p-heap}}}


\Argumentslabel
 \isa{\funarg{t-slots}}
      {a list of structure slot descriptions}
 \isanobjid{\funarg{p-objid}}
\Purposelabel
 Set the value of slot
 {\bf p-slots}
 of the persistent structure-description referenced by
 \funarg{p-objid}\ to \funarg{t-slots}.
\Seealsolabel
 Section \fcite{p-structure-description- ...}.


\endcom

\beginfncom[External]{p-structure-slot-description}

\Syntaxlabel
\Defun {p-structure-slot-description} {{\funarg{p-objid}} {\opt} {\funarg{depth}} {\funarg{p-heap}}}


\Argumentslabel
 \isanobjid{\funarg{p-objid}}
\Purposelabel
 Return a transient representation for the persistent
 structure-slot-description
 referenced by \funarg{p-objid}.
\Seealsolabel
 \Fcite{(setf p-structure-slot-description)}.


\endcom

\beginfncom[External]{(setf p-structure-slot-description)}

\Syntaxlabel
\Defun {(setf p-structure-slot-description)} {{\funarg{t-descr}} {\opt} {\funarg{p-objid}} {\funarg{depth}} {\funarg{p-heap}}}


\Argumentslabel
 \isa{\funarg{t-descr}}
      {a structure-slot-description}
 \isanobjid{\funarg{p-objid}}
\Valueslabel
 \retarg{\funarg{t-descr}}
\Purposelabel
 Store the transient structure-slot-description in
 \funarg{t-descr}\ to the
 persistent structure-slot-description referenced by \funarg{p-objid}.
\Seealsolabel
 \Fcite{p-structure-slot-description}.


\endcom

\beginfncom[External]{p-structure-slot-description-init}

\Syntaxlabel
\Defun {p-structure-slot-description-init} {{\funarg{p-objid}} {\opt} {\funarg{depth}} {\funarg{p-heap}}}


\Argumentslabel
 \isanobjid{\funarg{p-objid}}
\Purposelabel
 Get the value of slot
 {\bf p-init}
 of the persistent structure-slot-description referenced by
 \funarg{p-objid}.
\Seealsolabel
 Section \fcite{p-structure-slot-description- ...}.


\endcom

\beginfncom[External]{(setf p-structure-slot-description-init)}

\Syntaxlabel
\Defun {(setf p-structure-slot-description-init)} {{\funarg{t-init}} {\funarg{p-objid}} {\opt} {\funarg{depth}} {\funarg{p-heap}}}


\Argumentslabel
 \isa{\funarg{t-init}}
      {an expression}
 \isanobjid{\funarg{p-objid}}
\Purposelabel
 Set the value of slot
 {\bf p-init}
 of the persistent structure-slot-description referenced by
 \funarg{p-objid}\ to \funarg{t-init}.
\Seealsolabel
 Section \fcite{p-structure-slot-description- ...}.


\endcom

\beginfncom[External]{p-structure-slot-description-name}

\Syntaxlabel
\Defun {p-structure-slot-description-name} {{\funarg{p-objid}} {\opt} {\funarg{depth}} {\funarg{p-heap}}}


\Argumentslabel
 \isanobjid{\funarg{p-objid}}
\Purposelabel
 Get the value of slot
 {\bf p-name}
 of the persistent structure-slot-description referenced by
 \funarg{p-objid}.
\Seealsolabel
 Section \fcite{p-structure-slot-description- ...}.


\endcom

\beginfncom[External]{(setf p-structure-slot-description-name)}

\Syntaxlabel
\Defun {(setf p-structure-slot-description-name)} {{\funarg{t-name}} {\funarg{p-objid}} {\opt} {\funarg{depth}} {\funarg{p-heap}}}


\Argumentslabel
 \isa{\funarg{t-name}}
      {a symbol}
 \isanobjid{\funarg{p-objid}}
\Purposelabel
 Set the value of slot
 {\bf p-name}
 of the persistent structure-slot-description referenced by
 \funarg{p-objid}\ to \funarg{t-name}.
\Seealsolabel
 Section \fcite{p-structure-slot-description- ...}.


\endcom

\beginfncom[External]{p-structure-slot-description-p}

\Syntaxlabel
\Defun {p-structure-slot-description-p} {{\funarg{p-objid}} {\opt} {\funarg{p-heap}}}


\Argumentslabel
 \isanobjid{\funarg{p-objid}}
\Purposelabel
 Returns \nonnil\ iff \funarg{p-objid}\ references a
 persistent object of class
 structure-slot-description,
 \lispnil\ otherwise.
\Seealsolabel
 \Fcite{structure-slot-description}.


\endcom

\beginfncom[External]{p-structure-slot-description-type}

\Syntaxlabel
\Defun {p-structure-slot-description-type} {{\funarg{p-objid}} {\opt} {\funarg{depth}} {\funarg{p-heap}}}


\Argumentslabel
 \isanobjid{\funarg{p-objid}}
\Purposelabel
 Get the value of slot
 {\bf p-type}
 of the persistent structure-slot-description referenced by
 \funarg{p-objid}.
\Seealsolabel
 Section \fcite{p-structure-slot-description- ...}.


\endcom

\beginfncom[External]{(setf p-structure-slot-description-type)}

\Syntaxlabel
\Defun {(setf p-structure-slot-description-type)} {{\funarg{t-type}} {\funarg{p-objid}} {\opt} {\funarg{depth}} {\funarg{p-heap}}}


\Argumentslabel
 \isa{\funarg{t-type}}
      {a type specifier}
 \isanobjid{\funarg{p-objid}}
\Purposelabel
 Set the value of slot
 {\bf p-type}
 of the persistent structure-slot-description referenced by
 \funarg{p-objid}\ to \funarg{t-type}.
\Seealsolabel
 Section \fcite{p-structure-slot-description- ...}.


\endcom

\beginfncom[External]{p-structure-slot-ref}

\Syntaxlabel
\Defun {p-structure-slot-ref} {{\funarg{p-objid}} {\funarg{at-location}} {\opt} {\funarg{depth}} {\funarg{p-heap}}}


\Argumentslabel
 \isanobjid{\funarg{p-objid}}
 \isa{\funarg{at-location}}
      {a fixnum}
\Purposelabel
 Read a persistent structure object's component; the
 slot value of the persistent structure object referenced by
 \funarg{p-objid}\ at position \funarg{at-location}\ is
 returned in its transient representation.
\Seealsolabel
 \Fcite{(setf p-structure-slot-ref)};
 \fcite{persistent-structure}.


\endcom

\beginfncom[External]{(setf p-structure-slot-ref)}

\Syntaxlabel
\Defun {(setf p-structure-slot-ref)} {{\funarg{t-slot-value}} {\funarg{p-objid}} {\funarg{at-location}} {\opt} {\funarg{depth}} {\funarg{p-heap}}}


\Argumentslabel
 \isanobject{\funarg{t-slot-value}}
 \isanobjid{\funarg{p-objid}}
 \isa{\funarg{at-location}}
      {a fixnum}
\Valueslabel
 \retarg{\funarg{t-slot-value}}
\Purposelabel
 Write to a persistent structure object's component; the
 slot of the persistent structure object referenced by
 \funarg{p-objid}\ at position \funarg{at-location}\ is
 set to \funarg{t-slot-value}.
\Seealsolabel
 \Fcite{p-structure-slot-ref};
 \fcite{persistent-structure}.


\endcom

\beginfncom[External]{p-structurep}

\Syntaxlabel
\Defun {p-structurep} {{\funarg{p-objid}} {\opt} {\funarg{p-heap}}}


\Argumentslabel
 \isanobjid{\funarg{p-objid}}
\Purposelabel
 Returns \nonnil\ iff \funarg{p-objid}\ references a
 persistent object of type
 persistent structure,
 \lispnil\ otherwise. No further class checking is done by this
 function; it is only checked if the persistent object referenced
 by \funarg{p-objid}\ is a persistent structure object at all.


\endcom

\beginfncom[External]{p-svref}

\Syntaxlabel
\Defun {p-svref} {{\funarg{p-objid}} {\funarg{at-location}} {\opt} {\funarg{depth}} {\funarg{p-heap}}}


\Argumentslabel
 \isanobjid{\funarg{p-objid}}
 \isa{\funarg{at-location}}
      {a fixnum}
\Purposelabel
 See \fcite{svref}.


\endcom

\beginfncom[External]{(setf p-svref)}

\Syntaxlabel
\Defun {(setf p-svref)} {{\funarg{t-element}} {\funarg{p-objid}} {\funarg{at-location}} {\opt} {\funarg{depth}} {\funarg{p-heap}}}


\Argumentslabel
 \isanobjid{\funarg{p-objid}}
 \isa{\funarg{at-location}}
      {a fixnum}
\Purposelabel
 See \fcite{(setf svref)}.


\endcom

\beginfncom[External]{p-symbol}

\Syntaxlabel
\Defun {p-symbol} {{\funarg{p-objid}} {\opt} {\funarg{depth}} {\funarg{p-heap}}}


\Argumentslabel
 \isanobjid{\funarg{p-objid}}
\Purposelabel
 Return a transient representation for the persistent
 symbol
 referenced by \funarg{p-objid}.
\Remarkslabel
 If there is already a symbol found in the transient \cl\ image with
 the same name and package as the persistent symbol referenced by
 \funarg{p-objid}, the persistent symbol is {\sl not} loaded from
 the \sh. Such a load would `clobber' the existing transient symbol
 which could be a little too dangerous.
\Seealsolabel
 \Fcite{(setf p-symbol)}.


\endcom

\beginfncom[External]{(setf p-symbol)}

\Syntaxlabel
\Defun {(setf p-symbol)} {{\funarg{t-symbol}} {\opt} {\funarg{p-objid}} {\funarg{depth}} {\funarg{p-heap}}}


\Argumentslabel
 \isa{\funarg{t-symbol}}
      {a symbol}
 \isanobjid{\funarg{p-objid}}
\Valueslabel
 \retarg{\funarg{t-symbol}}
\Purposelabel
 Store the transient symbol in \funarg{t-symbol}\ to the
 persistent symbol referenced by \funarg{p-objid}.
\Seealsolabel
 \Fcite{p-symbol}.


\endcom

\beginfncom[External]{p-symbol-function}

\Syntaxlabel
\Defun {p-symbol-function} {{\funarg{p-objid}} {\opt} {\funarg{depth}} {\funarg{p-heap}}}


\Argumentslabel
 \isanobjid{\funarg{p-objid}}
\Purposelabel
 See \fcite{symbol-function}.


\endcom

\beginfncom[External]{(setf p-symbol-function)}

\Syntaxlabel
\Defun {(setf p-symbol-function)} {{\funarg{t-symbol-function}} {\funarg{p-objid}} {\opt} {\funarg{depth}} {\funarg{p-heap}}}


\Argumentslabel
 \isanobject{\funarg{t-symbol-function}}
 \isanobjid{\funarg{p-objid}}
\Purposelabel
 See \fcite{(setf symbol-function)}.


\endcom

\beginfncom[External]{p-symbol-name}

\Syntaxlabel
\Defun {p-symbol-name} {{\funarg{p-objid}} {\opt} {\funarg{depth}} {\funarg{p-heap}}}


\Argumentslabel
 \isanobjid{\funarg{p-objid}}
\Purposelabel
 See \fcite{symbol-name}.


\endcom

\beginfncom[External]{p-symbol-package}

\Syntaxlabel
\Defun {p-symbol-package} {{\funarg{p-objid}} {\opt} {\funarg{depth}} {\funarg{p-heap}}}


\Argumentslabel
 \isanobjid{\funarg{p-objid}}
\Purposelabel
 See \fcite{symbol-package}.


\endcom

\beginfncom[External]{p-symbol-plist}

\Syntaxlabel
\Defun {p-symbol-plist} {{\funarg{p-objid}} {\opt} {\funarg{depth}} {\funarg{p-heap}}}


\Argumentslabel
 \isanobjid{\funarg{p-objid}}
\Purposelabel
 See \fcite{symbol-plist}.


\endcom

\beginfncom[External]{(setf p-symbol-plist)}

\Syntaxlabel
\Defun {(setf p-symbol-plist)} {{\funarg{t-symbol-plist}} {\funarg{p-objid}} {\opt} {\funarg{depth}} {\funarg{p-heap}}}


\Argumentslabel
 \isanobject{\funarg{t-symbol-plist}}
 \isanobjid{\funarg{p-objid}}
\Purposelabel
 See \fcite{(setf symbol-plist)}.


\endcom

\beginfncom[External]{p-symbol-value}

\Syntaxlabel
\Defun {p-symbol-value} {{\funarg{p-objid}} {\opt} {\funarg{depth}} {\funarg{p-heap}}}


\Argumentslabel
 \isanobjid{\funarg{p-objid}}
\Purposelabel
 See \fcite{symbol-value}.


\endcom

\beginfncom[External]{(setf p-symbol-value)}

\Syntaxlabel
\Defun {(setf p-symbol-value)} {{\funarg{t-symbol-value}} {\funarg{p-objid}} {\opt} {\funarg{depth}} {\funarg{p-heap}}}


\Argumentslabel
 \isanobject{\funarg{t-symbol-value}}
 \isanobjid{\funarg{p-objid}}
\Purposelabel
 See \fcite{(setf symbol-value)}.


\endcom

\beginfncom[External]{p-symbolp}

\Syntaxlabel
\Defun {p-symbolp} {{\funarg{p-objid}} {\opt} {\funarg{p-heap}}}


\Argumentslabel
 \isanobjid{\funarg{p-objid}}
\Purposelabel
 See \fcite{symbolp}.


\endcom

\begingfcom[External]{p-type-tag-of}

\Syntaxlabel
\Defgen {p-type-tag-of} {{\funarg{p-objid}} {\opt} {\funarg{p-heap}}}


\Argumentslabel

 \isanobjid{\funarg{p-objid}}

\Purposelabel

 Return the \typetag\ of the persistent object referenced
 by \funarg{p-objid}.

 There is {\sl no} {\bf (setf p-type-tag-of)} because the type of a
 persistent object cannot be changed; it is fix for the lifetime of a
 persistent object.

\Seealsolabel

 \Fcite{sh-type-tag-of};
 \fcite{p-allocate}.


\Methodslabel

\flabel{\protect\mtd}{p-type-tag-of (slot-load-on-demand)}{}
{\Defmeth {p-type-tag-of} {(\funarg{p-objid}\ \ObjectWithRef{slot-load-on-demand}) {\opt} {\funarg{p-heap}}}}
\Fcite{slot-load-on-demand}\ is a subclass of
 \fcite{persistent-immediate-object}, but since both are structure
 classes, duplication of methods is necessary.

\flabel{\protect\mtd}{p-type-tag-of (persistent-immediate-object)}{}
{\Defmeth {p-type-tag-of} {(\funarg{p-objid}\ \ObjectWithRef{persistent-immediate-object}) {\opt} {\funarg{p-heap}}}}
%
% No behavior is specified for this method beyond that which is specified
% for the generic function.

\flabel{\protect\mtd}{p-type-tag-of (t)}{}
{\Defmeth {p-type-tag-of} {{\funarg{p-objid}} {\opt} {\funarg{p-heap}}}}
%
% No behavior is specified for this method beyond that which is specified
% for the generic function.


\endcom

\beginfncom[External]{p-unintern}

\Syntaxlabel
\Defun {p-unintern} {{\funarg{t-symbol}} \key {\keyarg{package}} {\keyarg{p-heap}}}


\Argumentslabel
 \isa{\funarg{t-symbol}}
      {a transient string or a transient symbol}
 \isa{\keyarg{package}}
      {either a package object or a package name as a string or symbol}
\Purposelabel
 See \fcite{unintern}.
\Seealsolabel
 \Fcite{p-find-symbol}.


\endcom

\beginfncom[External]{p-vector}

\Syntaxlabel
\Defun {p-vector} {{\funarg{p-objid}} {\opt} {\funarg{depth}} {\funarg{p-heap}}}


\Argumentslabel
 \isanobjid{\funarg{p-objid}}
\Purposelabel
 Return a transient representation for the persistent
 vector
 referenced by \funarg{p-objid}.
\Seealsolabel
 \Fcite{(setf p-vector)}.


\endcom

\beginfncom[External]{(setf p-vector)}

\Syntaxlabel
\Defun {(setf p-vector)} {{\funarg{t-vector}} {\opt} {\funarg{p-objid}} {\funarg{depth}} {\funarg{p-heap}}}


\Argumentslabel
 \isa{\funarg{t-vector}}
      {a vector}
 \isanobjid{\funarg{p-objid}}
\Valueslabel
 \retarg{\funarg{t-vector}}
\Purposelabel
 Store the transient vector in \funarg{t-vector}\ to the
 persistent vector referenced by \funarg{p-objid}.
\Seealsolabel
 \Fcite{p-vector}.


\endcom

\beginfncom[External]{p-vector-length}

\Syntaxlabel
\Defun {p-vector-length} {{\funarg{p-objid}} {\opt} {\funarg{p-heap}}}


\Argumentslabel
 \isanobjid{\funarg{p-objid}}
\Purposelabel
 See \fcite{array-total-size}.


\endcom

\beginfncom[External]{p-vectorp}

\Syntaxlabel
\Defun {p-vectorp} {{\funarg{p-objid}} {\opt} {\funarg{p-heap}}}


\Argumentslabel
 \isanobjid{\funarg{p-objid}}
\Purposelabel
 See \fcite{vectorp}.


\endcom

\begingfcom[External]{package-extent}

\Syntaxlabel
\Defgen {package-extent} {{\funarg{the-package}}}


\Argumentslabel
 \isa{\funarg{the-package}}
      {a \cl\ package object}
\Purposelabel
 Returns the extent of \funarg{the-package}.
\Seealsolabel
 \Fcite{(setf package-extent)};
 \fcite{class-extent};
 \fcite{slot-extent}.


\Methodslabel

\flabel{\protect\mtd}{package-extent (t)}{}
{\Defmeth {package-extent} {{\funarg{the-package}}}}
%
% No behavior is specified for this method beyond that which is specified
% for the generic function.


\endcom

\begingfcom[External]{(setf package-extent)}

\Syntaxlabel
\Defgen {(setf package-extent)} {{\funarg{extent}} {\funarg{the-package}}}


\Argumentslabel
 \isa{\funarg{extent}}
      {one of the symbols
       \lisp{:transient}, \lisp{:cached}, \lisp{:cached-demand-load},
       \lisp{:cached-write-through}\ or \lisp{:persistent}}
 \isa{\funarg{the-package}}
      {a \cl\ package object}
\Valueslabel
 \retarg{\funarg{extent}}
\Purposelabel
 Sets the extent of all classes which are named by symbols which belongs
 to \funarg{the-package}\ to \funarg{extent}; for further explanations
 see \fcite{(setf class-extent)}\ and \fcite{(setf slot-extent)}.

 If a class extent is specified for a class, this extent takes
 precedence over an eventually specified package extent for that class.

 This function is meant to be called from top-level to declare the
 extent of the predefined classes found in the \cl\ system packages;
 e.g.\ some predefined packages have only predefined classes with
 instances which should never become persistent.
\Exampleslabel
 Set the extent of all instances of all classes whose name symbol
 belongs to the package \lisp{:clue}\ to \lisp{:transient}.
 This will prevent \plob\ from making instances of one of these
 classes persistent:
 \begin{lispcode}
(setf (package-extent (find-package :clue)) :transient)
 \end{lispcode}
\Seealsolabel
 \Fcite{package-extent};
 example at \fcite{(setf class-extent)};
 \fcite{(setf slot-extent)}.


\Methodslabel

\flabel{\protect\mtd}{(setf package-extent) (t t)}{}
{\Defmeth {(setf package-extent)} {{\funarg{extent}} {\funarg{the-package}}}}
%
% No behavior is specified for this method beyond that which is specified
% for the generic function.


\endcom

\beginclcom[External Structure]{persistent-heap}

\Purposelabel
 A structure for representing persistent heaps in the transient
 \cl\ system. Persistent heaps are used for two purposes:
 \begin{enumerate}

 \item For the \plob\ C level functions, instances of
  \class{persistent-heap}\ represent the calling \cl\ session,
  e.g.\ session suspend resp.\ wakeup requests used for lock
  conflict resolution are sent to the \cl\ level from the C
  level by identifying the \cl\ session
  to suspend resp.\ wakeup by its instance of
  \class{persistent-heap}.
  %% \ (see \fcite{sh-suspend-callback},
  %% \fcite{sh-wakeup-callback})%
  1996/10/30 HK: Suspend and wakeup are now done by a busy wait
  on the lock to get granted to the object which should be locked.

 \item For the \cl\ session, instances of
  \class{persistent-heap}\ represent the `logical' heap which
  is used to store and load the
  persistent objects, e.g.\ the transaction handling and locking
  for a \cl\ session is done by an instance of
  \class{persistent-heap}, i.e.\ by the persistent heap object
  contained in the session-local variable
  {\bf *default-persistent-heap*}.

 \end{enumerate}
\Remarkslabel
 \basecls{persistent-heap}
\Seealsolabel
 Section \fcite{locking ...};
 \fcite{*default-persistent-heap*};
 %% \fcite{sh-suspend-callback};
 %% \fcite{sh-wakeup-callback};
 \fcite{begin-transaction}.


\Directsuperclasseslabel
\Defmethod{}{\tt}{\ObjectWithRef{persistent-object}}{}


\Directslotslabel

\Defdslot {in-transaction} {nil}


 A boolean flag indicating if the heap is currently in a transaction.

\Defdslot {suspended-p} {nil}


 A boolean flag indicating if the \cl\ session to which the heap belongs
 is suspended. Once upon a time, this flag was set by a call to
 \textbf{sh-suspend-callback}\ and reset by a call to
 \textbf{sh-wakeup-callback})\ with the \objid\ of the
 session-identifying persistent heap as argument. In the current
 client/server version of \plob, suspending the LISP process is not
 supported; a busy wait is done where a suspend would be appropiate.

\Defdslot {pid} {nil}


 The \cl\ PID of the current session as returned by
 \fcite{process-pid}.


\Classoptionslabel
\Defmethod{}{\tt}{:constructor make-persistent-heap (\&optional objid)}{}


\endcom

\beginclcom[External]{persistent-metaclass}


\Purposelabel

 A \clsmc\ for classes with additional class- and slot-options;
 it extends the behavior of the \clsmc\ \class{standard-class}.

 Persistence in \plob\ is not bound to the property of an
 instance that its class is inheriting from a class which
 implements persistence\footnote{This would be the
 pure-\clos\ view of implementing a property (like persistence)
 by a class and its methods: The property would be inherited via
 subclassing. The class in question for persistence if done so
 would be the \fcite{persistent-clos-object}.}.
 The overall task of \class{persistent-metaclass}\ is not to offer
 the ability of persistency for instances of its instances
 (the first one are `normal' instances, the latter are \clsmo{}s)
 since persistence is orthogonal in \plob\ but to provide
 some additional options on class- and slot-level
 w.r.t.\ persistence for its instances, i.e.\ for classes
 whose class is \class{persistent-metaclass}.

 These are the class options which are handled additionally
 for classes being an instance of \class{persistent-metaclass}:
 \begin{description}

 \item[\lisp{:constructor}]
  This option takes as argument an instance constructor
  function as specified for argument
  \funarg{new-constructor}\ of
  \fcite{(setf class-constructor)}.

 \item[\lisp{:dependent}]
  This option takes as argument a dependent option
  \funarg{new-dependent}\ of
  \fcite{(setf class-dependent)}.

 \item[\lisp{:extent}]
  This option takes as argument a class default slot extent
  as specified for argument \funarg{extent}\ of
  \fcite{(setf class-extent)}.

 \item[\lisp{:schema-evolution}]
  This option takes as argument a schema evolution
  as specified for argument \funarg{evolution}\ of
  \fcite{(setf schema-evolution)}.

 \end{description}

 These are the slot options which are handled additionally
 for classes being an instance of \class{persistent-metaclass}:
 \begin{description}

 \item[\lisp{:extent}]
  This option takes as argument a slot extent
  as specified for argument \funarg{extent}\ of
  \fcite{(setf slot-extent)}.

 \item[\lisp{:deferred}]
  This option takes as argument a slot deferred option
  as specified for argument \funarg{deferred}\ of
  \fcite{(setf slot-deferred)}.

 \item[\lisp{:index}]
  This option takes as argument an expression which defines
  an index for the slot value of all instances. The index
  maps a slot value to an instance; it is inherited to
  subclasses. See section \fcite{index ...}\ for details
  on indices.

  Currently, there are BTrees available: A slot option
  \lisp{:index (btree :test \textsl{\lt{}test-mode\gt}\/)}
  creates a
  BTree with test mode \textsl{\lt{}test-mode\gt} on the slot;
  see \fcite{make-btree}, argument \keyarg{test}\ for
  details of \textsl{\lt{}test-mode\gt}.

 \item[\lisp{:location}]
  \emph{This option is  only for usage by \plob's internal
   classes:} 

  Internally, the slot option \lisp{:location}\ is used with classes
  describing \plob's internal classes. Compared with \clos, these
  classes are the \mc[es]\ of \plob; since they differ from \clos'
  \mc[es]\ in some respects, they are called \dec[es].  The slot option
  takes a fixnum number as argument which determines the position of the
  slot in the persistent object's layout in persistent memory. This
  handling is needed to ensure that the layers below the LISP layer of
  \plob\ use the same slot positions into a description object as the
  high level LISP layer, since the lower layers do not have the
  sophisticated slot access methods that \clos\ has (simply for
  performance reasons).

 \end{description}

 The \lisp{:extent}\ option can be specified not only on
 class level but also on slot level. Furthermore, for
 computing the effective extent and the effective schema
 evolution for a slot resp.\ a class there can be option
 values specified on the `package'-level (see
 \fcite{(setf package-extent)}). The rule is that the most
 specific found option's value will be used; if no option's
 value is given on any level, \plob\ tries to find an
 option value by employing a \clos-like class inheritance
 search. If no value can be found by this search too,
 an appropiate default value will be used.
 The order from least to most specific level for the first
 search is package $\rightarrow$ class $\rightarrow$ slot.
 The order of the inheritance search used for the second search
 is given by the class's precedence list.
 The appropiate default values are the constants
 {\bf *default-\ldots-\{extent,schema-evolution\}*}.

 Once defined, these options and their values should be
 held constant as long as possible.
 Adding an option on class- or slot-level or changing the
 value of one of these options in the
 \lisp{defclass}\ statement is a `significant' change
 which will be promoted to the \sh\ by updating
 the class description (topic schema-evolution).

 The `linking' of a class to \class{persistent-metaclass}\ is
 done with the class option
 \lisp{(:metaclass persistent-metaclass)}.

\Exampleslabel

 This is the definition of a class with additional options:
 \begin{lispcode}
(defclass person ()
  ((first-name :extent :cached)
   (last-name  :extent :cached)
   (soc-sec-#  :index (btree :test equal)))
  (:extent :persistent)
  {\bf(:metaclass persistent-metaclass)})
 \end{lispcode}

\Seealsolabel

 Section \fcite{index ...};
 \Fcite{class-description}.


\Directsuperclasseslabel
\Defmethod{}{\tt}{(\ObjectWithRef{standard-class})}{}


\Directslotslabel

\Defdslot {t-extent} {:accessor class-extent\newline :initform nil}


 The extent of the class.
 This is the value of the class option \lisp{:extent}\ as specified
 in the \lisp{defclass}\ statement. For possible values and their
 meaning, see \fcite{(setf slot-extent)}.

\Defdslot {t-schema-evolution} {:accessor schema-evolution\newline :initform nil}


 The kind of schema-evolution to use for instances of the class.
 This is the value of the class option
 \lisp{:schema-evolution}\ as specified in the
 \lisp{defclass}\ statement. For possible values and their
 meaning, see \fcite{(setf schema-evolution)}.

\Defdslot {t-constructor} {:accessor class-constructor\newline :initform nil}


 The constructor function to use to create instances of the class.
 This is the value of the class option
 \lisp{:constructor}\ as specified in the
 \lisp{defclass}\ statement. For possible values and their
 meaning, see \fcite{(setf class-constructor)}.

\Defdslot {t-dependent} {:accessor class-dependent\newline :initform nil}


 The dependent option to use for instances of the class.
 This is the value of the class option
 \lisp{:dependent}\ as specified in the
 \lisp{defclass}\ statement. For possible values and their
 meaning, see \fcite{(setf class-dependent)}.

\Defdslot {t-mismatch-p} {:accessor mismatch-p\newline :initform nil}


 A flag indicating that the class definition might have changed
 and needs to be updated in the stable heap.
 This flag is set when {\bf [re]initialize-instance}\ onto
 the class object was called; see also \fcite{(setf mismatch-p)}.

\Defdslot {t-class-description} {:accessor class-description-of\newline :initform nil}


 The class's \plob\ class description, i.e.\ this
 is an instance of \fcite{class-description}.

\Defdslot {t-finalized-p} {:accessor class-description-finalized-p\newline :initform nil}


 A flag indicating if the class description is finalized in the sense
 of \plob. \note\ In \lw, this finalization takes place
 {\sl after} the \clos\ finalization because \plob\ must patch the
 class object (see \fcite{patch-class-metaobject}) to handle a
 non-\lw-standard slot allocation and access.


\endcom

\beginclcom[External Structure]{persistent-object}

\Purposelabel
 A structure for representing persistent objects in the transient
 \cl\ system. This structure can represent only non-immediate objects.

 The specified \lisp{:print-function}\ will not print the `naked'
 numeric \objid\ of a persistent object but a more elaborate form.
\Remarkslabel
 \basecls{persistent-object}


\Directslotslabel

\Defdslot {objid} {nil}


 The (numeric) \objid\ of the persistent object.


\Classoptionslabel
\Defmethod{}{\tt}{:conc-name persistent-object-internal-\newline :constructor make-persistent-object-internal (\&optional objid)\newline :print-function {\rm\sl omitted here}}{}


\endcom

\begingfcom[External]{persistent-object-objid}

\Syntaxlabel
\Defgen {persistent-object-objid} {{\funarg{p-object}}}


\Argumentslabel
 \isa{\funarg{p-object}}
      {a persistent object}
\Purposelabel
 Return the \objid\ of \funarg{p-object}.


\Methodslabel

\flabel{\protect\mtd}{persistent-object-objid (integer)}{}
{\Defmeth {persistent-object-objid} {(\funarg{p-object}\ \ObjectWithRef{integer})}}
Returns \funarg{p-object}\ itself, i.e.\ \funarg{p-object}\ is
 interpreted as a numeric \objid.

\flabel{\protect\mtd}{persistent-object-objid (persistent-object)}{}
{\Defmeth {persistent-object-objid} {(\funarg{p-object}\ \ObjectWithRef{persistent-object})}}
Calls to this method are trapped to the system-generated
 structure reader function
 {\bf persistent-object-internal-objid}.

\flabel{\protect\mtd}{persistent-object-objid (standard-object)}{}
{\Defmeth {persistent-object-objid} {(\funarg{the-object}\ \ObjectWithRef{standard-object})}}
Returns always \lispnil.

\flabel{\protect\mtd}{persistent-object-objid (t)}{}
{\Defmeth {persistent-object-objid} {{\funarg{p-object}}}}
Look into the cache for \funarg{p-object}'s \objid.


\endcom

\begingfcom[External]{(setf persistent-object-objid)}

\Syntaxlabel
\Defgen {(setf persistent-object-objid)} {{\funarg{the-objid}} {\funarg{p-object}}}


\Argumentslabel
 \isanobjid{\funarg{the-objid}}
 \isa{\funarg{p-object}}
      {a persistent object}
\Purposelabel
 Set the \objid\ of \funarg{p-object}\ to \funarg{the-objid}.


\Methodslabel

\flabel{\protect\mtd}{(setf persistent-object-objid) (t persistent-object)}{}
{\Defmeth {(setf persistent-object-objid)} {{\funarg{the-objid}} (\funarg{p-object}\ \ObjectWithRef{persistent-object})}}
Calls to this method are trapped to the system-generated
 structure writer function
 {\bf (setf persistent-object-internal-objid)}; see also
 \fcite{persistent-object}.

\flabel{\protect\mtd}{(setf persistent-object-objid) (t standard-object)}{}
{\Defmeth {(setf persistent-object-objid)} {{\funarg{new-objid}} (\funarg{the-object}\ \ObjectWithRef{standard-object})}}
Does nothing.


\endcom

\beginclcom[External]{persistent-s-expression}
A class for persistent s-expressions.


\Directslotslabel

\Defdslot {source} {:initform nil\newline :initarg :source\newline :accessor sexpr-source\newline :extent :cached-write-through}


 Source code of the s-expression.

\Defdslot {code} {:initform nil\newline :initarg :code\newline :accessor sexpr-code\newline :extent :transient}


 Compiled version of source code as found in slot
 source.


\Metaclasslabel
\Defmethod{}{\tt}{\ObjectWithRef{persistent-metaclass}}{}


\endcom

\beginclcom[External Structure]{persistent-structure}

\Purposelabel
 A transient structure representing persistent structures.
 All other persistent structures inherit implicit or explicit
 from \class{persistent-structure}.
\Remarkslabel
 \basecls{persistent-structure}


\Directsuperclasseslabel
\Defmethod{}{\tt}{\ObjectWithRef{persistent-object}}{}


\Directslotslabel

\Defdslot {p-descr} {nil}


 An instance of \class{structure-description}\ in
 transient \cl\ resp.\ an \objid\ referencing a persistent
 instance of \class{structure-description}\ in the stable heap
 which describes the stucture of the structure.


\endcom

\beginfncom[External]{plob-flush}

\Syntaxlabel
\Defun {plob-flush} {{\opt} {\funarg{p-heap}}}


\Purposelabel
 Flush any pending \sh\ write requests. After returning,
 it is guranteed that the \sh\ is saved to disk.
\Remarkslabel
 This function should of course be called everytime after a change
 done to a persistent object's state; but since flushing is very
 slow, it has to be called either when the system is idle (see
 \fcite{flush-mode}) or interactively by the user.
\Seealsolabel
 \Fcite{flush-mode};
 \fcite{sh-stabilise}.


\endcom

\begincncom[External]{+plob-max-marker+}

\Valuelabel
\begin{CompactCode}
(make-persistent-object +max-tag+ +max-tag+)
\end{CompactCode}

\Purposelabel
Object used for representing a maximum object.


\endcom

\begincncom[External]{+plob-min-marker+}

\Valuelabel
\begin{CompactCode}
(make-persistent-object +min-tag+ +min-tag+)
\end{CompactCode}

\Purposelabel
Object used for representing a minimum object.


\endcom

\begincncom[External]{+plob-unbound-marker+}

\Valuelabel
\begin{CompactCode}
(make-persistent-object +unbound-type-tag+ +unbound-type-tag+)
\end{CompactCode}

\Purposelabel
Object used as persistent unbound marker.


\endcom

\begincncom[External]{+plob-unstorable-object-marker+}

\Valuelabel
\begin{CompactCode}
(make-persistent-object +unstorable-object-marker+ +unstorable-object-marker+)
\end{CompactCode}

\Purposelabel
Object used as persistent unstorable object marker.


\endcom

\beginfncom[External]{pp-select}

\Syntaxlabel
\Defun {pp-select} {{\rest} {\funarg{all-args}}}

Does exactly the same as the \fcite{p-select},
 but \lisp{pprint}s the result.


\endcom

\begingfcom[External]{print-object}

\Syntaxlabel
\Defgen {print-object} {{\funarg{instance}} {\funarg{stream}}}


 See \fcite{print-object}.


\Methodslabel

\flabel{\protect\mtd}{print-object (persistent-clos-object t)}{}
{\Defmeth {print-object} {(\funarg{the-object}\ \ObjectWithRef{persistent-clos-object}) {\funarg{to-stream}}}}
%
% No behavior is specified for this method beyond that which is specified
% for the generic function.

\flabel{\protect\mtd}{print-object (simple-postore-error t)}{}
{\Defmeth {print-object} {(\funarg{c}\ \ObjectWithRef{simple-postore-error}) {\funarg{s}}}}
%
% No behavior is specified for this method beyond that which is specified
% for the generic function.


\endcom

\beginfncom[External]{read-lock-store}

\Syntaxlabel
\Defun {read-lock-store} {{\opt} {\funarg{p-heap}}}


 Put a read lock onto the whole database. This will speed up object
 locking, but care must be taken since the locking scheme can't be used
 any longer to detect if an object was already read.


\endcom

\message{^^JGeneric function clos:reader-method-class has no methods.^^J}
\begingfcom[External]{reinitialize-instance}

\Syntaxlabel
\Defgen {reinitialize-instance} {{\funarg{instance}} {\rest} {\funarg{initargs}}}


 See \fcite{reinitialize-instance}.


\Methodslabel

\flabel{\protect\mtd}{reinitialize-instance :around (persistent-metaclass)}{}
{\Defmetharound {reinitialize-instance} {(\funarg{class}\ \ObjectWithRef{persistent-metaclass}) {\rest} {\funarg{all-keys}} \key {\keyarg{direct-superclasses}} {\keyarg{constructor}} {\keyarg{dependent}} {\keyarg{extent}} {\keyarg{schema-evolution}}}}
Trapped to \fcite{re-and-initialize-persistent-metaclass-instance}.

\flabel{\protect\mtd}{reinitialize-instance :before (standard-class)}{}
{\Defmethb {reinitialize-instance} {(\funarg{class}\ \ObjectWithRef{standard-class}) {\rest} {\funarg{all-keys}}}}
Marks \funarg{class}\ as being (perhaps) mismatched;
 see \fcite{(setf mismatch-p)}.

\flabel{\protect\mtd}{reinitialize-instance :after (persistent-metaclass)}{}
{\Defmetha {reinitialize-instance} {(\funarg{class}\ \ObjectWithRef{persistent-metaclass}) {\rest} {\funarg{all-keys}}}}
Patch the class' accessor methods.

\flabel{\protect\mtd}{reinitialize-instance :after (structure-class)}{}
{\Defmetha {reinitialize-instance} {(\funarg{the-class}\ \ObjectWithRef{structure-class}) {\rest} {\funarg{initargs}}}}
Marks \funarg{the-class}\ as being (perhaps) mismatched;
 see \fcite{(setf mismatch-p)}.


\endcom

\begingfcom[External]{rembtree}

\Syntaxlabel
\Defgen {rembtree} {{\funarg{key}} {\funarg{p-btree}} {\opt} {\funarg{p-heap}}}


\Argumentslabel
 \isakey{\funarg{key}}{\funarg{p-btree}}
 \isabtree{\funarg{p-btree}}
\Valueslabel
 Returns \nonnil\ if the entry with key
 \funarg{key}\ was found in and deleted from the persistent BTree
 \funarg{p-btree}, \lispnil\ if the entry was not found at all.
\Purposelabel
 This generic function removes an entry with key \funarg{key}\ from
 the persistent BTree \funarg{p-btree}.
\Seealsolabel
 \Fcite{remhash}.


\Methodslabel

\flabel{\protect\mtd}{rembtree :around (persistent-clos-object cached-btree)}{}
{\Defmetharound {rembtree} {(\funarg{key}\ \ObjectWithRef{persistent-clos-object}) (\funarg{p-btree}\ \ObjectWithRef{cached-btree}) {\opt} {\funarg{p-heap}}}}

 Calls to this method are trapped to \fcite{rembtree-by-objid}.

\flabel{\protect\mtd}{rembtree :around (persistent-immediate-object cached-btree)}{}
{\Defmetharound {rembtree} {(\funarg{key}\ \ObjectWithRef{persistent-immediate-object}) (\funarg{p-btree}\ \ObjectWithRef{cached-btree}) {\opt} {\funarg{p-heap}}}}

 Calls to this method are trapped to \fcite{rembtree-by-objid}.

\flabel{\protect\mtd}{rembtree :around (persistent-object cached-btree)}{}
{\Defmetharound {rembtree} {(\funarg{key}\ \ObjectWithRef{persistent-object}) (\funarg{p-btree}\ \ObjectWithRef{cached-btree}) {\opt} {\funarg{p-heap}}}}

 Calls to this method are trapped to \fcite{rembtree-by-objid}.

\flabel{\protect\mtd}{rembtree :around (t cached-btree)}{}
{\Defmetharound {rembtree} {{\funarg{key}} (\funarg{p-btree}\ \ObjectWithRef{cached-btree}) {\opt} {\funarg{p-heap}}}}

 Removes the element found under \funarg{key}\ from the cache of the
 cached persistent BTree \funarg{p-btree}\ too.

\flabel{\protect\mtd}{rembtree (character t)}{}
{\Defmeth {rembtree} {(\funarg{key}\ \ObjectWithRef{character}) {\funarg{p-btree}} {\opt} {\funarg{p-heap}}}}
%
% No behavior is specified for this method beyond that which is specified
% for the generic function.

\flabel{\protect\mtd}{rembtree (float t)}{}
{\Defmeth {rembtree} {(\funarg{key}\ \ObjectWithRef{float}) {\funarg{p-btree}} {\opt} {\funarg{p-heap}}}}
%
% No behavior is specified for this method beyond that which is specified
% for the generic function.

\flabel{\protect\mtd}{rembtree (integer t)}{}
{\Defmeth {rembtree} {(\funarg{key}\ \ObjectWithRef{integer}) {\funarg{p-btree}} {\opt} {\funarg{p-heap}}}}
%
% No behavior is specified for this method beyond that which is specified
% for the generic function.

\flabel{\protect\mtd}{rembtree (persistent-clos-object t)}{}
{\Defmeth {rembtree} {(\funarg{key}\ \ObjectWithRef{persistent-clos-object}) {\funarg{p-btree}} {\opt} {\funarg{p-heap}}}}
%
% No behavior is specified for this method beyond that which is specified
% for the generic function.

\flabel{\protect\mtd}{rembtree (persistent-immediate-object t)}{}
{\Defmeth {rembtree} {(\funarg{key}\ \ObjectWithRef{persistent-immediate-object}) {\funarg{p-btree}} {\opt} {\funarg{p-heap}}}}
%
% No behavior is specified for this method beyond that which is specified
% for the generic function.

\flabel{\protect\mtd}{rembtree (persistent-object t)}{}
{\Defmeth {rembtree} {(\funarg{key}\ \ObjectWithRef{persistent-object}) {\funarg{p-btree}} {\opt} {\funarg{p-heap}}}}
%
% No behavior is specified for this method beyond that which is specified
% for the generic function.

\flabel{\protect\mtd}{rembtree (string t)}{}
{\Defmeth {rembtree} {(\funarg{key}\ \ObjectWithRef{string}) {\funarg{p-btree}} {\opt} {\funarg{p-heap}}}}
%
% No behavior is specified for this method beyond that which is specified
% for the generic function.

\flabel{\protect\mtd}{rembtree (symbol t)}{}
{\Defmeth {rembtree} {(\funarg{key}\ \ObjectWithRef{symbol}) {\funarg{p-btree}} {\opt} {\funarg{p-heap}}}}
%
% No behavior is specified for this method beyond that which is specified
% for the generic function.

\flabel{\protect\mtd}{rembtree (t t)}{}
{\Defmeth {rembtree} {{\funarg{key}} {\funarg{p-btree}} {\opt} {\funarg{p-heap}}}}
Store \funarg{key}\ and continue.


\endcom

\begingfcom[External]{rembtree-by-objid}

\Syntaxlabel
\Defgen {rembtree-by-objid} {{\funarg{key-objid}} {\funarg{key-type-tag}} {\funarg{p-btree}} {\opt} {\funarg{p-heap}}}


\Argumentslabel
 \isanobjid{\funarg{key}}
 \isabtree{\funarg{p-btree}}
\Valueslabel
 See \fcite{rembtree}.
\Purposelabel
 At first see \fcite{rembtree}; this function differs from
 \fcite{rembtree}\ in the sense that the \funarg{key}\ argument
 has to be a persistent object's \objid; no transient
 \cl\ \obj\ may be passed directly as \funarg{key}\ argument.
\Seealsolabel
 \Fcite{rembtree}.


\Methodslabel

\flabel{\protect\mtd}{rembtree-by-objid (t t cached-btree)}{}
{\Defmeth {rembtree-by-objid} {{\funarg{key-objid}} {\funarg{key-type-tag}} (\funarg{p-btree}\ \ObjectWithRef{cached-btree}) {\opt} {\funarg{p-heap}}}}

 Removes the element found under \funarg{key}\ from the cache of the
 cached persistent BTree \funarg{p-btree} too.

\flabel{\protect\mtd}{rembtree-by-objid (t t t)}{}
{\Defmeth {rembtree-by-objid} {{\funarg{key-objid}} {\funarg{key-type-tag}} {\funarg{p-btree}} {\opt} {\funarg{p-heap}}}}
%
% No behavior is specified for this method beyond that which is specified
% for the generic function.


\endcom

\begingfcom[External]{schema-evolution}

\Syntaxlabel
\Defgen {schema-evolution} {{\funarg{the-class}}}


\Argumentslabel
 \isacls{\funarg{the-class}}
\Purposelabel
 Return the schema evolution of \funarg{the-class}.
\Seealsolabel
 \Fcite{(setf schema-evolution)}.


\Methodslabel

\flabel{\protect\mtd}{schema-evolution (t)}{}
{\Defmeth {schema-evolution} {{\funarg{the-class}}}}
%
% No behavior is specified for this method beyond that which is specified
% for the generic function.


\endcom

\begingfcom[External]{(setf schema-evolution)}

\Syntaxlabel
\Defgen {(setf schema-evolution)} {{\funarg{evolution}} {\funarg{the-class}}}


\Argumentslabel
 \isa{\funarg{evolution}}
      {one of the symbols
       \lisp{:no-evolution}, \lisp{:write-back},
       \lisp{:write-back-allow-identity-change},
       \lisp{:write-back-deny-identity-change}\ or
       \lisp{:transform}}
 \isacls{\funarg{the-class}}
\Valueslabel
 \retarg{\funarg{evolution}}
\Purposelabel
 Set the schema evolution of \funarg{the-class}\ to
 \funarg{evolution}.

 The schema evolution of a class determines what to do with the
 persistent instances of that class if the class definition in
 the transient \cl\ runtime environment and the persistent
 \plob\ environment differ, e.g.\ by adding oder removing
 slots to the \lisp{defstruct}- or \lisp{defclass}-statement,
 changing the extent of slots etc.

 Schema evolution is supported for instances of
 \lisp{defstruct}\ and `real' (i.e.\ non-built-in)
 \clos\ classes.
 The possible values for
 \funarg{evolution}\ have following effects:
 \begin{description}
 \item[\lisp{:no-evolution}]
  Deny any request of schema evolution to \funarg{the-class};
  this one is used for persistent classes which must not change,
  e.g.\ the \plob\ base classes loaded at bootstrap.
  If \plob\ detects changes to \funarg{the-class}, an error is
  raised.
 \item[\lisp{:write-back}]
  Try to transform an `old' object into a `new' object and to
  write back the `new' object to the persistent heap preserving
  object identity;
  if the identity cannot be preserved, an error is signalled.
  This error may only be raised for \lisp{defstruct}\ instances since
  their number of slots cannot be extented.
  It never raises an error for \clos\ objects because their persistent
  class can change without loosing the persistent object's identity.
 \item[\lisp{:write-back-allow-identity-change}]
  transforms an `old' object into a `new'
  object and writes it back to the \sh; the identity of the object
  changes iff this cannot be avoided (e.g. if persistent structure slots are
  added, the identity of a structure object cannot be preserved).
  Because \clos\ instances never change their identity on changes done
  to the class definition, this mode is handled like
  \lisp{:write-back}\ for \clos\ instances.
 \item[\lisp{:write-back-deny-identity-change}]
  transforms an `old' object into a `new'
  object and writes it back to the \sh\ iff the identity of the
  object would not change; if the identity would change, the object is
  handled like \lisp{:transform}\ mode.
  Because \clos\ instances never change their identity on
  changes done to the class definition this mode is handled like
  \lisp{:write-back}\ for \clos\ instances.
 \item[\lisp{:transform}]
  Makes \plob\ transform the object from its `old' to its `new'
  class each time the object is loaded into transient memory. Slots
  with equal names are inherited from `old' to `new' classes; other slots
  are initialized according to their init values\footnote{Mode
  \lisp{:transform}\ not yet implemented}.
 \end{description}

 \plob\ does a `lazy schema evolution'. The representation of a
 persistent object whose class was modified is changed at the latest
 possible moment; normally, this is when either a slot of such an
 object is referenced (by a call to
 \fcite{slot-value}\ resp.\ \fcite{(setf slot-value)})
 or when the whole object is loaded from or stored to the
 persistent heap (by a call to
 \fcite{load-object}\ resp. \fcite{store-object}).

 This functions is meant to be called from top-level to declare the
 schema evolution of predefined \cl\ system classes or of classes
 of other user-defined systems whose classes where created without
 the \lisp{(:metaclass persistent-metaclass)}\ class option.
\Remarkslabel
 \lw\ has only limited support for structure instance evolution
 (see also \stcite{473, X3J13 vote of January 1989 \lt{}56\gt}).
 When a \lisp{defstruct}\ was changed, referencing an obsolete
 structure instance raises an error. \plob\ has full support
 of schema evolution also for structure classes; to avoid problems
 with obsolete structure instances after a structure redefinition
 call the \fcite{clear-cache}\ to remove all references from
 \plob\ to any obsolete structure instances.
\Exampleslabel
 This denies schema evolution for class
 \class{structure-description}; when \plob\ encounters a changed class
 definition for \class{structure-description}, an error is raised:
 \begin{lispcode}
(setf (schema-evolution (find-class 'structure-description))
      :no-evolution)
 \end{lispcode}
\Seealsolabel
 \Fcite{schema-evolution}.


\Methodslabel

\flabel{\protect\mtd}{(setf schema-evolution) (t t)}{}
{\Defmeth {(setf schema-evolution)} {{\funarg{evolution}} {\funarg{the-class}}}}
%
% No behavior is specified for this method beyond that which is specified
% for the generic function.


\endcom

\begingfcom[External]{sexpr-code}

\Syntaxlabel
\Defgen {sexpr-code} {{\funarg{instance}}}

\GfCreatedByOption{reader}{:accessor}{code}{persistent-s-expression}


\Methodslabel

\flabel{\protect\mtd}{sexpr-code :around (persistent-s-expression)}{}
{\Defmetharound {sexpr-code} {(\funarg{object}\ \ObjectWithRef{persistent-s-expression})}}
%
% No behavior is specified for this method beyond that which is specified
% for the generic function.


\endcom

\message{^^JGeneric function (setf sexpr-code) has no methods.^^J}
\message{^^JGeneric function sexpr-source has no methods.^^J}
\begingfcom[External]{(setf sexpr-source)}

\Syntaxlabel
\Defgen {(setf sexpr-source)} {{\funarg{new-value}} {\funarg{instance}}}

\GfCreatedByOption{writer}{:accessor}{source}{persistent-s-expression}


\Methodslabel

\flabel{\protect\mtd}{(setf sexpr-source) :around (t persistent-s-expression)}{}
{\Defmetharound {(setf sexpr-source)} {{\funarg{new-value}} (\funarg{object}\ \ObjectWithRef{persistent-s-expression})}}
%
% No behavior is specified for this method beyond that which is specified
% for the generic function.


\endcom

\beginfncom[External]{sh-close}

\Syntaxlabel
\Defun {sh-close} {{\funarg{p-heap-objid}} {\opt} {\funarg{with-garbage-collection}}}


\Purposelabel
 Low-level close of the \sh.
\Remarkslabel
 Do not call this function interactively; call \fcite{close-heap}\ for
 correct closing of the \sh.
\Seealsolabel
 \Fcite{close-heap};
 \shcite{function}{SH\us{}close}{2}.


\endcom

\begingfcom[External]{shared-initialize}

\Syntaxlabel
\Defgen {shared-initialize} {{\funarg{instance}} {\funarg{slot-names}} {\rest} {\funarg{initargs}}}


 See \fcite{shared-initialize}.


\Methodslabel

\flabel{\protect\mtd}{shared-initialize (persistent-clos-object t)}{}
{\Defmeth {shared-initialize} {(\funarg{instance}\ \ObjectWithRef{persistent-clos-object}) {\funarg{slot-names}} {\rest} {\funarg{all-keys}} \key {\keyarg{objid}} {\keyarg{p-heap}} {\keyarg{store-cached-slots}} {\keyarg{suppress-initialization}}}}

\Purposelabel
%% ;;; HK 03.09.92:
 In \allegro\ and \lw, the methods of the
 \fcite{shared-initialize}\ do not work like expected:\ the slot
 initialization values are set by using direct low-level slot
 accessors and not by calling the standard writer methods; so I
 implemented this method specialized to
 \fcite{persistent-clos-object}.  The code used here is a modified
 version of \fcite{shared-initialize (standard-object)}.

 Passing the \keyarg{suppress-initialization}\ as \nonnil\ will
 suppress the initialization totally; the only place where this
 behavior is needed is within generating the uninitialized prototype
 object, since \fcite{make-instance}\ can't be told to suppress
 initialization.

 Unless the \keyarg{suppress-initialization}\ argument is passed as
 \nonnil, the method will always initialize the transient
 representation of the slot.  If \keyarg{store-cached-slots}\ is
 passed as \nonnil\ (the default), the slot initializations will be
 written into the persistent representation, too.

\Seealsolabel
 \Fcite{shared-initialize}.


\endcom

\beginfncom[External]{show-machines}

\Syntaxlabel
\Defun {show-machines} {{\opt} {\funarg{p-heap}}}


\Purposelabel
 Show all machines which may login to the stable heap.
\Remarkslabel
 This function may only be called by the \plob\ administrator.


\endcom

\beginfncom[External]{show-sessions}

\Syntaxlabel
\Defun {show-sessions} {{\opt} {\funarg{p-heap}}}


\Purposelabel
 Show all active sessions. In the very left column a single indicator
 character is shown:
 \begin{description}
 \item[`*'] for the session which evaluated \lisp{(show-sessions)}
 \item[`.'] for sessions within the current LISP process
 \item[` ' (blank)] for sessions of other LISP processes
 \end{description}


\endcom

\begingfcom[External]{slot-boundp-using-class}

\Syntaxlabel
\Defgen {slot-boundp-using-class} {{\funarg{class}} {\funarg{object}} {\funarg{slot}}}


 See \fcite{slot-boundp-using-class}.


\Methodslabel

\flabel{\protect\mtd}{slot-boundp-using-class (persistent-metaclass t effective-slot-description)}{}
{\Defmeth {slot-boundp-using-class} {(\funarg{the-class}\ \ObjectWithRef{persistent-metaclass}) {\funarg{object}} (\funarg{slot-description}\ \ObjectWithRef{effective-slot-description})}}

\Remarkslabel
  In \allegro, this method specialized to
  \fcite{persistent-metaclass}\ must be defined; the method
  \fcite{slot-boundp-using-class (standard-class t %
effective-slot-description)}\ signals a Bus error.

\flabel{\protect\mtd}{slot-boundp-using-class (persistent-metaclass t
                         persistent-effective-slot-definition)}{}
{\Defmeth {slot-boundp-using-class} {(\funarg{the-class}\ \ObjectWithRef{persistent-metaclass}) {\funarg{object}} (\funarg{slot-definition}\ \ObjectWithRef{persistent-effective-slot-definition})}}
%
% No behavior is specified for this method beyond that which is specified
% for the generic function.

\flabel{\protect\mtd}{slot-boundp-using-class (persistent-metaclass t symbol)}{}
{\Defmeth {slot-boundp-using-class} {(\funarg{the-class}\ \ObjectWithRef{persistent-metaclass}) {\funarg{object}} (\funarg{slot-name}\ \ObjectWithRef{symbol})}}
Trapped to
 \fcite{slot-boundp-using-class (standard-class t %
effective-slot-description)}.

\flabel{\protect\mtd}{slot-boundp-using-class (standard-class t effective-slot-description)}{}
{\Defmeth {slot-boundp-using-class} {(\funarg{the-class}\ \ObjectWithRef{standard-class}) {\funarg{object}} (\funarg{slot-description}\ \ObjectWithRef{effective-slot-description})}}
%
% No behavior is specified for this method beyond that which is specified
% for the generic function.

\flabel{\protect\mtd}{slot-boundp-using-class (structure-class persistent-object t)}{}
{\Defmeth {slot-boundp-using-class} {(\funarg{the-class}\ \ObjectWithRef{structure-class}) (\funarg{p-objid}\ \ObjectWithRef{persistent-object}) {\funarg{slot-name}}}}
A method for low-level slot boundp:
 The persistent \clos\ instance is referenced by its
 \objid\ contained in \funarg{p-objid}.


\endcom

\begingfcom[External]{slot-deferred}

\Syntaxlabel
\Defgen {slot-deferred} {{\funarg{the-slot}} {\funarg{the-class}}}


\Argumentslabel
 \isa{\funarg{the-slot}}
      {either a symbol naming a slot of \funarg{the-class}\ or a \sltmo}
 \isacls{\funarg{the-class}}
\Purposelabel
 Return the deferred option of the slot described by
 \funarg{the-slot}\ of \funarg{the-class}.
\Seealsolabel
 \Fcite{(setf slot-deferred)}.


\Methodslabel

\flabel{\protect\mtd}{slot-deferred (persistent-direct-slot-definition t)}{}
{\Defmeth {slot-deferred} {(\funarg{slot-definition}\ \ObjectWithRef{persistent-direct-slot-definition}) {\funarg{the-class}}}}

 Returns the deferred stored in slot {\bf t-deferred} of
 \funarg{slot-definition}.

\flabel{\protect\mtd}{slot-deferred (persistent-effective-slot-definition t)}{}
{\Defmeth {slot-deferred} {(\funarg{slot-definition}\ \ObjectWithRef{persistent-effective-slot-definition}) {\funarg{the-class}}}}
%
% No behavior is specified for this method beyond that which is specified
% for the generic function.

\flabel{\protect\mtd}{slot-deferred (t t)}{}
{\Defmeth {slot-deferred} {{\funarg{the-slot}} {\funarg{the-class}}}}
%
% No behavior is specified for this method beyond that which is specified
% for the generic function.


\endcom

\begingfcom[External]{(setf slot-deferred)}

\Syntaxlabel
\Defgen {(setf slot-deferred)} {{\funarg{deferred}} {\funarg{the-slot}} {\funarg{the-class}}}


\Argumentslabel
 \isa{\funarg{deferred}}
      {either \lispnil\ or a number}
 \isa{\funarg{the-slot}}
      {either a symbol naming a slot of \funarg{the-class}\ or a \sltmo}
 \isacls{\funarg{the-class}}
\Valueslabel
 \retarg{\funarg{deferred}}
\Purposelabel
 Sets the deferred option of the slot described by
 \funarg{the-slot}\ of \funarg{the-class}\ to
 \funarg{deferred}. Slot with the \lisp{deferred}\ attribute
 set are stored after the other slots of the objects. This is used
 e.g.\ for objects having slots which reference many other objects.
 Setting the \lisp{deferred}\ attribute on this slot will store
 the slot's state when all other (maybe referenced) objects are
 stored.
\Remarkslabel
 From the view of good programming, this slot option is absolutely
 unnecessary, since its task is more or less to store resp.\ load
 the referenced objects before the dereferencing objects. This could
 be done more elegant but much more less efficient by a two-pass
 algorithm, where the first pass collects all objects to be saved,
 sorting the objects into referenced and dereferencing ones
 and write the objects out to the store resp.\ read them from the
 store in a second pass. My hope is that the second pass will be
 necessary only in very special circumstances, e.g.\ when the
 storing resp.\ loading operations put many intermediate objects
 onto the stack.
\Seealsolabel
 \Fcite{slot-deferred}.


\Methodslabel

\flabel{\protect\mtd}{(setf slot-deferred) (t persistent-direct-slot-definition t)}{}
{\Defmeth {(setf slot-deferred)} {{\funarg{deferred}} (\funarg{slot-definition}\ \ObjectWithRef{persistent-direct-slot-definition}) {\funarg{the-class}}}}

 Stores the \funarg{deferred}\ in slot {\bf t-deferred} of
 \funarg{slot-definition}.

\flabel{\protect\mtd}{(setf slot-deferred) (t persistent-effective-slot-definition t)}{}
{\Defmeth {(setf slot-deferred)} {{\funarg{deferred}} (\funarg{slot-definition}\ \ObjectWithRef{persistent-effective-slot-definition}) {\funarg{the-class}}}}
%
% No behavior is specified for this method beyond that which is specified
% for the generic function.

\flabel{\protect\mtd}{(setf slot-deferred) (t t t)}{}
{\Defmeth {(setf slot-deferred)} {{\funarg{deferred}} {\funarg{the-slot}} {\funarg{the-class}}}}
%
% No behavior is specified for this method beyond that which is specified
% for the generic function.

\flabel{\protect\mtd}{(setf slot-deferred) :after (t t t)}{}
{\Defmetha {(setf slot-deferred)} {{\funarg{deferred}} {\funarg{the-slot}} {\funarg{the-class}}}}
%
% No behavior is specified for this method beyond that which is specified
% for the generic function.


\endcom

\begingfcom[External]{slot-definition-allocation}

\Syntaxlabel
\Defgen {slot-definition-allocation} {{\funarg{slot}}}


 See \fcite{slot-definition-allocation}.


\Methodslabel

\flabel{\protect\mtd}{slot-definition-allocation (structure-effective-slot-definition)}{}
{\Defmeth {slot-definition-allocation} {(\funarg{slot}\ \ObjectWithRef{structure-effective-slot-definition})}}

  \Remarkslabel
 \sysdep{method}

\flabel{\protect\mtd}{slot-definition-allocation (structure-slot-description)}{}
{\Defmeth {slot-definition-allocation} {(\funarg{slot-description}\ \ObjectWithRef{structure-slot-description})}}
Returns always \lisp{:structure}\ to mark the
 \funarg{slot-description}\ as the description of a structure slot for
 the caller.


\endcom

\begingfcom[External]{slot-definition-initargs}

\Syntaxlabel
\Defgen {slot-definition-initargs} {{\funarg{slot}}}


 See \fcite{slot-definition-initargs}.


\Methodslabel

\flabel{\protect\mtd}{slot-definition-initargs (structure-effective-slot-definition)}{}
{\Defmeth {slot-definition-initargs} {(\funarg{slot}\ \ObjectWithRef{structure-effective-slot-definition})}}

  \Remarkslabel
 \sysdep{method}

 Hint for \allegro:
 For now, this function creates a list with a symbolic name for the
 structure slot definition initarg.
 A better idea would be to look if the
 structure slot definition initarg
 is represented somewhere associated with the structure's
 \clsmo\ (but it seems as if \allegro\ doesn't do this).

\flabel{\protect\mtd}{slot-definition-initargs (structure-slot-description)}{}
{\Defmeth {slot-definition-initargs} {(\funarg{slot-description}\ \ObjectWithRef{structure-slot-description})}}
Calls to this method are trapped to the system-generated
 structure reader function
 {\bf structure-slot-description-p-initargs}; see also
 \fcite{structure-slot-description}.


\endcom

\message{^^JGeneric function clos:slot-definition-initform has no methods.^^J}
\begingfcom[External]{slot-definition-initfunction}

\Syntaxlabel
\Defgen {slot-definition-initfunction} {{\funarg{slot}}}

\IfFLabelExists{clos:slot-definition-initfunction}
{\SeeAt\ \fcite{clos:slot-definition-initfunction}.}
{\message{^^JUndocumented generic function clos:slot-definition-initfunction.^^J}
\nodefgeneric}


\Methodslabel

\flabel{\protect\mtd}{slot-definition-initfunction (structure-effective-slot-definition)}{}
{\Defmeth {slot-definition-initfunction} {(\funarg{slot}\ \ObjectWithRef{structure-effective-slot-definition})}}

  \Remarkslabel
 \sysdep{method}


\endcom

\begingfcom[External]{slot-definition-location}

\Syntaxlabel
\Defgen {slot-definition-location} {{\funarg{slot}}}


 See \fcite{slot-definition-location}.


\Methodslabel

\flabel{\protect\mtd}{slot-definition-location (structure-slot-description)}{}
{\Defmeth {slot-definition-location} {(\funarg{slot-description}\ \ObjectWithRef{structure-slot-description})}}
Calls to this method are trapped to the system-generated
 structure reader function
 {\bf structure-slot-description-p-location}; see also
 \fcite{structure-slot-description}.


\endcom

\begingfcom[External]{slot-definition-name}

\Syntaxlabel
\Defgen {slot-definition-name} {{\funarg{slot}}}


 See \fcite{slot-definition-name}.


\Methodslabel

\flabel{\protect\mtd}{slot-definition-name (structure-slot-description)}{}
{\Defmeth {slot-definition-name} {(\funarg{slot-description}\ \ObjectWithRef{structure-slot-description})}}
Calls to this method are trapped to the system-generated
 structure reader function
 {\bf structure-slot-description-p-name}; see also
 \fcite{structure-slot-description}.


\endcom

\begingfcom[External]{slot-definition-type}

\Syntaxlabel
\Defgen {slot-definition-type} {{\funarg{slot}}}


 See \fcite{slot-definition-type}.


\Methodslabel

\flabel{\protect\mtd}{slot-definition-type (structure-slot-description)}{}
{\Defmeth {slot-definition-type} {(\funarg{slot-description}\ \ObjectWithRef{structure-slot-description})}}
Calls to this method are trapped to the system-generated
 structure reader function
 {\bf structure-slot-description-p-type}; see also
 \fcite{structure-slot-description}.


\endcom

\beginclcom[External]{slot-description}

\Purposelabel
 A transient class representing persistent slot descriptions.
 In the sense of \clos, this class corresponds roughly to the
 \std\ \sltmc\ \class{slot-definition}.
\Remarkslabel
 \basecls{slot-description}


\Directsuperclasseslabel
\Defmethod{}{\tt}{(\ObjectWithRef{plob-description})}{}


\Directslotslabel

\Defdslot {p-name} {:accessor slot-description-name\newline :reader slot-definition-name\newline :initform nil\newline :type symbol\newline :location +slot-description-location-name+}


 The name of the slot as a symbol; comparable with the returned
 value from
 \fcite{slot-definition-name}.

\Defdslot {p-initargs} {:accessor slot-description-initargs\newline :reader slot-definition-initargs\newline :initform nil\newline :location +slot-description-location-init-args+}


 The initialization arguments of the slot as a list of keywords;
 comparable with the returned value from
 \fcite{slot-definition-initargs}.

\Defdslot {p-initform} {:accessor slot-description-initform\newline :reader slot-definition-initform\newline :initform nil\newline :location +slot-description-location-init-form+}


 The initialization form of the slot;
 comparable with the returned value from
 \fcite{slot-definition-initform}.

\Defdslot {p-initfunction} {:accessor slot-description-initfunction\newline :reader slot-definition-initfunction\newline :initform nil\newline :location +slot-description-location-init-function+}


 The initialization function of the slot;
 comparable with the returned value from
 \fcite{slot-definition-initfunction}.

\Defdslot {p-type} {:accessor slot-description-type\newline :reader slot-definition-type\newline :initform t\newline :location +slot-description-location-type+}


 The type of the slot;
 comparable with the returned value from
 \fcite{slot-definition-type}.

\Defdslot {p-allocation} {:accessor slot-description-allocation\newline :reader slot-definition-allocation\newline :initform :instance\newline :location +slot-description-location-allocation+}


 The allocation of the slot;
 comparable with the returned value from
 \fcite{slot-definition-allocation}.

\Defdslot {p-extent} {:accessor slot-description-extent\newline :initform nil\newline :location +slot-description-location-extent+}


 The extent of the slot;
 see \fcite{slot-extent}\ and, for possible values,
 \fcite{(setf slot-extent)}.

\Defdslot {p-deferred} {:accessor slot-description-deferred\newline :initform nil\newline :location +slot-description-location-deferred+}


 The deferred option of the slot;
 see \fcite{slot-deferred}\ and, for possible values,
 \fcite{(setf slot-deferred)}.

\Defdslot {p-index} {:accessor slot-description-index\newline :initarg :index\newline :initform nil\newline :location +slot-description-location-index+}


 The index to maintain for the slot; this slot is only bound for
 class descriptions of classes whose class is
 \fcite{persistent-metaclass} (see the remarks concerning the
 additional slot option
 \lisp{:index}\ for instances of that \clsmc\ for details).


\Metaclasslabel
\Defmethod{}{\tt}{\ObjectWithRef{persistent-metaclass}}{}


\Classoptionslabel
\Defmethod{}{\tt}{:dependent :read\newline :extent :cached\newline :schema-evolution :no-evolution}{}


\endcom

\message{^^JGeneric function slot-description-allocation has no methods.^^J}
\message{^^JGeneric function (setf slot-description-allocation) has no methods.^^J}
\message{^^JGeneric function plob::slot-description-deferred has no methods.^^J}
\message{^^JGeneric function (setf plob::slot-description-deferred) has no methods.^^J}
\begingfcom[External]{slot-description-extent}

\Syntaxlabel
\Defgen {slot-description-extent} {{\funarg{slot-description}}}


\Argumentslabel
 \isa{\funarg{slot-description}}
      {a structure-slot-description or a slot-description}
\Purposelabel
 Returns the extent of \funarg{slot-description}.
\Seealsolabel
 Slot {\bf p-extent} of \fcite{structure-slot-description}\ resp.\ %
 \fcite{slot-description}.


\Methodslabel

\flabel{\protect\mtd}{slot-description-extent (structure-slot-description)}{}
{\Defmeth {slot-description-extent} {(\funarg{slot-description}\ \ObjectWithRef{structure-slot-description})}}
Calls to this method are trapped to the system-generated
 structure reader function
 {\bf structure-slot-description-p-extent}; see also
 \fcite{structure-slot-description}.


\endcom

\begingfcom[External]{(setf slot-description-extent)}

\Syntaxlabel
\Defgen {(setf slot-description-extent)} {{\funarg{extent}} {\funarg{slot-description}}}


\Argumentslabel
 \isa{\funarg{extent}}
      {a keyword symbol}
 \isa{\funarg{slot-description}}
      {a structure-slot-description or a slot-description}
\Purposelabel
 Set the extent of
 \funarg{slot-description}\ to
 \funarg{extent}.
\Seealsolabel
 Slot {\bf p-extent} of \fcite{structure-slot-description}\ resp.\ %
 \fcite{slot-description}.


\Methodslabel

\flabel{\protect\mtd}{(setf slot-description-extent) (t structure-slot-description)}{}
{\Defmeth {(setf slot-description-extent)} {{\funarg{extent}} (\funarg{slot-description}\ \ObjectWithRef{structure-slot-description})}}
Calls to this method are trapped to the system-generated
 structure writer function
 {\bf (setf structure-slot-description-p-extent)}; see also
 \fcite{structure-slot-description}.


\endcom

\begingfcom[External]{slot-description-index}

\Syntaxlabel
\Defgen {slot-description-index} {{\funarg{slot-description}}}


\Argumentslabel
 \isa{\funarg{slot-description}}
      {a structure-slot-description or a slot-description}
\Purposelabel
 Returns the index of \funarg{slot-description}.
\Seealsolabel
 Slot {\bf p-index} of \fcite{slot-description}.


\Methodslabel

\flabel{\protect\mtd}{slot-description-index (structure-slot-description)}{}
{\Defmeth {slot-description-index} {(\funarg{slot-description}\ \ObjectWithRef{structure-slot-description})}}
Since there can be no indices on structure slots this method always
 returns \lispnil.


\endcom

\message{^^JGeneric function slot-description-initargs has no methods.^^J}
\begingfcom[External]{(setf slot-description-initargs)}

\Syntaxlabel
\Defgen {(setf slot-description-initargs)} {{\funarg{initargs}} {\funarg{slot-description}}}


\Argumentslabel
 \isa{\funarg{initargs}}
      {a [list of] [keyword] symbol[s]}
 \isa{\funarg{slot-description}}
      {a structure-slot-description or a slot-description}
\Purposelabel
 Set the initarg[s] of
 \funarg{slot-description}\ to
 \funarg{initargs}.
\Seealsolabel
 Slot {\bf p-initarg[s]} of \fcite{structure-slot-description}\ resp.\ %
 \fcite{slot-description}.


\Methodslabel

\flabel{\protect\mtd}{(setf slot-description-initargs) (t structure-slot-description)}{}
{\Defmeth {(setf slot-description-initargs)} {{\funarg{initarg}} (\funarg{slot-description}\ \ObjectWithRef{structure-slot-description})}}
Calls to this method are trapped to the system-generated
 structure writer function
 {\bf (setf structure-slot-description-p-initargs)}; see also
 \fcite{structure-slot-description}.


\endcom

\message{^^JGeneric function slot-description-initform has no methods.^^J}
\message{^^JGeneric function (setf slot-description-initform) has no methods.^^J}
\message{^^JGeneric function slot-description-initfunction has no methods.^^J}
\message{^^JGeneric function (setf slot-description-initfunction) has no methods.^^J}
\begingfcom[External]{(setf slot-description-location)}

\Syntaxlabel
\Defgen {(setf slot-description-location)} {{\funarg{location}} {\funarg{slot-description}}}


\Argumentslabel
 \isanobject{\funarg{location}}
 \isa{\funarg{slot-description}}
      {a structure-slot-description or a slot-description}
\Purposelabel
 Set the location of
 \funarg{slot-description}\ to
 \funarg{location}.
\Seealsolabel
 Slot {\bf p-location} of
 \fcite{structure-slot-description}\ resp.\ %
 \fcite{effective-slot-description}.


\Methodslabel

\flabel{\protect\mtd}{(setf slot-description-location) (t structure-slot-description)}{}
{\Defmeth {(setf slot-description-location)} {{\funarg{location}} (\funarg{slot-description}\ \ObjectWithRef{structure-slot-description})}}
Calls to this method are trapped to the system-generated
 structure writer function
 {\bf (setf structure-slot-description-p-location)}; see also
 \fcite{structure-slot-description}.


\endcom

\message{^^JGeneric function slot-description-name has no methods.^^J}
\begingfcom[External]{(setf slot-description-name)}

\Syntaxlabel
\Defgen {(setf slot-description-name)} {{\funarg{name}} {\funarg{slot-description}}}


\Argumentslabel
 \isa{\funarg{name}}
      {a symbol}
 \isa{\funarg{slot-description}}
      {a structure-slot-description or a slot-description}
\Purposelabel
 Set the name of
 \funarg{slot-description}\ to
 \funarg{name}.
\Seealsolabel
 Slot {\bf p-name} of
 \fcite{structure-slot-description}\ resp.\ %
 \fcite{slot-description}.


\Methodslabel

\flabel{\protect\mtd}{(setf slot-description-name) (t structure-slot-description)}{}
{\Defmeth {(setf slot-description-name)} {{\funarg{name}} (\funarg{slot-description}\ \ObjectWithRef{structure-slot-description})}}
Calls to this method are trapped to the system-generated
 structure writer function
 {\bf (setf structure-slot-description-p-name)}; see also
 \fcite{structure-slot-description}.


\endcom

\message{^^JGeneric function slot-description-type has no methods.^^J}
\begingfcom[External]{(setf slot-description-type)}

\Syntaxlabel
\Defgen {(setf slot-description-type)} {{\funarg{type}} {\funarg{slot-description}}}


\Argumentslabel
 \isa{\funarg{type}}
      {a type expression}
 \isa{\funarg{slot-description}}
      {a structure-slot-description or a slot-description}
\Purposelabel
 Set the type of
 \funarg{slot-description}\ to
 \funarg{type}.
\Seealsolabel
 Slot {\bf p-type} of \fcite{structure-slot-description}\ resp.\ %
 \fcite{slot-description}.


\Methodslabel

\flabel{\protect\mtd}{(setf slot-description-type) (t structure-slot-description)}{}
{\Defmeth {(setf slot-description-type)} {{\funarg{type}} (\funarg{slot-description}\ \ObjectWithRef{structure-slot-description})}}
Calls to this method are trapped to the system-generated
 structure writer function
 {\bf (setf structure-slot-description-p-type)}; see also
 \fcite{structure-slot-description}.


\endcom

\begingfcom[External]{slot-extent}

\Syntaxlabel
\Defgen {slot-extent} {{\funarg{the-slot}} {\funarg{the-class}}}


\Argumentslabel
 \isa{\funarg{the-slot}}
      {either a symbol naming a slot of \funarg{the-class}\ or a \sltmo}
 \isacls{\funarg{the-class}}
\Purposelabel
 Return the extent of the slot described by
 \funarg{the-slot}\ of \funarg{the-class}.
\Seealsolabel
 \Fcite{(setf slot-extent)}.


\Methodslabel

\flabel{\protect\mtd}{slot-extent (persistent-direct-slot-definition t)}{}
{\Defmeth {slot-extent} {(\funarg{slot-definition}\ \ObjectWithRef{persistent-direct-slot-definition}) {\funarg{the-class}}}}

 Returns the extent stored in slot {\bf t-extent} of
 \funarg{slot-definition}.

\flabel{\protect\mtd}{slot-extent (persistent-effective-slot-definition t)}{}
{\Defmeth {slot-extent} {(\funarg{slot-definition}\ \ObjectWithRef{persistent-effective-slot-definition}) {\funarg{the-class}}}}
%
% No behavior is specified for this method beyond that which is specified
% for the generic function.

\flabel{\protect\mtd}{slot-extent (slot-definition class)}{}
{\Defmeth {slot-extent} {(\funarg{slot}\ \ObjectWithRef{slot-definition}) (\funarg{the-class}\ \ObjectWithRef{class})}}
%
% No behavior is specified for this method beyond that which is specified
% for the generic function.

\flabel{\protect\mtd}{slot-extent (symbol class)}{}
{\Defmeth {slot-extent} {(\funarg{the-slot}\ \ObjectWithRef{symbol}) (\funarg{the-class}\ \ObjectWithRef{class})}}
%
% No behavior is specified for this method beyond that which is specified
% for the generic function.


\endcom

\begingfcom[External]{(setf slot-extent)}

\Syntaxlabel
\Defgen {(setf slot-extent)} {{\funarg{extent}} {\funarg{the-slot}} {\funarg{the-class}}}


\Argumentslabel
 The \funarg{extent}\ argument depends on the value
 of the \funarg{the-class}\ argument: If \funarg{the-class}\ is
 an instance of \class{structure-class}, the \funarg{extent}\ argument
 is one of the symbols
 \lisp{:transient}, \lisp{:cached}\ or \lisp{:cached-demand-load}.
 Otherwise, the \funarg{extent}\ argument
 is one of the symbols \lisp{:transient}, \lisp{:cached},
 \lisp{:cached-write-through}\ or \lisp{:persistent}.

 \isa{\funarg{the-slot}}
      {either a symbol naming a slot of \funarg{the-class}\ or a \sltmo}
 \isacls{\funarg{the-class}}
\Valueslabel
 \retarg{\funarg{extent}}
\Purposelabel
 Sets the extent of the slot described by
 \funarg{the-slot}\ of \funarg{the-class}\ to
 \funarg{extent}.

 Each object handled by \plob\ has two representations: a
 {\sl transient}
 representation, which makes possible an easy and efficient access
 to the object
 with the `well-known' \cl\ accessing functions resp.\ methods
 and a {\sl persistent} representation which holds the object's
 state for an undetermined amount of time. An object as a whole is
 represented by a collection of slots. The value of a slot's extent
 affects the lifetime of the slot, its representation and the
 interaction between the transient and persistent slot
 state. %
 \input{tabext}%
 Figure~\ref{tab:extent} shows the values for the slot extent
 option for persistent \clos\ classes;
 for persistent structure classes, there is an additional slot extent
 option value \lisp{:cached-demand-load}, which will result in the
 slot's state
 being represented in both the transient and persistent object.
 Its state is loaded when the whole object is loaded.
 Slot reading is done from the transient slot's state.
 Slot writing is {\sl immediate} propagated to
 the persistent object.

 This function is meant to be called from top-level to declare the extent
 of slots of predefined \cl\ system classes; e.g.\ some predefined
 classes have slots which should never become persistent.
\Exampleslabel
 In the first line, the extent of the package \lisp{:system}\ is set to
 \lisp{:transient}; since the symbol \lisp{logical-pathname}\ is
 defined in the \lisp{:system}\ package, all instances of the class
 \class{logical-pathname}\ would be transient too; the second line
 declares instances of the class \class{logical-pathname}\ as being
 persistent with an extent of \lisp{:cached}. The third line
 declares the slot named \lisp{system::device}\ of class
 logical-pathname as being \lisp{:transient}:
 \begin{lispcode}
(setf (package-extent (find-package :system)) :transient)
(setf (class-extent (find-class 'logical-pathname)) :cached)
{\bf(setf (slot-extent 'system::device (find-class 'logical-pathname))
      :transient)}
 \end{lispcode}
\Seealsolabel
 \Fcite{slot-extent};
 \fcite{(setf class-extent)}.


\Methodslabel

\flabel{\protect\mtd}{(setf slot-extent) (t persistent-direct-slot-definition t)}{}
{\Defmeth {(setf slot-extent)} {{\funarg{extent}} (\funarg{slot-definition}\ \ObjectWithRef{persistent-direct-slot-definition}) {\funarg{the-class}}}}
Stores the \funarg{extent}\ in slot {\bf t-extent} of
 \funarg{slot-definition}.

\flabel{\protect\mtd}{(setf slot-extent) (t persistent-effective-slot-definition t)}{}
{\Defmeth {(setf slot-extent)} {{\funarg{extent}} (\funarg{slot-definition}\ \ObjectWithRef{persistent-effective-slot-definition}) {\funarg{the-class}}}}
%
% No behavior is specified for this method beyond that which is specified
% for the generic function.

\flabel{\protect\mtd}{(setf slot-extent) (t slot-definition class)}{}
{\Defmeth {(setf slot-extent)} {{\funarg{extent}} (\funarg{slot}\ \ObjectWithRef{slot-definition}) (\funarg{the-class}\ \ObjectWithRef{class})}}
%
% No behavior is specified for this method beyond that which is specified
% for the generic function.

\flabel{\protect\mtd}{(setf slot-extent) (t symbol class)}{}
{\Defmeth {(setf slot-extent)} {{\funarg{extent}} (\funarg{the-slot}\ \ObjectWithRef{symbol}) (\funarg{the-class}\ \ObjectWithRef{class})}}
%
% No behavior is specified for this method beyond that which is specified
% for the generic function.

\flabel{\protect\mtd}{(setf slot-extent) :after (t slot-definition class)}{}
{\Defmetha {(setf slot-extent)} {{\funarg{extent}} (\funarg{slot}\ \ObjectWithRef{slot-definition}) (\funarg{the-class}\ \ObjectWithRef{class})}}
%
% No behavior is specified for this method beyond that which is specified
% for the generic function.


\endcom

\begingfcom[External]{slot-makunbound-using-class}

\Syntaxlabel
\Defgen {slot-makunbound-using-class} {{\funarg{class}} {\funarg{object}} {\funarg{slot}}}


 See \fcite{slot-makunbound-using-class}.


\Methodslabel

\flabel{\protect\mtd}{slot-makunbound-using-class (persistent-metaclass t effective-slot-description)}{}
{\Defmeth {slot-makunbound-using-class} {(\funarg{the-class}\ \ObjectWithRef{persistent-metaclass}) {\funarg{object}} (\funarg{slot-description}\ \ObjectWithRef{effective-slot-description})}}

\Remarkslabel
  In \allegro, this method specialized to
  \fcite{persistent-metaclass}\ must be defined; the method
  \fcite{slot-makunbound-using-class (standard-class t effective-slot-description)}\ signals a Bus error.

\flabel{\protect\mtd}{slot-makunbound-using-class (persistent-metaclass t
                             persistent-effective-slot-definition)}{}
{\Defmeth {slot-makunbound-using-class} {(\funarg{the-class}\ \ObjectWithRef{persistent-metaclass}) {\funarg{object}} (\funarg{slot-definition}\ \ObjectWithRef{persistent-effective-slot-definition})}}
%
% No behavior is specified for this method beyond that which is specified
% for the generic function.

\flabel{\protect\mtd}{slot-makunbound-using-class (persistent-metaclass t symbol)}{}
{\Defmeth {slot-makunbound-using-class} {(\funarg{the-class}\ \ObjectWithRef{persistent-metaclass}) {\funarg{object}} (\funarg{slot-name}\ \ObjectWithRef{symbol})}}
Trapped to
 \fcite{slot-makunbound-using-class (standard-class t %
effective-slot-description)}.

\flabel{\protect\mtd}{slot-makunbound-using-class (standard-class t effective-slot-description)}{}
{\Defmeth {slot-makunbound-using-class} {(\funarg{the-class}\ \ObjectWithRef{standard-class}) {\funarg{object}} (\funarg{slot-description}\ \ObjectWithRef{effective-slot-description})}}
%
% No behavior is specified for this method beyond that which is specified
% for the generic function.

\flabel{\protect\mtd}{slot-makunbound-using-class (structure-class persistent-object symbol)}{}
{\Defmeth {slot-makunbound-using-class} {(\funarg{the-class}\ \ObjectWithRef{structure-class}) (\funarg{p-objid}\ \ObjectWithRef{persistent-object}) (\funarg{slot-name}\ \ObjectWithRef{symbol})}}
Trapped to
 \fcite{slot-makunbound-using-class (structure-class t %
structure-slot-description)}.

\flabel{\protect\mtd}{slot-makunbound-using-class (structure-class t structure-slot-description)}{}
{\Defmeth {slot-makunbound-using-class} {(\funarg{the-class}\ \ObjectWithRef{structure-class}) {\funarg{object}} (\funarg{slot-description}\ \ObjectWithRef{structure-slot-description})}}
%
% No behavior is specified for this method beyond that which is specified
% for the generic function.


\endcom

\begingfcom[External]{slot-value-using-class}

\Syntaxlabel
\Defgen {slot-value-using-class} {{\funarg{class}} {\funarg{object}} {\funarg{slot}}}


 See \fcite{slot-value-using-class}.


\Methodslabel

\flabel{\protect\mtd}{slot-value-using-class (persistent-metaclass t effective-slot-description)}{}
{\Defmeth {slot-value-using-class} {(\funarg{the-class}\ \ObjectWithRef{persistent-metaclass}) {\funarg{object}} (\funarg{slot-description}\ \ObjectWithRef{effective-slot-description})}}

\Remarkslabel
  In \allegro, this method specialized to
  \fcite{persistent-metaclass}\ must be defined; the method
  \fcite{slot-value-using-class (standard-class t effective-slot-description)}\ signals a Bus error.

\flabel{\protect\mtd}{slot-value-using-class (persistent-metaclass t
                        persistent-effective-slot-definition)}{}
{\Defmeth {slot-value-using-class} {(\funarg{the-class}\ \ObjectWithRef{persistent-metaclass}) {\funarg{object}} (\funarg{slot-definition}\ \ObjectWithRef{persistent-effective-slot-definition})}}
%
% No behavior is specified for this method beyond that which is specified
% for the generic function.

\flabel{\protect\mtd}{slot-value-using-class (persistent-metaclass t symbol)}{}
{\Defmeth {slot-value-using-class} {(\funarg{the-class}\ \ObjectWithRef{persistent-metaclass}) {\funarg{object}} (\funarg{slot-name}\ \ObjectWithRef{symbol})}}

 Trapped to
 \fcite{slot-value-using-class (standard-class t %
effective-slot-description)}.

\flabel{\protect\mtd}{slot-value-using-class (standard-class t effective-slot-description)}{}
{\Defmeth {slot-value-using-class} {(\funarg{the-class}\ \ObjectWithRef{standard-class}) {\funarg{object}} (\funarg{slot-description}\ \ObjectWithRef{effective-slot-description})}}
%
% No behavior is specified for this method beyond that which is specified
% for the generic function.

\flabel{\protect\mtd}{slot-value-using-class (structure-class persistent-object symbol)}{}
{\Defmeth {slot-value-using-class} {(\funarg{the-class}\ \ObjectWithRef{structure-class}) (\funarg{p-objid}\ \ObjectWithRef{persistent-object}) (\funarg{slot-name}\ \ObjectWithRef{symbol})}}
Trapped to
 \fcite{slot-value-using-class (structure-class t %
structure-slot-description)}.

\flabel{\protect\mtd}{slot-value-using-class (structure-class t structure-slot-description)}{}
{\Defmeth {slot-value-using-class} {(\funarg{the-class}\ \ObjectWithRef{structure-class}) {\funarg{object}} (\funarg{slot-description}\ \ObjectWithRef{structure-slot-description})}}
%
% No behavior is specified for this method beyond that which is specified
% for the generic function.


\endcom

\begingfcom[External]{(setf slot-value-using-class)}

\Syntaxlabel
\Defgen {(setf slot-value-using-class)} {{\funarg{new-value}} {\funarg{class}} {\funarg{object}} {\funarg{slot}}}


 See \fcite{(setf slot-value-using-class)}.


\Methodslabel

\flabel{\protect\mtd}{(setf slot-value-using-class) (t persistent-metaclass t
                               effective-slot-description)}{}
{\Defmeth {(setf slot-value-using-class)} {{\funarg{new-value}} (\funarg{the-class}\ \ObjectWithRef{persistent-metaclass}) {\funarg{object}} (\funarg{slot-description}\ \ObjectWithRef{effective-slot-description})}}

\Remarkslabel
  In \allegro, this method specialized to
  \fcite{persistent-metaclass}\ must be defined; the method
  \fcite{(setf slot-value-using-class) (t standard-class t effective-slot-description)}\ signals a Bus error.

\flabel{\protect\mtd}{(setf slot-value-using-class) (t persistent-metaclass t
                               persistent-effective-slot-definition)}{}
{\Defmeth {(setf slot-value-using-class)} {{\funarg{new-value}} (\funarg{the-class}\ \ObjectWithRef{persistent-metaclass}) {\funarg{object}} (\funarg{slot-definition}\ \ObjectWithRef{persistent-effective-slot-definition})}}
%
% No behavior is specified for this method beyond that which is specified
% for the generic function.

\flabel{\protect\mtd}{(setf slot-value-using-class) (t persistent-metaclass t symbol)}{}
{\Defmeth {(setf slot-value-using-class)} {{\funarg{new-value}} (\funarg{the-class}\ \ObjectWithRef{persistent-metaclass}) {\funarg{object}} (\funarg{slot-name}\ \ObjectWithRef{symbol})}}
Trapped to
 \fcite{(setf slot-value-using-class) (t standard-class t %
effective-slot-description)}.

\flabel{\protect\mtd}{(setf slot-value-using-class) (t standard-class t effective-slot-description)}{}
{\Defmeth {(setf slot-value-using-class)} {{\funarg{new-value}} (\funarg{the-class}\ \ObjectWithRef{standard-class}) {\funarg{object}} (\funarg{slot-description}\ \ObjectWithRef{effective-slot-description})}}
%
% No behavior is specified for this method beyond that which is specified
% for the generic function.

\flabel{\protect\mtd}{(setf slot-value-using-class) (t structure-class persistent-object symbol)}{}
{\Defmeth {(setf slot-value-using-class)} {{\funarg{new-value}} (\funarg{the-class}\ \ObjectWithRef{structure-class}) (\funarg{p-objid}\ \ObjectWithRef{persistent-object}) (\funarg{slot-name}\ \ObjectWithRef{symbol})}}
Trapped to
 \fcite{(setf slot-value-using-class) (t structure-class t %
structure-slot-description)}.

\flabel{\protect\mtd}{(setf slot-value-using-class) (t structure-class t structure-slot-description)}{}
{\Defmeth {(setf slot-value-using-class)} {{\funarg{new-value}} (\funarg{the-class}\ \ObjectWithRef{structure-class}) {\funarg{object}} (\funarg{slot-description}\ \ObjectWithRef{structure-slot-description})}}
%
% No behavior is specified for this method beyond that which is specified
% for the generic function.


\endcom

\beginclcom[External Structure]{stableheap-configuration}

\Purposelabel
 This is the \cl\ equivalent of the C
 \shcite{struct}{stableheap\us{}configuration}{1}.


\Directslotslabel

\Defdslot {configuration-flags} {0\newline :type fixnum}


 Bitmask with configuration flags; its value is a bitwise-or of the constants
 \lisp{KEY\us{}TO\us{}ADDRESS}\ \ldots\ \lisp{INCREMENTAL\us{}GC}\ %
 defined in \cite[\citepage{1}]{bib:Brown-92}.

\Defdslot {minimum-key} {0\newline :type fixnum}


 Minimum \objid\ allocated by the \postore.

\Defdslot {maximum-key} {0\newline :type fixnum}


 Maximum \objid\ allocated by the \postore. \note\ The \objid[s]\ allocated
 by \postore\ start at {\bf maximum-key} going down to {\bf minimum-key}.

\Defdslot {key-alignment} {0\newline :type fixnum}


 The alignment of the allocated \objid[s].


\endcom

\beginclcom[External Structure]{stableheap-statistics}

\Purposelabel

 This is the \cl\ equivalent of the C
 \shcite{struct}{stableheap\us{}statistics}{1}.


\Directslotslabel

\Defdslot {maximum-space} {0\newline :type fixnum}


 The maximum size of persistent memory in bytes.

\Defdslot {allocated-space} {0\newline :type fixnum}


 The already allocated persistent memory in bytes.

\Defdslot {unallocated-space} {0\newline :type fixnum}


 ???

\Defdslot {unused-allocated-space} {0\newline :type fixnum}


 ???

\Defdslot {allocated-management-space} {0\newline :type fixnum}


 ???

\Defdslot {number-of-objects} {0\newline :type fixnum}


 Number of allocated persistent objects; this is around 2837 after the
 \sh\ is formatted by calling the \fcite{format-plob-root};
 performing a garbage collection right after the formatting reduces
 the number of objects to 1740.


\endcom

\begingfcom[External]{store-object}

\Syntaxlabel
\Defgen {store-object} {{\funarg{t-object}} {\opt} {\funarg{depth}} {\funarg{p-heap}}}



\Argumentslabel
 \isanobject{\funarg{t-object}}
 \isa{\funarg{depth}}
      {a keyword symbol}
\Valueslabel
 The \objid\ referencing the persistent representation of
 \funarg{t-object}\ is returned.
\Purposelabel
 Store \funarg{t-object}\ to the \sh.
 Argument \funarg{depth}\ determines how `deep' the object is
 stored and can take one of the following values:
 \begin{description}

 \item[\lisp{:object}, \lisp{:objid}]
  Interpret \funarg{t-object}\ as an already persistent object.

 \item[\lisp{:cached}]
  Store only new allocated or immediate sub-objects.

 \item[\lisp{:flat}]
   Store only the top level of \funarg{t-object}.

 \item[\lisp{:deep}]
   Store all subobjects.

 \end{description}
 The default value for \funarg{depth}\ is defined in the
 \fcite{*default-depth*}.
\Seealsolabel
 \Fcite{load-object}.


\Methodslabel

\flabel{\protect\mtd}{store-object (persistent-clos-object)}{}
{\Defmeth {store-object} {(\funarg{t-object}\ \ObjectWithRef{persistent-clos-object}) {\opt} {\funarg{depth}} {\funarg{p-heap}}}}
Calls to this method are trapped to \fcite{t-object-to-p-objid}.

\flabel{\protect\mtd}{store-object (t)}{}
{\Defmeth {store-object} {{\funarg{t-object}} {\opt} {\funarg{depth}} {\funarg{p-heap}}}}
Calls to this method are trapped to \fcite{t-object-to-p-objid}.
 The numeric \objid\ received from {\bf t-object-to-p-objid}
 is put into an instance of \fcite{persistent-object}\ and returned;
 see also \fcite{make-persistent-object}.


\endcom

\begindccom[Persistent Symbols]{symbol ...}

\Purposelabel
 \plob\ offers persistent symbols as known in its transient form in
 \cl; each symbol belongs to a package, has a property list, a function
 and a value.

 To make the handling of symbols easier, the macro character
 \#! (hash sign followed by an exclamation mark) is used. Behind this
 letter, the name of a persistent symbol is expected; this can be
 e.g.\ a transient symbol. Its expansion is
 \begin{quote}\tt
  (p-symbol-value \textsl{\lt{}persistent-symbol-name\gt}\/)
 \end{quote}
 This form can be used to read the value of a persistent symbol;
 the \lisp{setf}-form can be used to set the value of a persistent
 symbol.

 The objects referenced by a persistent symbol are of course persistent
 too.
\Exampleslabel
 Store \cl\ data to the persistent symbol *p*:
 \begin{quote}\tt
(setf \#!*p* "This string is persistent.")
 \end{quote}
 Evaluating the above statement may produce an error message like
 \begin{quote}\tt
  Error: Persistent package COMMON-LISP-USER does not exist.
 \end{quote}
 This is not really an error condition but the error is raised as a
 `security valve' to escape from creating unwanted persistent
 packages (otherwise, since packages are persistent, too many
 unused packages might litter the \sh).

 Evaluating the following statement yields the value of the
 persistent symbol *p*:
 \begin{quote}\tt
\#!*p*
        ==> "This string is persistent."
 \end{quote}

 Please note that there is a difference between a {\sl transient}
 and a {\sl persistent symbol}\/: Both can have an own
 value, plist and function binding; there is no `tight coupling' between
 the transient and the persistent symbol.
\Seealsolabel
 \Fcite{persistent-symbol-reader};
 \fcite{p-symbol}.


\endcom

\begingfcom[External]{update-instance-for-redefined-class}

\Syntaxlabel
\Defgen {update-instance-for-redefined-class} {{\funarg{instance}} {\funarg{added-slot}} {\funarg{discarded-slots}} {\funarg{property-list}} {\rest} {\funarg{initargs}}}


 See \fcite{update-instance-for-redefined-class}.


\Methodslabel

\flabel{\protect\mtd}{update-instance-for-redefined-class :before (persistent-clos-object t t t)}{}
{\Defmethb {update-instance-for-redefined-class} {(\funarg{instance}\ \ObjectWithRef{persistent-clos-object}) {\funarg{added-slots}} {\funarg{discarded-slots}} {\funarg{property-list}} {\rest} {\funarg{initargs}}}}
Promotes the update of the transient \funarg{instance}\ to 
 its persistent companion in the \sh.


\endcom

\begingfcom[External]{validate-superclass}

\Syntaxlabel
\Defgen {validate-superclass} {{\funarg{class}} {\funarg{superclass}}}


 See \fcite{validate-superclass}.


\Methodslabel

\flabel{\protect\mtd}{validate-superclass (persistent-metaclass standard-class)}{}
{\Defmeth {validate-superclass} {(\funarg{class}\ \ObjectWithRef{persistent-metaclass}) (\funarg{superclass}\ \ObjectWithRef{standard-class})}}
%
% No behavior is specified for this method beyond that which is specified
% for the generic function.


\endcom

\beginmccom[External]{with-direct-representation}

\Syntaxlabel
\Defmac {with-direct-representation} {(\funarg{&optional}\ \ObjectWithRef{(depth object)}) {\rest} {\funarg{forms}}}


\Argumentslabel
 \isa{\funarg{forms}}
      {an implicit \lisp{progn}\ expression}
\Valueslabel
 Returns the value of evaluating \funarg{forms}.
\Purposelabel
 The \funarg{forms}\ are evaluated in a context which references
 persistent objects directly; no transient representations will be
 generated for persistent objects loaded from the database.
\Seealsolabel
 \Fcite{with-transient-representation}.


\endcom

\beginmccom[External]{with-session}

\Syntaxlabel
\Defmac {with-session} {{\rest} {\funarg{forms}}}


\Argumentslabel
 \isa{\funarg{forms}}
      {an implicit \lisp{progn}\ expression}
\Valueslabel
 Returns the value of evaluating \funarg{forms}.
\Purposelabel
 Embed the evaluation of \funarg{forms}\ into an own session. Each session
 has isolated access to the persistent heap.
\Seealsolabel
 \Fcite{open-my-session};
 \fcite{close-session}.


\endcom

\beginmccom[External]{with-transaction}

\Syntaxlabel
\Defmac {with-transaction} {(\funarg{&optional}\ \ObjectWithRef{(p-heap '*default-persistent-heap*)}) {\rest} {\funarg{forms}}}


\Argumentslabel
 \isa{\funarg{forms}}
      {an implicit \lisp{progn}\ expression}
\Valueslabel
 Returns the value of evaluating \funarg{forms}.
\Purposelabel
 Embed the evaluation of \funarg{forms}\ into an active transaction:

 If there is no transaction running on \funarg{p-heap},
 a transaction is started, \funarg{forms}\ are evaluated and the
 transaction is ended if no error occured at evaluating
 \funarg{forms}\ or cancelled if at least one error occured at
 evaluating \funarg{forms}.

 If there is already an active transaction,
 only \funarg{forms}\ are evaluated.

\Remarkslabel
 The user of this macro promises implicitly that before and after
 evaluating the \funarg{forms}\ the \sh\ is in a consistent
 state. Only during evaluating \funarg{forms}\ a temporary
 inconsistent \sh\ state may arise.

\Seealsolabel
 \Fcite{begin-transaction};
 \fcite{cancel-transaction};
 \fcite{end-transaction}.


\endcom

\beginmccom[External]{with-transient-representation}

\Syntaxlabel
\Defmac {with-transient-representation} {(\funarg{&optional}\ \ObjectWithRef{(depth cached)}) {\rest} {\funarg{forms}}}


\Argumentslabel
 \isa{\funarg{forms}}
      {an implicit \lisp{progn}\ expression}
\Valueslabel
 Returns the value of evaluating \funarg{forms}.
\Purposelabel
 The \funarg{forms}\ are evaluated in a context which references
 persistent objects indirectly by thier transient representation;
 so, transient representations will be generated for persistent
 objects loaded from the database.
\Seealsolabel
 \Fcite{with-direct-representation}.


\endcom

\beginfncom[External]{write-lock-store}

\Syntaxlabel
\Defun {write-lock-store} {{\opt} {\funarg{p-heap}}}


 Put a write lock onto the whole database. This will speed up object
 locking, but care must be taken since the locking scheme can't be used
 any longer to detect if an object was already stored.


\endcom

\message{^^JGeneric function clos:writer-method-class has no methods.^^J}
