% This is -*-LaTeX-*-
%
\documentclass[a4paper%
%,twocolumn%
%,12pt,%
]{article}
\usepackage[english]{babel}
\usepackage{dipldefs,crossref}
\usepackage{epsfig,timestt}
\usepackage{picinpar}
%
\newcommand\showfigrule{0pt}
%renewcommand\showfigrule{2pt}
%
\renewcommand\figurename{Fig.}
%
\newcommand{\etal}{+}
\newcommand{\inpea}[1]{%
P.\ P.\ Spies (Ed.):
{\em Proceedings Euro-ARCH '93\/},
\citepage{#1},
Informatik Aktuell,
Springer-Verlag, Berlin, 1993}
%
\newcommand{\inpos}[1]{%
John Rosenberg, David Koch (Eds.):
{\em Persistent Object Systems,
Newcastle, Australia 1989\/},
\citepage{#1},
Springer-Verlag, Berlin, 1989}
%
\title{%
Persistency in a Dynamic Object-Oriented Programming Language}
%
\author{%
Heiko Kirschke%
\thanks{The author's email address is
\texttt{%
% kirschke@informatik.uni-hamburg.de%
mailto:Heiko.Kirschke@poet.de%
}}%
\\[\smallskipamount]
\small University of Hamburg $\bullet$
Computer Science Department\vspace{-0.25\baselineskip}\\
\small Vogt-K\"{o}lln-Stra\ss{}e 30 $\bullet$
D 22527 Hamburg, Germany\\[\medskipamount]
\small New address: POET Software GmbH $\bullet$
Fo\ss{}redder 12 $\bullet$
D 22359 Hamburg\\[\smallskipamount]
\parbox{\textwidth}{\small The work described in this document has
been carried out private and within Hamburg University.  POET Software is not
otherwise affiliated with the work presented here.}}%
%
\date{21.\ August 1995}
%
\addtolength{\textwidth}{35mm}%
\addtolength{\evensidemargin}{-17mm}%
\addtolength{\oddsidemargin}{-17mm}%
\addtolength{\textheight}{16.10072mm}%
%
\begin{document}
%
\maketitle
%
%\sloppy
%
\noindent%
The common approach used for storing longlived structured data is to
employ a relational database which provides its users with types for
structuring data and operations to manipulate them.  Along with its
data definition and manipulation language, a database often provides
an interface to a general programming language.  This interface is a
possibility to access the database's functionality, but it neglects
the concepts of the programming language using the database.  A
solution to this problem is to remove the dichotomy between a database
and a programming language, i.e.\ to integrate the concepts of a
database into the general programming language.  This abstract
presents some aspects of research done on persistency and explains
shortly an implemented architecture for integrating persistency into
the dynamic, object-oriented programming language \cl\ Object System
(\clos).  Further details can be found in
\cite{bib:ki94a,bib:ki94b,bib:ki95}.
%
\par{}The background for this work was the field of model-based image
analysis, which involves two kinds of data: On the one side, the raw
image data (e.g.\ high resolution color images) and on the other side,
models of the objects mapped to the images represented by highly
interconnected data objects.  This resulted in the following demands
for a system capable of storing data:
%
\begin{itemize}
%
\item For storing the raw images, the system must be able to cope with
very large data objects.
%
\item For storing the object models, a storage system should be able to
handle references between data objects appropriate.
%
\item Since the programming language chosen for model-based image
analysis was \clos, the storage system's interface should be adapted
both in its syntax and semantics as far as possible to \clos.  The
development of the image analyzing software and the storage system was
done in parallel, so the integration of the storage system into an
existing \clos\ application should be possible without big efforts.
%
\item Besides simply storing data, the system should offer some
database functionality, e.g.\ transactions, data locking and
associative search.
%
\end{itemize}
%
A more personal goal was the time constraint imposed by the
examination instructions of Hamburg University: A diploma thesis has
to be finished after one year. I took this as a challenge to design,
implement and document a real-working efficient system with an open
interface for further extensions in this time interval.
%
\par{}The reason for selecting a dynamic programming language was that
in most of them (esp.\ in \clos), to each data object a class
metaobject is associated which describes the data's structure and
behavior. This description can be used to obtain all informations
necessary for storing an object by a persistent system; in static
systems, these informations are often not available at all or must be
generated by dedicated compilers.
%
\section{Systems for persistent data}
%
The classical approach to make data persist over time and to access it
conveniently is to use a relational database. The formal basis of
relational databases is the relational calculus defined by
\cite{bib:co79}.\footnote{The original definition dates back to 1970;
the reference given here contains the original and some extensions to
it.} His definition was aimed 
at abstracting
from the details of the data's representation.  The
relational calculus has some mathematically provable, attractive
properties, e.g.\ the existence of normal forms to avoid redundancies
and anomalies, so a database obeying the relational calculus inherits
these properties. Furthermore, there is no need for the notion of an
explicit reference like in most other general programming languages;
instead, a reference is established by a common value shared between
the referencing objects.
%
\begin{figwindow}[2,r,{\rule{\showfigrule}{4\baselineskip}
                       \fbox{\psfig{figure=tenpt/incldbme.eps}}},%
                  {Modelling a real system%
                   {$^{\ref{fn:fig}}$}\label{fig:incldbme}}]
%
\addtocounter{footnote}{1}%
\footnotetext{Figures from
\protect\cite[\protect\citepage{81}]{bib:at89}\label{fn:fig}}%
Besides storing data, a real-world application also consists of
methods working on the data; of course, Codd and others realized this
and extended the relational calculus by relational algebra to comprise
data manipulation too \cite[\citepage{400}]{bib:co79}
\cite[\citepage{44}]{bib:on94}, but although his solution clearly has
some theoretical advantages, it did not succeed in practice, perhaps
because it was too formal to be developed into a general programming
language. Instead, relational databases have been made available to
general programming languages by more or less obscure interfaces,
e.g.\ Embedded SQL
\cite[\citepage{201--283}]{bib:on94} or the LIBPQ interface of
\postgres\ \cite[\citepage{112--126}]{bib:we93}
(\figurename~\ref{fig:incldbme}). Another way was taken
by some database vendors: They extended their (relational) databases
by more or less general programming languages whose development
started as an ad-hoc solution, examples are SQL, NATURAL/ADABAS and
ABAP-SAP/R3.%
\footnote{Although ADABAS and SAP/R3 are not
relational databases, the above statement is also valid for
NATURAL and ABAP, respectively.}
\end{figwindow}%
%
\begin{figwindow}[2,r,{\rule{\showfigrule}{2\baselineskip}%
                       \fbox{\psfig{figure=tenpt/inclme.eps}}},%
                 {Modelling a real system%
                  {$^{\ref{fn:fig}}$}\label{fig:inclme}}]
%
Starting around the mid-70s, a new view to persistency was
established. Instead of using a seperate subsystem, persistency was
integrated into a general programming language; in the first attempts,
an existing language was extended by dedicated constructs for defining
types with its instances being persistent and additional control
structures, e.g.\ selectors, iterators etc. \cite{bib:schm80}. Later
on, general programming languages have been defined with persistency
being a property of \emph{each} object which can be represented
\cite{bib:cl91,bib:ma93}; persistency became orthogonal w.r.t.\ the
type system (\figurename~\ref{fig:inclme}). Practice also showed that
it is desirable to keep the notion of an explicit reference between
objects: Besides being a very efficient implementation of a relation
between representations of real-world objects, it reflects this
relation more direct than the relational calculus of sharing a common
value.
\end{figwindow}%
%
\section{Architecture concepts for persistent systems}
%
\begin{figwindow}[2,r,{\rule{\showfigrule}{7\baselineskip}%
                       \psfig{figure=tenpt/rperlaye.eps}},%
                 {Persistent system architecture%
                  \label{fig:rperlaye}}]
%
\noindent%
From the various possible architectures for persistent systems, I
decided to use the one shown in \figurename{\ref{fig:rperlaye}}:
An existing transient object system (\clos) is extended by a new
system which adds persistency. The application layer can use the
transient system directly for its transient objects and the persistent
system for its objects which should be held persistent. Building a
persistent system on top of an existing transient system has the
advantage that the persistent system can use all the services
provided by the transient system. Especially for \clos\ this approach
yields a very elegant solution, since the persistent system can be
integrated seamlessly into the overall architecture; this is
accomplished by the Metaobject Protocol (\mop) of \clos, which makes
syntactic and semantic extensions for \clos\ possible by means
of \clos\ itself (see \cite{bib:amop91,bib:st90} for details).
\end{figwindow}%
%
\par{}One important question what kind of subsystem should be used
for the persistent memory. Persistent systems using a relational
database as a persistent memory can pass the rich data manipulation
functionality to higher levels, but usually they suffer from the
different type concepts of the relational database and \clos.  Since
\clos\ is a very type-rich language and relational databases
normally offer only a subset of \clos' types, these systems have to
translate between both data representations; also, references between
objects have to be transformed to the value-based approach of the
relational calculus. A solution to this problem is to use a
\emph{persistent heap} as persistent memory; it works very similar to
a transient heap, especially it has the possibility of establishing
explicit references between the objects contained in it. These
explicit references allow the lifetime of persistent objects to be
defined in terms of reachability: The persistent system is allowed to
delete a persistent object, if it can prove that it is no longer in
the transitive closure of the references of a designated root
object. The root object itself has an infinite lifetime.
%
\par{}Since a persistent heap offers a `low-level' untyped data
representation, typing the objects in the heap must be done by higher
layers, i.e.\ the persistent object system. Thereby, the type
restrictions normally imposed upon the persistent system by using a
relational database can be avoided, since the persistent system can
simply adopt the typing concepts of \clos.
%
\section{Persistent LISP Objects}
%
\begin{figwindow}[2,r,{\rule{\showfigrule}{9.5\baselineskip}%
                       \psfig{figure=tenpt/ploblaye.eps}},
                  {\plob\ layers%
                   \label{fig:ploblaye}}]
%
\noindent%
The evaluation of the concepts important for persistent object systems
lead to the development of the Persistent LISP objects (\plob) system
(\figurename~\ref{fig:ploblaye}). The lowest level is the persistent
heap POSTORE developed at the University of St Andrews
\cite{bib:br92}; it implements the administration of persistent
records. Its `typing' consists of dividing each record into a section
with references to other persistent records and a value section, which
is not further interpreted by POSTORE.
%
The next layer C-\plob\ implements the overall database functionality
of the persistent system in ANSI-C. Regarding data modelling, it
imposes a refined typing onto the POSTORE records which can be
characterized as a mapping of \emph{each} \clos\ type into an
appropriate persistent type with the database specific extensions of
object locking and transaction handling. Regarding data manipulation,
this layer handles Two-Phase transactions and associative access to
the objects contained in the persistent memory.
%
The \plob\ layer written in \clos\ is the link between the application
layer (the `sessions' in \figurename~\ref{fig:ploblaye}) and the
persistent object system. Its task regarding data representation is to
transform between the different representations used for objects in
\clos\ and in the lower levels of \plob.
Its second task is to make the functionality of the C-\plob\ layer
available to the higher application layer and to offer some more
convenient concepts, e.g.\ persistent symbols for simple adressing of
persistent objects. Care was taken that the integration of persistency
into existing \clos\ applications is possible.
%
The highest session layer represents applications using \plob. Each
session is an aggregation of a \clos\ process and a transaction. The
transaction is used by the process to make consistent changes to the
persistent system, i.e.\ all changes to the states of persistent
objects are embedded into transactions. Since \plob\ is almost type
complete, the application layer gets persistency without
restrictions.\footnote{The only exception is function code, which can
not be stored because of relocation problems.}
\end{figwindow}
%
\section{Conclusions}
%
Practice showed that the system described in the last section proved
very flexible and efficient. Its flexibility stems from its
implemented orthogonal view of persistency w.r.t.\ the type system of
\clos; using the Metaobject Protocol of \clos\ made
the interface between the persistent system and an application very
simple; indeed, persistency is transparent to the users of \plob. 
%
\par{}Besides that meanwhile almost any database is decorated with the
term `object-oriented' in some sense, the market of `real'
object-oriented databases is growing. There are now available a number
of commercial persistent systems for static programming languages
(e.g.\ ObjectStore for C++) and for dynamic programming languages
(among the here presented system e.g.\ Ithasca for \clos\ and for
C++). To my opinion, following the dynamic paradigm for persistent
systems is more promising than concentrating on pure static
systems, because the static systems can be subsummed under the dynamic
systems. However, it must be noted that full dynamic systems are more
difficult to optimize; a combination of both techniques might show the
right way. Furthermore, the concept of persistent objects with
explicit references leaves the path shown by the relational calculus;
from a very radical point of view, this could even be seen as a step
back towards databases with complicated, graph-like and cyclic
structures. Clearly, some theoretical research has to be done on this
area, but it looks as if persistent object systems have much benefits
w.r.t.\ general programming languages.
%
\begin{thebibliography}{Sch\etal\ 80}
%
\bibitem[AMOP]{bib:amop91}
Gregor Kiczales, Jim des Rivi\`{e}res, Daniel G.\ Bobrow: The Art of
the Metaobject Protocol.  MIT Press, Cambridge, Mass., 1991
%
\bibitem[Atk\etal\ 89]{bib:at89}
Malcolm Atkinson, Ronald Morrison:
Persistent System Architectures.
\inpos{73--97}
%
\bibitem[Br 92]{bib:br92}
A.\ L.\ Brown:
\sh\ manual pages,
File \lisp{postore/man/stable\us{}heap.3p},
25~Mai 1992
%
\bibitem[Cl 91]{bib:cl91}
Stewart M.\ Clamen:
Data Persistency in Programming Languages, A Survey.
Report CMU-CS-91-155,
Carnegie Mellon University, Pittsburgh,
1991
%
\bibitem[CLtLII]{bib:st90}
Guy L.\ Steele Jr.:
\cl\ the Language, Second Edition.
Digital Press, Bedford, Mass., 1990
%
\bibitem[Co 79]{bib:co79}
E.\ F.\ Codd:
Extending The Database Relational Model to Capture More Meaning.
{\em ACM Transactions on Database Systems\/},
4(4):397--434, December 1979
%
\bibitem[Kir 94a]{bib:ki94a}
Heiko Kirschke:
Persistenz in objekt-orientierten Programmiersprachen am Beispiel von
CLOS.
Diploma thesis,
Dept.\ of Computer Science, University of Hamburg,
1994
%
\bibitem[Kir 94b]{bib:ki94b}
Heiko Kirschke:
Persistent LISP Objects:
User's Guide, Reference Manual.
Dept.\ of Computer Science, University of Hamburg,
1994
%
\bibitem[Kir 95]{bib:ki95}
Heiko Kirschke:
Persistenz in der objekt-orientierten
Programmiersprache \clos\ am Beispiel
des \plob\ Systems.
Report FBI-HH-B-179/95,
Dept.\ of Computer Science, University of Hamburg,
1995
%
\bibitem[Mat\etal\ 93]{bib:ma93}
F.\ Matthes, J.\ Schmidt:
System Construction in the Tycoon Environment:
Architectures, Interfaces and Gateways.
\inpea{301--317}
%
\bibitem[O'N 94]{bib:on94}
Patrick O'Neil:
Database Principles, Programming, Performance.
Morgan Kaufmann Publishers, San Francisco, Ca., 1994
%
\bibitem[Sch\etal\ 80]{bib:schm80}
Joachim W.\ Schmidt, Manuel Mall:
\pascalr\ Report.
Report IFI-HH-B-66/80,
Dept.\ of Computer Science, University of Hamburg,
1980
%
\bibitem[Wen\ 93]{bib:we93}
S.\ Wensel (Ed.):
The \postgres\ Reference Manual,
Version~4.1.
Report M88/20, University of California, Berkeley, 1993
%
\end{thebibliography}
\end{document}
