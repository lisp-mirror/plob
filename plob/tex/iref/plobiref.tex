%
% This file was generated from the LISP module `lisp-doc' by extracting
% the LISP documentation strings of the files
%
%   PLOB:SOURCE;PLOB-EXTRA-DOC.LISP
%   PLOB:SOURCE;PLOB-URL.LISP
%   PLOB:SOURCE;PLOB-DEFAULTS.LISP
%   PLOB:SOURCE;PLOB-ERROR.LISP
%   PLOB:SOURCE;PLOB-EXTENT.LISP
%   PLOB:SOURCE;PLOB-EVOLUTION.LISP
%   PLOB:SOURCE;PLOB-SYSDEP.LISP
%   PLOB:SOURCE;PLOB-METACLASS-1.LISP
%   PLOB:SOURCE;PLOB-METACLASS-2.LISP
%   PLOB:SOURCE;PLOB-METACLASS-3.LISP
%   PLOB:SOURCE;PLOB-DEFINES.LISP
%   PLOB:SOURCE;PLOB-INT.LISP
%   PLOB:SOURCE;PLOB-LOW.LISP
%   PLOB:SOURCE;PLOB-OBJID-BUFFER.LISP
%   PLOB:SOURCE;PLOB-WRITERS.LISP
%   PLOB:SOURCE;PLOB-HEAP.LISP
%   PLOB:SOURCE;PLOB-BTREE.LISP
%   PLOB:SOURCE;PLOB-BTREE-MAPPER.LISP
%   PLOB:SOURCE;PLOB-SESSION.LISP
%   PLOB:SOURCE;PLOB-MACHINE.LISP
%   PLOB:SOURCE;PLOB-MISC.LISP
%   PLOB:SOURCE;PLOB-CONS.LISP
%   PLOB:SOURCE;PLOB-SYMBOL.LISP
%   PLOB:SOURCE;PLOB-FUNCTION.LISP
%   PLOB:SOURCE;PLOB-VECTOR.LISP
%   PLOB:SOURCE;PLOB-ARRAY.LISP
%   PLOB:SOURCE;PLOB-STRING.LISP
%   PLOB:SOURCE;PLOB-BIT-VECTOR.LISP
%   PLOB:SOURCE;PLOB-NUMERIC.LISP
%   PLOB:SOURCE;PLOB-STRUCT-DESCR.LISP
%   PLOB:SOURCE;PLOB-STRUCT.LISP
%   PLOB:SOURCE;PLOB-STRUCT-SLOT-DESCR.LISP
%   PLOB:SOURCE;PLOB-STRUCT-HASH-TABLE.LISP
%   PLOB:SOURCE;PLOB-STRUCT-PACKAGE.LISP
%   PLOB:SOURCE;PLOB-STRUCT-ROOT.LISP
%   PLOB:SOURCE;PLOB-CLOS-DESCR.LISP
%   PLOB:SOURCE;PLOB-CLOS.LISP
%   PLOB:SOURCE;PLOB-CLOS-SLOT-DESCR.LISP
%   PLOB:SOURCE;PLOB-CLOS-SLOT-VALUE.LISP
%   PLOB:SOURCE;PLOB-METHOD-DESCR.LISP
%   PLOB:SOURCE;PLOB-DATABASE.LISP
%   PLOB:SOURCE;PLOB-BUILTIN.LISP
%   PLOB:SOURCE;PLOB-INSPECT.LISP
%   PLOB:SOURCE;PLOB-BOOTSTRAP.LISP
%   PLOB:UTIL;PLOB-SEXPR.LISP
%
% as of 2005/05/24 16:12    (year/mm/dd hh:mm)
% Changes done here will be lost.
%
% lisp-doc (C) 1994--1998 Heiko Kirschke
%
\let\tempa\relax%
\ifx\flabel\undefined%
 \let\tempa\endinput%
 Missing document substyle {\tt `crossref.sty'}; ending input.
 \message{^^J^^JMissing document substyle `crossref.sty'; ending input.^^J^^J}%
\fi%
\ifx\Seealsolabel\undefined%
 \let\tempa\endinput%
 Missing document substyle {\tt `lispdoc.sty'}; ending input.
 \message{^^J^^JMissing document substyle `lispdoc.sty'; ending input.^^J^^J}%
\fi%
\tempa\def\tempa{}%

\begindccom[Class Hierarchy]{Structure Class Hierarchy}

\ClassHierarchyLine{0}{External Structure Class}{t}
\ClassHierarchyLine{1}{Internal Structure Class}{btree-cache-entry}
\ClassHierarchyLine{1}{Internal Structure Class}{cached-heap}
\ClassHierarchyLine{1}{Internal Structure Class}{migrate-info}
\ClassHierarchyLine{1}{Internal Structure Class}{objid-buffer}
\ClassHierarchyLine{1}{Internal Structure Class}{persistent-btree}
\ClassHierarchyLine{2}{Internal Structure Class}{cached-btree}
\ClassHierarchyLine{1}{Internal Structure Class}{persistent-btree-mapper}
\ClassHierarchyLine{1}{Internal Structure Class}{persistent-hash-table}
\ClassHierarchyLine{1}{Internal Structure Class}{persistent-immediate-object}
\ClassHierarchyLine{2}{Internal Structure Class}{slot-load-on-demand}
\ClassHierarchyLine{1}{Internal Structure Class}{persistent-lisproot}
\ClassHierarchyLine{1}{Internal Structure Class}{persistent-package}
\ClassHierarchyLine{1}{Internal Structure Class}{structure-description}
\ClassHierarchyLine{1}{Internal Structure Class}{structure-slot-description}
\ClassHierarchyLine{1}{Internal Structure Class}{type-info}
\ClassHierarchyLine{1}{Internal Structure Class}{url}



\endcom

\begindccom[Class Hierarchy]{CLOS Class Hierarchy}

\ClassHierarchyLine{0}{External CLOS Class}{t}
\ClassHierarchyLine{1}{External CLOS Class}{standard-object}
\ClassHierarchyLine{2}{External CLOS Class}{metaobject}
\ClassHierarchyLine{3}{External CLOS Class}{method}
\ClassHierarchyLine{4}{External CLOS Class}{standard-method}
\ClassHierarchyLine{5}{External CLOS Class}{standard-accessor-method}
\ClassHierarchyLine{6}{External CLOS Class}{standard-reader-method}
\ClassHierarchyLine{7}{Internal CLOS Class}{persistent-reader-method}
\ClassHierarchyLine{6}{External CLOS Class}{standard-writer-method}
\ClassHierarchyLine{7}{Internal CLOS Class}{persistent-writer-method}
\ClassHierarchyLine{3}{External CLOS Class}{slot-definition}
\ClassHierarchyLine{4}{External CLOS Class}{standard-slot-definition}
\ClassHierarchyLine{5}{External CLOS Class}{standard-direct-slot-definition}
\ClassHierarchyLine{6}{Internal CLOS Class}{persistent-direct-slot-definition}
\ClassHierarchyLine{5}{External CLOS Class}{standard-effective-slot-definition}
\ClassHierarchyLine{6}{Internal CLOS Class}{persistent-effective-slot-definition}
\ClassHierarchyLine{2}{Internal CLOS Class}{persistent-clos-object}
\ClassHierarchyLine{3}{Internal CLOS Class}{plob-description}
\ClassHierarchyLine{4}{Internal CLOS Class}{direct-slot-description}
\ClassHierarchyLine{4}{Internal CLOS Class}{effective-slot-description}
\ClassHierarchyLine{4}{Internal CLOS Class}{method-description}



\endcom

\beginfncom[Internal]{allocate-bignum}

\Syntaxlabel
\Defun {allocate-bignum} {{\funarg{size-in-bits}}}


\Argumentslabel
 \isa{\funarg{size-in-bits}}
      {a fixnum}
\Valueslabel
 An uninitialized transient object of `class' \class{bignum}.
\Purposelabel
 Low-level allocate of a transient instance of `class'
 \class{bignum}\ (i.e.\ {\sl no} persistent instance
 is allocated) occupying \funarg{size-in-bits}\ memory bits.
\Remarkslabel
 \sysdep{function}

 Actually, \class{bignum}\ is not the name of a class which can be
 located by evaluating \lisp{(find-class 'bignum)}. It is a fairly
 low-level built-in class which is made up from a collection of low-level
 functions. The `external view' of instances of class
 \class{bignum}\ is the class \class{integer}, but
 \plob\ differentiates because of efficency considerations between
 the subclasses \class{fixnum}\ (whose instances are handled in an
 `immediate'-fashion) and
 non-fixnum $\equiv$ \class{bignum}\ (whose instances are
 handled in a `non-immediate'-fashion) of class \class{integer}.

 The \allegrocl\ code is derived from an example sent to me
 by Duane Rettig \lisp{duane@Franz.COM}


\endcom

\begindccom[Array Information Functions]{array ...}

 Arrays are a rather baroque and bizarre `feature' in \cl,
 especially arrays created with the \lisp{:displaced-to}\ option.
 Almost all array information can be obtained by calling the
 appropiate array-specific functions,
 e.g.\ \fcite{array-dimensions},
 \fcite{array-element-type},
 \fcite{array-rank}\ etc. The only important
 information which can {\sl not} be obtained by a well-defined
 \cl\ function is the fact if an array is displaced
 to \cite[\citepage{444}]{bib:CLtLII} another array
 and to which array it is displaced to.\footnote{I guess this has been
 omitted from the \cl\ standard to give the implementator of a
 \cl\ system a big degree of freedom in designing the internal memory
 representation of arrays.}
 The following functions {\bf array-data-vector},
 {\bf array-displaced-offset}, {\bf array-displaced-to} and
 {\bf array-displaced-to-p} are
 defined here to get around this problem and to allow \plob\ to
 cope also with displaced arrays in a \cl\ fashion, i.e.\ to
 obey the references established between displaced arrays.

 Users of these functions should care for the type-declarations
 done for the functions arguments because the called sub-functions
 are very low-low-level functions and expect the declared types;
 \lw\ may crash if the argument type is not of the type the
 sub-function expects.
\Seealsolabel
 \Fcite{array-data-vector};
 \fcite{array-displaced-offset};
 \fcite{array-displaced-to};
 \fcite{array-displaced-to-p};
 argument \keyarg{displaced-to}\ of
 \fcite{make-array}.


\endcom

\beginfncom[Internal]{array-data-vector}

\Syntaxlabel
\Defun {array-data-vector} {{\funarg{the-array}}}


\Argumentslabel
 \isa{\funarg{the-array}}
      {an array object}
\Valueslabel
 Returns a \cl\ object holding the elements of \funarg{the-array}.
\Purposelabel
 Returns the object which is used by the lisp system to hold the
 elements contained in \funarg{the-array}.
 If this object cannot be determined return \lispnil.
\Remarkslabel
 \sysdep{function}

 Please note that \lw\ may crash if \funarg{the-array}\ is not
 of type array or vector.
\Exampleslabel
 In \lw\ this is an instance of class \class{vector}\ or
 \class{bit-vector}\ with a length of
 \lisp{(array-total-size \funarg{the-array})}:
 \begin{lispcode}
(setf *a* #2a((1 2)(3 4))) ==> #2A((1 2)(3 4))
(array-data-vector *a*)    ==> #(1 2 3 4)
 \end{lispcode}
\Seealsolabel
 Section \fcite{array ...}.


\endcom

\beginfncom[Internal]{array-displaced-offset}

\Syntaxlabel
\Defun {array-displaced-offset} {{\funarg{displaced-array}}}


\Argumentslabel
 \isa{\funarg{displaced-array}}
      {an array object}
\Purposelabel
 Return the displaced offset for \funarg{displaced-array}.
\Remarkslabel
 \sysdep{function}
\Seealsolabel
 \Fcite{array-displaced-to};
 \fcite{array-displaced-to-p};
 section \fcite{array ...};
 argument \keyarg{displaced-index-offset}\ of
 \fcite{make-array}.


\endcom

\beginfncom[Internal]{array-displaced-to}

\Syntaxlabel
\Defun {array-displaced-to} {{\funarg{displaced-array}}}


\Argumentslabel
 \isa{\funarg{displaced-array}}
      {an array object}
\Valueslabel
 Two values are returned:
 \begin{enumerate}

 \item The first value being \nonnil\ means that
  \funarg{displaced-array}\ is displaced to another array,
  \lispnil\ means that \funarg{displaced-array}\ is not displaced
  to any other array.

 \item The meaning of the second value depends on the first value:

   \begin{description}

   \item[First value is \lispnil]
    A second value being \lispnil\ indicates that it could not be
    determined if \funarg{displaced-array}\ is displaced to another
    array.
    A second value being \lispt\ means that
    \funarg{displaced-array}\ is definitely not displaced to any other
    array.

   \item[First value is \nonnil]
    A second value of \lispnil\ or \lispt\ means that
    \funarg{displaced-array}\ is definitely displaced to
    another array but this array cannot be determined (in this
    case it is the responsibility of the caller of this function to
    compute the array anyhow). Any other second
    value is interpreted as the another array to which
    \funarg{displaced-array}\ is displaced to.

  \end{description}

 \end{enumerate}
\Purposelabel
 Check if \funarg{displaced-array}\ is an array
 which is displaced to another array, i.e.\ if
 \funarg{displaced-array}\ was created like
 \lisp{(make-array ... :displaced-to \textit{\lt{}another array\gt} \ldots)}.
\Remarkslabel
 \sysdep{function}
\Seealsolabel
 \Fcite{array-displaced-offset};
 \fcite{array-displaced-to-p};
 section \fcite{array ...};
 argument \keyarg{displaced-to}\ of
 \fcite{make-array}.


\endcom

\beginfncom[Internal]{array-displaced-to-p}

\Syntaxlabel
\Defun {array-displaced-to-p} {{\funarg{displaced-array}} {\opt} {\funarg{displaced-to-array}}}


\Argumentslabel
 \isa{\funarg{displaced-array}\ resp.\ \funarg{displaced-to-array}}
      {an array object}
\Valueslabel
 The returned value depends on whether the {\opt} argument
 \funarg{displaced-to-array}\ is given:
 \begin{description}

 \item [The \funarg{displaced-to-array}\ argument is missing:]
  The returned values are like those of
   \fcite{array-displaced-to}.

 \item [The \funarg{displaced-to-array}\ argument is given:]

  Two values are returned:
  \begin{enumerate}

  \item The first value being \nonnil\ means that
   \funarg{displaced-array}\ is displaced to
   \funarg{displaced-to-array},
   \lispnil\ means that \funarg{displaced-array}\ is not displaced
   to \funarg{displaced-to-array}.

  \item The second value \nonnil\ means that the first value
   could be computed and is valid,
   \lispnil\ means that it could not be decided whether
   \funarg{displaced-array}\ is displaced to
   \funarg{displaced-to-array}; therefore, the first value is invalid.

  \end{enumerate}
 \end{description}
\Purposelabel
 Check if \funarg{displaced-array}\ is an array which is displaced
 to \funarg{displaced-to-array}, i.e.\ if
 \funarg{displaced-array}\ was created with
 \lisp{(make-array ... :displaced-to \funarg{displaced-to-array} \ldots)}.
\Remarkslabel
 \sysdep{function}
\Seealsolabel
 \Fcite{array-displaced-offset};
 \fcite{array-displaced-to};
 section \fcite{array ...};
 argument \keyarg{displaced-to}\ of
 \fcite{make-array}.


\endcom

\beginfncom[Internal]{array-displaced-to-with-interaction}

\Syntaxlabel
\Defun {array-displaced-to-with-interaction} {{\funarg{t-array}}}


\Purposelabel
 Straight call to \fcite{array-displaced-to}\ with some
 additional user-interaction if it cannot be decided if
 \funarg{t-array}\ is displaced to another array.


\endcom

\beginfncom[Internal]{assert-open-session-p}

\Syntaxlabel
\Defun {assert-open-session-p} {{\opt} {\funarg{p-heap}}}


\Purposelabel
 Assert that the \sh\ and the process-local sessions is open at all;
 if it is not yet open, it is opened.
\Seealsolabel
 \Fcite{assert-sh-open-p}.


\endcom

\beginfncom[Internal]{assert-sh-open-p}

\Syntaxlabel
\Defun {assert-sh-open-p} {}


\Purposelabel
 Assert that the \sh\ is open at all; if it is not yet open,
 it is opened.
\Seealsolabel
 \Fcite{sh-open-p}.


\endcom

\beginfncom[Internal]{assert-structure-class}

\Syntaxlabel
\Defun {assert-structure-class} {{\funarg{class-of-structure}}}


\Argumentslabel
 \isanobject{\funarg{class-of-structure}}
\Purposelabel
 Assert that \funarg{class-of-structure}\ is the \clsmo\ of a
 \lisp{defstruct}\ class; raise an error otherwise.


\endcom

\begincncom[Internal]{+bignum-deref+}

\Valuelabel
\begin{CompactCode}
(or nil)
\end{CompactCode}

 \Purposelabel
  A flag if the pointer to a bignum needs one more dereferencing.
  This is needed for \allegrocl\ 5.0; the foreign function mapping
  code in ff-mapping.lisp puts an additional array `around' the bignum
  to address from the C layer.
 \Remarkslabel
  \sysdep{constant}


\endcom

\begincncom[Internal]{+bignum-header-size+}

\Valuelabel
\begin{CompactCode}
(or 12 0)
\end{CompactCode}

\Purposelabel
 Size of \lw\ bignum objects header information in bytes.
\Remarkslabel
 \sysdep{constant}


\endcom

\beginfncom[Internal]{bootstrap-allocate-instance}

\Syntaxlabel
\Defun {bootstrap-allocate-instance} {{\funarg{p-objid-class-description}} {\funarg{number-of-slots}} {\opt} {\funarg{p-heap}}}


 Allocate a CLOS instance at formatting of the root.


\endcom

\beginfncom[Internal]{bootstrap-allocate-structure}

\Syntaxlabel
\Defun {bootstrap-allocate-structure} {{\funarg{number-of-slots}} {\opt} {\funarg{p-heap}}}


 Allocate a structure at formatting of the root.


\endcom

\beginfncom[Internal]{bootstrap-clear-cache}

\Syntaxlabel
\Defun {bootstrap-clear-cache} {}


 Like \fcite{clear-cache}\ plus the list of base objects is deleted.


\endcom

\beginfncom[Internal]{bootstrap-load-phase-1-structure-description}

\Syntaxlabel
\Defun {bootstrap-load-phase-1-structure-description} {{\funarg{p-objid}} {\funarg{t-into-descr}} {\opt} {\funarg{depth}} {\funarg{p-heap}}}


\Argumentslabel
 \isanobjid{\funarg{p-objid}}
 \isa{\funarg{t-into-descr}}
      {a structure description}
\Purposelabel
 Begins loading \funarg{t-into-descr}\ `by hand', i.e.\ by calling
 low-level reader functions. In phase~1, only objects of immediate or simple
 classes (fixnum and string) can be read from the \sh.
 The transient structure-slot-descriptions referenced by
 \funarg{t-into-descr}\ are allocated and partly filled.
\Remarkslabel
 It is an error to call this function being not in the bootstrap phase.
\Seealsolabel
 Section \fcite{bootstrap ...}.


\endcom

\beginfncom[Internal]{bootstrap-load-phase-2-structure-description}

\Syntaxlabel
\Defun {bootstrap-load-phase-2-structure-description} {{\funarg{p-objid}} {\funarg{t-into-descr}} {\opt} {\funarg{depth}} {\funarg{p-heap}}}


\Argumentslabel
 \isanobjid{\funarg{p-objid}}
 \isa{\funarg{t-into-descr}}
      {a structure description}
\Purposelabel
 Now the `normal' functions read the structure description slots
 not read in phase~1 into \funarg{t-into-descr}.
 The transient structure-slot-descriptions referenced by
 \funarg{t-into-descr}\ are read from the \sh.
\Remarkslabel
 It is an error to call this function being not in the bootstrap phase.
\Seealsolabel
 Section \fcite{bootstrap ...}.


\endcom

\beginfncom[Internal]{bootstrap-load-phase-3-class-description}

\Syntaxlabel
\Defun {bootstrap-load-phase-3-class-description} {{\funarg{p-objid}} {\funarg{t-into-descr}} {\opt} {\funarg{depth}} {\funarg{p-heap}}}


\Argumentslabel
 \isanobjid{\funarg{p-objid}}
 \isa{\funarg{t-into-descr}}
      {a class description}
\Purposelabel
 Begins loading \funarg{t-into-descr}\ `by hand', i.e.\ by calling
 low-level reader functions. In phase~3, only non-\clos\ objects
 can be read from the \sh.
 The transient slot-descriptions referenced by
 \funarg{t-into-descr}\ are allocated and partly filled.
\Remarkslabel
 It is an error to call this function being not in the bootstrap phase.
\Seealsolabel
 Section \fcite{bootstrap ...}.


\endcom

\beginfncom[Internal]{bootstrap-load-phase-4-class-description}

\Syntaxlabel
\Defun {bootstrap-load-phase-4-class-description} {{\funarg{p-objid}} {\funarg{t-into-descr}} {\opt} {\funarg{depth}} {\funarg{p-heap}}}


\Argumentslabel
 \isanobjid{\funarg{p-objid}}
 \isa{\funarg{t-into-descr}}
      {a structure description}
\Purposelabel
 Now the `normal' functions read the class description slots
 not read in phase~3 into \funarg{t-into-descr}.
 The transient slot-descriptions referenced by
 \funarg{t-into-descr}\ are read from the \sh.
\Remarkslabel
 It is an error to call this function being not in the bootstrap phase.
\Seealsolabel
 Section \fcite{bootstrap ...}.


\endcom

\beginfncom[Internal]{bootstrap-p-symbol}

\Syntaxlabel
\Defun {bootstrap-p-symbol} {{\funarg{p-objid}} {\opt} {\funarg{p-heap}}}


\Argumentslabel
 \isanobjid{p-objid}
\Purposelabel
 Loads a symbol during the bootstrap.
\Remarkslabel
 It is an error to call this function being not in the bootstrap phase.
\Seealsolabel
 Section \fcite{bootstrap ...}.


\endcom

\beginfncom[Internal]{bootstrap-store-phase-1-structure-description}

\Syntaxlabel
\Defun {bootstrap-store-phase-1-structure-description} {{\funarg{p-objid}} {\funarg{t-descr}} {\funarg{class-of-struct}} {\opt} {\funarg{depth}} {\funarg{p-heap}}}


\Argumentslabel
 \isanobjid{\funarg{p-objid}}
 \isa{\funarg{t-descr}}
      {a structure description}
 \isastrcls{\funarg{class-of-struct}}
\Purposelabel
 Fills the transient \funarg{t-descr}\ with a description of
 \funarg{class-of-struct}\ and begins storing
 \funarg{t-descr}\ `by hand', i.e.\ by calling low-level
 writer functions. In phase~1, only objects of immediate or simple
 classes (fixnum and string) can be stored to the \sh.
\Remarkslabel
 It is an error to call this function being not in the bootstrap phase.
\Seealsolabel
 Section \fcite{bootstrap ...}.


\endcom

\beginfncom[Internal]{bootstrap-store-phase-2-structure-description}

\Syntaxlabel
\Defun {bootstrap-store-phase-2-structure-description} {{\funarg{p-objid}} {\funarg{t-descr}} {\funarg{class-of-struct}} {\opt} {\funarg{depth}} {\funarg{p-heap}}}


\Argumentslabel
 \isanobjid{\funarg{p-objid}}
 \isa{\funarg{t-descr}}
      {a structure description}
 \isastrcls{\funarg{class-of-struct}}
\Purposelabel
 Stores the slots not stored in phase~1 of
 \funarg{t-descr}\ `by hand', i.e.\ by calling low-level writer
 functions. In phase~2, symbols may be stored to the \sh.
\Remarkslabel
 It is an error to call this function being not in the bootstrap phase.
\Seealsolabel
 Section \fcite{bootstrap ...}.


\endcom

\beginfncom[Internal]{bootstrap-store-phase-3-structure-description}

\Syntaxlabel
\Defun {bootstrap-store-phase-3-structure-description} {{\funarg{p-objid}} {\funarg{t-descr}} {\funarg{class-of-struct}} {\opt} {\funarg{depth}} {\funarg{p-heap}}}


\Argumentslabel
 \isanobjid{\funarg{p-objid}}
 \isa{\funarg{t-descr}}
      {a structure description}
 \isastrcls{\funarg{class-of-struct}}
\Purposelabel
 Now the `normal' functions save \funarg{t-descr}. In phase~3,
 all structure objects may be stored to the \sh.
\Remarkslabel
 It is an error to call this function being not in the bootstrap phase.
\Seealsolabel
 Section \fcite{bootstrap ...}.


\endcom

\beginfncom[Internal]{bootstrap-store-phase-4-class-description}

\Syntaxlabel
\Defun {bootstrap-store-phase-4-class-description} {{\funarg{p-objid}} {\funarg{t-descr}} {\funarg{the-class}} {\opt} {\funarg{depth}} {\funarg{p-heap}}}


\Argumentslabel
 \isanobjid{\funarg{p-objid}}
 \isa{\funarg{t-descr}}
      {a class description}
 \isacls{\funarg{the-class}}
\Purposelabel
 Fills the transient \funarg{t-descr}\ with a description of
 \funarg{the-class}\ and begins storing
 \funarg{t-descr}\ `by hand', i.e.\ by calling low-level
 writer functions. In phase~4, only non-\clos\ objects including
 structures can be stored to the \sh.
\Remarkslabel
 It is an error to call this function being not in the bootstrap phase.
\Seealsolabel
 Section \fcite{bootstrap ...}.


\endcom

\beginfncom[Internal]{bootstrap-store-phase-5-class-description}

\Syntaxlabel
\Defun {bootstrap-store-phase-5-class-description} {{\funarg{p-objid}} {\funarg{t-descr}} {\funarg{the-class}} {\opt} {\funarg{depth}} {\funarg{p-heap}}}


\Argumentslabel
 \isanobjid{\funarg{p-objid}}
 \isa{\funarg{t-descr}}
      {a class description}
 \isacls{\funarg{the-class}}
\Purposelabel
 In phase~5, all objects can be stored to the \sh.
\Remarkslabel
 It is an error to call this function being not in the bootstrap phase.
\Seealsolabel
 Section \fcite{bootstrap ...}.


\endcom

\beginclcom[Internal Structure]{btree-cache-entry}

\Purposelabel
 A structure used for cached BTree cache entries.
\Seealsolabel
 \Fcite{make-btree}, argument \keyarg{cached};
 \fcite{cached-btree}.


\Directslotslabel

\Defdslot {objid} {nil}


 The \objid\ of the cached data object.

\Defdslot {type-tag} {nil}


 The \typetag\ of the cached data object.

\Defdslot {object} {nil}


 The instance of \fcite{persistent-object}\ containing the \objid.

\Defdslot {datap} {nil\newline :type symbol}


 A flag if {\bf data} is a valid cached entry at all.

\Defdslot {data} {nil}


 The cached \cl\ data object.


\Classoptionslabel
\Defmethod{}{\tt}{:constructor make-btree-cache-entry (objid type-tag \&optional object datap data)}{}


\endcom

\begincncom[Internal]{+btree-mapper-origin->symbol+}

\Valuelabel
\begin{CompactCode}
`((,+seek-set+ ,@:set)
  (,+seek-current+ ,@:current)
  (,+seek-end+ ,@:end))
\end{CompactCode}

\Purposelabel
 Internal constant.
 Mapping between symbols \lisp{:set}, \lisp{:current}\,
 \lisp{:end}\ and their \plob\ C level numeric BTree mapper origin
 companions {\bf +seek-set+}, {\bf +seek-current+}, {\bf +seek-end+}.
\Seealsolabel
  \Fcite{btree-mapper-seek}.


\endcom

\begingfcom[Internal]{btree-mapper-search-internal}

\Syntaxlabel
\Defgen {btree-mapper-search-internal} {{\funarg{p-mapper-objid}} {\funarg{p-btree-objid}} {\funarg{start-value}} {\funarg{start-type-tag}} {\funarg{compare-start}} {\funarg{end-value}} {\funarg{end-type-tag}} {\funarg{compare-end}} {\funarg{descending}} {\funarg{filter}} {\funarg{p-heap}}}


\Argumentslabel
\Purposelabel
 Internal used function for \fcite{btree-mapper-search}.
\Remarkslabel
\Seealsolabel
 \Fcite{btree-mapper-search}.


\Methodslabel

\flabel{\protect\mtd}{btree-mapper-search-internal (t t float t t float t t t t t)}{}
{\Defmeth {btree-mapper-search-internal} {{\funarg{p-mapper-objid}} {\funarg{p-btree-objid}} (\funarg{start-value}\ \ObjectWithRef{float}) {\funarg{start-type-tag}} {\funarg{compare-start}} (\funarg{end-value}\ \ObjectWithRef{float}) {\funarg{end-type-tag}} {\funarg{compare-end}} {\funarg{descending}} {\funarg{filter}} {\funarg{p-heap}}}}
%
% No behavior is specified for this method beyond that which is specified
% for the generic function.

\flabel{\protect\mtd}{btree-mapper-search-internal (t t integer t t integer t t t t t)}{}
{\Defmeth {btree-mapper-search-internal} {{\funarg{p-mapper-objid}} {\funarg{p-btree-objid}} (\funarg{start-value}\ \ObjectWithRef{integer}) {\funarg{start-type-tag}} {\funarg{compare-start}} (\funarg{end-value}\ \ObjectWithRef{integer}) {\funarg{end-type-tag}} {\funarg{compare-end}} {\funarg{descending}} {\funarg{filter}} {\funarg{p-heap}}}}
%
% No behavior is specified for this method beyond that which is specified
% for the generic function.

\flabel{\protect\mtd}{btree-mapper-search-internal (t t string t t string t t t t t)}{}
{\Defmeth {btree-mapper-search-internal} {{\funarg{p-mapper-objid}} {\funarg{p-btree-objid}} (\funarg{start-value}\ \ObjectWithRef{string}) {\funarg{start-type-tag}} {\funarg{compare-start}} (\funarg{end-value}\ \ObjectWithRef{string}) {\funarg{end-type-tag}} {\funarg{compare-end}} {\funarg{descending}} {\funarg{filter}} {\funarg{p-heap}}}}
%
% No behavior is specified for this method beyond that which is specified
% for the generic function.


\endcom

\begincncom[Internal]{+btree-test-mode->symbol+}

\Valuelabel
\begin{CompactCode}
`((,+eq+ ,@#'eq)
  (,+eq+ . eq)
  (,+eql+ ,@#'eql)
  (,+eql+ . eql)
  (,+equal+ ,@#'equal)
  (,+equal+ . equal))
\end{CompactCode}

\Purposelabel
 Internal constant.
 Mapping between symbols \lisp{eq}, \lisp{eql}, \lisp{equal}\ and their
 \plob\ C level numeric BTree test-mode companions {\bf +eq+},
 {\bf +eql+}, {\bf +equal+}.
\Seealsolabel
  \Fcite{btree-test}.


\endcom

\begincncom[Internal]{+c-int-type+}

\Valuelabel
\begin{CompactCode}
'(signed-byte 32)
\end{CompactCode}

\Purposelabel
LISP type declaration matching a C int.


\endcom

\beginpmcom[Internal]{*cache-numbers*}

\Initialvaluelabel
\begin{CompactCode}
nil
\end{CompactCode}

\Purposelabel
  A flag if numbers (i.e.\ single and double floats, bignums)
  should be cached. Not caching numbers will result
  in identical (in the sense of \lisp{eq}) numbers stored
  more than once in the persistent heap.


\endcom

\beginpmcom[Internal]{*cache-strings*}

\Initialvaluelabel
\begin{CompactCode}
t
\end{CompactCode}

\Purposelabel
  A flag if strings should be cached. Not caching strings will result
  in identical (in the sense of \lisp{eq}) strings stored
  more than once in the persistent heap.


\endcom

\beginclcom[Internal Structure]{cached-btree}

\Purposelabel
 A structure for representing persistent BTrees with an associated
 transient cache.
\Remarkslabel
 To create a cached persistent BTree, call \fcite{make-btree}\ with the
 \keyarg{cached}\ argument set to \nonnil.
\Seealsolabel
 \Fcite{make-btree};
 \fcite{persistent-btree}.


\Directsuperclasseslabel
\Defmethod{}{\tt}{\ObjectWithRef{persistent-btree}}{}


\Directslotslabel

\Defdslot {key->data-cache} {nil}


 A cache mapping a BTree key to its data item.
 This is a hash table created in \fcite{make-btree}\ with a test mode
 as given by the \keyarg{test}\ argument of {\bf make-btree};
 the hash table key is an \objid, the data is an instance of
 \fcite{btree-cache-entry}.


\Classoptionslabel
\Defmethod{}{\tt}{:constructor make-cached-btree (\&optional objid)}{}


\endcom

\beginclcom[Internal Structure]{cached-heap}

\Purposelabel
 A structure for cached persistent heaps.
\Remarkslabel
 Useful only for internal purposes; the only instance of
 \class{cached-heap}\ used is contained in variable
 {\bf *root-persistent-heap*}.
\Seealsolabel
 \Fcite{*root-persistent-heap*}.


\Directsuperclasseslabel
\Defmethod{}{\tt}{\ObjectWithRef{persistent-heap}}{}


\Directslotslabel

\Defdslot {objid->object-cache} {(make-hash-table :test (function eql) :size 100000 :rehash-size 2.0)}


 Cache containing all \cl\ objects seen so far.
 Key is an \objid, associated data is the transient \cl\ object
 representing the persistent object referenced by that \objid.
 Should be a hash table with `weak pointers' for both keys and values
 (but \lwcl\ does not offer this).

\Defdslot {object->objid-cache} {(make-hash-table :test (function eq) :size 100000 :rehash-size 2.0)}


 This is the inverse for {\bf objid->object-cache}. Should be
 a hash table with `weak pointers' for both keys and values (but
 \lwcl\ does not offer this).


\Classoptionslabel
\Defmethod{}{\tt}{:constructor make-cached-heap (\&optional objid)}{}


\endcom

\beginfncom[Internal]{call-structure-slot-description-writer}

\Syntaxlabel
\Defun {call-structure-slot-description-writer} {{\funarg{struct-descr}} {\funarg{slot-descr}} {\funarg{p-heap}} {\funarg{t-object}} {\funarg{new-value}}}


\Argumentslabel
 \isa{\funarg{struct-descr}}
      {a structure-description}
 \isa{\funarg{slot-descr}}
      {a structure-slot-description}
 \isa{\funarg{t-object}}
      {a transient structure object}
 \isanobject{\funarg{new-value}}
\Valueslabel
 \retarg{\funarg{new-value}}
\Purposelabel
 Write \funarg{new-value}\ into the slot of the structure class
 instance \funarg{t-object}\ described by
 \funarg{slot-descr}\ of structure class \funarg{struct-descr}.
\Seealsolabel
 \Fcite{structure-slot-description-writer}.


\endcom

\begingfcom[Internal]{canonicalize-class-options}

\Syntaxlabel
\Defgen {canonicalize-class-options} {{\funarg{prototype}} {\funarg{class-options}}}


 See \fcite{canonicalize-defclass-options}.


\Methodslabel

\flabel{\protect\mtd}{canonicalize-class-options :around (persistent-metaclass t)}{}
{\Defmetharound {canonicalize-class-options} {(\funarg{prototype}\ \ObjectWithRef{persistent-metaclass}) {\funarg{class-options}}}}
\lw\ signals an error on unknown class options;
 so this method removes any extra allowed options
 before calling the default method and returns the canonicalized extra
 options concatenated to the result of the default method.
 The extra allowed options are the value of the
 \fcite{+extra-class-options+}.


\endcom

\begingfcom[Internal]{canonicalize-defclass-slot}

\Syntaxlabel
\Defgen {canonicalize-defclass-slot} {{\funarg{prototype}} {\funarg{slot}}}


 See \fcite{canonicalize-direct-slot}.


\Methodslabel

\flabel{\protect\mtd}{canonicalize-defclass-slot :around (persistent-metaclass t)}{}
{\Defmetharound {canonicalize-defclass-slot} {(\funarg{prototype}\ \ObjectWithRef{persistent-metaclass}) {\funarg{slot}}}}
\lw\ signals an error on unknown slot options;
 so this method removes any extra allowed options
 before calling the default method and returns the canonicalized extra
 options concatenated to the result of the default method.
 The extra allowed options are the value of the
 \fcite{+extra-slot-options+}.


\endcom

\beginfncom[Internal]{canonicalize-expecting-class}

\Syntaxlabel
\Defun {canonicalize-expecting-class} {{\funarg{expecting-class}}}


\Argumentslabel
 \isanobjid{\funarg{expecting-class}}
\Purposelabel
 Returns a canonicalized \funarg{expecting-class}.


\endcom

\beginfncom[Internal]{canonicalize-expecting-type-tag}

\Syntaxlabel
\Defun {canonicalize-expecting-type-tag} {{\funarg{expecting-type-tag}}}


\Argumentslabel
 \isatypetag{\funarg{expecting-type-tag}}
\Purposelabel
 Returns a canonicalized \funarg{expecting-type-tag}.


\endcom

\begincncom[Internal]{+cant-boundp-transient-slot-error-prompt+}

\Valuelabel
\begin{CompactCode}
"Cannot boundp transient slot ~S for ~A of class ~S."
\end{CompactCode}

\Purposelabel
Prompt which is shown in the error message concerning
 non-boundp'able slots.


\endcom

\begincncom[Internal]{+cant-find-slot-error-prompt+}

\Valuelabel
\begin{CompactCode}
"Cannot find slot ~S for ~A of class ~S."
\end{CompactCode}

\Purposelabel
Prompt which is shown in the error message concerning non-found slots.


\endcom

\begincncom[Internal]{+cant-load-transient-slot-error-prompt+}

\Valuelabel
\begin{CompactCode}
"Cannot load transient slot ~S for ~A of class ~S."
\end{CompactCode}

\Purposelabel
Prompt which is shown in the error message concerning non-loadable slots.


\endcom

\begincncom[Internal]{+cant-makunbound-transient-slot-error-prompt+}

\Valuelabel
\begin{CompactCode}
"Cannot makunbound transient slot ~S for ~A of class ~S."
\end{CompactCode}

\Purposelabel
Prompt which is shown in the error message concerning
 non-makunbound'able slots.


\endcom

\begincncom[Internal]{+cant-set-slot-to-immediate+}

\Valuelabel
\begin{CompactCode}
"Cannot set slot ~A of ~A to immediate objid ~A"
\end{CompactCode}

\Purposelabel
Prompt in warnings for slots with \lisp{:extent}\ \lisp{:objid},
 for which a non-immediate object is loaded. A non-immediate object
 cannot be represented as a short \objid.


\endcom

\begincncom[Internal]{+cant-setf-transient-slot-error-prompt+}

\Valuelabel
\begin{CompactCode}
"Cannot setf transient slot ~S for ~A of class ~S to value ~A."
\end{CompactCode}

\Purposelabel
Prompt which is shown in the error message concerning non-setf'able slots.


\endcom

\beginmccom[Internal]{catch-errors}

\Syntaxlabel
\Defmac {catch-errors} {{\body} {\funarg{forms}}}


\Argumentslabel
 \isa{\funarg{forms}}
      {an implicit \lisp{progn}\ expression
       with calls to \plob\ C level functions}
\Valueslabel
 Returns the result of evaluating \funarg{forms}.
\Purposelabel
 Evaluates \funarg{forms}\ in an environment which catches all errors
 which might occure in the \plob\ C level functions; when an error is
 caught, control can be transferred out of the C functions back to
 the \cl\ system debugger.
\Remarkslabel
 The errors caught are raised from the C level using the C macros
 \lisp{CERROR}\ and \lisp{ERROR}. A situation which leads to raising
 an error from the C level is shown in figure~\ref{tab:backtrace}.
 \begin{figure}[htbp]\centering%
 \begin{tabular}{|c|l|p{10cm}|}%
 \hline
 \tabularheader{Level}
	&\tabularheader{Environment}
		&\tabularheader{Description}\\
 \hline\hline
 1 
  & LISP
   & This is in the LISP toplevel processing of {\bf catch-errors};
     here the \funarg{forms}\ are evaluated which call the C level
     functions.\\
 \hline
 2
  & C
   & During the processing of the C function called, an error is raised
     by the C macro \lisp{ERROR}.\\
 \hline
 3
 & LISP
  & The C macro \lisp{ERROR}\ transfers control to the error handler
    {\bf sh-error-callback}, which  raises immediately an error condition
    of class \class{postore-error}. This error condition is caught
    by {\bf catch-errors} on level~1, i.e.\ the process control is
g    thrown back to level~1.\\
 \hline
 \end{tabular}%
 \caption{\protect\clogo\ code error handling}%
 \label{tab:backtrace}%
 \end{figure}%
 The handling done by the C macro \lisp{CERROR}\ is very similar;
 the difference is that the process control is transferred from
 level~3 to level~1 only when the user requests so, because the
 transfer of control to level~1 makes a continuation of the C
 function impossible.

 The above error handling is done especially for \lw\ to enable
 a useful stack backtrace: When the \cl\ debugger is called
 already in level~3, the stack backtrace looks very poor, since it
 shows only the call to {\bf sh-error-callback} but not the calls
 leading to and done in level~1, i.e.\ the debugger cannot `see'
 the calls which happened before level~3.

 This error handling is only done for `soft' errors raised from the
 C level by using the C macros \lisp{CERROR}\ and
 \lisp{ERROR}. `Hard' errors like de-refencing an invalid pointer
 in the C level often crash \lw, sometimes without any further
 announcements. If \lw\ did not crash but shows something like
 \begin{quote}\tt
 Signal 10: Bus error
 \end{quote}
 in the debugger, try to close \plob\ by calling
 \fcite{close-heap}, leave and restart \lw.
 An error handling for `hard' errors could only be done by integrating
 a complete C debugger into the C code, since \lw\ cannot debug C code.

 \note\ Uncontrolled writing into the binary representation of
 \cl\ objects (not done by \plob) normally crashes the system
 at the next garbage collection.
\Seealsolabel
 \Fcite{sh-cerror-callback};
 \fcite{sh-error-callback}.


\endcom

\beginfncom[Internal]{check-version-numbers}

\Syntaxlabel
\Defun {check-version-numbers} {{\opt} {\funarg{p-heap}}}


\Purposelabel
 Check if there is a version number mismatch between
 \plobwoexcl's layers.
\Valueslabel
  Returns the number of version number mismatches between \plobwoexcl's
  layers.


\endcom

\beginvrcom[Internal]{*class->constructor-table*}

\Initialvaluelabel
\begin{CompactCode}
(make-hash-table :test #'eq)
\end{CompactCode}

\Purposelabel
 A variable for mapping structure classes to constructor
 symbols.
\Seealsolabel
 \Fcite{(setf class-constructor)};
 \fcite{class-constructor}.


\endcom

\beginvrcom[Internal]{*class->dependent-table*}

\Initialvaluelabel
\begin{CompactCode}
(make-hash-table :test #'eq)
\end{CompactCode}

\Purposelabel
 A variable for mapping structure classes to dependent
 symbols.
\Seealsolabel
 \Fcite{(setf class-dependent)};
 \fcite{class-dependent}.


\endcom

\beginvrcom[Internal]{*class->extent-table*}

\Initialvaluelabel
\begin{CompactCode}
(make-hash-table :test #'eq)
\end{CompactCode}

\Purposelabel
 A variable used for mapping \clsmo{}s to their extents.
\Seealsolabel
 \Fcite{(setf class-extent)};
 \fcite{class-extent}.


\endcom

\beginvrcom[Internal]{*class->mismatch-table*}

\Initialvaluelabel
\begin{CompactCode}
(make-hash-table :test #'eq)
\end{CompactCode}

\Purposelabel
 A variable used for mapping \clsmo{}s to their
 mismatch marker.
\Seealsolabel
 \Fcite{(setf mismatch-p)};
 \fcite{mismatch-p}.


\endcom

\beginvrcom[Internal]{*class->schema-evolution-table*}

\Initialvaluelabel
\begin{CompactCode}
(make-hash-table :test #'eq)
\end{CompactCode}

\Purposelabel
 A variable used for mapping \clsmo{}s to their
 schema evolution.
\Seealsolabel
 \Fcite{(setf schema-evolution)};
 \fcite{schema-evolution}.


\endcom

\beginvrcom[Internal]{*class->slot-deferred-table*}

\Initialvaluelabel
\begin{CompactCode}
(make-hash-table :test #'eq)
\end{CompactCode}

\Purposelabel
 A variable used for mapping \clsmo{}s to slot deferred options.
\Seealsolabel
 \Fcite{(setf slot-deferred)};
 \fcite{slot-deferred}.


\endcom

\beginvrcom[Internal]{*class->slot-extent-table*}

\Initialvaluelabel
\begin{CompactCode}
(make-hash-table :test #'eq)
\end{CompactCode}

\Purposelabel
 A variable used for mapping \clsmo{}s to slot extents.
\Seealsolabel
 \Fcite{(setf slot-extent)};
 \fcite{slot-extent}.


\endcom

\beginvrcom[Internal]{*class->slot-initarg-table*}

\Initialvaluelabel
\begin{CompactCode}
(make-hash-table :test #'eq)
\end{CompactCode}

\Purposelabel
 A variable used for mapping \clsmo{}s to slot initialization
 arguments.
\Seealsolabel
 \Fcite{(setf slot-initarg)};
 \fcite{slot-initarg}.


\endcom

\beginvrcom[Internal]{*class->slot-location-table*}

\Initialvaluelabel
\begin{CompactCode}
(make-hash-table :test #'eq)
\end{CompactCode}

\Purposelabel
 A variable used for mapping \clsmo{}s to slot location options.
\Seealsolabel
 \Fcite{(setf slot-location)};
 \fcite{slot-location}.


\endcom

\beginvrcom[Internal]{*class-and-slot->reader-table*}

\Initialvaluelabel
\begin{CompactCode}
(make-hash-table :test #'equal)
\end{CompactCode}

\Purposelabel
 A hash table mapping a cons of a structure class name and a slot
 name to a system-generated structure slot reader function.
 Used in \fcite{establish-all-slot-loaders}.
\Seealsolabel
 \Fcite{*reader->class-and-slot-table*}.


\endcom

\beginvrcom[Internal]{*class-description*}

\Initialvaluelabel
\begin{CompactCode}
nil
\end{CompactCode}

\Purposelabel
 Contains a persistent object of
 \fcite{class-description}\ describing the
 \fcite{class-description}.
\Seealsolabel
 \Fcite{*class-description-objid*}.


\endcom

\begincncom[Internal]{+class-description-class+}

\Valuelabel
\begin{CompactCode}
(let ((the-class (find-class 'class-description nil)))
  (if the-class
      the-class
    (ensure-class 'class-description :metaclass 'persistent-metaclass)))
\end{CompactCode}

\Purposelabel
The \clsmo\ of \fcite{class-description}.


\endcom

\begingfcom[Internal]{(setf class-description-constructor)}

\Syntaxlabel
\Defgen {(setf class-description-constructor)} {{\funarg{constructor}} {\funarg{class-description}}}


\Argumentslabel
 \isa{\funarg{constructor}}
      {a symbol}
 \isa{\funarg{class-description}}
      {a structure-description or a class-description}
\Purposelabel
 Set the constructor of
 \funarg{class-description}\ to
 \funarg{constructor}.
\Seealsolabel
 Slot {\bf p-constructor} of
 \fcite{structure-description}\ resp.\ \fcite{class-description}.


\Methodslabel

\flabel{\protect\mtd}{(setf class-description-constructor) (t structure-description)}{}
{\Defmeth {(setf class-description-constructor)} {{\funarg{constructor}} (\funarg{class-description}\ \ObjectWithRef{structure-description})}}
Calls to this method are trapped to the system-generated
 structure writer function
 {\bf (setf structure-description-p-constructor)}; see also
 \fcite{structure-description}.


\endcom

\begingfcom[Internal]{(setf class-description-dependent)}

\Syntaxlabel
\Defgen {(setf class-description-dependent)} {{\funarg{dependent}} {\funarg{class-description}}}

\IfFLabelExists{(setf plob::class-description-dependent)}
{\SeeAt\ \fcite{(setf plob::class-description-dependent)}.}
{\message{^^JUndocumented generic function (setf plob::class-description-dependent).^^J}
\nodefgeneric}


\Methodslabel

\flabel{\protect\mtd}{(setf class-description-dependent) (t structure-description)}{}
{\Defmeth {(setf class-description-dependent)} {{\funarg{dependent}} (\funarg{class-description}\ \ObjectWithRef{structure-description})}}
Calls to this method are trapped to the system-generated
 structure writer function
 {\bf (setf structure-description-p-dependent)}; see also
 \fcite{structure-description}.


\endcom

\begingfcom[Internal]{class-description-equal-p}

\Syntaxlabel
\Defgen {class-description-equal-p} {{\funarg{t-class-descr}} {\funarg{p-class-descr}} {\opt} {\funarg{verbose}}}


\Argumentslabel
 \isa{\funarg{t-class-descr}\ resp.\ \funarg{p-class-descr}}
      {a class description}
\Purposelabel
 Returns \nonnil\ iff the (transient) class description
 \funarg{t-class-descr}\ and the (persistent) class description
 \funarg{p-class-descr}\ are \lisp{equal}, \lispnil\ otherwise.


\Methodslabel

\flabel{\protect\mtd}{class-description-equal-p (class-description class-description)}{}
{\Defmeth {class-description-equal-p} {(\funarg{t-class-descr}\ \ObjectWithRef{class-description}) (\funarg{p-class-descr}\ \ObjectWithRef{class-description}) {\opt} {\funarg{verbose}}}}
%
% No behavior is specified for this method beyond that which is specified
% for the generic function.

\flabel{\protect\mtd}{class-description-equal-p (t t)}{}
{\Defmeth {class-description-equal-p} {{\funarg{t-class-descr}} {\funarg{p-class-descr}} {\opt} {\funarg{verbose}}}}
%
% No behavior is specified for this method beyond that which is specified
% for the generic function.


\endcom

\begingfcom[Internal]{class-description-name->slot-cache}

\Syntaxlabel
\Defgen {class-description-name->slot-cache} {{\funarg{class-description}}}


\Argumentslabel
 \isa{\funarg{class-description}}
      {a structure-description or a class-description}
\Purposelabel
 Return the slot name to slot description cache of
 \funarg{class-description}.
\Seealsolabel
 Slot {\bf p-name->slot-cache} of
 \fcite{structure-description}\ resp.\ \fcite{class-description}.


\Methodslabel

\flabel{\protect\mtd}{class-description-name->slot-cache (structure-description)}{}
{\Defmeth {class-description-name->slot-cache} {(\funarg{class-description}\ \ObjectWithRef{structure-description})}}
Calls to this method are trapped to the system-generated
 structure reader function
 {\bf structure-description-t-name->slot-cache}; see also
 \fcite{structure-description}.


\endcom

\begingfcom[Internal]{(setf class-description-name->slot-cache)}

\Syntaxlabel
\Defgen {(setf class-description-name->slot-cache)} {{\funarg{name->slot-cache}} {\funarg{class-description}}}


\Argumentslabel
 \isa{\funarg{name->slot-cache}}
      {a cache, i.e.\ a hash-table}
 \isa{\funarg{class-description}}
      {a structure-description or a class-description}
\Purposelabel
 Set the name->slot-cache of
 \funarg{class-description}\ to
 \funarg{name->slot-cache}.
\Seealsolabel
 Slot {\bf p-name->slot-cache} of
 \fcite{structure-description}\ resp.\ \fcite{class-description}.


\Methodslabel

\flabel{\protect\mtd}{(setf class-description-name->slot-cache) (t structure-description)}{}
{\Defmeth {(setf class-description-name->slot-cache)} {{\funarg{cache}} (\funarg{class-description}\ \ObjectWithRef{structure-description})}}
Calls to this method are trapped to the system-generated
 structure writer function
 {\bf (setf structure-description-t-name->slot-cache)}; see also
 \fcite{structure-description}.


\endcom

\beginvrcom[Internal]{*class-description-objid*}

\Initialvaluelabel
\begin{CompactCode}
nil
\end{CompactCode}

\Purposelabel
 Contains the \objid\ of the value of the variable
 {\bf *class-description*}.
\Seealsolabel
 \Fcite{*class-description*}.


\endcom

\begingfcom[Internal]{class-description-of}

\Syntaxlabel
\Defgen {class-description-of} {{\funarg{class}}}


\Argumentslabel
 \isacls{\funarg{class}}
\Purposelabel
 Return the class description of \funarg{class}.
\Seealsolabel
 \Fcite{structure-description};
 \fcite{class-description}.


\Methodslabel

\flabel{\protect\mtd}{class-description-of :around (persistent-metaclass)}{}
{\Defmetharound {class-description-of} {(\funarg{the-class}\ \ObjectWithRef{persistent-metaclass})}}

 Reads the class-description from the slot {\bf t-class-description}
 of \funarg{the-class};
 if the returned value is \lispnil, the class description is loaded
 and written into the slot {\bf t-class-description}.

\flabel{\protect\mtd}{class-description-of (class)}{}
{\Defmeth {class-description-of} {(\funarg{the-class}\ \ObjectWithRef{class})}}
Trapped to \fcite{p-find-class-description}.


\endcom

\begingfcom[Internal]{(setf class-description-of)}

\Syntaxlabel
\Defgen {(setf class-description-of)} {{\funarg{class-description}} {\funarg{class}}}


\Argumentslabel
 \isa{\funarg{class-description}}
      {a structure-description or a class-description}
 \isacls{\funarg{class}}
\Purposelabel
 Set the class-description of \funarg{class}\ to
 \funarg{class-description}.
\Seealsolabel
 \Fcite{structure-description};
 \fcite{class-description}.


\Methodslabel

\flabel{\protect\mtd}{(setf class-description-of) (t class)}{}
{\Defmeth {(setf class-description-of)} {{\funarg{class-description}} (\funarg{the-class}\ \ObjectWithRef{class})}}
Does nothing.


\endcom

\begincncom[Internal]{+clos-slot-extents+}

\Valuelabel
\begin{CompactCode}
'(:transient :cached)
\end{CompactCode}

\Purposelabel
 List with allowed slot extents for non-\plob\ \clos\ classes,
 i.e.\ for \clos\ classes without a
 \lisp{(:metaclass persistent-metaclass)}\ class option.
\Seealsolabel
 \Fcite{(setf slot-extent)};
 \fcite{+plob-slot-extents+};
 \fcite{+structure-slot-extents+}.


\endcom

\beginfncom[Internal]{close-objid-buffer}

\Syntaxlabel
\Defun {close-objid-buffer} {{\funarg{objid-buffer}}}

Close an \objid\ buffer.
\Seealsolabel
  \Fcite{objid-buffer}


\endcom

\begingfcom[Internal]{clrindex}

\Syntaxlabel
\Defgen {clrindex} {{\funarg{the-table}} {\opt} {\funarg{p-heap}}}


\Argumentslabel
 \isaidxtable{\funarg{the-table}}
\Purposelabel
 \idxadmfn:
 Delete all keys (i.e.\ slot values) contained in \funarg{the-table}.
\Seealsolabel
 Section \fcite{index ...}.


\Methodslabel

\flabel{\protect\mtd}{clrindex (persistent-btree)}{}
{\Defmeth {clrindex} {(\funarg{the-table}\ \ObjectWithRef{persistent-btree}) {\opt} {\funarg{p-heap}}}}
Trapped to \fcite{clrbtree}.


\endcom

\begingfcom[Internal]{compile-description}

\Syntaxlabel
\Defgen {compile-description} {{\funarg{class-descr}}}


\Purposelabel
 Compile the \funarg{class-descr}\ into the current transient
 \cl\ environment.


\Methodslabel

\flabel{\protect\mtd}{compile-description (class-description)}{}
{\Defmeth {compile-description} {(\funarg{class-descr}\ \ObjectWithRef{class-description})}}
%
% No behavior is specified for this method beyond that which is specified
% for the generic function.

\flabel{\protect\mtd}{compile-description (structure-description)}{}
{\Defmeth {compile-description} {(\funarg{class-descr}\ \ObjectWithRef{structure-description})}}
%
% No behavior is specified for this method beyond that which is specified
% for the generic function.


\endcom

\beginfncom[Internal]{compile-silent}

\Syntaxlabel
\Defun {compile-silent} {{\funarg{name}} {\opt} {\funarg{definition}}}


\Purposelabel
 Compile \funarg{name}\ with optional \funarg{definition}\ without
 writing any annoying messages to \lisp{*standard-ouput*}.
\Seealsolabel
 \Fcite{compile}.


\endcom

\beginfncom[Internal]{compute-objid-buffer-size}

\Syntaxlabel
\Defun {compute-objid-buffer-size} {{\funarg{suggested-size}}}

Compute an optimal size for an \objid\ buffer.
\Seealsolabel
  \Fcite{objid-buffer}


\endcom

\beginfncom[Internal]{copy-structure-description}

\Syntaxlabel
\Defun {copy-structure-description} {{\funarg{original}}}


\Argumentslabel
 \isa{\funarg{original}}
      {a structure-description}
\Purposelabel
 Returns a copy of \funarg{original}.
\Seealsolabel
 \Fcite{structure-description}.


\endcom

\beginvrcom[Internal]{*data-vector-array-table*}

\Initialvaluelabel
\begin{CompactCode}
(make-hash-table)
\end{CompactCode}

\Purposelabel
A variable mapping the data vector of an array to
 the array (which uses the data vector for holding its elements).


\endcom

\beginpmcom[Internal]{*default-clos-schema-evolution*}

\Initialvaluelabel
\begin{CompactCode}
:write-back
\end{CompactCode}

\Purposelabel
 The default schema evolution to use for
 \clos\ objects.
\Seealsolabel
 \Fcite{(setf schema-evolution)};
 \fcite{schema-evolution}.


\endcom

\beginpmcom[Internal]{*default-clos-slot-extent*}

\Initialvaluelabel
\begin{CompactCode}
:cached
\end{CompactCode}

\Purposelabel
 The default extent
 for slots of \clos\ objects whose class object was created by a
 \lisp{defclass}-statement without a
 \lisp{(:metaclass persistent-metaclass)}\ class option,
 i.e.\ for \clos\ objects without direct \plob\ support.
 These are e.g.\ always all classes created before \plob\ was started,
 like all system-defined classes etc.
\Seealsolabel
 \Fcite{(setf slot-extent)};
 \fcite{slot-extent}.


\endcom

\beginpmcom[Internal]{*default-database-url*}

\Initialvaluelabel
\begin{CompactCode}
"tcp://localhost/database"
\end{CompactCode}

\Purposelabel
 The URL naming the default database. The actual database is found
 in \fcite{*database-url*}.
\Seealsolabel
  \Fcite{*database-url*}.


\endcom

\beginpmcom[Internal]{*default-depth*}

\Initialvaluelabel
\begin{CompactCode}
:flat
\end{CompactCode}

\Purposelabel
 Default depth used for storing and loading of objects.
\Seealsolabel
 \Fcite{store-object}, \fcite{load-object}.


\endcom

\beginpmcom[Internal]{*default-plob-slot-extent*}

\Initialvaluelabel
\begin{CompactCode}
:cached-write-through
\end{CompactCode}

\Purposelabel
 The default extent
 for slots of \clos\ objects whose class object was created by a
 \lisp{defclass}-statement with a
 \lisp{(:metaclass persistent-metaclass)} class option,
 i.e.\ for \clos\ objects with direct \plob\ support.
\Seealsolabel
 \Fcite{(setf slot-extent)};
 \fcite{slot-extent}.


\endcom

\beginpmcom[Internal]{*default-structure-schema-evolution*}

\Initialvaluelabel
\begin{CompactCode}
:write-back-deny-identity-change
\end{CompactCode}

\Purposelabel
 The default schema evolution to use for
 \cl\ \lisp{defstruct}\ objects.
\Seealsolabel
 \Fcite{(setf schema-evolution)};
 \fcite{schema-evolution}.


\endcom

\beginpmcom[Internal]{*default-structure-slot-extent*}

\Initialvaluelabel
\begin{CompactCode}
:cached-demand-load
\end{CompactCode}

\Purposelabel
 The default extent for slots of \cl\ \lisp{defstruct}\ objects.
\Seealsolabel
 \Fcite{(setf slot-extent)};
 \fcite{slot-extent}.


\endcom

\beginclcom[Internal]{direct-slot-description}

\Purposelabel
 A transient class representing persistent direct slot descriptions.
 In the sense of \clos, this class corresponds roughly to the
 \std\ \sltmc\ \class{standard-direct-slot-definition}.
\Remarkslabel
 \basecls{direct-slot-description}


\Directsuperclasseslabel
\Defmethod{}{\tt}{(\ObjectWithRef{slot-description})}{}


\Directslotslabel

\Defdslot {p-readers} {:accessor slot-description-readers\newline :reader slot-definition-readers\newline :initform nil\newline :location +slot-description-location-readers+}


 A vector of slot reader function symbols;
 comparable with the returned value from
 \fcite{slot-definition-readers}.

\Defdslot {p-writers} {:accessor slot-description-writers\newline :reader slot-definition-writers\newline :initform nil\newline :location +slot-description-location-writers+}


 A vector of slot writer function symbols;
 comparable with the returned value from
 \fcite{slot-definition-writers}.


\Metaclasslabel
\Defmethod{}{\tt}{\ObjectWithRef{persistent-metaclass}}{}


\Classoptionslabel
\Defmethod{}{\tt}{:dependent :read\newline :extent :cached\newline :schema-evolution :no-evolution}{}


\endcom

\beginvrcom[Internal]{*direct-slot-description*}

\Initialvaluelabel
\begin{CompactCode}
nil
\end{CompactCode}

\Purposelabel
 Contains a persistent object of
 \fcite{class-description}\ describing the
 \fcite{direct-slot-description}.
\Seealsolabel
 \Fcite{*direct-slot-description-objid*}.


\endcom

\beginvrcom[Internal]{*direct-slot-description-objid*}

\Initialvaluelabel
\begin{CompactCode}
nil
\end{CompactCode}

\Purposelabel
 Contains the \objid\ of the value of the variable
 {\bf *direct-slot-description*}.
\Seealsolabel
 \Fcite{*direct-slot-description*}.


\endcom

\beginvrcom[Internal]{*dynamic-allocated-int-vectors*}

\Initialvaluelabel
\begin{CompactCode}
nil
\end{CompactCode}

\Purposelabel
List containing all dynamic allocated [unsigned] int vectors so far.


\endcom

\beginclcom[Internal]{effective-slot-description}

\Purposelabel
 A transient class representing persistent effective slot descriptions.
 In the sense of \clos, this class corresponds roughly to the
 \std\ \sltmc\ \class{standard-effective-slot-definition}.
\Remarkslabel
 \basecls{effective-slot-description}


\Directsuperclasseslabel
\Defmethod{}{\tt}{(\ObjectWithRef{slot-description})}{}


\Directslotslabel

\Defdslot {p-location} {:accessor slot-description-location\newline :reader slot-definition-location\newline :initform nil\newline :location +slot-description-location-location+}


 The location of the slot; comparable with the returned value from
 \fcite{slot-definition-location}.

 For persistent slots without an \lisp{:allocation :class}, the
 {\bf location} is the postion of the slot in the persistent
 object.

 For persistent slots with an \lisp{:allocation :class}, the
 {\bf location} contains a persistent cons cell whose car
 is a symbol naming the slot (only for documention purpose) and
 whose cdr holds the slot value. This cons cell is inherited
 to subclasses; the additional indirection assures that by accessing
 the cdr of the cell all classes share the same (i.e.\ \lisp{eq})
 value.


\Metaclasslabel
\Defmethod{}{\tt}{\ObjectWithRef{persistent-metaclass}}{}


\Classoptionslabel
\Defmethod{}{\tt}{:dependent :read\newline :extent :cached\newline :schema-evolution :no-evolution}{}


\endcom

\beginvrcom[Internal]{*effective-slot-description*}

\Initialvaluelabel
\begin{CompactCode}
nil
\end{CompactCode}

\Purposelabel
 Contains a persistent object of
 \fcite{class-description}\ describing the
 \fcite{effective-slot-description}.
\Seealsolabel
 \Fcite{*effective-slot-description-objid*}.


\endcom

\begincncom[Internal]{+effective-slot-description-class+}

\Valuelabel
\begin{CompactCode}
(find-class 'effective-slot-description)
\end{CompactCode}

\Purposelabel
The \clsmo\ of \fcite{effective-slot-description}.


\endcom

\beginvrcom[Internal]{*effective-slot-description-objid*}

\Initialvaluelabel
\begin{CompactCode}
nil
\end{CompactCode}

\Purposelabel
 Contains the \objid\ of the value of the variable
 {\bf *effective-slot-description*}.
\Seealsolabel
 \Fcite{*effective-slot-description*}.


\endcom

\beginfncom[Internal]{effective-url}

\Syntaxlabel
\Defun {effective-url} {{\opt} {\funarg{url}} {\funarg{default-url}}}


 Compute the effective URL to open.


\endcom

\begingfcom[Internal]{ensure-allocated-object}

\Syntaxlabel
\Defgen {ensure-allocated-object} {{\funarg{t-object}} {\opt} {\funarg{p-heap}}}


\Argumentslabel
 \isa{\funarg{t-object}}
      {a persistent object}
\Valueslabel
 Returns the numeric \objid\ of \funarg{t-object}.
\Purposelabel
 Check if \funarg{t-object}\ is allocated on the \sh;
 if not, do so.


\Methodslabel

\flabel{\protect\mtd}{ensure-allocated-object (class-description)}{}
{\Defmeth {ensure-allocated-object} {(\funarg{t-object}\ \ObjectWithRef{class-description}) {\opt} {\funarg{p-heap}}}}
%
% No behavior is specified for this method beyond that which is specified
% for the generic function.

\flabel{\protect\mtd}{ensure-allocated-object (structure-description)}{}
{\Defmeth {ensure-allocated-object} {(\funarg{t-object}\ \ObjectWithRef{structure-description}) {\opt} {\funarg{p-heap}}}}
%
% No behavior is specified for this method beyond that which is specified
% for the generic function.


\endcom

\beginfncom[Internal]{ensure-class-description}

\Syntaxlabel
\Defun {ensure-class-description} {{\funarg{name}} {\opt} {\funarg{depth}}}


\Argumentslabel
 \isa{\funarg{name}}
      {a symbol naming a class}
\Valueslabel
 Returns two values:
 \begin{enumerate}

 \item The actual class description of the class
  named \funarg{name}\ is returned as the first value.

 \item If the class description was subject to schema evolution,
  \nonnil\ is returned as the second value; \lispnil\ otherwise.

 \end{enumerate}

\Purposelabel
 Establish the class named \funarg{name}:
 \begin{itemize}

 \item When there was no class description named
  \funarg{name}\ found in the \sh\ class table, store the
  class description of the class named
  \funarg{name}\ to the \sh.

 \item When a class description named
  \funarg{name}\ was found in the \sh\ class table, check if there
  is a mismatch between the persistent class description and the
  current transient version of the class definition.
  If a mismatch is detected, resolve the mismatch by calling
  \fcite{handle-class-mismatch}. Do nothing if no mismatch
  was detected.

 \end{itemize}
\Seealsolabel
 \Fcite{p-find-class};
 \fcite{handle-class-mismatch};
 \fcite{ensure-structure-description}.


\endcom

\beginfncom[Internal]{ensure-process-cleanup}

\Syntaxlabel
\Defun {ensure-process-cleanup} {{\funarg{cleanup-form}} {\opt} {\funarg{process}}}


\Purposelabel
 Ensures that \funarg{cleanup-form}\ is executed when the
 \funarg{process}\ terminates.
\Seealsolabel
 \Fcite{ensure-process-cleanup}


\endcom

\beginfncom[Internal]{ensure-structure-description}

\Syntaxlabel
\Defun {ensure-structure-description} {{\funarg{name}} {\opt} {\funarg{depth}}}


\Argumentslabel
 \isa{\funarg{name}}
      {a symbol naming a structure class}
\Valueslabel
 Returns two values:
 \begin{enumerate}

 \item The actual structure-description of the structure class
  named \funarg{name}\ is returned as the first value.

 \item If the structure-description was subject to schema evolution,
  \nonnil\ is returned as the second value; \lispnil\ otherwise.

 \end{enumerate}
\Purposelabel
 Establish the structure class named \funarg{name}:
 \begin{itemize}

 \item When there was no structure-description named
  \funarg{name}\ found in the \sh\ class table, store the
  structure-description of the structure named
  \funarg{name}\ to the \sh.

 \item When a structure-description named
  \funarg{name}\ was found in the \sh\ class table, check if there
  is a mismatch between the persistent structure-description and the
  current transient version of the structure definition.
  If a mismatch is detected, resolve the mismatch by calling
  \fcite{handle-class-mismatch}. Do nothing if no mismatch
  was detected.

 \end{itemize}
\Seealsolabel
 \Fcite{p-find-class};
 \fcite{handle-class-mismatch};
 \fcite{ensure-class-description}.


\endcom

\beginfncom[Internal]{establish-all-slot-loaders}

\Syntaxlabel
\Defun {establish-all-slot-loaders} {{\funarg{struct-descr}} {\opt} {\funarg{depth}} {\funarg{p-heap}}}


\Purposelabel
 Replaces each system-generated structure slot reader function by a 
 \plob-generated slot reader function for each slot with an extent not
 \lisp{equal}\ to \lisp{:no-demand-load}.
\Remarkslabel
 The names of the
 system-generated slot reader functions are derived from
 \funarg{struct-descr}.
\Seealsolabel
 \Fcite{load-structure-slot};
 \fcite{structure-description}.


\endcom

\beginfncom[Internal]{external-to-internal-name}

\Syntaxlabel
\Defun {external-to-internal-name} {{\funarg{external-name}}}


\Purposelabel
 With \allegrocl\ version 5.0, a case sensitive mode has been introduced
 for reading symbol and package names. Since \plob\ uses uppercase for
 all names of persistent symbols and packages, a conversion is necessary
 between \emph{external} (that means, a name in the persistent namespace)
 and \emph{internal} (that means, a name in the transient namespace) names.
\Seealsolabel
 \Fcite{internal-to-external-name}


\endcom

\begincncom[Internal]{+extra-class-options+}

\Valuelabel
\begin{CompactCode}
'(:constructor :dependent :extent :schema-evolution)
\end{CompactCode}

\Purposelabel
 List of additional allowed \clos\ class options.
\Seealsolabel
 \Fcite{canonicalize-class-options :around (persistent-metaclass t)}.


\endcom

\begincncom[Internal]{+extra-slot-options+}

\Valuelabel
\begin{CompactCode}
'(:extent :deferred :index :location)
\end{CompactCode}

\Purposelabel
 List of additional allowed \clos\ slot options.
\Seealsolabel
 \Fcite{canonicalize-defclass-slot :around (persistent-metaclass t)}.


\endcom

\begingfcom[Internal]{fill-description}

\Syntaxlabel
\Defgen {fill-description} {{\funarg{the-class}} {\opt} {\funarg{t-descr}} {\funarg{p-heap}}}


\Argumentslabel
 \isacls{\funarg{the-class}}
 \isa{\funarg{t-descr}}
      {a class description}
\Valueslabel
 \retarg{\funarg{t-descr}}
\Purposelabel
 Stores a description of \funarg{the-class}\ to \funarg{t-descr};
 if \funarg{t-descr}\ is missing, the method returns a new created
 transient description object.
\Seealsolabel
 \Fcite{fill-slot-description}.


\Methodslabel

\flabel{\protect\mtd}{fill-description :around (t)}{}
{\Defmetharound {fill-description} {{\funarg{the-class}} {\opt} {\funarg{t-descr}} {\funarg{p-heap}}}}
Make sure that only a transient description will be filled.

\flabel{\protect\mtd}{fill-description (structure-class)}{}
{\Defmeth {fill-description} {(\funarg{the-class}\ \ObjectWithRef{structure-class}) {\opt} {\funarg{t-descr}} {\funarg{p-heap}}}}
%
% No behavior is specified for this method beyond that which is specified
% for the generic function.

\flabel{\protect\mtd}{fill-description (class)}{}
{\Defmeth {fill-description} {(\funarg{the-class}\ \ObjectWithRef{class}) {\opt} {\funarg{t-descr}} {\funarg{p-heap}}}}
%
% No behavior is specified for this method beyond that which is specified
% for the generic function.

\flabel{\protect\mtd}{fill-description (method)}{}
{\Defmeth {fill-description} {(\funarg{the-method}\ \ObjectWithRef{method}) {\opt} {\funarg{t-method-descr}} {\funarg{p-heap}}}}
%
% No behavior is specified for this method beyond that which is specified
% for the generic function.


\endcom

\beginfncom[Internal]{fill-persistent-slot-description}

\Syntaxlabel
\Defun {fill-persistent-slot-description} {{\funarg{slot-definition}} {\funarg{the-class}} {\funarg{t-slot-descr}}}


\Argumentslabel
 \isa{\funarg{slot-definition}}
      {an instance of [a subclass of]
       \class{persistent-direct-slot-definition}\ or
       \class{persistent-effective-slot-definition}}
 \isacls{\funarg{the-class}}
 \isa{\funarg{t-slot-descr}}
      {a slot description}
\Valueslabel
 \retarg{\funarg{t-slot-descr}}
\Purposelabel
 A workhorse for different methods of \fcite{fill-slot-description}.
\Seealsolabel
 \Fcite{fill-slot-description}.


\endcom

\begingfcom[Internal]{fill-slot-description}

\Syntaxlabel
\Defgen {fill-slot-description} {{\funarg{slot-definition}} {\funarg{the-class}} {\opt} {\funarg{t-slot-descr}} {\funarg{p-heap}}}


\Argumentslabel
 \isa{\funarg{slot-definition}}
      {a slot definition metaobject}
 \isacls{\funarg{the-class}}
 \isa{\funarg{t-slot-descr}}
      {a slot description}
\Valueslabel
 \retarg{\funarg{t-slot-descr}}
\Purposelabel
 Stores a description of slot \funarg{slot-definition}\ of class
 \funarg{the-class}\ to \funarg{t-slot-descr};
 if \funarg{t-slot-descr}\ is missing, the method returns a new
 created transient description object.
\Seealsolabel
 \Fcite{fill-description}.


\Methodslabel

\flabel{\protect\mtd}{fill-slot-description :around (t t)}{}
{\Defmetharound {fill-slot-description} {{\funarg{slot-definition}} {\funarg{the-class}} {\opt} {\funarg{t-slot-descr}} {\funarg{p-heap}}}}
Make sure that only a transient description will be filled.

\flabel{\protect\mtd}{fill-slot-description (direct-slot-definition t)}{}
{\Defmeth {fill-slot-description} {(\funarg{slot-definition}\ \ObjectWithRef{direct-slot-definition}) {\funarg{the-class}} {\opt} {\funarg{t-slot-descr}} {\funarg{p-heap}}}}
%
% No behavior is specified for this method beyond that which is specified
% for the generic function.

\flabel{\protect\mtd}{fill-slot-description (persistent-effective-slot-definition t)}{}
{\Defmeth {fill-slot-description} {(\funarg{slot-definition}\ \ObjectWithRef{persistent-effective-slot-definition}) {\funarg{the-class}} {\opt} {\funarg{t-slot-descr}} {\funarg{p-heap}}}}
%
% No behavior is specified for this method beyond that which is specified
% for the generic function.

\flabel{\protect\mtd}{fill-slot-description (effective-slot-definition t)}{}
{\Defmeth {fill-slot-description} {(\funarg{slot-definition}\ \ObjectWithRef{effective-slot-definition}) {\funarg{the-class}} {\opt} {\funarg{t-slot-descr}} {\funarg{p-heap}}}}
%
% No behavior is specified for this method beyond that which is specified
% for the generic function.

\flabel{\protect\mtd}{fill-slot-description (persistent-direct-slot-definition t)}{}
{\Defmeth {fill-slot-description} {(\funarg{slot-definition}\ \ObjectWithRef{persistent-direct-slot-definition}) {\funarg{the-class}} {\opt} {\funarg{t-slot-descr}} {\funarg{p-heap}}}}
%
% No behavior is specified for this method beyond that which is specified
% for the generic function.


\endcom

\beginfncom[Internal]{fill-slot-description-into}

\Syntaxlabel
\Defun {fill-slot-description-into} {{\funarg{slot-definition}} {\funarg{t-slot-descr}} {\funarg{the-class}} {\funarg{default-slot-extent}}}


\Argumentslabel
 \isa{\funarg{slot-definition}}
      {a slot definition metaobject}
 \isa{\funarg{t-slot-descr}}
      {a slot description}
 \isacls{\funarg{the-class}}
\Valueslabel
 \retarg{\funarg{t-slot-descr}}
\Purposelabel
 A workhorse for different methods of \fcite{fill-slot-description}.
\Seealsolabel
 \Fcite{fill-slot-description}.


\endcom

\beginfncom[Internal]{fill-transient-slot-description}

\Syntaxlabel
\Defun {fill-transient-slot-description} {{\funarg{slot-definition}} {\funarg{the-class}} {\funarg{t-slot-descr}}}


\Argumentslabel
 \isa{\funarg{slot-definition}}
      {an instance of [a superclass of]
       \class{standard-direct-slot-definition}\ or
       \class{standard-effective-slot-definition}}
 \isacls{\funarg{the-class}}
 \isa{\funarg{t-slot-descr}}
      {a slot description}
\Valueslabel
 \retarg{\funarg{t-slot-descr}}
\Purposelabel
 A workhorse for different methods of \fcite{fill-slot-description}.
\Seealsolabel
 \Fcite{fill-slot-description}.


\endcom

\begingfcom[Internal]{finalize-class-description}

\Syntaxlabel
\Defgen {finalize-class-description} {{\funarg{class-descr}}}


\Argumentslabel
 \isa{\funarg{class-descr}}
      {a class description}
\Purposelabel
 Finalize a class description. This finalization is done {\sl after}
 the \clos\ finalization done by \fcite{finalize-inheritance}.
\Seealsolabel
 Slot {\bf t-finalized-p} of \fcite{persistent-metaclass};
 \fcite{finalize-inheritance}.


\Methodslabel

\flabel{\protect\mtd}{finalize-class-description :around (class-description)}{}
{\Defmetharound {finalize-class-description} {(\funarg{class-descr}\ \ObjectWithRef{class-description})}}
%
% No behavior is specified for this method beyond that which is specified
% for the generic function.

\flabel{\protect\mtd}{finalize-class-description (class-description)}{}
{\Defmeth {finalize-class-description} {(\funarg{class-descr}\ \ObjectWithRef{class-description})}}
Patch-as-patch-can: Call \fcite{patch-class-metaobject}\ and
 \fcite{patch-class-methods}\ so that \lw\ does a slot allocation
 and access in the sense of \plob.


\endcom

\beginfncom[Internal]{find-bignum-size-in-bits}

\Syntaxlabel
\Defun {find-bignum-size-in-bits} {{\funarg{the-bignum}}}


\Argumentslabel
 \isa{\funarg{the-bignum}}{a bignum}
\Valueslabel
 Size of \funarg{the-bignum}\ in bits, being negative for a negative
 bignum and positive for a positive bignum.
\Purposelabel
 Calculates the size of \funarg{the-bignum}\ in bits.
\Remarkslabel
 \sysdep{function}

 The \allegrocl\ code is derived from an example sent to me
 by Duane Rettig \lisp{duane@Franz.COM}


\endcom

\beginfncom[Internal]{find-direct-slot}

\Syntaxlabel
\Defun {find-direct-slot} {{\funarg{slot-name}} {\funarg{the-class}}}


\Argumentslabel
 \isa{\funarg{slot-name}}
      {a symbol naming a direct slot of \funarg{the-class}}
 \isacls{\funarg{the-class}}
\Purposelabel
 Returns the direct slot definition metaobject of the slot
 named \funarg{slot-name}\ in \funarg{the-class}.
\Seealsolabel
 \Fcite{find-effective-slot}.


\endcom

\beginfncom[Internal]{find-effective-slot}

\Syntaxlabel
\Defun {find-effective-slot} {{\funarg{slot-name}} {\funarg{the-class}}}


\Argumentslabel
 \isa{\funarg{slot-name}}
      {a symbol naming an effective slot of \funarg{the-class}}
 \isacls{\funarg{the-class}}
\Purposelabel
 Returns the effective slot definition metaobject of the slot
 named \funarg{slot-name}\ in \funarg{the-class}.
\Remarkslabel
 The functions {\bf find-effective-slot},
 {\bf find-effective-slot-description} and
 {\bf find-slot-description} do almost the same; conclusion into
 a single function would be better.
\Seealsolabel
 \Fcite{find-direct-slot};
 \fcite{find-effective-slot-description};
 \fcite{find-effective-slot-description-by-objid};
 \fcite{find-slot-description}.


\endcom

\beginfncom[Internal]{find-effective-slot-description}

\Syntaxlabel
\Defun {find-effective-slot-description} {{\funarg{slot-or-name}} {\funarg{the-class}}}


 \Argumentslabel
  \isa{\funarg{slot-or-name}}
       {a slot or a symbol naming an effective slot of \funarg{the-class}}
  \isacls{\funarg{the-class}}
 \Purposelabel
  Returns the effective slot description object of the slot
  named \funarg{slot-or-name}\ in \funarg{the-class}.
 \Seealsolabel
  \Fcite{find-effective-slot};
  \fcite{find-effective-slot-description-by-objid};
  \fcite{find-slot-description}.


\endcom

\beginfncom[Internal]{find-effective-slot-description-by-objid}

\Syntaxlabel
\Defun {find-effective-slot-description-by-objid} {{\funarg{slot-name}} {\funarg{p-objid}} {\opt} {\funarg{depth}} {\funarg{p-heap}}}


\Argumentslabel
 \isa{\funarg{slot-name}}
      {a symbol naming an effective slot of the class of \funarg{p-objid}}
 \isanobjid{\funarg{p-objid}}
\Valueslabel
 Returns three values:
 \begin{enumerate}

 \item The \clsmo\ of the class of the persistent \clos\ instance
   referenced by \funarg{p-objid}\ is returned as first value.

 \item The effective-slot-description object of the slot
   named \funarg{slot-name}\ in the class of the persistent
   \clos\ instance referenced by \funarg{p-objid}\ is
   returned as second value.

  \item If a transient object associated to
   \funarg{p-objid}\ is found in the cache, this transient object
   is returned as third value, \lispnil\ otherwise.

 \end{enumerate}
\Purposelabel
 Search the slot named \funarg{slot-name}\ in the class of the
 persistent \clos\ instance referenced by \funarg{p-objid}.
\Seealsolabel
 \Fcite{find-effective-slot};
 \fcite{find-effective-slot-description};
 \fcite{find-slot-description}.


\endcom

\beginfncom[Internal]{find-nearest-built-in-class}

\Syntaxlabel
\Defun {find-nearest-built-in-class} {{\funarg{type-symbol}}}


\Argumentslabel
 \isa{\funarg{type-symbol}}
      {a \cl\ type specifier}
\Purposelabel
 Find the most specific built-in class for \funarg{type-symbol}.
\Exampleslabel
 \begin{lispcode}
(find-nearest-built-in-class '(unsigned-byte 8))
        ==> #<built-in-class integer 102733C0>
 \end{lispcode}


\endcom

\beginfncom[Internal]{find-slot-description}

\Syntaxlabel
\Defun {find-slot-description} {{\funarg{slot-descr}} {\funarg{struct-descr}}}


\Argumentslabel
 \isa{\funarg{slot-descr}}
      {a slot description of a slot of the structure class described by
       \funarg{struct-descr}}
 \isa{\funarg{struct-descr}}
      {a structure-description}
\Purposelabel
 Searches the effective-slot-description of a slot having the same name
 as the slot described by \funarg{slot-descr}\ in
 \funarg{struct-descr}.
\Seealsolabel
 \Fcite{find-effective-slot-description};
 \fcite{find-effective-slot-description-by-objid};
 \Fcite{find-effective-slot}.


\endcom

\beginfncom[Internal]{flag-word}

\Syntaxlabel
\Defun {flag-word} {{\opt} {\funarg{new-flag-word}}}


\Argumentslabel
 \isa{\funarg{new-flag-word}}
      {a fixnum}
\Valueslabel
 Returns the current value of the flag word.
\Purposelabel
 Set resp.\ retrieve the flag word from the C level. The flag word is a
 32~bit \lisp{int}\ represented only in the C level;
 its meaning is currently undefined. I used it for
 [re]setting flag bits which signalled to the C level to switch on
 resp.\ off debugging messages.

 The action done by this function depends upon if the {\opt} argument
 \funarg{new-flag-word}\ was passed or not:
 \begin{description}
 \item[Argument \funarg{new-flag-word}\ was passed:]
  The flag word of the C level is set to \funarg{new-flag-word}.
 \item[Argument \funarg{new-flag-word}\ was not passed:]
  The current flag word of the C level is returned.
 \end{description}


\endcom

\beginfncom[Internal]{flush-if-idle}

\Syntaxlabel
\Defun {flush-if-idle} {}


\Purposelabel
 A hook called when \lw\ goes idle:
 The \sh\ is flushed to disk.
\Seealsolabel
 \Fcite{flush-if-idle-mode}.


\endcom

\beginfncom[Internal]{flush-if-idle-mode}

\Syntaxlabel
\Defun {flush-if-idle-mode} {{\opt} {\funarg{set-it}}}


\Argumentslabel
 \isabool{\funarg{set-it}}
\Purposelabel
 For argument \funarg{set-it}\ passed with a \nonnil\ value,
 \fcite{flush-if-idle}\ is put on the idle sleep hook.
 For argument \funarg{set-it}\ passed with \lispnil,
 \fcite{flush-if-idle}\ is removed from the idle sleep hook.
 For argument \funarg{set-it}\ not passed,
 it is checked if \fcite{flush-if-idle}\ is on the idle sleep hook.
\Seealsolabel
 \Fcite{flush-mode};
 \fcite{is-on-idle-sleep-hook};
 \fcite{push-to-idle-sleep-hook};
 \fcite{remove-from-idle-sleep-hook};
 \fcite{flush-if-idle}.


\endcom

\begincncom[Internal]{+flush-mode->keyword+}

\Valuelabel
\begin{CompactCode}
`((,+flush-never+ ,@:never)
  (,+flush-seldom+ ,@:seldom)
  (,+flush-sometimes+ ,@:sometimes)
  (,+flush-often+ ,@:often)
  (,+flush-always+ ,@:always))
\end{CompactCode}

\Purposelabel
 Internal constant.
 Mapping between keyword symbols \lisp{:never}, \lisp{:seldom},
 \lisp{:sometimes}, \lisp{:often}\ and \lisp{:always}\ and their
 \plob\ C level numeric flush-mode companions {\bf +flush-never+},
 {\bf +flush-seldom+}, {\bf +flush-sometimes+}, {\bf +flush-often+} and
 {\bf +flush-always+}.
\Seealsolabel
 \Fcite{flush-mode}.


\endcom

\beginfncom[Internal]{flush-object}

\Syntaxlabel
\Defun {flush-object} {{\funarg{p-object}} {\opt} {\funarg{remove-from-cache-p}} {\funarg{p-heap}}}


 \Purposelabel
  Flush the object referenced by \funarg{p-object}.
  If \funarg{p-object}\ is \lispnil, all objects cached for
  \funarg{p-heap}\ will be flushed.
 \Seealsolabel
  \Fcite{sh-flush-object}.


\endcom

\beginfncom[Internal]{flush-objid-buffer}

\Syntaxlabel
\Defun {flush-objid-buffer} {{\funarg{objid-buffer}}}

Flush an \objid\ buffer if it was modified.


\endcom

\beginpmcom[Internal]{+force-read-in-bootstrap+}

\Initialvaluelabel
\begin{CompactCode}
t
\end{CompactCode}



\endcom

\beginfncom[Internal]{format-plob-root}

\Syntaxlabel
\Defun {format-plob-root} {{\opt} {\funarg{url}}}


\Purposelabel
 Initialize the \sh\ for usage. The description objects (comparable to
 the \mo[s]\ of \clos) are stored to the initially empty \sh.
 When at startup time the \sh\ is detected as being empty, this function
 is called; so there is no need to call it explicit. There is one exception
 from this rule: When the state of the \sh\ is inconsistent, this
 function can be called to force a re-format, but {\sl all objects
 stored in the \sh\ will be lost}. The symbol {\bf format-plob-root}
 is not exported from the \lisp{:plob}\ package,
 so evaluate \lisp{(plob::format-plob-root)}.
\Seealsolabel
 \Fcite{open-heap};
 section \fcite{bootstrap ...}.


\endcom

\beginfncom[Internal]{free-int-vector}

\Syntaxlabel
\Defun {free-int-vector} {{\funarg{vector}}}

Free memory occupied by \funarg{vector}.


\endcom

\begingfcom[Internal]{generate-description}

\Syntaxlabel
\Defgen {generate-description} {{\funarg{class-descr}} {\opt} {\funarg{add-extra-slot-options}} {\funarg{add-extra-class-options}}}


\Argumentslabel
 \isa{\funarg{class-descr}}
      {a class description}
 \isabool{\funarg{add-extra-slot-options}\ resp.\ %
           \funarg{add-extra-class-options}}
\Purposelabel
 Returns a human-readable \cl\ adequate definition of
 \funarg{class-descr}.


\Methodslabel

\flabel{\protect\mtd}{generate-description (class-description)}{}
{\Defmeth {generate-description} {(\funarg{class-descr}\ \ObjectWithRef{class-description}) {\opt} {\funarg{add-extra-slot-options}} {\funarg{add-extra-class-options}}}}
See \fcite{generate-defclass}.

\flabel{\protect\mtd}{generate-description (structure-description)}{}
{\Defmeth {generate-description} {(\funarg{class-descr}\ \ObjectWithRef{structure-description}) {\opt} {\funarg{add-extra-slot-options}} {\funarg{add-extra-class-options}}}}
%
% No behavior is specified for this method beyond that which is specified
% for the generic function.


\endcom

\beginfncom[Internal]{get-depth-of-next-level}

\Syntaxlabel
\Defun {get-depth-of-next-level} {{\funarg{depth}}}

Get the depth parameter for the next recursion level.


\endcom

\beginfncom[Internal]{get-function-name}

\Syntaxlabel
\Defun {get-function-name} {{\funarg{function}}}


\Argumentslabel
  \isa{\funarg{object}}
       {a function}
\Purposelabel
 Return the name of \funarg{function}.
\Remarkslabel
 \sysdep{macro}


\endcom

\begingfcom[Internal]{get-inspector-values-for-p-objid}

\Syntaxlabel
\Defgen {get-inspector-values-for-p-objid} {{\funarg{p-objid}} {\funarg{p-objid-type-tag}} {\funarg{mode}} {\funarg{p-heap}}}


\Argumentslabel
 \isa{\funarg{p-objid}}
      {either a numeric immediate value or an \objid}
 \isatypetag{\funarg{p-objid-type-tag}}
\Valueslabel
 See \fcite{get-inspector-values}.
\Purposelabel
 Return the values needed by the \lw\ inspector to inspect a persistent
 object.


\Methodslabel

\flabel{\protect\mtd}{get-inspector-values-for-p-objid (t (eql +btree-page-tag+) t t)}{}
{\Defmeth {get-inspector-values-for-p-objid} {{\funarg{p-objid}} (\funarg{p-objid-type-tag}\ \ObjectWithRef{(eql +btree-page-tag+)}) {\funarg{mode}} {\funarg{p-heap}}}}
%
% No behavior is specified for this method beyond that which is specified
% for the generic function.

\flabel{\protect\mtd}{get-inspector-values-for-p-objid (t (eql +btree-type-tag+) t t)}{}
{\Defmeth {get-inspector-values-for-p-objid} {{\funarg{p-objid}} (\funarg{p-objid-type-tag}\ \ObjectWithRef{(eql +btree-type-tag+)}) {\funarg{mode}} {\funarg{p-heap}}}}
%
% No behavior is specified for this method beyond that which is specified
% for the generic function.

\flabel{\protect\mtd}{get-inspector-values-for-p-objid (t (eql +cons-type-tag+) t t)}{}
{\Defmeth {get-inspector-values-for-p-objid} {{\funarg{p-objid}} (\funarg{p-objid-type-tag}\ \ObjectWithRef{(eql +cons-type-tag+)}) {\funarg{mode}} {\funarg{p-heap}}}}
%
% No behavior is specified for this method beyond that which is specified
% for the generic function.

\flabel{\protect\mtd}{get-inspector-values-for-p-objid (t (eql +short-objid-tag+) t t)}{}
{\Defmeth {get-inspector-values-for-p-objid} {{\funarg{p-objid}} (\funarg{p-objid-type-tag}\ \ObjectWithRef{(eql +short-objid-tag+)}) {\funarg{mode}} {\funarg{p-heap}}}}
Get the `real' type of the persistent object referenced by
 \funarg{p-objid}\ and go on with this \typetag.

\flabel{\protect\mtd}{get-inspector-values-for-p-objid (t (eql +string-type-tag+) t t)}{}
{\Defmeth {get-inspector-values-for-p-objid} {{\funarg{p-objid}} (\funarg{p-objid-type-tag}\ \ObjectWithRef{(eql +string-type-tag+)}) {\funarg{mode}} {\funarg{p-heap}}}}
%
% No behavior is specified for this method beyond that which is specified
% for the generic function.

\flabel{\protect\mtd}{get-inspector-values-for-p-objid (t (eql +symbol-type-tag+) t t)}{}
{\Defmeth {get-inspector-values-for-p-objid} {{\funarg{p-objid}} (\funarg{p-objid-type-tag}\ \ObjectWithRef{(eql +symbol-type-tag+)}) {\funarg{mode}} {\funarg{p-heap}}}}
%
% No behavior is specified for this method beyond that which is specified
% for the generic function.

\flabel{\protect\mtd}{get-inspector-values-for-p-objid (t (eql +vector-type-tag+) t t)}{}
{\Defmeth {get-inspector-values-for-p-objid} {{\funarg{p-objid}} (\funarg{p-objid-type-tag}\ \ObjectWithRef{(eql +vector-type-tag+)}) {\funarg{mode}} {\funarg{p-heap}}}}
%
% No behavior is specified for this method beyond that which is specified
% for the generic function.

\flabel{\protect\mtd}{get-inspector-values-for-p-objid (t t t t)}{}
{\Defmeth {get-inspector-values-for-p-objid} {{\funarg{p-objid}} {\funarg{p-objid-type-tag}} {\funarg{mode}} {\funarg{p-heap}}}}
Return the pure-transient top-level representation for inspection.


\endcom

\beginfncom[Internal]{get-instance-vector-and-location}

\Syntaxlabel
\Defun {get-instance-vector-and-location} {{\funarg{the-class}} {\funarg{object}} {\funarg{slot-description}}}


\Argumentslabel
 \isacls{\funarg{the-class}}
 \isaclosobject{\funarg{object}}
 \isa{\funarg{slot-description}}
      {a slot-description}
\Valueslabel
  Four values are returned. The kind of values returned depend
  upon the allocation of the slot described by
  \funarg{slot-description}:
  \begin{itemize}
  \item The slot described by \funarg{slot-description}\ has
    an \lisp{:allocation :class}:
   \begin{enumerate}

   \item The \objid\ of the persistent cons cell which is used
    for holding the slot value is returned as first value.

   \item The position in the cons cell which contains the slot
    value is returned; this is the position {\bf +cons-location-cdr+}
    since the value is stored in the cdr of the persistent cons cell.

   \item The \typetag\ for type cons is returned as third value,
    i.e.\ the value of the constant {\bf +cons-type-tag+}.

   \item The slot allocation keyword {\bf :class} is returned as
    fourth value.

   \end{enumerate}

  \item The slot described by \funarg{slot-description}\ has
   not an \lisp{:allocation :class}, i.e.\ is a `normal'
   instance slot:

   \begin{enumerate}

   \item The \objid\ of the persistent vector which is used
    for holding the persistent \clos\ instance slot values is
    returned as first value.

   \item The position in the vector which contains the slot
    value is returned.

   \item The \typetag\ for type vector is returned as third
    value, i.e.\ the value of the constant
    {\bf +vector-type-tag+}.

   \item The slot allocation keyword {\bf :instance} is
    returned as fourth value.

   \end{enumerate}
  \end{itemize}
  For slot representation see also slot {\bf p-location}
  of \fcite{effective-slot-description}.
\Purposelabel
 This function is used for preparing the slot access to a
 persistent \clos\ instance. Returned are all informations
 necessary for a controlled access to the slot of a
 persistent \clos\ instance.


\endcom

\beginfncom[Internal]{get-slot-extent}

\Syntaxlabel
\Defun {get-slot-extent} {{\funarg{the-slot}} {\funarg{the-class}}}


\Argumentslabel
 \isa{\funarg{table}}
      {a hash-table}
 \isa{\funarg{the-slot}}
      {a symbol naming a slot of \funarg{the-class}}
 \isacls{\funarg{the-class}}
\Purposelabel
 Get the slot extent of the slot named \funarg{the-slot}\ of
 class \funarg{the-class}.
\Seealsolabel
 \Fcite{*class->slot-extent-table*};
 \fcite{set-slot-extent}.


\endcom

\beginfncom[Internal]{get-structure-constructor}

\Syntaxlabel
\Defun {get-structure-constructor} {{\funarg{class-of-struct}}}


\Purposelabel
 Call to \fcite{class-constructor}\ with some
 additional user-interaction if required.
\Seealsolabel
 \Fcite{class-constructor}.


\endcom

\beginfncom[Internal]{get-structure-slot-default-init}

\Syntaxlabel
\Defun {get-structure-slot-default-init} {{\funarg{class-of-struct}} {\funarg{slot-name}}}

Calls to this function are trapped to
 \fcite{structure-slot-default-init}.


\endcom

\beginfncom[Internal]{get-structure-slot-reader}

\Syntaxlabel
\Defun {get-structure-slot-reader} {{\funarg{class-of-struct}} {\funarg{slot-name}}}


\Purposelabel
 Call to \fcite{structure-slot-reader}\ with some
 additional user-interaction if required.
\Seealsolabel
 \Fcite{structure-slot-reader}.


\endcom

\beginfncom[Internal]{get-structure-slot-type}

\Syntaxlabel
\Defun {get-structure-slot-type} {{\funarg{class-of-struct}} {\funarg{slot-name}}}

Calls to this function are trapped to
 \fcite{structure-slot-type}.


\endcom

\beginfncom[Internal]{get-type-info}

\Syntaxlabel
\Defun {get-type-info} {{\funarg{type-tag}}}


\Argumentslabel
 \isatypetag{\funarg{type-tag}}
\Purposelabel
 Find an instance of \fcite{type-info}\ for the
 \plob\ built-in type referenced by \funarg{type-tag}.
\Seealsolabel
 \Fcite{type-info}.


\endcom

\begingfcom[Internal]{getbtree-by-objid-with-data}

\Syntaxlabel
\Defgen {getbtree-by-objid-with-data} {{\funarg{key}} {\funarg{key-objid}} {\funarg{key-type-tag}} {\funarg{p-btree}} {\funarg{depth}} {\funarg{p-heap}}}


\Argumentslabel
 See \fcite{getbtree-by-objid}.
\Valueslabel
 See \fcite{getbtree-with-data}.
\Purposelabel
 Internal used workhorse for \fcite{getbtree-by-objid}.
\Seealsolabel
 \Fcite{getbtree-by-objid}.


\Methodslabel

\flabel{\protect\mtd}{getbtree-by-objid-with-data (t t t cached-btree t t)}{}
{\Defmeth {getbtree-by-objid-with-data} {{\funarg{key}} {\funarg{key-objid}} {\funarg{key-type-tag}} (\funarg{p-btree}\ \ObjectWithRef{cached-btree}) {\funarg{depth}} {\funarg{p-heap}}}}
Searches \funarg{key}\ at first in the cache of the
 cached persistent BTree \funarg{p-btree}.

\flabel{\protect\mtd}{getbtree-by-objid-with-data (t t t t t t)}{}
{\Defmeth {getbtree-by-objid-with-data} {{\funarg{key}} {\funarg{key-objid}} {\funarg{key-type-tag}} {\funarg{p-btree}} {\funarg{depth}} {\funarg{p-heap}}}}
%
% No behavior is specified for this method beyond that which is specified
% for the generic function.


\endcom

\begingfcom[Internal]{(setf getbtree-by-objid-with-data)}

\Syntaxlabel
\Defgen {(setf getbtree-by-objid-with-data)} {{\funarg{data}} {\funarg{key}} {\funarg{key-objid}} {\funarg{key-type-tag}} {\funarg{p-btree}} {\funarg{depth}} {\funarg{p-heap}} {\funarg{data-objid}} {\funarg{data-type-tag}}}


\Argumentslabel
 For the \funarg{data}, \funarg{key}\ and \funarg{p-btree}\ arguments
 see \fcite{(setf getbtree-by-objid)}.
 \isanobjid{\funarg{data-objid}}
 \isatypetag{\funarg{data-type-tag}}
\Valueslabel
 See \fcite{(setf getbtree-by-objid)}.
\Purposelabel
 Internal used workhorse for \fcite{(setf getbtree-by-objid)}.
 Arguments \funarg{data-objid}\ resp.\ \funarg{data-type-tag}\ are
 the \objid\ resp.\ \typetag\ of \funarg{data}\ already stored to the
 \sh\ by the caller of this function.
\Seealsolabel
 \Fcite{(setf getbtree-by-objid)}.


\Methodslabel

\flabel{\protect\mtd}{(setf getbtree-by-objid-with-data) (t t t t cached-btree t t t t)}{}
{\Defmeth {(setf getbtree-by-objid-with-data)} {{\funarg{data}} {\funarg{key}} {\funarg{key-objid}} {\funarg{key-type-tag}} (\funarg{p-btree}\ \ObjectWithRef{cached-btree}) {\funarg{depth}} {\funarg{p-heap}} {\funarg{data-objid}} {\funarg{data-type-tag}}}}
Inserts \funarg{data}, \funarg{data-objid},
 \funarg{data-type-tag}\ associated to \funarg{key} into the cache of
 the cached persistent BTree \funarg{p-btree}.

\flabel{\protect\mtd}{(setf getbtree-by-objid-with-data) (t t t t t t t t t)}{}
{\Defmeth {(setf getbtree-by-objid-with-data)} {{\funarg{data}} {\funarg{key}} {\funarg{key-objid}} {\funarg{key-type-tag}} {\funarg{p-btree}} {\funarg{depth}} {\funarg{p-heap}} {\funarg{data-objid}} {\funarg{data-type-tag}}}}
%
% No behavior is specified for this method beyond that which is specified
% for the generic function.


\endcom

\beginfncom[Internal]{getbtree-from-cached-btree}

\Syntaxlabel
\Defun {getbtree-from-cached-btree} {{\funarg{key}} {\funarg{entry-key}} {\funarg{key-objid}} {\funarg{key-type-tag}} {\funarg{p-btree}} {\funarg{depth}} {\funarg{p-heap}} {\funarg{next-method}}}


\Argumentslabel
 \isanobject{\funarg{key}}
 \isanobject{\funarg{entry-key}}
 \isacbtree{\funarg{p-btree}}
 \isa{\funarg{next-method}}
      {a method function with arguments as accepted by the
       \fcite{getbtree-with-data}}
\Valueslabel
 See \fcite{getbtree-with-data}.
\Purposelabel
 Internal used function.
 Searches \funarg{key}\ in the cache of \funarg{p-btree}. If a value
 was found, that value is returned as the result of the BTree search.
 If no value was found, the \funarg{next-method}\ is called to
 search the \funarg{key}\ in \funarg{p-btree}\ and the found value
 is inserted into \funarg{p-btree}'s cache.


\endcom

\beginfncom[Internal]{(setf getbtree-into-cached-btree)}

\Syntaxlabel
\Defun {(setf getbtree-into-cached-btree)} {{\funarg{data}} {\funarg{key}} {\funarg{entry-key}} {\funarg{key-objid}} {\funarg{key-type-tag}} {\funarg{p-btree}} {\funarg{depth}} {\funarg{p-heap}} {\funarg{data-objid}} {\funarg{data-type-tag}} {\funarg{next-setf-method}}}


\Argumentslabel
 \isanobject{\funarg{data}}
 \isanobject{\funarg{key}}
 \isanobject{\funarg{entry-key}}
 \isacbtree{\funarg{p-btree}}
 \isanobjid{\funarg{data-objid}}
 \isatypetag{\funarg{data-type-tag}}
 \isa{\funarg{next-setf-method}}
      {a method function with arguments as accepted by the
       \fcite{(setf getbtree-with-data)}}
\Valueslabel
 Returns \nonnil\ if \funarg{key}\ was inserted in \funarg{p-btree},
 \lispnil\ otherwise.
\Purposelabel
 Internal used function.
 Calls \funarg{next-setf-method}\ to insert \funarg{data}\ associated
 to \funarg{key}\ into \funarg{p-btree}\ and 
 inserts afterwards \funarg{data}, \funarg{data-objid},
 \funarg{data-type-tag}\ associated to \funarg{entry-key}\ into the
 cache of \funarg{p-btree}.


\endcom

\begingfcom[Internal]{getbtree-with-data}

\Syntaxlabel
\Defgen {getbtree-with-data} {{\funarg{key}} {\funarg{p-btree}} {\funarg{depth}} {\funarg{p-heap}}}


\Argumentslabel
 See \fcite{getbtree}.
\Valueslabel
 Four values are returned:
 \begin{enumerate}
 \item The transient representation of the persistent object
  found under \funarg{key}\ in the persistent BTree
  \funarg{p-btree}.
 \item A flag indicating if the \funarg{key}\ was found in the
  persistent BTree \funarg{p-btree}, i.e.\ if the
  first value is valid at all.
 \item If an \obj\ was found, the \objid\ of the first
   returned value, i.e.\ the \objid\ of the persistent object
   found under \funarg{key}\ in the persistent BTree
   \funarg{p-btree}\ is returned as 3rd value;
   \lispnil\ otherwise.
 \item If an \obj\ was found, the \typetag\ of the first
   returned value, i.e.\ the \typetag\ of the persistent object
   found under \funarg{key}\ in the persistent BTree
   \funarg{p-btree}\ is returned as 4th value;
   \lispnil\ otherwise.
 \end{enumerate}
\Purposelabel
 Internal used workhorse for \fcite{getbtree}.
\Seealsolabel
 \Fcite{getbtree}.


\Methodslabel

\flabel{\protect\mtd}{getbtree-with-data :around (persistent-clos-object cached-btree t t)}{}
{\Defmetharound {getbtree-with-data} {(\funarg{key}\ \ObjectWithRef{persistent-clos-object}) (\funarg{p-btree}\ \ObjectWithRef{cached-btree}) {\funarg{depth}} {\funarg{p-heap}}}}
Searches \funarg{key}\ at first in the cache of the
 cached persistent BTree \funarg{p-btree}.

\flabel{\protect\mtd}{getbtree-with-data :around (persistent-object cached-btree t t)}{}
{\Defmetharound {getbtree-with-data} {(\funarg{key}\ \ObjectWithRef{persistent-object}) (\funarg{p-btree}\ \ObjectWithRef{cached-btree}) {\funarg{depth}} {\funarg{p-heap}}}}
Searches \funarg{key}\ at first in the cache of the
 cached persistent BTree \funarg{p-btree}.

\flabel{\protect\mtd}{getbtree-with-data :around (t cached-btree t t)}{}
{\Defmetharound {getbtree-with-data} {{\funarg{key}} (\funarg{p-btree}\ \ObjectWithRef{cached-btree}) {\funarg{depth}} {\funarg{p-heap}}}}
Searches \funarg{key}\ at first in the cache of the
 cached persistent BTree \funarg{p-btree}.

\flabel{\protect\mtd}{getbtree-with-data (character t t t)}{}
{\Defmeth {getbtree-with-data} {(\funarg{key}\ \ObjectWithRef{character}) {\funarg{p-btree}} {\funarg{depth}} {\funarg{p-heap}}}}
%
% No behavior is specified for this method beyond that which is specified
% for the generic function.

\flabel{\protect\mtd}{getbtree-with-data (float t t t)}{}
{\Defmeth {getbtree-with-data} {(\funarg{key}\ \ObjectWithRef{float}) {\funarg{p-btree}} {\funarg{depth}} {\funarg{p-heap}}}}
%
% No behavior is specified for this method beyond that which is specified
% for the generic function.

\flabel{\protect\mtd}{getbtree-with-data (integer t t t)}{}
{\Defmeth {getbtree-with-data} {(\funarg{key}\ \ObjectWithRef{integer}) {\funarg{p-btree}} {\funarg{depth}} {\funarg{p-heap}}}}
%
% No behavior is specified for this method beyond that which is specified
% for the generic function.

\flabel{\protect\mtd}{getbtree-with-data (persistent-clos-object t t t)}{}
{\Defmeth {getbtree-with-data} {(\funarg{key}\ \ObjectWithRef{persistent-clos-object}) {\funarg{p-btree}} {\funarg{depth}} {\funarg{p-heap}}}}
Calls to this method are trapped to \fcite{getbtree-by-objid-with-data}.

\flabel{\protect\mtd}{getbtree-with-data (persistent-immediate-object t t t)}{}
{\Defmeth {getbtree-with-data} {(\funarg{key}\ \ObjectWithRef{persistent-immediate-object}) {\funarg{p-btree}} {\funarg{depth}} {\funarg{p-heap}}}}
Calls to this method are trapped to \fcite{getbtree-by-objid-with-data}.

\flabel{\protect\mtd}{getbtree-with-data (persistent-object t t t)}{}
{\Defmeth {getbtree-with-data} {(\funarg{key}\ \ObjectWithRef{persistent-object}) {\funarg{p-btree}} {\funarg{depth}} {\funarg{p-heap}}}}
Calls to this method are trapped to \fcite{getbtree-by-objid-with-data}.

\flabel{\protect\mtd}{getbtree-with-data (string t t t)}{}
{\Defmeth {getbtree-with-data} {(\funarg{key}\ \ObjectWithRef{string}) {\funarg{p-btree}} {\funarg{depth}} {\funarg{p-heap}}}}
%
% No behavior is specified for this method beyond that which is specified
% for the generic function.

\flabel{\protect\mtd}{getbtree-with-data (symbol t t t)}{}
{\Defmeth {getbtree-with-data} {(\funarg{key}\ \ObjectWithRef{symbol}) {\funarg{p-btree}} {\funarg{depth}} {\funarg{p-heap}}}}
%
% No behavior is specified for this method beyond that which is specified
% for the generic function.

\flabel{\protect\mtd}{getbtree-with-data (t t t t)}{}
{\Defmeth {getbtree-with-data} {{\funarg{key}} {\funarg{p-btree}} {\funarg{depth}} {\funarg{p-heap}}}}
Store \funarg{key}\ and continue.


\endcom

\begingfcom[Internal]{(setf getbtree-with-data)}

\Syntaxlabel
\Defgen {(setf getbtree-with-data)} {{\funarg{data}} {\funarg{key}} {\funarg{p-btree}} {\funarg{depth}} {\funarg{p-heap}} {\funarg{data-objid}} {\funarg{data-type-tag}}}


\Argumentslabel
 For the \funarg{data}, \funarg{key}\ and
 \funarg{p-btree} arguments see \fcite{(setf getbtree)}.
 \isanobjid{\funarg{data-objid}}
 \isatypetag{\funarg{data-type-tag}}
\Valueslabel
 See \fcite{(setf getbtree)}.
\Purposelabel
 Internal used workhorse for \fcite{(setf getbtree)}.
 Arguments \funarg{data-objid}\ resp.\ \funarg{data-type-tag}\ are
 the \objid\ resp.\ \typetag\ of \funarg{data}\ already stored to the
 \sh\ by the caller of this function.
\Seealsolabel
 \Fcite{(setf getbtree)}.


\Methodslabel

\flabel{\protect\mtd}{(setf getbtree-with-data) :around (t persistent-clos-object cached-btree t t t t)}{}
{\Defmetharound {(setf getbtree-with-data)} {{\funarg{data}} (\funarg{key}\ \ObjectWithRef{persistent-clos-object}) (\funarg{p-btree}\ \ObjectWithRef{cached-btree}) {\funarg{depth}} {\funarg{p-heap}} {\funarg{data-objid}} {\funarg{data-type-tag}}}}
Inserts \funarg{data}, \funarg{data-objid},
 \funarg{data-type-tag}\ associated to \funarg{key} into the cache of
 the cached persistent BTree \funarg{p-btree}.

\flabel{\protect\mtd}{(setf getbtree-with-data) :around (t persistent-object cached-btree t t t t)}{}
{\Defmetharound {(setf getbtree-with-data)} {{\funarg{data}} (\funarg{key}\ \ObjectWithRef{persistent-object}) (\funarg{p-btree}\ \ObjectWithRef{cached-btree}) {\funarg{depth}} {\funarg{p-heap}} {\funarg{data-objid}} {\funarg{data-type-tag}}}}
Inserts \funarg{data}, \funarg{data-objid},
 \funarg{data-type-tag}\ associated to \funarg{key} into the cache of
 the cached persistent BTree \funarg{p-btree}.

\flabel{\protect\mtd}{(setf getbtree-with-data) :around (t t cached-btree t t t t)}{}
{\Defmetharound {(setf getbtree-with-data)} {{\funarg{data}} {\funarg{key}} (\funarg{p-btree}\ \ObjectWithRef{cached-btree}) {\funarg{depth}} {\funarg{p-heap}} {\funarg{data-objid}} {\funarg{data-type-tag}}}}
Inserts \funarg{data}, \funarg{data-objid},
 \funarg{data-type-tag}\ associated to \funarg{key} into the cache of
 the cached persistent BTree \funarg{p-btree}.

\flabel{\protect\mtd}{(setf getbtree-with-data) (t character t t t t t)}{}
{\Defmeth {(setf getbtree-with-data)} {{\funarg{data}} (\funarg{key}\ \ObjectWithRef{character}) {\funarg{p-btree}} {\funarg{depth}} {\funarg{p-heap}} {\funarg{data-objid}} {\funarg{data-type-tag}}}}
%
% No behavior is specified for this method beyond that which is specified
% for the generic function.

\flabel{\protect\mtd}{(setf getbtree-with-data) (t float t t t t t)}{}
{\Defmeth {(setf getbtree-with-data)} {{\funarg{data}} (\funarg{key}\ \ObjectWithRef{float}) {\funarg{p-btree}} {\funarg{depth}} {\funarg{p-heap}} {\funarg{data-objid}} {\funarg{data-type-tag}}}}
%
% No behavior is specified for this method beyond that which is specified
% for the generic function.

\flabel{\protect\mtd}{(setf getbtree-with-data) (t integer t t t t t)}{}
{\Defmeth {(setf getbtree-with-data)} {{\funarg{data}} (\funarg{key}\ \ObjectWithRef{integer}) {\funarg{p-btree}} {\funarg{depth}} {\funarg{p-heap}} {\funarg{data-objid}} {\funarg{data-type-tag}}}}
%
% No behavior is specified for this method beyond that which is specified
% for the generic function.

\flabel{\protect\mtd}{(setf getbtree-with-data) (t persistent-clos-object t t t t t)}{}
{\Defmeth {(setf getbtree-with-data)} {{\funarg{data}} (\funarg{key}\ \ObjectWithRef{persistent-clos-object}) {\funarg{p-btree}} {\funarg{depth}} {\funarg{p-heap}} {\funarg{data-objid}} {\funarg{data-type-tag}}}}
Calls to this method are trapped to
 \fcite{(setf getbtree-by-objid-with-data)}.

\flabel{\protect\mtd}{(setf getbtree-with-data) (t persistent-immediate-object t t t t t)}{}
{\Defmeth {(setf getbtree-with-data)} {{\funarg{data}} (\funarg{key}\ \ObjectWithRef{persistent-immediate-object}) {\funarg{p-btree}} {\funarg{depth}} {\funarg{p-heap}} {\funarg{data-objid}} {\funarg{data-type-tag}}}}
Calls to this method are trapped to
 \fcite{(setf getbtree-by-objid-with-data)}.

\flabel{\protect\mtd}{(setf getbtree-with-data) (t persistent-object t t t t t)}{}
{\Defmeth {(setf getbtree-with-data)} {{\funarg{data}} (\funarg{key}\ \ObjectWithRef{persistent-object}) {\funarg{p-btree}} {\funarg{depth}} {\funarg{p-heap}} {\funarg{data-objid}} {\funarg{data-type-tag}}}}
Calls to this method are trapped to
 \fcite{(setf getbtree-by-objid-with-data)}.

\flabel{\protect\mtd}{(setf getbtree-with-data) (t string t t t t t)}{}
{\Defmeth {(setf getbtree-with-data)} {{\funarg{data}} (\funarg{key}\ \ObjectWithRef{string}) {\funarg{p-btree}} {\funarg{depth}} {\funarg{p-heap}} {\funarg{data-objid}} {\funarg{data-type-tag}}}}
%
% No behavior is specified for this method beyond that which is specified
% for the generic function.

\flabel{\protect\mtd}{(setf getbtree-with-data) (t symbol t t t t t)}{}
{\Defmeth {(setf getbtree-with-data)} {{\funarg{data}} (\funarg{key}\ \ObjectWithRef{symbol}) {\funarg{p-btree}} {\funarg{depth}} {\funarg{p-heap}} {\funarg{data-objid}} {\funarg{data-type-tag}}}}
%
% No behavior is specified for this method beyond that which is specified
% for the generic function.

\flabel{\protect\mtd}{(setf getbtree-with-data) (t t t t t t t)}{}
{\Defmeth {(setf getbtree-with-data)} {{\funarg{data}} {\funarg{key}} {\funarg{p-btree}} {\funarg{depth}} {\funarg{p-heap}} {\funarg{data-objid}} {\funarg{data-type-tag}}}}
Store \funarg{key}\ and continue.


\endcom

\begingfcom[Internal]{getindex}

\Syntaxlabel
\Defgen {getindex} {{\funarg{key-slot-value}} {\funarg{the-table}} {\opt} {\funarg{depth}} {\funarg{p-heap}}}



\Argumentslabel
 \isanobject{\funarg{key-slot-value}}
 \isaidxtable{\funarg{the-table}}
\Purposelabel
 \idxadmfn:
 Search \funarg{key-slot-value}\ in \funarg{the-table}\ and
 return a found persistent \clos\ instance;
 if the search was not successfull, \lispnil\ is returned.
\Seealsolabel
 \Fcite{(setf getindex)};
 \fcite{getindex-by-objid};
 section \fcite{index ...}.


\Methodslabel

\flabel{\protect\mtd}{getindex (t persistent-btree)}{}
{\Defmeth {getindex} {{\funarg{key-slot-value}} (\funarg{the-table}\ \ObjectWithRef{persistent-btree}) {\opt} {\funarg{depth}} {\funarg{p-heap}}}}
Trapped to \fcite{getbtree}.


\endcom

\begingfcom[Internal]{(setf getindex)}

\Syntaxlabel
\Defgen {(setf getindex)} {{\funarg{data-persistent-instance}} {\funarg{key-slot-value}} {\funarg{the-table}} {\opt} {\funarg{depth}} {\funarg{p-heap}}}


\Argumentslabel
 \isa{\funarg{data-persistent-instance}}
      {a persistent \clos\ instance}
 \isanobject{\funarg{key-slot-value}}
 \isaidxtable{\funarg{the-table}}
\Purposelabel
 \idxadmfn:
 Insert \funarg{data-persistent-instance}\ associated to
 \funarg{key-slot-value}\ into \funarg{the-table}.
\Seealsolabel
 \Fcite{getindex};
 \fcite{(setf getindex-by-objid)};
 section \fcite{index ...}.


\Methodslabel

\flabel{\protect\mtd}{(setf getindex) (t t persistent-btree)}{}
{\Defmeth {(setf getindex)} {{\funarg{data-persistent-instance}} {\funarg{key-slot-value}} (\funarg{the-table}\ \ObjectWithRef{persistent-btree}) {\opt} {\funarg{depth}} {\funarg{p-heap}}}}
Trapped to \fcite{(setf getbtree)}.


\endcom

\begingfcom[Internal]{getindex-by-objid}

\Syntaxlabel
\Defgen {getindex-by-objid} {{\funarg{key-slot-value}} {\funarg{the-table}} {\opt} {\funarg{depth}} {\funarg{p-heap}}}


\Argumentslabel
 \isanobjid{\funarg{key-slot-value}}
 \isaidxtable{\funarg{the-table}}
\Purposelabel
 \idxadmfn:
 Search \funarg{key-slot-value}\ in \funarg{the-table}\ and
 return a found persistent \clos\ instance;
 if the search was not successfull, \lispnil\ is returned.
\Seealsolabel
 \Fcite{getindex};
 section \fcite{index ...}.


\Methodslabel

\flabel{\protect\mtd}{getindex-by-objid (t persistent-btree)}{}
{\Defmeth {getindex-by-objid} {{\funarg{key-slot-value}} (\funarg{the-table}\ \ObjectWithRef{persistent-btree}) {\opt} {\funarg{depth}} {\funarg{p-heap}}}}
Trapped to \fcite{getbtree-by-objid}.


\endcom

\begingfcom[Internal]{(setf getindex-by-objid)}

\Syntaxlabel
\Defgen {(setf getindex-by-objid)} {{\funarg{data-persistent-instance}} {\funarg{key-slot-value}} {\funarg{the-table}} {\opt} {\funarg{depth}} {\funarg{p-heap}}}


\Argumentslabel
 \isa{\funarg{data-persistent-instance}}
      {a persistent \clos\ instance}
 \isanobjid{\funarg{key-slot-value}}
 \isaidxtable{\funarg{the-table}}
\Purposelabel
 \idxadmfn:
 Insert \funarg{data-persistent-instance}\ associated to
 \funarg{key-slot-value}\ into \funarg{the-table}.
\Seealsolabel
 \Fcite{(setf getindex)};
 section \fcite{index ...}.


\Methodslabel

\flabel{\protect\mtd}{(setf getindex-by-objid) (t t persistent-btree)}{}
{\Defmeth {(setf getindex-by-objid)} {{\funarg{data-persistent-instance}} {\funarg{key-slot-value}} (\funarg{the-table}\ \ObjectWithRef{persistent-btree}) {\opt} {\funarg{depth}} {\funarg{p-heap}}}}
Trapped to \fcite{(setf getbtree-by-objid)}.


\endcom

\beginfncom[Internal]{getindex-by-tag}

\Syntaxlabel
\Defun {getindex-by-tag} {{\funarg{key-slot-value-objid}} {\funarg{key-slot-value-type-tag}} {\funarg{the-table}} {\opt} {\funarg{depth}} {\funarg{p-heap}}}


\Argumentslabel
 \isa{\funarg{key-slot-value-objid}}
      {either an immediate value or an \objid}
 \isatypetag{\funarg{key-slot-value-type-tag}}
 \isaidxtable{\funarg{the-table}}
\Valueslabel
 See \fcite{getindex}\ resp.\ \fcite{getindex-by-objid}.
\Purposelabel
 The action done by this function depends on the value of the 
 \funarg{key-slot-value-type-tag}\ argument, i.e.\ if it
 references an immediate or a non-immediate \plob\ type:
 \begin{description}

 \item [immediate type]
  In this case \funarg{key-slot-value-objid}\ is not an
  \objid\ but an immediate value; {\bf getindex} is called
  with that value as key argument.

 \item [non-immediate type]
  In this case \funarg{key-slot-value-objid}\ is an
  \objid; {\bf getindex-by-objid} is called with that
  \objid\ as key argument.

 \end{description}
\Seealsolabel
 \Fcite{getindex};
 \fcite{getindex-by-objid};
 section \fcite{index ...}.


\endcom

\beginfncom[Internal]{(setf getindex-by-tag)}

\Syntaxlabel
\Defun {(setf getindex-by-tag)} {{\funarg{data-persistent-instance}} {\funarg{key-slot-value-objid}} {\funarg{key-slot-value-type-tag}} {\funarg{the-table}} {\opt} {\funarg{depth}} {\funarg{p-heap}}}


\Argumentslabel
 \isa{\funarg{data-persistent-instance}}
      {a persistent \clos\ instance}
 \isa{\funarg{key-slot-value-objid}}
      {either an immediate value or an \objid}
 \isatypetag{\funarg{key-slot-value-type-tag}}
 \isaidxtable{\funarg{the-table}}
\Valueslabel
 See \fcite{(setf getindex)}\ resp.\ %
 \fcite{(setf getindex-by-objid)}.
\Purposelabel
 The action done by this function depends on the value of the 
 \funarg{key-slot-value-type-tag}\ argument, i.e.\ if it
 references an immediate or a non-immediate \plob\ type:
 \begin{description}

 \item [immediate type]
  In this case \funarg{key-slot-value-objid}\ is not an
  \objid\ but an immediate value; {\bf (setf getindex)} is called
  with that value as key argument.

 \item [non-immediate type]
  In this case \funarg{key-slot-value-objid}\ is an
  \objid; {\bf (setf getindex-by-objid)} is called with that
  \objid\ as key argument.

 \end{description}
\Seealsolabel
 \Fcite{(setf getindex)};
 \fcite{(setf getindex-by-objid)};
 section \fcite{index ...}.


\endcom

\beginfncom[Internal]{handle-class-mismatch}

\Syntaxlabel
\Defun {handle-class-mismatch} {{\funarg{t-class-descr}} {\funarg{p-class-descr}} {\funarg{reason}} {\opt} {\funarg{p-heap}}}


\Argumentslabel
 \isa{\funarg{t-class-descr}\ resp.\ \funarg{p-class-descr}}
      {a class description}
\Valueslabel
 Returns \nonnil\ iff the transient class definition
 has been stored to the \sh,
 \lispnil\ otherwise.
\Purposelabel
 Handles a mismatch between the class description
 of the class as found in the transient system
 \funarg{t-class-descr}\ and the class description
 found in the \sh\ \funarg{p-class-descr}.

 The user is asked what \plob\ should do next;
 either \funarg{t-class-descr}\ replaces the current class
 description stored in the \sh\ (this is the normal way of
 schema evolution) or the class description in the \sh\ is
 replaced by \funarg{t-class-descr}\ (this would be the not
 so normal way of `schema degration').
\Remarkslabel
 Perhaps \plob\ should always choose the first way by default
 without asking for user-intervention; the error prompt raised
 here is a kind of `safety valve' to escape from an unwanted
 schema evolution.
\Seealsolabel
 \Fcite{(setf schema-evolution)}.


\endcom

\beginfncom[Internal]{handle-lock-conflict}

\Syntaxlabel
\Defun {handle-lock-conflict} {{\funarg{lock-expression}} {\funarg{p-heap-objid}} {\funarg{p-objid}} {\funarg{lock-conflict}}}


\Argumentslabel
 \isa{\funarg{lock-expression}}
      {a function taking one argument, the \funarg{p-objid}}
 \isanobjid{\funarg{p-objid}}
\Valueslabel
 If the lock operation is retried, the value returned by
 calling \funarg{lock-expression}\ with argument \funarg{p-objid}.
\Purposelabel
 Show a \lisp{cerror}\ which indicates that locking the persistent
 object referenced by \funarg{p-objid}\ failed. The
 \funarg{lock-expression} argument is a function which contains
 the call to the C level which indicated the failed lock.
 The user is asked what to do next; this is one of:
 \begin{itemize}

 \item Retry the lock by calling \funarg{lock-expression}\ again
  with the \funarg{p-objid}\ argument in the hope that the
  conflicting lock has been relased in the meantime.

 \item Remove all locks from \funarg{p-objid}\ brute-force
  and call \funarg{lock-expression}\ again with the
  \funarg{p-objid}\ argument to obtain the lock.

 \end{itemize}
\Seealsolabel
 \Fcite{with-handle-lock-conflict}.


\endcom

\beginfncom[Internal]{handle-lock-error}

\Syntaxlabel
\Defun {handle-lock-error} {{\funarg{p-heap-objid}} {\funarg{p-objid}} {\funarg{lock-error}}}


\Purposelabel
 Signal an error for a failed lock request.



\endcom

\begincncom[Internal]{+has-short-float-p+}

\Valuelabel
\begin{CompactCode}
(eq (type-of 1.0) 'short-float)
\end{CompactCode}

\Purposelabel
 A flag if the used LISP system supports short float numbers,
 i.e.\ if the type \textbf{short-float} is a true subtype
 of type \textbf{single-float}.


\endcom

\beginfncom[Internal]{has-slot-p}

\Syntaxlabel
\Defun {has-slot-p} {{\funarg{the-slot}} {\funarg{the-class}}}


\Argumentslabel
 \isa{\funarg{the-slot}}
      {either a symbol or a \sltmo}
 \isacls{\funarg{the-class}}
\Purposelabel
 Returns \nonnil\ if \funarg{the-slot}\ names an \eff\ \slt\ of
 \funarg{the-class}, \lispnil\ otherwise.
\Remarkslabel
 The search is always done by name, i.e.\ if a \sltmo\ was passed as
 the \funarg{the-slot}\ argument, the name of the slot is used.


\endcom

\beginvrcom[Internal]{*hash-table->persistent-hash-table*}

\Initialvaluelabel
\begin{CompactCode}
(make-hash-table :test 'eq)
\end{CompactCode}

\Purposelabel
 A hash table mapping transient hash tables to persistent hash tables.


\endcom

\beginpmcom[Internal]{*heap-spare-size*}

\Initialvaluelabel
\begin{CompactCode}
(* 32 1024 1024)
\end{CompactCode}

\Purposelabel

 Max.\ size of the LISP heap.


\endcom

\beginvrcom[Internal]{*ignore-displaced-to-failed*}

\Initialvaluelabel
\begin{CompactCode}
nil
\end{CompactCode}

\Purposelabel
Flag if the error should be ignored which is signalled when
a call to \fcite{array-displaced-to}\ fails.


\endcom

\beginvrcom[Internal]{*ignore-info-messages-semaphore*}

\Initialvaluelabel
\begin{CompactCode}
0
\end{CompactCode}

\Purposelabel
 A semaphore used to suppress info messages during the active wait for
 a lock.


\endcom

\beginvrcom[Internal]{*ignore-missing-function-name*}

\Initialvaluelabel
\begin{CompactCode}
nil
\end{CompactCode}

\Purposelabel

 Flag if unnamed functions should be stored as unloadable objects.


\endcom

\begincncom[Internal]{+illegal-deferred-error-prompt+}

\Valuelabel
\begin{CompactCode}
"~S is an illegal deferred option for slot ~S of ~A; allowed is only NIL or a number."
\end{CompactCode}

\Purposelabel
Prompt which is shown in the error message
 concerning invalid \lisp{deferred}\ slot options.


\endcom

\begincncom[Internal]{+illegal-extent-error-prompt+}

\Valuelabel
\begin{CompactCode}
"~S is an illegal extent for slot ~S of ~A; allowed are ~S."
\end{CompactCode}

\Purposelabel
Prompt which is shown in the error message
 concerning invalid slot extents.


\endcom

\beginvrcom[Internal]{*in-bootstrap-p*}

\Initialvaluelabel
\begin{CompactCode}
nil
\end{CompactCode}

\Purposelabel
 A flag indicating if the bootstrap is active. If \nonnil,
 this indicates to some functions that the system is in the
 bootstrap phase; this will causes some methods to call
 low-level accessor functions directly.
\Seealsolabel
 \Fcite{*in-bootstrap-wait-timeout*};
 \fcite{open-heap}.


\endcom

\beginpmcom[Internal]{*in-bootstrap-wait-timeout*}

\Initialvaluelabel
\begin{CompactCode}
60
\end{CompactCode}

\Purposelabel
 The max.\ time in seconds a LISP process will wait until the process
 doing the \plob\ bootstrap will have finished the bootstrap.
\Seealsolabel
 \Fcite{*in-bootstrap-p*};
 \fcite{open-heap}.


\endcom

\begincncom[Internal]{+index-kind->constructor+}

\Valuelabel
\begin{CompactCode}
`((hash-table ,@#'make-hash-table) (btree ,@#'make-btree))
\end{CompactCode}

\Purposelabel
 Maps the \lisp{car}\ of the \lisp{:index}\ slot option's value
 to a function which creates the object which holds the index.
\Seealsolabel
 \Fcite{make-index}


\endcom

\beginfncom[Internal]{insert-into-btree-cache}

\Syntaxlabel
\Defun {insert-into-btree-cache} {{\funarg{data}} {\funarg{entry-key}} {\funarg{p-btree}} {\funarg{depth}} {\funarg{data-objid}} {\funarg{data-type-tag}}}


\Argumentslabel
 \isanobject{\funarg{data}}
 \isanobject{\funarg{entry-key}}
 \isabtree{\funarg{p-btree}}
 \isanobjid{\funarg{data-objid}}
 \isatypetag{\funarg{data-type-tag}}
\Purposelabel
 Internal used function.
 Insert \funarg{data}, \funarg{data-objid},
 \funarg{data-type-tag}\ associated to \funarg{entry-key}\ into the
 cache of \funarg{p-btree}.


\endcom

\begincncom[Internal]{+inspector-btree-page-slot-name-next+}

\Valuelabel
\begin{CompactCode}
"  Next of `~A' ->"
\end{CompactCode}

\Purposelabel
The slot name to show for a btree page next slot.


\endcom

\begincncom[Internal]{+inspector-btree-page-slot-name-parent+}

\Valuelabel
\begin{CompactCode}
"  Parent ->"
\end{CompactCode}

\Purposelabel
The slot name to show for a btree page parent slot.


\endcom

\beginvrcom[Internal]{*instance->data-vector-cache*}

\Initialvaluelabel
\begin{CompactCode}
(make-hash-table :test #'eql)
\end{CompactCode}

\Purposelabel
 A cache mapping an \objid\ of a persistent \clos\ instance
 to the \objid\ of the data vector of the instance.
\Seealsolabel
 \Fcite{p-instance-data-vector}.


\endcom

\beginfncom[Internal]{int-vector}

\Syntaxlabel
\Defun {int-vector} {{\funarg{vector}} {\funarg{location}}}

Return the element at \funarg{location}\ in \funarg{vector}.


\endcom

\beginfncom[Internal]{(setf int-vector)}

\Syntaxlabel
\Defun {(setf int-vector)} {{\funarg{new-value}} {\funarg{vector}} {\funarg{location}}}

Set the element at \funarg{location}\ in \funarg{vector}\ 
 to \funarg{new-value}.


\endcom

\beginfncom[Internal]{int-vector-fill}

\Syntaxlabel
\Defun {int-vector-fill} {{\funarg{vector}} {\funarg{item}}}

Set all elements in \funarg{vector}\ to \funarg{item}.


\endcom

\beginfncom[Internal]{int-vector-length}

\Syntaxlabel
\Defun {int-vector-length} {{\funarg{vector}}}

Return the number of elements in \funarg{vector}.


\endcom

\beginfncom[Internal]{int-vector-to-c-pointer}

\Syntaxlabel
\Defun {int-vector-to-c-pointer} {{\funarg{vector}}}

Return \funarg{vector}\ converted into a C pointer
 addressing the vector.


\endcom

\beginfncom[Internal]{int-vector-to-vector}

\Syntaxlabel
\Defun {int-vector-to-vector} {{\funarg{vector}}}

Return \funarg{vector}\ converted into a vector.


\endcom

\beginfncom[Internal]{internal-to-external-name}

\Syntaxlabel
\Defun {internal-to-external-name} {{\funarg{internal-name}}}


\Purposelabel
 See comment at \fcite{external-to-internal-name}.
\Seealsolabel
 \Fcite{external-to-internal-name}


\endcom

\beginfncom[Internal]{invalidate-all-globals}

\Syntaxlabel
\Defun {invalidate-all-globals} {}


\Purposelabel
 Invalidate all global variables. This marks the \sh\ as
 `logically closed'.
\Seealsolabel
 \Fcite{close-heap}.


\endcom

\beginfncom[Internal]{is-on-idle-sleep-hook}

\Syntaxlabel
\Defun {is-on-idle-sleep-hook} {{\funarg{function-symbol}}}


\Argumentslabel
 \isa{\funarg{function-symbol}}
      {the name of a function taking no arguments}
\Purposelabel
 Check if \funarg{function-symbol}\ is on the idle sleep hook.
\Remarkslabel
 \sysdep{function}

 Hint for portability:
 Should always return \lispnil\ if the used \cl\ system has no
 idle sleep hook at all.
\Seealsolabel
 \Fcite{push-to-idle-sleep-hook};
 \fcite{remove-from-idle-sleep-hook};
 section \fcite{process ...}.


\endcom

\beginfncom[Internal]{is-registered-object}

\Syntaxlabel
\Defun {is-registered-object} {{\funarg{t-object}}}


\Argumentslabel
 \isanobject{\funarg{t-object}}
\Purposelabel
 Returns the \objid\ of the transient object
 \funarg{t-object}\ if found in the cache,
 \lispnil\ otherwise.
\Seealsolabel
 \Fcite{register-to-cache};
 \fcite{is-registered-objid};
 \fcite{registered-objid-p}.


\endcom

\beginfncom[Internal]{is-registered-objid}

\Syntaxlabel
\Defun {is-registered-objid} {{\funarg{p-objid}}}


\Argumentslabel
 \isanobjid{\funarg{p-objid}}
\Purposelabel
 Returns the transient object which is associated to \funarg{p-objid}.
\Seealsolabel
 \Fcite{register-to-cache};
 \fcite{registered-objid-p};
 \fcite{is-registered-object}.


\endcom

\begincncom[Internal]{+least-negative-p-fixnum+}

\Valuelabel
\begin{CompactCode}
(- (ash 1 (1- +p-fixnum-bits+)))
\end{CompactCode}

\Purposelabel
The largest representable positive persistent fixnum.


\endcom

\begincncom[Internal]{+length-structure-persistent-slot-names+}

\Valuelabel
\begin{CompactCode}
(length +structure-persistent-slot-names+)
\end{CompactCode}

\Purposelabel
The length of the list in
 \fcite{+structure-persistent-slot-names+}.


\endcom

\begincncom[Internal]{+lisp-code-type+}

\Valuelabel
\begin{CompactCode}
:wfasl
\end{CompactCode}

\Purposelabel
 Contains the kind of compiled \cl\ code for this \cl\ system.
\Remarkslabel
 \sysdep{constant}

 Hint for portability:
 For each code kind an own keyword symbol should be defined;
 The value of \lisp{+lisp-code-type+}\ reflects the kind of
 code this \cl\ compiler generates.
\Exampleslabel
 For \lwcl\ running on SUN SPARCs,
 the code kind is \lisp{:wfasl}.


\endcom

\begincncom[Internal]{+lisp-symbolic-system-name+}

\Valuelabel
\begin{CompactCode}
(or :lispworks4)
\end{CompactCode}

\Purposelabel
 The name of the current LISP system as a keyword symbol.


\endcom

\beginvrcom[Internal]{*lisp-type->subtypes*}

\Initialvaluelabel
\begin{CompactCode}
(make-hash-table :test #'eql)
\end{CompactCode}

\Purposelabel
 A variable used for mapping \cl\ built-in classes to its
 subtypes. Used in \fcite{p-upgraded-array-element-tag}.
\Seealsolabel
 \Fcite{*lisp-type->type-tag*}


\endcom

\beginvrcom[Internal]{*lisp-type->type-tag*}

\Initialvaluelabel
\begin{CompactCode}
(make-hash-table :test #'eql)
\end{CompactCode}

\Purposelabel
 A variable used for mapping \cl\ types to \typetag[s]. Used
 in \fcite{p-upgraded-array-element-tag}.
\Seealsolabel
 \Fcite{*lisp-type->subtypes*}.


\endcom

\beginvrcom[Internal]{*lisproot-description*}

\Initialvaluelabel
\begin{CompactCode}
nil
\end{CompactCode}

\Purposelabel
 Contains a persistent object of
 \fcite{structure-description}\ describing the
 \fcite{persistent-lisproot}.
\Seealsolabel
 \Fcite{*lisproot-description-objid*}.


\endcom

\beginvrcom[Internal]{*lisproot-description-objid*}

\Initialvaluelabel
\begin{CompactCode}
nil
\end{CompactCode}

\Purposelabel
 Contains the \objid\ of the value of the
 fcite{*lisproot-description*}.
\Seealsolabel
 \Fcite{*lisproot-description*}.


\endcom

\beginpmcom[Internal]{*lisproot-version*}

\Initialvaluelabel
\begin{CompactCode}
101
\end{CompactCode}

\Purposelabel
Contains the actual version number of the LISP root object. Must be
 a fixnum.


\endcom

\begincncom[Internal]{+lispworks-structure-definition-index+}

\Valuelabel
\begin{CompactCode}
13
\end{CompactCode}

\Purposelabel
 The index into the vector returned by the \lw\ function
 {\bf structure::get-structure-definition} which contains the
 structure definition.
\Remarkslabel
 \sysdep{constant}


\endcom

\begincncom[Internal]{+lispworks-structure-definition-location-constructor+}

\Valuelabel
\begin{CompactCode}
13
\end{CompactCode}

\Purposelabel
 The index into the \lw\ structure definition which contains the
 constructor function symbol of the structure.
\Remarkslabel
 \sysdep{constant}


\endcom

\begingfcom[Internal]{load-instance-for-class}

\Syntaxlabel
\Defgen {load-instance-for-class} {{\funarg{t-class-name}} {\funarg{p-class-descr}} {\funarg{p-objid}} {\funarg{depth}} {\funarg{p-heap}} {\opt} {\funarg{t-into-object}}}


\Argumentslabel
 \isasymbol{\funarg{t-class-name}}
 \isa{\funarg{p-class-descr}}
      {either a structure class description or a \clos\ class description}
 \isa{\funarg{p-objid}}
      {either a numeric immediate value or an \objid}
\Valueslabel
 See \fcite{p-objid-to-t-object}.
\Purposelabel
 Load an instance from the \sh\ into the transient memory.

 This generic function can be used to specialize load methods on
 structure and \clos\ classes. 
\Seealsolabel
 \Fcite{p-objid-to-t-object}.


\Methodslabel

\flabel{\protect\mtd}{load-instance-for-class ((eql (quote persistent-hash-table)) structure-description t t t)}{}
{\Defmeth {load-instance-for-class} {(\funarg{t-class-name}\ \ObjectWithRef{(eql 'persistent-hash-table)}) (\funarg{p-class-descr}\ \ObjectWithRef{structure-description}) {\funarg{p-objid}} {\funarg{depth}} {\funarg{p-heap}} {\opt} {\funarg{t-into-object}}}}
%
% No behavior is specified for this method beyond that which is specified
% for the generic function.

\flabel{\protect\mtd}{load-instance-for-class (t class-description t t t)}{}
{\Defmeth {load-instance-for-class} {{\funarg{t-class-name}} (\funarg{class-descr}\ \ObjectWithRef{class-description}) {\funarg{p-objid}} {\funarg{depth}} {\funarg{p-heap}} {\opt} {\funarg{t-into-object}}}}

\Argumentslabel
 \isa{\funarg{class-descr}}
      {a class-description}
 \isanobjid{\funarg{p-objid}}
\Purposelabel
 Return a transient \clos\ instance representing the persistent
 \clos\ instance referenced by \funarg{p-objid}.
\Seealsolabel
 \Fcite{load-instance-for-redefined-class}.

\flabel{\protect\mtd}{load-instance-for-class (t structure-description t t t)}{}
{\Defmeth {load-instance-for-class} {{\funarg{t-class-name}} (\funarg{p-class-descr}\ \ObjectWithRef{structure-description}) {\funarg{p-objid}} {\funarg{depth}} {\funarg{p-heap}} {\opt} {\funarg{t-into-object}}}}
%
% No behavior is specified for this method beyond that which is specified
% for the generic function.


\endcom

\begingfcom[Internal]{load-instance-for-redefined-class}

\Syntaxlabel
\Defgen {load-instance-for-redefined-class} {{\funarg{t-class-name}} {\funarg{p-class-descr-old}} {\funarg{p-class-descr-new}} {\funarg{p-objid}} {\funarg{depth}} {\funarg{p-heap}} {\opt} {\funarg{t-into-object}}}


\Argumentslabel
 \isasymbol{\funarg{t-class-name}}
 \isa{\funarg{p-class-descr-old}}
      {either a structure class description or a \clos\ class description}
 \isa{\funarg{p-class-descr-new}}
      {either a structure class description or a \clos\ class description}
 \isa{\funarg{p-objid}}
      {either a numeric immediate value or an \objid}
\Valueslabel
 See \fcite{p-objid-to-t-object}.
\Purposelabel
 Load an instance from the \sh\ into the transient memory
 for an instance whose class definition was changed from
 \funarg{p-class-descr-old}\ to \funarg{p-class-descr-new}.

 This generic function can be used to specialize load methods on
 structure and \clos\ classes. 
\Seealsolabel
 \Fcite{p-objid-to-t-object}.


\Methodslabel

\flabel{\protect\mtd}{load-instance-for-redefined-class (t class-description class-description t t t)}{}
{\Defmeth {load-instance-for-redefined-class} {{\funarg{t-class-name}} (\funarg{old-class-descr}\ \ObjectWithRef{class-description}) (\funarg{new-class-descr}\ \ObjectWithRef{class-description}) {\funarg{p-objid}} {\funarg{depth}} {\funarg{p-heap}} {\opt} {\funarg{t-into-object}}}}

\Argumentslabel
 \isa{\funarg{old-class-descr}\ resp.\ \funarg{new-class-descr}}
      {a class-description}
 \isanobjid{\funarg{p-objid}}
\Purposelabel
 Return a transient \clos\ instance representing the persistent
 \clos\ instance referenced by \funarg{p-objid}\ whose
 class-description was redefined.
\Seealsolabel
 \Fcite{update-instance-for-redefined-description};
 \fcite{load-instance-for-class};
 \fcite{(setf schema-evolution)}.

\flabel{\protect\mtd}{load-instance-for-redefined-class (t structure-description structure-description t t t)}{}
{\Defmeth {load-instance-for-redefined-class} {{\funarg{t-class-name}} (\funarg{p-class-descr-old}\ \ObjectWithRef{structure-description}) (\funarg{p-class-descr-new}\ \ObjectWithRef{structure-description}) {\funarg{p-objid}} {\funarg{depth}} {\funarg{p-heap}} {\opt} {\funarg{t-into-object}}}}
%
% No behavior is specified for this method beyond that which is specified
% for the generic function.


\endcom

\beginfncom[Internal]{load-instance-for-redefined-structure}

\Syntaxlabel
\Defun {load-instance-for-redefined-structure} {{\funarg{old-struct-descr}} {\funarg{new-struct-descr}} {\funarg{p-objid}} {\funarg{depth}} {\funarg{p-heap}} {\opt} {\funarg{t-into-object}}}


\Argumentslabel
 \isa{\funarg{old-struct-descr}\ resp.\ \funarg{new-struct-descr}}
      {a structure-description}
 \isanobjid{\funarg{p-objid}}
\Purposelabel
 Return a transient structure instance representing the persistent
 structure object referenced by \funarg{p-objid}\ whose
 structure-description was redefined.

 The persistent structure object referenced by \funarg{p-objid}\ is
 migrated (or `schema-evoluted') from its current
 \funarg{old-struct-descr}\ (found in the persistent structure object's
 slot {\bf p-descr}) to the global actual
 \funarg{new-struct-descr}\ (as now contained in the class table,
 i.e.\ the structure-description as returned by
 \fcite{p-find-class}). This migration includes updating the 
 description reference of the structure object to the global
 actual structure description.
\Remarkslabel
 A `full' schema evolution from \funarg{old-struct-descr}\ to
 \funarg{new-struct-descr}\ is only possible if the number of
 slots was not increased; otherwise, the persistent structure
 object's description of \funarg{p-objid}\ is not changed.
 In this case the returned transient structure object contains
 the additional slots initalized to their slot default initializations.

 For redefining \cl\ structures created by
 \lisp{defstruct}\ see also
 \stcite{473, X3J13 vote of January 1989 \lt{}56\gt}.
\Seealsolabel
 \Fcite{load-instance-for-structure};
 \fcite{(setf schema-evolution)}.


\endcom

\beginfncom[Internal]{load-instance-for-structure}

\Syntaxlabel
\Defun {load-instance-for-structure} {{\funarg{struct-descr}} {\funarg{p-objid}} {\funarg{depth}} {\funarg{p-heap}} {\opt} {\funarg{t-into-object}} {\funarg{get-slot-description}}}


\Argumentslabel
 \isa{\funarg{struct-descr}}
      {a structure-description}
 \isanobjid{\funarg{p-objid}}
\Purposelabel
 Return a transient structure instance representing the persistent
 structure object referenced by \funarg{p-objid}.

 This function corresponds roughly to the
 \fcite{make-instance (standard-class)}.
\Seealsolabel
 \Fcite{load-instance-for-redefined-structure};
 \fcite{make-instance (standard-class)}.


\endcom

\begingfcom[Internal]{load-object-into}

\Syntaxlabel
\Defgen {load-object-into} {{\funarg{p-objid}} {\funarg{into-t-object}} {\funarg{depth}} {\funarg{p-heap}}}


\Argumentslabel
 \isanobjid{\funarg{p-objid}}
 \isanobject{\funarg{into-t-object}}
\Valueslabel
 \retarg{\funarg{into-t-object}}
\Purposelabel
 Load a persistent object referenced by
 \funarg{p-objid}\ destructively into \funarg{into-t-object}.
 This generic function is for internal use only;
 it has specialized methods only for a few
 \funarg{into-t-object}'s classes.
\Seealsolabel
 \Fcite{p-objid-to-t-object}.


\Methodslabel

\flabel{\protect\mtd}{load-object-into (t bit-vector t t)}{}
{\Defmeth {load-object-into} {{\funarg{p-objid}} (\funarg{into-t-bit-vector}\ \ObjectWithRef{bit-vector}) {\funarg{depth}} {\funarg{p-heap}}}}
%
% No behavior is specified for this method beyond that which is specified
% for the generic function.

\flabel{\protect\mtd}{load-object-into (t vector t t)}{}
{\Defmeth {load-object-into} {{\funarg{p-objid}} (\funarg{into-t-vector}\ \ObjectWithRef{vector}) {\funarg{depth}} {\funarg{p-heap}}}}
%
% No behavior is specified for this method beyond that which is specified
% for the generic function.


\endcom

\beginfncom[Internal]{load-shared-slots}

\Syntaxlabel
\Defun {load-shared-slots} {{\funarg{the-class}}}

Load all shared slots after a class has been established.


\endcom

\beginfncom[Internal]{load-slot-boundp-using-class}

\Syntaxlabel
\Defun {load-slot-boundp-using-class} {{\funarg{the-class}} {\funarg{the-object}} {\funarg{slot-description}} {\opt} {\funarg{p-heap}}}


\Argumentslabel
 \isacls{\funarg{the-class}}
 \isaclosobject{\funarg{the-object}}
 \isa{\funarg{slot-description}}
      {an effective slot-description}
\Purposelabel
 Check if the slot described by \funarg{slot-description}\ of
 the persistent \clos\ instance \funarg{the-object}\ of class
 \funarg{the-class}\ is bound.
\Seealsolabel
 \Fcite{persistent-slot-boundp-using-class};
 \fcite{slot-boundp-using-class (standard-class t %
effective-slot-description)}.


\endcom

\beginfncom[Internal]{load-slot-value-using-class}

\Syntaxlabel
\Defun {load-slot-value-using-class} {{\funarg{the-class}} {\funarg{the-object}} {\funarg{slot-description}} {\opt} {\funarg{depth}} {\funarg{p-heap}}}


\Argumentslabel
 \isacls{\funarg{the-class}}
 \isaclosobject{\funarg{the-object}}
 \isa{\funarg{slot-description}}
      {an effective slot-description}
\Purposelabel
 Load the value of the slot described by
 \funarg{slot-description}\ of the persistent
 \clos\ instance \funarg{the-object}\ of class
 \funarg{the-class}.
\Seealsolabel
 \Fcite{persistent-slot-value-using-class};
 \fcite{slot-value-using-class (standard-class t %
effective-slot-description)}.


\endcom

\beginfncom[Internal]{load-slot-value-using-class-on-demand}

\Syntaxlabel
\Defun {load-slot-value-using-class-on-demand} {{\funarg{the-class}} {\funarg{the-object}} {\funarg{slot-description}} {\funarg{transient-slot-reader}} {\opt} {\funarg{depth}} {\funarg{p-heap}}}


\endcom

\beginfncom[Internal]{load-slot-value-using-class-on-demand-with-extent}

\Syntaxlabel
\Defun {load-slot-value-using-class-on-demand-with-extent} {{\funarg{the-class}} {\funarg{the-object}} {\funarg{slot-description}} {\funarg{slot-extent}} {\funarg{transient-slot-reader}} {\opt} {\funarg{depth}} {\funarg{p-heap}}}


\Argumentslabel
 \isacls{\funarg{the-class}}
 \isaclosobject{\funarg{the-object}}
 \isa{\funarg{slot-description}}
      {an effective slot-description}
\Purposelabel
 Load the value of the slot described by
 \funarg{slot-description}\ of the persistent
 \clos\ instance \funarg{the-object}\ of class
 \funarg{the-class}.
\Seealsolabel
 \Fcite{persistent-slot-value-using-class};
 \fcite{slot-value-using-class (standard-class t %
effective-slot-description)}.


\endcom

\beginfncom[Internal]{load-structure-slot}

\Syntaxlabel
\Defun {load-structure-slot} {{\funarg{struct-descr}} {\funarg{slot-descr}} {\funarg{t-object}} {\funarg{p-objid}} {\funarg{depth}} {\funarg{p-heap}}}


\Argumentslabel
 \isa{\funarg{struct-descr}}
      {a structure-description}
 \isa{\funarg{slot-descr}}
      {a structure slot description}
 \isa{\funarg{t-object}}
      {a transient structure object}
\Purposelabel
 Load the transient representation of the persistent object referenced
 by \funarg{p-objid}\ if \funarg{p-objid}'s transient
 representation is of \fcite{slot-load-on-demand}.

 This function is called by the slot load function which was replaced
 for the system-generated structure slot read function, see
 \fcite{establish-all-slot-loaders}. The
 \funarg{p-objid}\ argument is the value loaded in the slot
 denoted by the \funarg{slot-descr}\ in structure class given by the
 \funarg{struct-descr}\ argument of the structure object
 \funarg{t-object}. The idea is that at structure object load-time
 for a structure slot which should be loaded on demand there
 is not put the `real' (i.e.\ fully loaded persistent object
 contained in the slot) slot value into the structure object's
 slot but an instance of
 \fcite{slot-load-on-demand}\ which contains itself only the
 \objid\ of the slot-value. The system-generated structure slot
 reader for a structure slot was replaced with a \plob-generated
 structure slot reader function which calls this function in turn;
 when this reader function finds an instance of
 \fcite{slot-load-on-demand}\ as the structure slot's value, it
 replaces the structure slot's value by the `real' (i.e.\ now fully
 loaded persistent object contained in the slot) slot value.
\Seealsolabel
 \Fcite{structure-description};
 \fcite{structure-slot-description}.


\endcom

\beginfncom[Internal]{local-url-p}

\Syntaxlabel
\Defun {local-url-p} {{\opt} {\funarg{url}}}


 Check if the passed URL is refererring a local database.


\endcom

\begincncom[Internal]{+logical-pathname-class+}

\Valuelabel
\begin{CompactCode}
(find-class 'logical-pathname)
\end{CompactCode}

\Purposelabel
The \clsmo\ of class \class{logical-pathname}.


\endcom

\beginfncom[Internal]{make-2-map-keys}

\Syntaxlabel
\Defun {make-2-map-keys} {{\funarg{less}} {\funarg{lessp}} {\funarg{less-equal}} {\funarg{less-equal-p}} {\funarg{greater}} {\funarg{greaterp}} {\funarg{greater-equal}} {\funarg{greater-equal-p}} {\funarg{depth}} {\funarg{p-heap}}}


\endcom

\begingfcom[Internal]{make-accessor-lambda}

\Syntaxlabel
\Defgen {make-accessor-lambda} {{\funarg{generic-function}} {\funarg{method}} {\funarg{environment}}}


 \Argumentslabel
  \isa{\funarg{generic-function}}
       {a generic function metaobject}
  \isa{\funarg{method}}
       {a method metaobject of a subclass of
        \class{standard-accessor-method}}
 \Valueslabel
  Returns a $\lambda$-expression to use as method function for
  \funarg{method}.
 \Purposelabel
  Make a $\lambda$-expression for a slot accessor method.
  The code returned is intended to be used for accessing
  an instance slot. The $\lambda$-expression returned
  takes one argument (an instance) for reader-methods
  and two arguments (a new value and an instance) for
  writer methods.

  Similar to \fcite{make-method-lambda}.


\Methodslabel

\flabel{\protect\mtd}{make-accessor-lambda (standard-generic-function persistent-reader-method t)}{}
{\Defmeth {make-accessor-lambda} {(\funarg{generic-function}\ \ObjectWithRef{standard-generic-function}) (\funarg{method}\ \ObjectWithRef{persistent-reader-method}) {\funarg{environment}}}}
%
% No behavior is specified for this method beyond that which is specified
% for the generic function.

\flabel{\protect\mtd}{make-accessor-lambda (standard-generic-function persistent-writer-method t)}{}
{\Defmeth {make-accessor-lambda} {(\funarg{generic-function}\ \ObjectWithRef{standard-generic-function}) (\funarg{method}\ \ObjectWithRef{persistent-writer-method}) {\funarg{environment}}}}
%
% No behavior is specified for this method beyond that which is specified
% for the generic function.


\endcom

\beginfncom[Internal]{make-effective-slot-lambda}

\Syntaxlabel
\Defun {make-effective-slot-lambda} {{\funarg{the-class}} {\funarg{slot-name}}}


 \Argumentslabel
  \isacls{\funarg{the-class}}
  \isa{\funarg{slot-name}}
       {a symbol naming a slot of \funarg{the-class}}
 \Purposelabel
  Returns a $\lambda$-expression which returns the effective slot
  definition metaobject of the slot named
  \funarg{slot-name}\ in \funarg{the-class}\ when called.
  The returned $\lambda$-expression is very similar to the body
  of the \fcite{find-effective-slot-description}.
 \Seealsolabel
  \Fcite{find-effective-slot-description}.


\endcom

\beginfncom[Internal]{make-extra-class-options}

\Syntaxlabel
\Defun {make-extra-class-options} {{\funarg{class-descr}}}


\Argumentslabel
 \isa{\funarg{class-descr}}
      {a class description}
\Purposelabel
 Returns a human-readable form of the extra class options
 specified for \funarg{class-descr}.


\endcom

\beginfncom[Internal]{make-index}

\Syntaxlabel
\Defun {make-index} {{\funarg{index-kind-and-create-options}}}


\Argumentslabel
 \isa{\funarg{index-kind-and-create-options}}
      {the value of the \lisp{:index}\ slot option as specified
       in the slot definition in the \lisp{defclass}\ statement}
\Valueslabel
 Returns the object which maintains the index, for now this
 is always a BTree.
\Purposelabel
 Create an index-maintaining object from the value of the
 \lisp{:index}\ slot option as specified in the slot definition
 in the \lisp{defclass}\ statement; see comment of
 \fcite{persistent-metaclass}, additional slot option
 \lisp{:index}, for details.
\Remarkslabel
 For now persistent BTree objects are supported as index-maintaining
 objects.
\Seealsolabel
 \Fcite{persistent-metaclass};
 section \fcite{index ...}.


\endcom

\beginfncom[Internal]{make-int-vector}

\Syntaxlabel
\Defun {make-int-vector} {{\funarg{length}} {\opt} {\funarg{dynamic}}}


\Purposelabel
  Make a vector of \funarg{length}\ elements holding signed C integers.
\Seealsolabel
  \Fcite{free-int-vector}.


\endcom

\beginfncom[Internal]{make-logical-pathname-by-plob}

\Syntaxlabel
\Defun {make-logical-pathname-by-plob} {\key {\keyarg{host}} {\keyarg{directory}} {\keyarg{name}} {\keyarg{type}} {\keyarg{version}}}


\Argumentslabel
 \isa{\keyarg{host}\ %
       resp.\ \keyarg{directory}\ %
       resp.\ \keyarg{name}\ %
       resp.\ \keyarg{type}\ %
       resp.\ \keyarg{version}}
      {a string}
\Purposelabel
 Create a \lw\ logical pathname which is loaded by \plob.
\Seealsolabel
 \Fcite{(setf class-constructor)}.


\endcom

\beginfncom[Internal]{make-map-key}

\Syntaxlabel
\Defun {make-map-key} {{\funarg{value}} {\funarg{type-tag}} {\funarg{depth}} {\funarg{p-heap}}}


\endcom

\beginfncom[Internal]{make-process-heap}

\Syntaxlabel
\Defun {make-process-heap} {}


\Purposelabel
 Lightweight process variable initialization.



\endcom

\beginfncom[Internal]{make-process-variable}

\Syntaxlabel
\Defun {make-process-variable} {{\funarg{variable}} {\opt} {\funarg{initform}} {\funarg{on-end}}}


\Argumentslabel
 \isa{\funarg{variable}}
      {a symbol}
 \isa{\funarg{initform}}
      {either a symbol optional bound to a function
       or a list with its \lisp{car}\ being a symbol bound to a function
       and the \lisp{cdr}\ being an argument list for that function}
\Purposelabel
 If the \funarg{initform}\ argument is missing,
 remove the \funarg{variable}\ from the list of lisp-internal
 process-local (i.e.\ session-local) variables for the each new
 created process.

 If the \funarg{initform}\ argument is given,
 makes the \funarg{variable}\ a lisp-internal process-local
 (i.e.\ session-local) variable for the each new created process.

 If the first form of \funarg{initform}\ is passed,
 each new \funarg{variable}\ is either initialized to
 \funarg{initform}\ if \funarg{initform}\ is not bound to a
 function or it is initialized to the evaluation of
 \funarg{initform}\ with no arguments if \funarg{initform}\ is
 bound to a function.

 If the second form of \funarg{initform}\ is passed,
 each new \funarg{variable}\ is initialized to the
 evaluation of \funarg{initform}.
\Remarkslabel
 \sysdep{function}

 Hint for \allegro:
 The multi-processing interface of \allegro\ is almost the same
 as the one of \lw; the variable called 
 \textbf{mp:*process-initial-bindings*} in \lw is called
 \textbf{excl:*cl-default-special-bindings*} in \allegro.
\Exampleslabel
 This call makes \lisp{*default-persistent-heap*}\ a lisp-internal
 process-local variable initialized to the evaluation of
 \lisp{(make-persistent-heap)}\ each time \lw\ creates a new
 lisp-internal process, i.e.\ every lisp-internal process has
 `an own' value for \lisp{*default-persistent-heap*}:
 \begin{lispcode}
(make-process-variable '*default-persistent-heap*
                       '(make-persistent-heap))
 \end{lispcode}
\Seealsolabel
 Section \fcite{process ...};
 \lw\ variable \textbf{mp:*process-initial-bindings*};
 \allegro\ variable \textbf{excl:*cl-default-special-bindings*}.


\endcom

\beginfncom[Internal]{make-stable-heap-description}

\Syntaxlabel
\Defun {make-stable-heap-description} {}


Return a string describing the Stable Heap to be created.


\endcom

\beginfncom[Internal]{make-structure-description}

\Syntaxlabel
\Defun {make-structure-description} {{\opt} {\funarg{objid}}}


\Purposelabel
 Returns a new allocated transient structure-description.
\Seealsolabel
 \Fcite{structure-description}.


\endcom

\beginfncom[Internal]{make-structure-slot-description}

\Syntaxlabel
\Defun {make-structure-slot-description} {{\opt} {\funarg{objid}}}


\Purposelabel
 Returns a new allocated transient structure-slot-description.
\Seealsolabel
 \Fcite{structure-slot-description}.


\endcom

\beginfncom[Internal]{make-structure-slot-loader}

\Syntaxlabel
\Defun {make-structure-slot-loader} {{\funarg{struct-descr}} {\funarg{slot-descr}} {\funarg{old-slot-reader}}}


\Argumentslabel
 \isa{\funarg{struct-descr}}
      {a structure-description}
 \isa{\funarg{slot-descr}}
      {a structure slot description}
 \isa{\funarg{old-slot-reader}}
      {the system-generated structure slot reader function
       for structure slot \funarg{slot-descr}\ of instances
       of structure class \funarg{struct-descr}}
\Purposelabel
 Returns a function object suitable as a structure slot reader
 with loading of the structure slot's value on demand
 for structure slot \funarg{slot-descr}\ of instances of structure
 class \funarg{struct-descr}.
\Seealsolabel
 \Fcite{load-structure-slot};
 \fcite{establish-all-slot-loaders};
 \fcite{structure-description}.


\endcom

\beginfncom[Internal]{make-unloadable-function-stub}

\Syntaxlabel
\Defun {make-unloadable-function-stub} {{\funarg{p-objid}}}


\Purposelabel
 Returns a $\lambda$-expression which signals an error like
 \begin{quote}\tt
 Unloadable \plob\ function \funarg{p-objid}\ called \ldots
 \end{quote}
 on being called. This is used as code for a function whose name
 was not found at load time in the current \cl\ image.
\Seealsolabel
 \Fcite{p-function}.


\endcom

\beginfncom[Internal]{make-url-from-string}

\Syntaxlabel
\Defun {make-url-from-string} {{\funarg{url-string}}}


\Purposelabel
  Make an instance of \fcite{url}\ from \funarg{url-string}.
\Seealsolabel
  \Fcite{split-url}.


\endcom

\begincncom[Internal]{+map-buffer-size+}

\Valuelabel
\begin{CompactCode}
256
\end{CompactCode}

\Purposelabel
 Size of the mapping buffers used for returning multiple values from
 the \plob\ low-level btree mapping functions.


\endcom

\beginfncom[Internal]{map-comparetag-to-keyword}

\Syntaxlabel
\Defun {map-comparetag-to-keyword} {{\funarg{comparetag}}}


\endcom

\beginfncom[Internal]{map-numeric-loginp}

\Syntaxlabel
\Defun {map-numeric-loginp} {{\funarg{numeric-loginp}}}


\Purposelabel
 Map the \funarg{numeric-loginp}\ to a keyword symbol.


\endcom

\beginfncom[Internal]{mapappend}

\Syntaxlabel
\Defun {mapappend} {{\funarg{fun}} {\rest} {\funarg{args}}}


\Argumentslabel
 \isa{\funarg{fun}}
      {a function taking a list argument}
 \isa{\funarg{args}}
      {a list}
\Purposelabel
 {\bf mapappend} is like the \fcite{mapcar}\ except
 that the results are appended together.
\Seealsolabel
 \Fcite{mapappend};
 \fcite{mapcar}.


\endcom

\begingfcom[Internal]{mapbtree-internal}

\Syntaxlabel
\Defgen {mapbtree-internal} {{\funarg{map-function}} {\funarg{p-btree-objid}} {\funarg{start-value}} {\funarg{start-type-tag}} {\funarg{compare-start}} {\funarg{end-value}} {\funarg{end-type-tag}} {\funarg{compare-end}} {\funarg{descending}} {\funarg{filter}} {\funarg{p-heap}}}


\Argumentslabel
 For the \funarg{map-function}, \funarg{start-value}\ and
 \funarg{end-value}\ arguments see \fcite{mapbtree}.
 \isanobjid{\funarg{p-btree-objid}}
 \isatypetag{\funarg{start-type-tag}}
 \isatypetag{\funarg{end-type-tag}}
\Purposelabel
 Internal used function for \fcite{mapbtree}.
\Remarkslabel
 There are some problems with \lw\ 3.2.0: The methods of
 {\bf mapbtree-internal} call C code which calls \cl\ code
 which might call C code again.
 This seems to trash either the foreign language stack or
 the \cl\ stack a little bit so that there are shown error
 messages like
 \begin{quote}\tt
  <**> pointer out of bounds in fixup-stack pointer 7ff4ea
  field 10ca0fcc stack 10c92393
 \end{quote}
 in the shell window from which \lw\ has been started up.
 These kind of messages normally indicate heavy problems
 with the garbage collector which normally crashes the system,
 but \lw\ 3.2.0 keeps on running (stable?).

 In \lw\ 3.1.1 these problems did not occure; so the indicated
 problem is perhaps an effect of an `optimization degration' done
 for the foreign language interface of 3.2.0.
\Seealsolabel
 \Fcite{mapbtree}.


\Methodslabel

\flabel{\protect\mtd}{mapbtree-internal (t t float t t float t t t t t)}{}
{\Defmeth {mapbtree-internal} {{\funarg{map-function}} {\funarg{p-btree-objid}} (\funarg{start-value}\ \ObjectWithRef{float}) {\funarg{start-type-tag}} {\funarg{compare-start}} (\funarg{end-value}\ \ObjectWithRef{float}) {\funarg{end-type-tag}} {\funarg{compare-end}} {\funarg{descending}} {\funarg{filter}} {\funarg{p-heap}}}}
%
% No behavior is specified for this method beyond that which is specified
% for the generic function.

\flabel{\protect\mtd}{mapbtree-internal (t t integer t t integer t t t t t)}{}
{\Defmeth {mapbtree-internal} {{\funarg{map-function}} {\funarg{p-btree-objid}} (\funarg{start-value}\ \ObjectWithRef{integer}) {\funarg{start-type-tag}} {\funarg{compare-start}} (\funarg{end-value}\ \ObjectWithRef{integer}) {\funarg{end-type-tag}} {\funarg{compare-end}} {\funarg{descending}} {\funarg{filter}} {\funarg{p-heap}}}}
%
% No behavior is specified for this method beyond that which is specified
% for the generic function.

\flabel{\protect\mtd}{mapbtree-internal (t t string t t string t t t t t)}{}
{\Defmeth {mapbtree-internal} {{\funarg{map-function}} {\funarg{p-btree-objid}} (\funarg{start-value}\ \ObjectWithRef{string}) {\funarg{start-type-tag}} {\funarg{compare-start}} (\funarg{end-value}\ \ObjectWithRef{string}) {\funarg{end-type-tag}} {\funarg{compare-end}} {\funarg{descending}} {\funarg{filter}} {\funarg{p-heap}}}}
%
% No behavior is specified for this method beyond that which is specified
% for the generic function.


\endcom

\begingfcom[Internal]{mapindex}

\Syntaxlabel
\Defgen {mapindex} {{\funarg{map-function}} {\funarg{the-table}} {\rest} {\funarg{rest-args}}}


\Argumentslabel
 \isa{\funarg{map-function}}
      {a function which accepts two arguments}
 \isaidxtable{\funarg{the-table}}
 \isa{\funarg{rest-args}}
      {a list of arguments which will be passed to the called
       mapping function}
\Purposelabel
 \idxadmfn:
 For each entry in \funarg{the-table}\ matching the
 \funarg{rest-args}, the \funarg{map-function}\ on
 two arguments should be called: the key (i.e.\ a slot value) and
 associated data (i.e.\ a persistent \clos\ object) of the index entry.

 The called \funarg{map-function}\ has to return with \nonnil\ to
 continue the mapping; if \funarg{map-function}\ returns
 \lispnil\, the mapping is stopped.

\Seealsolabel
 Section \fcite{index ...}.


\Methodslabel

\flabel{\protect\mtd}{mapindex (t persistent-btree)}{}
{\Defmeth {mapindex} {{\funarg{map-function}} (\funarg{the-table}\ \ObjectWithRef{persistent-btree}) {\rest} {\funarg{rest-args}}}}
Trapped to \fcite{mapbtree}.


\endcom

\beginvrcom[Internal]{*marker-tag->marker-object*}

\Initialvaluelabel
\begin{CompactCode}
(make-hash-table :test #'equal)
\end{CompactCode}

\Purposelabel
A hash table mapping a marker tag to a marker object.


\endcom

\beginpmcom[Internal]{*max-lisp-addr*}

\Initialvaluelabel
\begin{CompactCode}
(or)
\end{CompactCode}

\Purposelabel

 Max.\ address which is in use by LISP. For using a local client, this is
 the address where the POSTORE library will map the database file in.


\endcom

\beginfncom[Internal]{merge-urls}

\Syntaxlabel
\Defun {merge-urls} {{\funarg{first-url}} {\rest} {\funarg{more-urls}}}


\Purposelabel
 Merge URLs.
\Seealsolabel
 \Fcite{url}, \fcite{merge-pathnames}.


\endcom

\begincncom[Internal]{+metaheap-description+}

\Valuelabel
\begin{CompactCode}
"Metaheap"
\end{CompactCode}

\Purposelabel

 The description string of the persistent heap used for storing and loading
 of metaobjects.


\endcom

\begincncom[Internal]{+metaobject-class+}

\Valuelabel
\begin{CompactCode}
(find-class 'metaobject)
\end{CompactCode}

\Purposelabel
The \clsmo\ of class \class{metaobject}.


\endcom

\beginclcom[Internal]{method-description}

\Purposelabel
 A transient class representing persistent method descriptions.
 In the sense of \clos, this class corresponds roughly to the
 \std\ \mtdmc\ \class{standard-method}.
\Remarkslabel
 \basecls{method-description}

 Since \plob\ cannot store function code (see comment of
 \fcite{(setf p-function)}), instances of
 \class{method-description}\ have more or less documentary
 properties; therefore, no
 method-descriptions are generated or stored in a class-description.
 To store method-descriptions along with class-descriptions,
 re-compile \plob\ with the keyword
 \lisp{:store-methods}\ pushed into the {\bf *features*}-list.


\Directsuperclasseslabel
\Defmethod{}{\tt}{(\ObjectWithRef{plob-description})}{}


\Directslotslabel

\Defdslot {p-name} {:accessor method-description-name\newline :initform nil\newline :type symbol\newline :location +method-description-location-name+}


 The name of the method's generic function as a symbol.

\Defdslot {p-function} {:accessor method-description-function\newline :reader method-function\newline :initform nil\newline :location +method-description-location-function+}


 The function of the method;
 comparable with the returned value from
 \fcite{method-function}.
 For the restrictions on storing functions in \plob,
 see \fcite{p-function}\ and \fcite{(setf p-function)}.

\Defdslot {p-lambda-list} {:accessor method-description-lambda-list\newline :reader method-lambda-list\newline :initform nil\newline :location +method-description-location-lambda-list+}


 The unspecialized $\lambda$-list of the method;
 comparable with the returned value from
 \fcite{method-lambda-list}.

\Defdslot {p-specializers} {:accessor method-description-specializers\newline :reader method-specializers\newline :initform nil\newline :location +method-description-location-specializers+}


 The list of specializers of the method;
 comparable with the returned value from
 \fcite{method-specializers}.

\Defdslot {p-qualifiers} {:accessor method-description-qualifiers\newline :reader method-qualifiers\newline :initform nil\newline :location +method-description-location-qualifiers+}


 The list of qualifiers of the method;
 comparable with the returned value from
 \fcite{method-qualifiers}.


\Metaclasslabel
\Defmethod{}{\tt}{\ObjectWithRef{persistent-metaclass}}{}


\Classoptionslabel
\Defmethod{}{\tt}{:extent :cached\newline :schema-evolution :no-evolution}{}


\endcom

\beginvrcom[Internal]{*method-description*}

\Initialvaluelabel
\begin{CompactCode}
nil
\end{CompactCode}

\Purposelabel
 Contains a persistent object of
 \fcite{class-description}\ describing the
 \fcite{method-description}.
\Seealsolabel
 \Fcite{*method-description-objid*}.


\endcom

\beginfncom[Internal]{method-description-equal-p}

\Syntaxlabel
\Defun {method-description-equal-p} {{\funarg{t-method-descr}} {\funarg{p-method-descr}} {\opt} {\funarg{verbose}}}


\Argumentslabel

 \isa{\funarg{t-method-descr}\ resp.\ \funarg{p-method-descr}}
      {a method description}

\Purposelabel

 Returns \nonnil\ iff the (transient) method description
 \funarg{t-method-descr}\ and the (persistent) method description
 \funarg{p-method-descr}\ are \lisp{equal}, \lispnil\ otherwise.


\endcom

\message{^^JGeneric function plob::method-description-function has no methods.^^J}
\message{^^JGeneric function (setf plob::method-description-function) has no methods.^^J}
\message{^^JGeneric function plob::method-description-lambda-list has no methods.^^J}
\message{^^JGeneric function (setf plob::method-description-lambda-list) has no methods.^^J}
\message{^^JGeneric function plob::method-description-name has no methods.^^J}
\message{^^JGeneric function (setf plob::method-description-name) has no methods.^^J}
\beginvrcom[Internal]{*method-description-objid*}

\Initialvaluelabel
\begin{CompactCode}
nil
\end{CompactCode}

\Purposelabel
 Contains the \objid\ of the value of the variable
 {\bf *method-description*}.
\Seealsolabel
 \Fcite{*method-description*}.


\endcom

\message{^^JGeneric function plob::method-description-qualifiers has no methods.^^J}
\message{^^JGeneric function (setf plob::method-description-qualifiers) has no methods.^^J}
\message{^^JGeneric function plob::method-description-specializers has no methods.^^J}
\message{^^JGeneric function (setf plob::method-description-specializers) has no methods.^^J}
\message{^^JGeneric function method-function has no methods.^^J}
\message{^^JGeneric function method-lambda-list has no methods.^^J}
\message{^^JGeneric function method-qualifiers has no methods.^^J}
\message{^^JGeneric function method-specializers has no methods.^^J}
\beginclcom[Internal Structure]{migrate-info}

\Purposelabel
 A structure used at schema evolution for migrating an 'old' to a
 'new' persistent structure object;
 used in \fcite{load-instance-for-redefined-structure}.
 For each slot to migrate, an instance of \class{migrate-info}\ is
 created.


\Directslotslabel

\Defdslot {location} {-1\newline :type fixnum}


 The new location of the slot's value in the object.

\Defdslot {value} {+null-objid+\newline :type fixnum}


 Either the immediate value or the \objid\ of the slot's value.

\Defdslot {type} {+short-objid-tag+\newline :type fixnum}


 The \typetag\ of the slot's value.


\Classoptionslabel
\Defmethod{}{\tt}{:constructor make-migrate-info (location value type)}{}


\endcom

\begingfcom[Internal]{mismatch-p}

\Syntaxlabel
\Defgen {mismatch-p} {{\funarg{the-class}}}


\Argumentslabel
 \isacls{\funarg{the-class}}
\Purposelabel
 Check if \funarg{the-class}\ was redefined since the last call to
 \fcite{(setf mismatch-p)}.
\Seealsolabel
 \Fcite{(setf mismatch-p)}.


\Methodslabel

\flabel{\protect\mtd}{mismatch-p (t)}{}
{\Defmeth {mismatch-p} {{\funarg{the-class}}}}
%
% No behavior is specified for this method beyond that which is specified
% for the generic function.


\endcom

\begingfcom[Internal]{(setf mismatch-p)}

\Syntaxlabel
\Defgen {(setf mismatch-p)} {{\funarg{mismatch}} {\funarg{the-class}}}


\Argumentslabel
 \isabool{\funarg{mismatch}}
 \isacls{\funarg{the-class}}
\Valueslabel
  \retarg{\funarg{mismatch}}
\Purposelabel
 Set the mismatch marker of \funarg{the-class}\ to \funarg{mismatch}.
 This should be set when anything in the class
 definition of \funarg{the-class}\ changed.
 It is reset to \lispnil\ when the new class definition
 was written to the persistent store.
\Remarkslabel
 Is used in conjunction with schema evolution. The class is marked
 as mismatched in
 \fcite{reinitialize-instance :after (structure-class)}\ resp.\ %
 \fcite{initialize-instance :before (standard-class)}\ resp.\ %
 \fcite{reinitialize-instance :after (standard-class)};
 the mismatch is then later detected
 by \plob\ by requesting with \fcite{mismatch-p}\ if the
 mismatch marker was set.
\Seealsolabel
 \Fcite{mismatch-p};
 \fcite{reinitialize-instance :after (structure-class)};
 \fcite{initialize-instance :before (standard-class)};
 \fcite{reinitialize-instance :after (standard-class)}.


\Methodslabel

\flabel{\protect\mtd}{(setf mismatch-p) (t t)}{}
{\Defmeth {(setf mismatch-p)} {{\funarg{mismatch}} {\funarg{the-class}}}}
%
% No behavior is specified for this method beyond that which is specified
% for the generic function.


\endcom

\begincncom[Internal]{+most-positive-p-fixnum+}

\Valuelabel
\begin{CompactCode}
(1- (ash 1 (1- +p-fixnum-bits+)))
\end{CompactCode}

\Purposelabel
The largest representable positive persistent fixnum.


\endcom

\beginvrcom[Internal]{*name->package-table*}

\Initialvaluelabel
\begin{CompactCode}
(make-cached-btree)
\end{CompactCode}

\Purposelabel
 The persistent package table.
 Maps a package name string to a persistent package object.
\Seealsolabel
 \Fcite{p-find-package}.


\endcom

\beginfncom[Internal]{namestring-if}

\Syntaxlabel
\Defun {namestring-if} {{\funarg{pathname}}}


\Argumentslabel
  \isa{\funarg{pathname}}
       {a [logical] pathname}
\Valueslabel
 Returns argument \funarg{pathname}\ converted to a string.
\Purposelabel
 Bug-fix for the \lw\ \fcite{namestring}; \lw\ does not return a
 correct path expression for logical pathnames.
\Remarkslabel
 \sysdep{function}
\Seealsolabel
 \Fcite{namestring}.


\endcom

\begincncom[Internal]{+no-slot-error-prompt+}

\Valuelabel
\begin{CompactCode}
"~A is no slot of ~A."
\end{CompactCode}

\Purposelabel
Prompt which is shown in the error message concerning invalid slot names.


\endcom

\begincncom[Internal]{+null-io+}

\Valuelabel
\begin{CompactCode}
(or system::*null-stream* nil)
\end{CompactCode}

\Purposelabel
 A stream sending its output to nirvana.
\Remarkslabel
 \sysdep{constant}

%% Perhaps someone can give me a hint were the term `nirvana' stems
%% from (please, not the suicide-threatened rock-band); send your answer to
%% {\tt kirschke@kogs26.informatik.uni-hamburg.de}.
%%\Seealsolabel
%% Section \fcite{tlatter ...}.



\endcom

\beginclcom[Internal Structure]{objid-buffer}

\Purposelabel
 A structure holding an \objid\ buffer.
 An \objid\ buffer is used for a more efficient communication between
 LISP and the \plob\ C client code. Since the foreign function calls
 to C are rather expensive, an \objid\ buffer holds \emph{all}
 \objid{}s and \typetag{}s contained in a persistent object (so LISP
 doesn't read/write each of it with an extra call).


\Directslotslabel

\Defdslot {objid} {nil}


 The buffered persistent object.

\Defdslot {heap} {nil}


 The heap to use for \objid\ input/output.

\Defdslot {dirty} {nil}


 A flag if the \objid\ buffer has been written to.

\Defdslot {start} {nil}


 The slot index into the referenced persistent object.

\Defdslot {current-size} {0}


 The current size of the \objid\ and \typetag\ buffer.

\Defdslot {objids} {nil}


 The buffer holding the \objid{}s

\Defdslot {type-tags} {nil}


 The buffer holding the \typetag{}s


\Classoptionslabel
\Defmethod{}{\tt}{:constructor make-objid-buffer (objid heap objids type-tags)}{}


\endcom

\beginpmcom[Internal]{*objid-buffer-size*}

\Initialvaluelabel
\begin{CompactCode}
128
\end{CompactCode}

\Purposelabel
The max.\ number of \objid{}s and \typetag{}s
 to hold in a single objid buffer.


\endcom

\beginfncom[Internal]{objid-of-cdr}

\Syntaxlabel
\Defun {objid-of-cdr} {{\funarg{p-heap}} {\funarg{objid}}}


\Argumentslabel
 \isanobjid{\funarg{objid}}
\Purposelabel
 Return the \objid\ of the persistent object
 located in the cdr of the persistent cons
 cell referenced by \funarg{objid}.
\Seealsolabel
 \Fcite{p-cdr}.


\endcom

\begingfcom[Internal]{obsolete-instance-trap-internal}

\Syntaxlabel
\Defgen {obsolete-instance-trap-internal} {{\funarg{class}} {\funarg{old-instance}} {\funarg{old-wrapper}}}



\Argumentslabel

 \isacls{\funarg{class}}
 \isa{\funarg{old-instance}}
      {an obsolete \clos\ instance}
 \isa{\funarg{old-wrapper}}
      {the old class wrapper with a minimal class description
       for \funarg{old-instance}}

\Purposelabel

 This generic function is called by \lw\ when an instance
 is referenced whose class was marked as having obsolete
 instances by a call to the \fcite{make-instances-obsolete}.


\Methodslabel

\flabel{\protect\mtd}{obsolete-instance-trap-internal (persistent-metaclass t t t)}{}
{\Defmeth {obsolete-instance-trap-internal} {(\funarg{class}\ \ObjectWithRef{persistent-metaclass}) {\funarg{oinstance}} {\funarg{owrapper}} {\funarg{special-wrapper}}}}

 This is the obsolete-instance-trap-internal for instances of
 \fcite{persistent-clos-object}; it is called each time
 \clos\ detects an out-of-date instance.
 The \lw\ method
 {\bf obsolete-instance-trap-internal (standard-class t t)}
 cannot be used because \plob\ modifies a \clsmo\ with persistent
 instances so that slots with \lisp{:extent :persistent} are
 not allocated by \clos\ and therefore are also not direct
 accessible by \clos; the mentioned method uses fairly low-level
 accessing functions which do not know about the modifications done
 by \plob\ and will crash \lw\ when called.

 The right solution would be to compute the discarded slots here in
 this method, re-allocate an \clos\ instance vector, modify the
 \funarg{oinstance}\ to use the new re-allocated instance vector,
 fill this new vector from the old one and call
 \fcite{update-instance-for-redefined-class}. Since some
 of these steps involve calling low-low-low-level
 \lw\ \clos\ functions, I ommitted this for now here; only an
 error is signalled.

 Since there might be old instances in the cache,
 the cache is cleared too; so this method is perhaps not
 called any more because the offending instance was only
 found in the cache.
\Seealsolabel
 \Fcite{signal-obsolete-instance-error}.


\endcom

\beginfncom[Internal]{open-objid-buffer}

\Syntaxlabel
\Defun {open-objid-buffer} {{\funarg{p-objid}} {\opt} {\funarg{suggested-size}} {\funarg{p-heap}}}

Open an \objid-buffer.
\Seealsolabel
  \Fcite{objid-buffer}


\endcom

\beginfncom[Internal]{p-allocate}

\Syntaxlabel
\Defun {p-allocate} {{\funarg{p-heap}} {\funarg{type-tag}} {\opt} {\funarg{number-of-extra-references}} {\funarg{extra-values-type-tag}} {\funarg{number-of-extra-values}}}


\Argumentslabel
 \isatypetag{\funarg{type-tag}}
 \isa{\funarg{number-of-extra-objids}\ resp.\ %
       \funarg{number-of-extra-values}}
      {a fixnum}
\Valueslabel
 The \objid\ of the allocated persistent object is returned.
\Purposelabel
 Allocate a persistent object in the \sh\ with a
 \plob\ built-in type referenced by \funarg{type-tag}.

 Table~\ref{tab:layout} shows the \sh\ vector layout
 superposed by \plob\ above the \postore\ vector layout.
 \begin{figure}[htbp]\centering%
 \begin{tabular}{|c|p{7cm}|l|l|}
 \hline
 \tabularheader{Words}
	&\tabularheader{Description}
		&\tabularheader{Reader}
			&\tabularheader{Writer}\\
 \hline\hline
 $1$
  & Size $m$ of reference field in words
   & {\bf p-objid-size}
    & ---\\
 \hline
 $1$
  & Size $n$ of value field in words
   & {\bf p-value-size}
    & ---\\
 \hline
 $1$
  & \TypeTag, Flags
   & {\bf p-type-tag-of}
    & ---\\
 \hline
 $1$
  & Lock-Info
   & \multicolumn{2}{l|}%
     {{\bf p-insert-lock}, {\bf p-set-lock}, {\bf p-unlock}} \\
 \hline
 $m$
  & Reference Field: References to other \sh\ vectors
   & {\bf p-index}
    & {\bf (setf p-index)} \\
 \hline
 $n$
  & Value field: Uninterpreted values
   & {\bf p-values-into}
    & {\bf (setf p-values)}\\
 \hline
 \end{tabular}%
 \caption{\sh\ persistent object layout}\label{tab:layout}%
 \end{figure}%
 The reference resp.\ value field span $m$
 resp.\ $n$ memory words.

 The reference field can only be adressed on a per-element
 basis; this is done by passing an element index into the
 reference field additionally to the \sh\ vector's
 \objid; the element index is zero-origined
 w.r.t.\ the begin of the reference field. It is always checked
 if the passed index is a valid index into the reference field.

 Since no reading or writing of single value elements is necessary,
 the value field can only be adressed as a whole, i.e.\ a
 complete \cl\ immediate vector or string is copied into or
 out of a \sh\ vector. The copying is limited to a maximum of
 $n$ words; no error is signalled when a larger number of words
 was passed to {\bf p-values} resp.\ {\bf (setf p-values)}.
\Remarkslabel
 The \funarg{type-tag}\ is checked by the \plob\ C level if it is a
 valid \typetag; the object's size is derived from \funarg{type-tag}.
 If the class denoted by \funarg{type-tag}\ has a variable-length
 reference resp.\ value field, \funarg{number-of-extra-objids}\ %
 resp.\ \funarg{number-of-extra-values}\ extra reference
 resp.\ value words are additionally allocated; otherwise, the
 parameter \funarg{number-of-extra-objids}\ resp.\ %
 \funarg{number-of-extra-values}\ is ignored.
\Seealsolabel
 \fcite{p-objid-size};
 \fcite{p-value-size};
 \fcite{p-type-tag-of};
 \fcite{p-insert-lock};
 \fcite{p-set-lock};
 \fcite{p-unlock};
 \fcite{p-index};
 \fcite{(setf p-index)};
 \fcite{p-values-into};
 \fcite{(setf p-values)};
 \fcite{sh-create-object}.


\endcom

\beginfncom[Internal]{p-allocate-btree}

\Syntaxlabel
\Defun {p-allocate-btree} {{\opt} {\funarg{p-heap}}}


\Purposelabel
 Returns the \objid\ of a new initially empty persistent BTree
 allocated in the \sh.
\Seealsolabel
 \Fcite{make-btree};
 \fcite{p-allocate}.


\endcom

\beginfncom[Internal]{p-allocate-btree-mapper}

\Syntaxlabel
\Defun {p-allocate-btree-mapper} {{\opt} {\funarg{p-heap}}}


\Purposelabel
 Returns the \objid\ of a new initially empty persistent BTree
 mapper allocated in the \sh.
\Seealsolabel
 \Fcite{make-btree-mapper};
 \fcite{p-allocate}.


\endcom

\beginfncom[Internal]{p-allocate-class-description}

\Syntaxlabel
\Defun {p-allocate-class-description} {{\opt} {\funarg{p-heap}}}


\Purposelabel
 Returns the \objid\ of a new persistent
 class-description
 allocated in the \sh.
\Seealsolabel
 \Fcite{class-description};
 \fcite{p-allocate}.


\endcom

\beginfncom[Internal]{p-allocate-direct-slot-description}

\Syntaxlabel
\Defun {p-allocate-direct-slot-description} {{\opt} {\funarg{p-heap}}}


\Purposelabel
 Returns the \objid\ of a new persistent
 direct-slot-description
 allocated in the \sh.
\Seealsolabel
 \Fcite{direct-slot-description};
 \fcite{p-allocate}.


\endcom

\beginfncom[Internal]{p-allocate-effective-slot-description}

\Syntaxlabel
\Defun {p-allocate-effective-slot-description} {{\opt} {\funarg{p-heap}}}


\Purposelabel
 Returns the \objid\ of a new persistent
 effective-slot-description
 allocated in the \sh.
\Seealsolabel
 \Fcite{effective-slot-description};
 \fcite{p-allocate}.


\endcom

\beginfncom[Internal]{p-allocate-instance}

\Syntaxlabel
\Defun {p-allocate-instance} {{\funarg{class-description}} {\opt} {\funarg{p-heap}}}


\Argumentslabel
 \isa{\funarg{class-description}}
      {a class description}
\Purposelabel
 Returns the \objid\ of a new persistent
 \clos\ instance described by \funarg{class-description}\ allocated
 in the \sh.
\Seealsolabel
 \Fcite{p-allocate}.


\endcom

\beginfncom[Internal]{p-allocate-lisproot}

\Syntaxlabel
\Defun {p-allocate-lisproot} {{\opt} {\funarg{p-heap}}}


\Purposelabel
 Returns the \objid\ of a new persistent
 LISP root
 allocated in the \sh.
\Seealsolabel
 \Fcite{p-allocate}.


\endcom

\beginfncom[Internal]{p-allocate-method-description}

\Syntaxlabel
\Defun {p-allocate-method-description} {{\opt} {\funarg{p-heap}}}


\Purposelabel
 Returns the \objid\ of a new persistent
 method-description
 allocated in the \sh.
\Seealsolabel
 \Fcite{method-description};
 \fcite{p-allocate}.


\endcom

\beginfncom[Internal]{p-bit-vector-into}

\Syntaxlabel
\Defun {p-bit-vector-into} {{\funarg{into-bit-vector}} {\funarg{p-objid}} {\opt} {\funarg{depth}} {\funarg{p-heap}}}


\Argumentslabel
 \isa{\funarg{into-bit-vector}}
      {a bit vector}
 \isanobjid{\funarg{p-objid}}
\Purposelabel
 Read the persistent bit vector referenced by
 \funarg{p-objid}\ destructively into \funarg{into-bit-vector}.
\Seealsolabel
 \Fcite{p-bit-vector}.


\endcom

\beginfncom[Internal]{p-bit-vector-into-internal}

\Syntaxlabel
\Defun {p-bit-vector-into-internal} {{\funarg{p-heap}} {\funarg{p-objid}} {\funarg{into-bit-vector}}}


\Argumentslabel

 See \fcite{p-bit-vector-into}.

\Purposelabel

 Internal used function for \fcite{p-bit-vector-into}.


\endcom

\beginfncom[Internal]{(setf p-chars)}

\Syntaxlabel
\Defun {(setf p-chars)} {{\funarg{from-string}} {\funarg{p-heap}} {\funarg{p-objid}} {\funarg{number-of-characters}}}


\Argumentslabel
 \isa{\funarg{from-string}}
      {a string}
 \isanobjid{\funarg{p-objid}}
 \isa{\funarg{number-of-s}}
      {a fixnum}
\Valueslabel
 Returns either a negative error number or the number of characters
 actually written.
\Purposelabel
 Write to the persistent object's value field referenced by
 \funarg{p-objid}\ from the transient
 \funarg{from-string}\ exact
 \funarg{number-of-characters}\ characters.
\Remarkslabel
 It is checked if a write-lock is set
 on `vector'-level on \funarg{p-objid}; if no lock is
 set, a `vector'-level write lock is set on \funarg{p-objid}.
\Seealsolabel
 \Fcite{p-chars-into};
 \fcite{sh-write-chars}.


\endcom

\beginfncom[Internal]{p-chars-into}

\Syntaxlabel
\Defun {p-chars-into} {{\funarg{p-heap}} {\funarg{p-objid}} {\funarg{into-string}} {\funarg{number-of-characters}}}


\Argumentslabel
 \isanobjid{\funarg{p-objid}}
 \isa{\funarg{into-string}}
      {a string}
 \isa{\funarg{number-of-characters}}
      {a fixnum}
\Valueslabel
 Returns either a negative error number or the number of characters
 actually read.
\Purposelabel
 Read from the persistent object's value field referenced by
 \funarg{p-objid}\ destructively into the transient
 \funarg{into-string}\ a maximum of
 \funarg{number-of-characters}\ characters.
\Remarkslabel
 It is checked if a read-lock is set
 on `vector'-level on \funarg{p-objid}; if no lock is
 set, a `vector'-level read lock is set on \funarg{p-objid}.
\Seealsolabel
 \Fcite{p-allocate};
 \fcite{(setf p-chars)};
 \fcite{sh-read-chars};
 \shcite{function}{SH\us{}read\us{}words}{5}.


\endcom

\beginfncom[Internal]{p-class-description}

\Syntaxlabel
\Defun {p-class-description} {{\funarg{p-objid}} {\opt} {\funarg{depth}} {\funarg{p-heap}}}


\Argumentslabel
 \isanobjid{\funarg{p-objid}}
\Purposelabel
 Return a transient representation for the persistent
 class-description
 referenced by \funarg{p-objid}.
\Seealsolabel
 \Fcite{(setf p-class-description)}.


\endcom

\beginfncom[Internal]{(setf p-class-description)}

\Syntaxlabel
\Defun {(setf p-class-description)} {{\funarg{t-descr}} {\opt} {\funarg{p-objid}} {\funarg{depth}} {\funarg{p-heap}}}


\Argumentslabel
 \isa{\funarg{t-descr}}
      {a class-description}
 \isanobjid{\funarg{p-objid}}
\Valueslabel
 \retarg{\funarg{t-descr}}
\Purposelabel
 Store the transient class-description in
 \funarg{t-descr}\ to the
 persistent class-description referenced by \funarg{p-objid}.
\Seealsolabel
 \Fcite{p-class-description}.


\endcom

\begindccom[Class Description Accessors]{p-class-description- ...}

\Purposelabel
 All following functions
 {\bf p-class-description-\textsl{\lt{}slot-name\gt}} and
 {\bf (setf p-class-description-\textsl{\lt{}slot-name\gt}\/)}
 with \textsl{\lt{}slot-name\gt} being one of the slot names of
 \fcite{class-description}\ without the `p-' prefix
 access directly a slot of a persistent \clos\ instance
 of \fcite{class-description}\ in the \sh.

 The accessor functions defined here are merely used in the
 bootstrap phase. After the bootstrap, the persistent objects of
 \fcite{class-description}\ are created and accessed as all
 persistent \clos\ instances by employing their
 class-descriptions, i.e.\ all information needed to create
 a persistent \clos\ instance or to access a persistent
 \clos\ instance's slot is contained in its class-description.
\Seealsolabel
 \Fcite{class-description};
 section \fcite{bootstrap ...}.


\endcom

\beginfncom[Internal]{p-class-description-constructor}

\Syntaxlabel
\Defun {p-class-description-constructor} {{\funarg{p-objid}} {\opt} {\funarg{depth}} {\funarg{p-heap}}}


\Argumentslabel
 \isanobjid{\funarg{p-objid}}
\Purposelabel
 Get the value of slot
 {\bf p-constructor}
 of the persistent class-description referenced by \funarg{p-objid}.
\Seealsolabel
 Section \fcite{p-class-description- ...}.


\endcom

\beginfncom[Internal]{(setf p-class-description-constructor)}

\Syntaxlabel
\Defun {(setf p-class-description-constructor)} {{\funarg{t-constructor}} {\funarg{p-objid}} {\opt} {\funarg{depth}} {\funarg{p-heap}}}


\Argumentslabel
 \isa{\funarg{t-constructor}}
      {a symbol bound to a function which generates an instance of
       the class described by the persistent class description
       referenced by \funarg{p-objid}}
 \isanobjid{\funarg{p-objid}}
\Purposelabel
 Set the value of slot
 {\bf p-constructor}
 of the persistent class-description referenced by
 \funarg{p-objid}\ to \funarg{t-constructor}.
\Seealsolabel

 Section \fcite{p-class-description- ...}.


\endcom

\beginfncom[Internal]{p-class-description-dependent}

\Syntaxlabel
\Defun {p-class-description-dependent} {{\funarg{p-objid}} {\opt} {\funarg{depth}} {\funarg{p-heap}}}


\Argumentslabel
 \isanobjid{\funarg{p-objid}}
\Purposelabel
 Get the value of slot
 {\bf p-dependent}
 of the persistent class-description referenced by \funarg{p-objid}.
\Seealsolabel
 Section \fcite{p-class-description- ...}.


\endcom

\beginfncom[Internal]{(setf p-class-description-dependent)}

\Syntaxlabel
\Defun {(setf p-class-description-dependent)} {{\funarg{t-dependent}} {\funarg{p-objid}} {\opt} {\funarg{depth}} {\funarg{p-heap}}}


\Argumentslabel
 \isa{\funarg{t-dependent}}
      {a symbol bound to a function which generates an instance of
       the class described by the persistent class description
       referenced by \funarg{p-objid}}
 \isanobjid{\funarg{p-objid}}
\Purposelabel
 Set the value of slot
 {\bf p-dependent}
 of the persistent class-description referenced by
 \funarg{p-objid}\ to \funarg{t-dependent}.
\Seealsolabel

 Section \fcite{p-class-description- ...}.


\endcom

\beginfncom[Internal]{p-class-description-direct-methods}

\Syntaxlabel
\Defun {p-class-description-direct-methods} {{\funarg{p-objid}} {\opt} {\funarg{depth}} {\funarg{p-heap}}}


\Argumentslabel
 \isanobjid{\funarg{p-objid}}
\Purposelabel
 Get the value of slot
 {\bf p-direct-methods}
 of the persistent class-description referenced by \funarg{p-objid}.
\Seealsolabel
 Section \fcite{p-class-description- ...}.


\endcom

\beginfncom[Internal]{(setf p-class-description-direct-methods)}

\Syntaxlabel
\Defun {(setf p-class-description-direct-methods)} {{\funarg{t-direct-methods}} {\funarg{p-objid}} {\opt} {\funarg{depth}} {\funarg{p-heap}}}


\Argumentslabel
 \isa{\funarg{t-direct-methods}}
      {a list or vector either with \mtdmo{}s or method-descriptions}
 \isanobjid{\funarg{p-objid}}
\Purposelabel
 Set the value of slot
 {\bf p-direct-methods}
 of the persistent class-description referenced by
 \funarg{p-objid}\ to \funarg{t-direct-methods}.
\Seealsolabel
 Section \fcite{p-class-description- ...}.


\endcom

\beginfncom[Internal]{p-class-description-direct-slots}

\Syntaxlabel
\Defun {p-class-description-direct-slots} {{\funarg{p-objid}} {\opt} {\funarg{depth}} {\funarg{p-heap}}}


\Argumentslabel
 \isanobjid{\funarg{p-objid}}
\Purposelabel
 Get the value of slot
 {\bf p-direct-slots}
 of the persistent class-description referenced by \funarg{p-objid}.
\Seealsolabel
 Section \fcite{p-class-description- ...}.


\endcom

\beginfncom[Internal]{(setf p-class-description-direct-slots)}

\Syntaxlabel
\Defun {(setf p-class-description-direct-slots)} {{\funarg{t-slots}} {\funarg{p-objid}} {\opt} {\funarg{depth}} {\funarg{p-heap}}}


\Argumentslabel
 \isa{\funarg{t-slots}}
      {a list or vector either with \dir\ \sltmo{}s or
       direct-slot-descriptions}
 \isanobjid{\funarg{p-objid}}
\Purposelabel
 Set the value of slot
 {\bf p-direct-slots}
 of the persistent class-description referenced by
 \funarg{p-objid}\ to \funarg{t-slots}.
\Seealsolabel
 Section \fcite{p-class-description- ...}.


\endcom

\beginfncom[Internal]{p-class-description-effective-slots}

\Syntaxlabel
\Defun {p-class-description-effective-slots} {{\funarg{p-objid}} {\opt} {\funarg{depth}} {\funarg{p-heap}}}


\Argumentslabel
 \isanobjid{\funarg{p-objid}}
\Purposelabel
 Get the value of slot
 {\bf p-effective-slots}
 of the persistent class-description referenced by \funarg{p-objid}.
\Seealsolabel
 Section \fcite{p-class-description- ...}.


\endcom

\beginfncom[Internal]{(setf p-class-description-effective-slots)}

\Syntaxlabel
\Defun {(setf p-class-description-effective-slots)} {{\funarg{t-slots}} {\funarg{p-objid}} {\opt} {\funarg{depth}} {\funarg{p-heap}}}


\Argumentslabel
 \isa{\funarg{t-effective-slots}}
      {a list or vector either with \eff\ \sltmo{}s or
       effective-slot-descriptions}
 \isanobjid{\funarg{p-objid}}
\Purposelabel
 Set the value of slot
 {\bf p-effective-slots}
 of the persistent class-description referenced by
 \funarg{p-objid}\ to \funarg{t-effective-slots}.
\Seealsolabel
 Section \fcite{p-class-description- ...}.


\endcom

\beginfncom[Internal]{p-class-description-into}

\Syntaxlabel
\Defun {p-class-description-into} {{\funarg{t-into-descr}} {\funarg{p-objid}} {\opt} {\funarg{depth}} {\funarg{p-heap}}}


\Argumentslabel
 \isa{\funarg{t-into-descr}}
      {a class-description}
 \isanobjid{\funarg{p-objid}}
\Purposelabel
 Read the persistent class-description referenced by
 \funarg{p-objid}\ destructively into \funarg{t-into-descr}.
\Seealsolabel
 \Fcite{p-class-description}.


\endcom

\beginfncom[Internal]{p-class-description-metaclass}

\Syntaxlabel
\Defun {p-class-description-metaclass} {{\funarg{p-objid}} {\opt} {\funarg{depth}} {\funarg{p-heap}}}


\Argumentslabel
 \isanobjid{\funarg{p-objid}}
\Purposelabel
 Get the value of slot
 {\bf p-metaclass}
 of the persistent class-description referenced by \funarg{p-objid}.
\Seealsolabel
 Section \fcite{p-class-description- ...}.


\endcom

\beginfncom[Internal]{(setf p-class-description-metaclass)}

\Syntaxlabel
\Defun {(setf p-class-description-metaclass)} {{\funarg{t-metaclass}} {\funarg{p-objid}} {\opt} {\funarg{depth}} {\funarg{p-heap}}}


\Argumentslabel
 \isa{\funarg{t-metaclass}}
      {a \clsmo\ or a class-description}
 \isanobjid{\funarg{p-objid}}
\Purposelabel
 Set the value of slot
 {\bf p-metaclass}
 of the persistent class-description referenced by
 \funarg{p-objid}\ to \funarg{t-metaclass}.
\Seealsolabel
 Section \fcite{p-class-description- ...}.


\endcom

\beginfncom[Internal]{p-class-description-name}

\Syntaxlabel
\Defun {p-class-description-name} {{\funarg{p-objid}} {\opt} {\funarg{depth}} {\funarg{p-heap}}}


\Argumentslabel
 \isanobjid{\funarg{p-objid}}
\Purposelabel
 Get the value of slot
 {\bf p-name}
 of the persistent class-description referenced by \funarg{p-objid}.
\Seealsolabel
 Section \fcite{p-class-description- ...}.


\endcom

\beginfncom[Internal]{(setf p-class-description-name)}

\Syntaxlabel
\Defun {(setf p-class-description-name)} {{\funarg{t-name}} {\funarg{p-objid}} {\opt} {\funarg{depth}} {\funarg{p-heap}}}


\Argumentslabel
 \isa{\funarg{t-name}}
      {a symbol}
 \isanobjid{\funarg{p-objid}}
\Purposelabel
 Set the value of slot
 {\bf p-name}
 of the persistent class-description referenced by
 \funarg{p-objid}\ to \funarg{t-name}.
\Seealsolabel
 Section \fcite{p-class-description- ...}.


\endcom

\beginfncom[Internal]{p-class-description-next-generation}

\Syntaxlabel
\Defun {p-class-description-next-generation} {{\funarg{p-objid}} {\opt} {\funarg{depth}} {\funarg{p-heap}}}


\Argumentslabel
 \isanobjid{\funarg{p-objid}}
\Purposelabel
 Get the value of slot
 {\bf p-next-generation}
 of the persistent class-description referenced by \funarg{p-objid}.
\Seealsolabel
 Section \fcite{p-class-description- ...}.


\endcom

\beginfncom[Internal]{(setf p-class-description-next-generation)}

\Syntaxlabel
\Defun {(setf p-class-description-next-generation)} {{\funarg{t-next-generation}} {\funarg{p-objid}} {\opt} {\funarg{depth}} {\funarg{p-heap}}}


\Argumentslabel
 \isa{\funarg{t-next-generation}}
      {either \lispnil\ or a class-description}
 \isanobjid{\funarg{p-objid}}
\Purposelabel
 Set the value of slot
 {\bf p-next-generation}
 of the persistent class-description referenced by
 \funarg{p-objid}\ to \funarg{t-next-generation}.
\Seealsolabel
 Section \fcite{p-class-description- ...}.


\endcom

\beginfncom[Internal]{p-class-description-p}

\Syntaxlabel
\Defun {p-class-description-p} {{\funarg{p-objid}} {\opt} {\funarg{p-heap}}}


\Argumentslabel
 \isanobjid{\funarg{p-objid}}
\Purposelabel
 Returns \nonnil\ iff \funarg{p-objid}\ references a
 persistent object of class
 class-description,
 \lispnil\ otherwise.
\Seealsolabel
 \Fcite{class-description}.


\endcom

\beginfncom[Internal]{p-class-description-persistent-slot-numbers}

\Syntaxlabel
\Defun {p-class-description-persistent-slot-numbers} {{\funarg{p-objid}} {\opt} {\funarg{depth}} {\funarg{p-heap}}}


\Argumentslabel
 \isanobjid{\funarg{p-objid}}
\Purposelabel
 Get the value of slot
 {\bf p-persistent-slot-numbers}
 of the persistent class-description referenced by \funarg{p-objid}.
\Seealsolabel
 Section \fcite{p-class-description- ...}.


\endcom

\beginfncom[Internal]{(setf p-class-description-persistent-slot-numbers)}

\Syntaxlabel
\Defun {(setf p-class-description-persistent-slot-numbers)} {{\funarg{t-persistent-slot-numbers}} {\funarg{p-objid}} {\opt} {\funarg{depth}} {\funarg{p-heap}}}


\Argumentslabel
 \isa{\funarg{n-slots}}
      {a fixnum}
 \isanobjid{\funarg{p-objid}}
\Purposelabel
 Set the value of slot
 {\bf p-persistent-slot-numbers}
 of the persistent class-description referenced by
 \funarg{p-objid}\ to \funarg{n-slots}.
\Seealsolabel
 Section \fcite{p-class-description- ...}.


\endcom

\beginfncom[Internal]{p-class-description-plist}

\Syntaxlabel
\Defun {p-class-description-plist} {{\funarg{p-objid}} {\opt} {\funarg{depth}} {\funarg{p-heap}}}


\Argumentslabel
 \isanobjid{\funarg{p-objid}}
\Purposelabel
 Get the value of slot
 {\bf p-plist}
 of the persistent class-description referenced by \funarg{p-objid}.
\Seealsolabel
 Section \fcite{p-class-description- ...}.


\endcom

\beginfncom[Internal]{(setf p-class-description-plist)}

\Syntaxlabel
\Defun {(setf p-class-description-plist)} {{\funarg{t-plist}} {\funarg{p-objid}} {\opt} {\funarg{depth}} {\funarg{p-heap}}}


\Argumentslabel
 \isa{\funarg{t-plist}}
      {a property list}
 \isanobjid{\funarg{p-objid}}
\Purposelabel
 Set the value of slot
 {\bf p-plist}
 of the persistent class-description referenced by
 \funarg{p-objid}\ to \funarg{t-plist}.
\Seealsolabel
 Section \fcite{p-class-description- ...}.


\endcom

\beginfncom[Internal]{p-class-description-precedence-list}

\Syntaxlabel
\Defun {p-class-description-precedence-list} {{\funarg{p-objid}} {\opt} {\funarg{depth}} {\funarg{p-heap}}}


\Argumentslabel
 \isanobjid{\funarg{p-objid}}
\Purposelabel
 Get the value of slot
 {\bf p-precedence-list}
 of the persistent class-description referenced by \funarg{p-objid}.
\Seealsolabel
 Section \fcite{p-class-description- ...}.


\endcom

\beginfncom[Internal]{(setf p-class-description-precedence-list)}

\Syntaxlabel
\Defun {(setf p-class-description-precedence-list)} {{\funarg{t-precedence-list}} {\funarg{p-objid}} {\opt} {\funarg{depth}} {\funarg{p-heap}}}


\Argumentslabel
 \isa{\funarg{t-precedence-list}}
      {a list or vector either with \clsmo{}s or class-descriptions}
 \isanobjid{\funarg{p-objid}}
\Purposelabel
 Set the value of slot
 {\bf p-precedence-list}
 of the persistent class-description referenced by
 \funarg{p-objid}\ to \funarg{t-precedence-list}.
\Seealsolabel
 Section \fcite{p-class-description- ...}.


\endcom

\beginfncom[Internal]{p-class-description-prototype}

\Syntaxlabel
\Defun {p-class-description-prototype} {{\funarg{p-objid}} {\opt} {\funarg{depth}} {\funarg{p-heap}}}


\Argumentslabel
 \isanobjid{\funarg{p-objid}}
\Purposelabel
 Get the value of slot
 {\bf p-prototype}
 of the persistent class-description referenced by \funarg{p-objid}.
\Seealsolabel
 Section \fcite{p-class-description- ...}.


\endcom

\beginfncom[Internal]{(setf p-class-description-prototype)}

\Syntaxlabel
\Defun {(setf p-class-description-prototype)} {{\funarg{t-prototype}} {\funarg{p-objid}} {\opt} {\funarg{depth}} {\funarg{p-heap}}}


\Argumentslabel
 \isa{\funarg{t-prototype}}
      {a persistent instance of
       the class described by the persistent class description
       referenced by \funarg{p-objid}}
 \isanobjid{\funarg{p-objid}}
\Purposelabel
 Set the value of slot
 {\bf p-prototype}
 of the persistent class-description referenced by
 \funarg{p-objid}\ to \funarg{t-prototype}.
\Seealsolabel
 Section \fcite{p-class-description- ...}.


\endcom

\beginfncom[Internal]{p-class-description-schema-evolution}

\Syntaxlabel
\Defun {p-class-description-schema-evolution} {{\funarg{p-objid}} {\opt} {\funarg{depth}} {\funarg{p-heap}}}


\Argumentslabel
 \isanobjid{\funarg{p-objid}}
\Purposelabel
 Get the value of slot
 {\bf p-schema-evolution}
 of the persistent class-description referenced by \funarg{p-objid}.
\Seealsolabel
 Section \fcite{p-class-description- ...}.


\endcom

\beginfncom[Internal]{(setf p-class-description-schema-evolution)}

\Syntaxlabel
\Defun {(setf p-class-description-schema-evolution)} {{\funarg{t-schema-evolution}} {\funarg{p-objid}} {\opt} {\funarg{depth}} {\funarg{p-heap}}}


\Argumentslabel
 \isa{\funarg{t-schema-evolution}}
      {a keyword symbol}
 \isanobjid{\funarg{p-objid}}
\Purposelabel
 Set the value of slot
 {\bf p-schema-evolution}
 of the persistent class-description referenced by
 \funarg{p-objid}\ to \funarg{t-schema-evolution}.
\Seealsolabel
 Section \fcite{p-class-description- ...}.


\endcom

\beginfncom[Internal]{p-class-description-slot-numbers}

\Syntaxlabel
\Defun {p-class-description-slot-numbers} {{\funarg{p-objid}} {\opt} {\funarg{depth}} {\funarg{p-heap}}}


\Argumentslabel
 \isanobjid{\funarg{p-objid}}
\Purposelabel
 Get the value of slot
 {\bf p-slot-numbers}
 of the persistent class-description referenced by \funarg{p-objid}.
\Seealsolabel
 Section \fcite{p-class-description- ...}.


\endcom

\beginfncom[Internal]{(setf p-class-description-slot-numbers)}

\Syntaxlabel
\Defun {(setf p-class-description-slot-numbers)} {{\funarg{t-slot-numbers}} {\funarg{p-objid}} {\opt} {\funarg{depth}} {\funarg{p-heap}}}


\Argumentslabel
 \isa{\funarg{n-slots}}
      {a fixnum}
 \isanobjid{\funarg{p-objid}}
\Purposelabel
 Set the value of slot
 {\bf p-slot-numbers}
 of the persistent class-description referenced by
 \funarg{p-objid}\ to \funarg{n-slots}.
\Seealsolabel
 Section \fcite{p-class-description- ...}.


\endcom

\beginfncom[Internal]{p-class-description-superclasses}

\Syntaxlabel
\Defun {p-class-description-superclasses} {{\funarg{p-objid}} {\opt} {\funarg{depth}} {\funarg{p-heap}}}


\Argumentslabel
 \isanobjid{\funarg{p-objid}}
\Purposelabel
 Get the value of slot
 {\bf p-superclasses}
 of the persistent class-description referenced by \funarg{p-objid}.
\Seealsolabel
 Section \fcite{p-class-description- ...}.


\endcom

\beginfncom[Internal]{(setf p-class-description-superclasses)}

\Syntaxlabel
\Defun {(setf p-class-description-superclasses)} {{\funarg{t-superclasses}} {\funarg{p-objid}} {\opt} {\funarg{depth}} {\funarg{p-heap}}}


\Argumentslabel
 \isa{\funarg{t-superclasses}}
      {a list or vector either with \clsmo{}s or class-descriptions}
 \isanobjid{\funarg{p-objid}}
\Purposelabel
 Set the value of slot
 {\bf p-superclasses}
 of the persistent class-description referenced by
 \funarg{p-objid}\ to \funarg{t-superclasses}.
\Seealsolabel
 Section \fcite{p-class-description- ...}.


\endcom

\beginfncom[Internal]{p-class-description-time-stamp}

\Syntaxlabel
\Defun {p-class-description-time-stamp} {{\funarg{p-objid}} {\opt} {\funarg{depth}} {\funarg{p-heap}}}


\Argumentslabel
 \isanobjid{\funarg{p-objid}}
\Purposelabel
 Get the value of slot
 {\bf p-time-stamp}
 of the persistent class-description referenced by \funarg{p-objid}.
\Seealsolabel
 Section \fcite{p-class-description- ...}.


\endcom

\beginfncom[Internal]{(setf p-class-description-time-stamp)}

\Syntaxlabel
\Defun {(setf p-class-description-time-stamp)} {{\funarg{t-time-stamp}} {\funarg{p-objid}} {\opt} {\funarg{depth}} {\funarg{p-heap}}}


\Argumentslabel
 \isa{\funarg{t-time-stamp}}
      {a time stamp in \cl\ Universal Time divided by 60,
       i.e.\ the time is in minutes, not in seconds.}
 \isanobjid{\funarg{p-objid}}
\Purposelabel
 Set the value of slot
 {\bf p-time-stamp}
 of the persistent class-description referenced by
 \funarg{p-objid}\ to \funarg{t-time-stamp}.
\Seealsolabel
 Section \fcite{p-class-description- ...}.


\endcom

\beginfncom[Internal]{p-class-description-version-number}

\Syntaxlabel
\Defun {p-class-description-version-number} {{\funarg{p-objid}} {\opt} {\funarg{depth}} {\funarg{p-heap}}}


\Argumentslabel
 \isanobjid{\funarg{p-objid}}
\Purposelabel
 Get the value of slot
 {\bf p-version-number}
 of the persistent class-description referenced by \funarg{p-objid}.
\Seealsolabel
 Section \fcite{p-class-description- ...}.


\endcom

\beginfncom[Internal]{(setf p-class-description-version-number)}

\Syntaxlabel
\Defun {(setf p-class-description-version-number)} {{\funarg{t-version-number}} {\funarg{p-objid}} {\opt} {\funarg{depth}} {\funarg{p-heap}}}


\Argumentslabel
 \isa{\funarg{t-version-number}}
      {a fixnum}
 \isanobjid{\funarg{p-objid}}
\Purposelabel
 Set the value of slot
 {\bf p-version-number}
 of the persistent class-description referenced by
 \funarg{p-objid}\ to \funarg{t-version-number}.
\Seealsolabel
 Section \fcite{p-class-description- ...}.


\endcom

\beginfncom[Internal]{p-direct-slot-description}

\Syntaxlabel
\Defun {p-direct-slot-description} {{\funarg{p-objid}} {\opt} {\funarg{depth}} {\funarg{p-heap}}}


\Argumentslabel
 \isanobjid{\funarg{p-objid}}
\Purposelabel
 Return a transient representation for the persistent
 direct-slot-description
 referenced by \funarg{p-objid}.
\Seealsolabel
 \Fcite{(setf p-direct-slot-description)}.


\endcom

\beginfncom[Internal]{(setf p-direct-slot-description)}

\Syntaxlabel
\Defun {(setf p-direct-slot-description)} {{\funarg{t-descr}} {\opt} {\funarg{p-objid}} {\funarg{depth}} {\funarg{p-heap}}}


\Argumentslabel
 \isa{\funarg{t-descr}}
      {a direct-slot-description}
 \isanobjid{\funarg{p-objid}}
\Valueslabel
 \retarg{\funarg{t-descr}}
\Purposelabel
 Store the transient direct-slot-description in
 \funarg{t-descr}\ to the
 persistent direct-slot-description referenced by \funarg{p-objid}.
\Seealsolabel
 \Fcite{p-direct-slot-description};
 \fcite{p-effective-slot-description}.


\endcom

\beginfncom[Internal]{p-direct-slot-description-p}

\Syntaxlabel
\Defun {p-direct-slot-description-p} {{\funarg{p-objid}} {\opt} {\funarg{p-heap}}}


\Argumentslabel
 \isanobjid{\funarg{p-objid}}
\Purposelabel
 Returns \nonnil\ iff \funarg{p-objid}\ references a
 persistent object of
 \fcite{direct-slot-description},
 \lispnil\ otherwise.


\endcom

\beginfncom[Internal]{p-effective-slot-description}

\Syntaxlabel
\Defun {p-effective-slot-description} {{\funarg{p-objid}} {\opt} {\funarg{depth}} {\funarg{p-heap}}}


\Argumentslabel
 \isanobjid{\funarg{p-objid}}
\Purposelabel
 Return a transient representation for the persistent
 effective-slot-description
 referenced by \funarg{p-objid}.
\Seealsolabel
 \Fcite{(setf p-effective-slot-description)}.


\endcom

\beginfncom[Internal]{(setf p-effective-slot-description)}

\Syntaxlabel
\Defun {(setf p-effective-slot-description)} {{\funarg{t-descr}} {\opt} {\funarg{p-objid}} {\funarg{depth}} {\funarg{p-heap}}}


\Argumentslabel
 \isa{\funarg{t-descr}}
      {an effective-slot-description}
 \isanobjid{\funarg{p-objid}}
\Valueslabel
 \retarg{\funarg{t-descr}}
\Purposelabel
 Store the transient effective-slot-description in
 \funarg{t-descr}\ to the
 persistent effective-slot-description referenced by \funarg{p-objid}.
\Seealsolabel
 \Fcite{p-direct-slot-description};
 \fcite{p-effective-slot-description}.


\endcom

\beginfncom[Internal]{p-effective-slot-description-p}

\Syntaxlabel
\Defun {p-effective-slot-description-p} {{\funarg{p-objid}} {\opt} {\funarg{p-heap}}}


\Argumentslabel
 \isanobjid{\funarg{p-objid}}
\Purposelabel
 Returns \nonnil\ iff \funarg{p-objid}\ references a
 persistent object of
 \fcite{effective-slot-description},
 \lispnil\ otherwise.


\endcom

\beginfncom[Internal]{p-extern}

\Syntaxlabel
\Defun {p-extern} {{\funarg{name-symbol}}}


\Argumentslabel
 \isa{\funarg{name-symbol}}
      {a string or a symbol}
\Valueslabel
 Returns the \objid\ of the persistent symbol named
 \funarg{name-symbol}.
\Purposelabel
 Checks if \funarg{name-symbol}\ names a persistent
 symbol; if not, a \lisp{cerror}\ is raised and the
 user is asked if a persistent symbol named
 \funarg{name-symbol}\ should be created.
\Seealsolabel
 \Fcite{p-find-symbol};
 \fcite{p-intern};
 \fcite{p-unintern}.


\endcom

\beginfncom[Internal]{p-find-class-cache-entry}

\Syntaxlabel
\Defun {p-find-class-cache-entry} {{\funarg{name}} {\funarg{p-heap}}}

Find the cached-btree entry for the class named \funarg{name}.


\endcom

\beginfncom[Internal]{p-find-class-description}

\Syntaxlabel
\Defun {p-find-class-description} {{\funarg{name}} {\funarg{p-heap}}}

Find the class description of the class named \funarg{name}.


\endcom

\beginfncom[Internal]{p-find-class-objid}

\Syntaxlabel
\Defun {p-find-class-objid} {{\funarg{name}} {\funarg{p-heap}}}

Find the \objid\ of a class description.


\endcom

\beginfncom[Internal]{p-find-name}

\Syntaxlabel
\Defun {p-find-name} {{\funarg{name}} {\opt} {\funarg{p-heap}}}


\Argumentslabel
 \isa{\funarg{name}}
      {either a string or a symbol}
\Purposelabel
 Returns \funarg{name}\ mapped to a string.
\Seealsolabel
 \Fcite{p-find-package-name}.


\endcom

\beginfncom[Internal]{p-find-package-name}

\Syntaxlabel
\Defun {p-find-package-name} {{\funarg{name}}}


\Argumentslabel
 \isa{\funarg{name}}
      {either a string or a symbol or a package}
\Purposelabel
 Returns \funarg{name}\ mapped to a string.
\Seealsolabel
 \Fcite{p-find-name}.


\endcom

\beginfncom[Internal]{p-fixnum}

\Syntaxlabel
\Defun {p-fixnum} {{\funarg{p-heap}} {\funarg{p-objid}} {\funarg{at-location}} {\opt} {\funarg{expecting-type-tag}} {\funarg{expecting-class}}}


\Argumentslabel
 \isanobjid{\funarg{p-objid}}
 \isa{\funarg{at-location}}
      {a fixnum}
 \isatypetag{\funarg{expecting-type-tag}}
 \isanobjid{\funarg{expecting-class}}
\Valueslabel
 Returns the fixnum object located at position
 \funarg{at-location}\ in \funarg{p-objid}.
\Purposelabel
 Read a persistent object of immediate type fixnum.
 The slot value of the persistent object referenced by
 \funarg{p-objid}\ at position \funarg{at-location}\ is
 returned as a fixnum.
\Remarkslabel
 It is checked if \funarg{at-location}\ is a valid position index
 for the persistent object referenced by \funarg{p-objid}.

 It is checked if the object contained at position
 \funarg{at-location}\ in the persistent object referenced by
 \funarg{p-objid}\ is an object of type fixnum.

 If \funarg{expecting-type-tag}\ is not \lisp{equal}\ to
 \lisp{+null-type-tag+}, it is checked if
 \funarg{p-objid}\ references a persistent object of type
 \funarg{expecting-type-tag}.

 It is checked if a read-lock is set either on `element'-level
 on position \funarg{at-location}\ in \funarg{p-objid}\ or
 on `vector'-level on \funarg{p-objid}; if neither lock is
 set, an `element'-level read lock is set on position
 \funarg{at-location}\ in \funarg{p-objid}.
\Seealsolabel
 \Fcite{(setf p-fixnum)};
 \fcite{sh-read-fixnum}.


\endcom

\beginfncom[Internal]{(setf p-fixnum)}

\Syntaxlabel
\Defun {(setf p-fixnum)} {{\funarg{the-fixnum}} {\funarg{p-heap}} {\funarg{p-objid}} {\funarg{at-location}} {\opt} {\funarg{expecting-type-tag}} {\funarg{expecting-class}}}


\Argumentslabel
 \isa{\funarg{the-fixnum}}
      {a fixnum}
 \isanobjid{\funarg{p-objid}}
 \isa{\funarg{at-location}}
      {a fixnum}
 \isatypetag{\funarg{expecting-type-tag}}
\Valueslabel
 \retarg{\funarg{the-fixnum}}
\Purposelabel
 Write to a persistent object's component; the
 slot value of the persistent object referenced by
 \funarg{p-objid}\ at position \funarg{at-location}\ is
 set to \funarg{the-fixnum}.
\Remarkslabel
 It is checked if \funarg{at-location}\ is a valid position index
 for the persistent object referenced by \funarg{p-objid}.

 If \funarg{expecting-type-tag}\ is not \lisp{equal}\ to
 \lisp{+null-type-tag+}, it is checked if
 \funarg{p-objid}\ references a persistent object of type
 \funarg{expecting-type-tag}.

 It is checked if a write-lock is set either on `element'-level
 on position \funarg{at-location}\ in \funarg{p-objid}\ or
 on `vector'-level on \funarg{p-objid}; if neither lock is
 set, an `element'-level write lock is set on position
 \funarg{at-location}\ in \funarg{p-objid}.
\Seealsolabel
 \Fcite{p-fixnum};
 \fcite{sh-write-fixnum}.


\endcom

\beginfncom[Internal]{p-fixnump}

\Syntaxlabel
\Defun {p-fixnump} {{\funarg{object}}}


\Argumentslabel
  \isanobject{\funarg{object}}
\Purposelabel
  Return \nonnil\ if \funarg{object}\ is of type fixnum,
  \lispnil\ otherwise.
\Remarkslabel
 \sysdep{macro}


\endcom

\beginfncom[Internal]{p-get-cdr}

\Syntaxlabel
\Defun {p-get-cdr} {{\funarg{p-heap}} {\funarg{last-cons-objid}} {\funarg{last-cons}} {\funarg{depth}}}


\Argumentslabel
 \isanobjid{\funarg{last-cons-objid}}
 \isa{\funarg{last-cons}}
      {a transient cons cell}
\Purposelabel
 Tail-recursive function for loading of lists.


\endcom

\beginfncom[Internal]{p-get-version}

\Syntaxlabel
\Defun {p-get-version} {{\opt} {\funarg{layer}} {\funarg{p-heap}}}


\Argumentslabel
  \isa{\funarg{layer}}
       {a keyword symbol naming the version to retrieve}
\Purposelabel
  Get a \plob\ version number; which kind of version number to retrieve
  is decided by \funarg{layer}:
  \begin{description}
  \item[\lisp{:database}] Get the version number the database was
    formatted with.
  \item[\lisp{:server}] Get the version number of the server's C code.
  \item[\lisp{:client}] Get the version number of the client's C code.
  \item[\lisp{:api}] Get the version number of the LISP API code.
  \end{description}


\endcom

\beginmccom[Internal]{p-immediatep}

\Syntaxlabel
\Defmac {p-immediatep} {{\funarg{type-tag}}}

Check if \funarg{type-tag}\ denominates an immediate type.


\endcom

\beginfncom[Internal]{p-index}

\Syntaxlabel
\Defun {p-index} {{\funarg{p-heap}} {\funarg{p-objid}} {\funarg{at-location}} {\opt} {\funarg{expecting-type-tag}} {\funarg{expecting-class}}}


\Argumentslabel

 \isanobjid{\funarg{p-objid}}
 \isa{\funarg{at-location}}
      {a fixnum}
 \isatypetag{\funarg{expecting-type-tag}\ %
              resp.\ \funarg{immediate-type-tag}}
\Valueslabel
 Returns two values:
 \begin{enumerate}

 \item The \objid\ of the persistent object located at position
  \funarg{at-location}\ in \funarg{p-objid}.

 \item The \typetag\ of the persistent object located at position
  \funarg{at-location}\ in \funarg{p-objid}.

 \end{enumerate}
\Purposelabel
 Read a persistent object's component; the
 slot value of the persistent object referenced by
 \funarg{p-objid}\ at position \funarg{at-location}\ is
 returned as an \objid\ and a \typetag.
\Remarkslabel
 It is checked if \funarg{at-location}\ is a valid position index
 for the persistent object referenced by \funarg{p-objid}.

 If \funarg{expecting-type-tag}\ is not \lisp{equal}\ to
 \lisp{+null-type-tag+}, it is checked if
 \funarg{p-objid}\ references a persistent object of type
 \funarg{expecting-type-tag}.

 It is checked if a read-lock is set either on `element'-level
 on position \funarg{at-location}\ in \funarg{p-objid}\ or
 on `vector'-level on \funarg{p-objid}; if neither lock is
 set, an `element'-level lock is set on position
 \funarg{at-location}\ in \funarg{p-objid}.

 The \funarg{immediate-type-tag}\ argument is ignored.
\Seealsolabel
 \Fcite{(setf p-index)};
 \fcite{sh-read-index}.


\endcom

\beginfncom[Internal]{(setf p-index)}

\Syntaxlabel
\Defun {(setf p-index)} {{\funarg{immediate-value}} {\funarg{p-heap}} {\funarg{p-objid}} {\funarg{at-location}} {\opt} {\funarg{expecting-type-tag}} {\funarg{expecting-class}} {\funarg{immediate-type-tag}}}


\Argumentslabel
 \isa{\funarg{immediate-value}}
      {either an immediate value or an \objid}
 \isanobjid{\funarg{p-objid}}
 \isa{\funarg{at-location}}
      {a fixnum}
 \isatypetag{\funarg{expecting-type-tag}\ %
              resp.\ \funarg{immediate-type-tag}}
\Valueslabel
 \retoldmode{\funarg{p-heap}}{\funarg{p-objid}}
\Purposelabel
 Write to a persistent object's component; the
 slot value of the persistent object referenced by
 \funarg{p-objid}\ at position \funarg{at-location}\ is
 set to the persistent object which is made up from the
 \funarg{immediate-value}\ and
 \funarg{immediate-type-tag}\ argument.
 \Remarkslabel
 It is checked if \funarg{at-location}\ is a valid position index
 for the persistent object referenced by \funarg{p-objid}.

 If \funarg{expecting-type-tag}\ is not \lisp{equal}\ to
 \lisp{+null-type-tag+}, it is checked if
 \funarg{p-objid}\ references a persistent object of type
 \funarg{expecting-type-tag}.

 It is checked if a write-lock is set either on `element'-level
 on position \funarg{at-location}\ in \funarg{p-objid}\ or
 on `vector'-level on \funarg{p-objid}; if neither lock is
 set, an `element'-level write lock is set on position
 \funarg{at-location}\ in \funarg{p-objid}.
\Seealsolabel
 \Fcite{p-index};
 \fcite{sh-write-index}.


\endcom

\beginfncom[Internal]{p-initialize-lisproot}

\Syntaxlabel
\Defun {p-initialize-lisproot} {{\funarg{p-objid}} {\opt} {\funarg{p-heap}}}


\Purposelabel
 Initializes a LISP root allocated in the \sh.
\Seealsolabel
 \Fcite{p-allocate-lisproot}.


\endcom

\beginfncom[Internal]{p-insert-lock}

\Syntaxlabel
\Defun {p-insert-lock} {{\funarg{p-heap}} {\funarg{p-objid}} {\opt} {\funarg{expecting-type-tag}} {\funarg{lock-mode}} {\funarg{at-location}}}


\Argumentslabel
 \isanobjid{\funarg{p-objid}}
 \isatypetag{\funarg{expecting-type-tag}}
 \isa{\funarg{lock-mode}}
      {a fixnum bitwise-or'ed from
       one of the constant values of
       {\bf *lock-level-\ldots{}*}
       (figure~\ref{tab:lock-levels}%
       %% 1998/01/07 HK: This makes problems with hyperref:
       %% \fcitepage{\pageref{tab:lock-levels}}
       ) with
       one of the constant values of {\bf *lock-mode-\ldots{}*}
       (figure~\ref{tab:lock-modes}%
       %% 1998/01/07 HK: This makes problems with hyperref:
       %% \fcitepage{\pageref{tab:lock-modes}}
       )}
 \isa{\funarg{at-location}}
      {a fixnum}
\Valueslabel
 \retoldmode{\funarg{p-heap}}{\funarg{p-objid}}
\Purposelabel
 If there is no lock as requested by \funarg{lock-mode}\ set
 to \funarg{p-objid},
 set a lock with the level and mode of \funarg{lock-mode}\ to
 \funarg{p-objid}\ or, if the passed \funarg{lock-mode}\ requests
 an `element'-level lock, to the slot of the persistent object
 referenced by \funarg{p-objid}\ at position \funarg{at-location}.
\Remarkslabel
 If \funarg{expecting-type-tag}\ is not \lisp{equal}\ to
 \lisp{+null-type-tag+}, it is checked if
 \funarg{p-objid}\ references a persistent object of type
 \funarg{expecting-type-tag}.

 If the passed \funarg{lock-mode}\ requests an `element'-level lock,
 it is checked if \funarg{at-location}\ is a valid position index
 for the persistent object referenced by \funarg{p-objid}.
\Seealsolabel
 Section \fcite{locking ...};
 \fcite{p-set-lock};
 \fcite{sh-insert-lock}.


\endcom

\beginfncom[Internal]{p-instance}

\Syntaxlabel
\Defun {p-instance} {{\funarg{p-objid}} {\opt} {\funarg{depth}} {\funarg{p-heap}}}


\Argumentslabel
 \isanobjid{\funarg{p-objid}}
\Purposelabel
 Return a transient representation for the persistent \clos\ instance
 referenced by \funarg{p-objid}.
\Seealsolabel
 \Fcite{(setf p-instance)}.


\endcom

\beginfncom[Internal]{(setf p-instance)}

\Syntaxlabel
\Defun {(setf p-instance)} {{\funarg{t-instance}} {\opt} {\funarg{p-objid}} {\funarg{depth}} {\funarg{p-heap}}}


\Argumentslabel
 \isaclosobject{\funarg{t-instance}}
 \isanobjid{\funarg{p-objid}}
\Valueslabel
 \retarg{\funarg{t-instance}}
\Purposelabel
 Store the transient \clos\ instance in \funarg{t-instance}\ to
 the persistent \clos\ instance referenced by \funarg{p-objid}.

 Only the slots with \lisp{:extent :cached}\ are stored here;
 the slots with other extents are stored by calls to the
 \fcite{(setf slot-value-using-class) (t standard-class t effective-slot-description)}.
\Seealsolabel
 \Fcite{p-instance}.


\endcom

\beginfncom[Internal]{p-instance-class-wrapper}

\Syntaxlabel
\Defun {p-instance-class-wrapper} {{\funarg{p-objid}} {\opt} {\funarg{depth}} {\funarg{p-heap}}}


\Argumentslabel
 \isanobjid{\funarg{p-objid}}
\Purposelabel
 Get the class-wrapper of the persistent \clos\ instance
 referenced by \funarg{p-objid}.
\Seealsolabel
 \Fcite{(setf p-instance-class-wrapper)}.


\endcom

\beginfncom[Internal]{(setf p-instance-class-wrapper)}

\Syntaxlabel
\Defun {(setf p-instance-class-wrapper)} {{\funarg{t-class-wrapper}} {\funarg{p-objid}} {\opt} {\funarg{depth}} {\funarg{p-heap}}}


\Argumentslabel
 \isa{\funarg{t-descr}}
      {a class-description}
 \isanobjid{\funarg{p-objid}}
\Purposelabel
 Set the class-wrapper of the persistent \clos\ instance
 referenced by \funarg{p-objid}\ to \funarg{t-class-wrapper}.

 The class-wrapper defines the class of the persistent
 \clos\ instance referenced by \funarg{p-objid}.
\Seealsolabel
 \Fcite{p-instance-class-wrapper}.


\endcom

\beginfncom[Internal]{p-instance-data-vector}

\Syntaxlabel
\Defun {p-instance-data-vector} {{\funarg{p-objid}} {\opt} {\funarg{depth}} {\funarg{p-heap}}}


\Argumentslabel
 \isanobjid{\funarg{p-objid}}
\Purposelabel
 Get the data-vector of the persistent \clos\ instance
 referenced by \funarg{p-objid}.
\Seealsolabel
 \Fcite{p-instance-data-vector}.


\endcom

\beginfncom[Internal]{(setf p-instance-data-vector)}

\Syntaxlabel
\Defun {(setf p-instance-data-vector)} {{\funarg{t-data-vector}} {\funarg{p-objid}} {\opt} {\funarg{depth}} {\funarg{p-heap}}}


\Argumentslabel
 \isa{\funarg{t-data-vector}}
      {a vector}
 \isanobjid{\funarg{p-objid}}
\Purposelabel
 Set the data-vector of the persistent \clos\ instance
 referenced by \funarg{p-objid}\ to \funarg{t-data-vector}.

 The data-vector holds the state of the persistent
 \clos\ instance referenced by \funarg{p-objid}; its length
 is the number of persistent slots of the persistent
 \clos\ instance. The number of persistent slots is the value
 of the slot {\bf p-persistent-slot-numbers} of the persistent
 \clos\ instance's class-description (see
 \fcite{class-description}).
\Seealsolabel
 \Fcite{p-instance-data-vector}.


\endcom

\beginfncom[Internal]{p-instancep}

\Syntaxlabel
\Defun {p-instancep} {{\funarg{p-objid}} {\opt} {\funarg{p-heap}}}


\Argumentslabel
 \isanobjid{\funarg{p-objid}}
\Purposelabel
 Returns \nonnil\ iff \funarg{p-objid}\ references a
 persistent object of type
 persistent \clos\ instance,
 \lispnil\ otherwise. No further class checking is done by this
 function; it is only checked if the persistent object referenced
 by \funarg{p-objid}\ is a persistent \clos\ instance at all.


\endcom

\beginfncom[Internal]{p-ivector-into}

\Syntaxlabel
\Defun {p-ivector-into} {{\funarg{into-ivector}} {\funarg{p-objid}} {\opt} {\funarg{depth}} {\funarg{p-heap}}}


\Argumentslabel
 \isa{\funarg{into-ivector}}
      {an immediate vector}
 \isanobjid{\funarg{p-objid}}
\Purposelabel
 Read the persistent immediate vector referenced by
 \funarg{p-objid}\ destructively into \funarg{into-ivector}.
\Seealsolabel
 \Fcite{p-ivector}.


\endcom

\beginfncom[Internal]{p-ivector-into-internal}

\Syntaxlabel
\Defun {p-ivector-into-internal} {{\funarg{p-heap}} {\funarg{p-objid}} {\funarg{into-ivector}} {\funarg{depth}}}


\Argumentslabel
 See \fcite{p-ivector-into}.
\Purposelabel
 Internal used function for \fcite{p-ivector-into}.


\endcom

\begindccom[Persistent Lisproot Accessors]{p-lisproot- ...}

\Purposelabel
 All following functions
 {\bf p-lisproot-\textsl{\lt{}slot-name\gt}} and
 {\bf (setf p-lisproot-\textsl{\lt{}slot-name\gt}\/)}
 with \textsl{\lt{}slot-name\gt} being one of the slot names of
 \fcite{persistent-lisproot}\ without the `p-' prefix
 access directly a slot of a persistent structure instance
 of \fcite{persistent-lisproot}\ in the \sh.

 The accessor functions defined here are merely used in the
 bootstrap phase. After the bootstrap, the persistent objects of
 \fcite{persistent-lisproot}\ are created and accessed as all
 persistent structure objects by employing their
 structure-descriptions, i.e.\ all information needed to create
 a persistent structure object or to access a persistent structure
 object's slot is contained in its structure-description.
\Seealsolabel
 \Fcite{persistent-lisproot};
 section \fcite{bootstrap ...}.


\endcom

\beginfncom[Internal]{p-lisproot-class-description}

\Syntaxlabel
\Defun {p-lisproot-class-description} {{\funarg{p-objid}} {\opt} {\funarg{depth}} {\funarg{p-heap}}}


\Argumentslabel
 \isanobjid{\funarg{p-objid}}
\Purposelabel
 Get the value of slot
 {\bf p-class-description}
 of the persistent-lisproot referenced by \funarg{p-objid}.
\Seealsolabel
 Section \fcite{p-lisproot- ...}.


\endcom

\beginfncom[Internal]{(setf p-lisproot-class-description)}

\Syntaxlabel
\Defun {(setf p-lisproot-class-description)} {{\funarg{t-class-description}} {\funarg{p-objid}} {\opt} {\funarg{depth}} {\funarg{p-heap}}}


\Argumentslabel
 \isa{\funarg{t-class-description}}
      {the class description object}
 \isanobjid{\funarg{p-objid}}
\Purposelabel
 Set the value of slot
 {\bf p-class-description}
 of the persistent-lisproot referenced by
 \funarg{p-objid}\ to \funarg{t-class-description}.
\Seealsolabel
 Section \fcite{p-lisproot- ...}.


\endcom

\beginfncom[Internal]{p-lisproot-direct-slot-description}

\Syntaxlabel
\Defun {p-lisproot-direct-slot-description} {{\funarg{p-objid}} {\opt} {\funarg{depth}} {\funarg{p-heap}}}


\Argumentslabel
 \isanobjid{\funarg{p-objid}}
\Purposelabel
 Get the value of slot
 {\bf p-direct-slot-description}
 of the persistent-lisproot referenced by \funarg{p-objid}.
\Seealsolabel
 Section \fcite{p-lisproot- ...}.


\endcom

\beginfncom[Internal]{(setf p-lisproot-direct-slot-description)}

\Syntaxlabel
\Defun {(setf p-lisproot-direct-slot-description)} {{\funarg{t-direct-slot-description}} {\funarg{p-objid}} {\opt} {\funarg{depth}} {\funarg{p-heap}}}


\Argumentslabel
 \isa{\funarg{t-direct-slot-description}}
      {the direct slot description object}
 \isabtree{\funarg{t-direct-slot-description}}
 \isanobjid{\funarg{p-objid}}
\Purposelabel
 Set the value of slot
 {\bf p-direct-slot-description}
 of the persistent-lisproot referenced by
 \funarg{p-objid}\ to \funarg{t-direct-slot-description}.
\Seealsolabel
 Section \fcite{p-lisproot- ...}.


\endcom

\beginfncom[Internal]{p-lisproot-effective-slot-description}

\Syntaxlabel
\Defun {p-lisproot-effective-slot-description} {{\funarg{p-objid}} {\opt} {\funarg{depth}} {\funarg{p-heap}}}


\Argumentslabel
 \isanobjid{\funarg{p-objid}}
\Purposelabel
 Get the value of slot
 {\bf p-effective-slot-description}
 of the persistent-lisproot referenced by \funarg{p-objid}.
\Seealsolabel
 Section \fcite{p-lisproot- ...}.


\endcom

\beginfncom[Internal]{(setf p-lisproot-effective-slot-description)}

\Syntaxlabel
\Defun {(setf p-lisproot-effective-slot-description)} {{\funarg{t-effective-slot-description}} {\funarg{p-objid}} {\opt} {\funarg{depth}} {\funarg{p-heap}}}


\Argumentslabel
 \isa{\funarg{t-effective-slot-description}}
      {the effective slot description object}
 \isanobjid{\funarg{p-objid}}
\Purposelabel
 Set the value of slot
 {\bf p-effective-slot-description}
 of the persistent-lisproot referenced by
 \funarg{p-objid}\ to \funarg{t-effective-slot-description}.
\Seealsolabel
 Section \fcite{p-lisproot- ...}.


\endcom

\beginfncom[Internal]{p-lisproot-formatted}

\Syntaxlabel
\Defun {p-lisproot-formatted} {{\funarg{p-objid}} {\opt} {\funarg{depth}} {\funarg{p-heap}}}


\Argumentslabel
 \isanobjid{\funarg{p-objid}}
\Purposelabel
 Get the value of slot
 {\bf p-formatted}
 of the persistent-lisproot referenced by \funarg{p-objid}.
\Seealsolabel
 Section \fcite{p-lisproot- ...}.


\endcom

\beginfncom[Internal]{(setf p-lisproot-formatted)}

\Syntaxlabel
\Defun {(setf p-lisproot-formatted)} {{\funarg{t-formatted}} {\funarg{p-objid}} {\opt} {\funarg{depth}} {\funarg{p-heap}}}


\Argumentslabel
 \isakeyword{\funarg{t-formatted}}
 \isanobjid{\funarg{p-objid}}
\Purposelabel
 Set the value of slot
 {\bf p-formatted}
 of the persistent-lisproot referenced by
 \funarg{p-objid}\ to \funarg{t-formatted}.
\Seealsolabel
 Section \fcite{p-lisproot- ...}.


\endcom

\beginfncom[Internal]{p-lisproot-method-description}

\Syntaxlabel
\Defun {p-lisproot-method-description} {{\funarg{p-objid}} {\opt} {\funarg{depth}} {\funarg{p-heap}}}


\Argumentslabel
 \isanobjid{\funarg{p-objid}}
\Purposelabel
 Get the value of slot
 {\bf p-method-description}
 of the persistent-lisproot referenced by \funarg{p-objid}.
\Seealsolabel
 Section \fcite{p-lisproot- ...}.


\endcom

\beginfncom[Internal]{(setf p-lisproot-method-description)}

\Syntaxlabel
\Defun {(setf p-lisproot-method-description)} {{\funarg{t-method-description}} {\funarg{p-objid}} {\opt} {\funarg{depth}} {\funarg{p-heap}}}


\Argumentslabel
 \isa{\funarg{t-method-description}}
      {the method description object}
 \isanobjid{\funarg{p-objid}}
\Purposelabel
 Set the value of slot
 {\bf p-method-description}
 of the persistent-lisproot referenced by
 \funarg{p-objid}\ to \funarg{t-method-description}.
\Seealsolabel
 Section \fcite{p-lisproot- ...}.


\endcom

\beginfncom[Internal]{p-lisproot-name->package-table}

\Syntaxlabel
\Defun {p-lisproot-name->package-table} {{\funarg{p-objid}} {\opt} {\funarg{depth}} {\funarg{p-heap}}}


\Argumentslabel
 \isanobjid{\funarg{p-objid}}
\Purposelabel
 Get the value of slot
 {\bf p-name->package-table}
 of the persistent-lisproot referenced by \funarg{p-objid}.
\Seealsolabel
 Section \fcite{p-lisproot- ...}.


\endcom

\beginfncom[Internal]{(setf p-lisproot-name->package-table)}

\Syntaxlabel
\Defun {(setf p-lisproot-name->package-table)} {{\funarg{t-name->package-table}} {\funarg{p-objid}} {\opt} {\funarg{depth}} {\funarg{p-heap}}}


\Argumentslabel
 \isabtree{\funarg{t-name->package-table}}
 \isanobjid{\funarg{p-objid}}
\Purposelabel
 Set the value of slot
 {\bf p-name->package-table}
 of the persistent-lisproot referenced by
 \funarg{p-objid}\ to \funarg{t-name->package-table}.
\Seealsolabel
 Section \fcite{p-lisproot- ...}.


\endcom

\beginfncom[Internal]{p-lisproot-package-description}

\Syntaxlabel
\Defun {p-lisproot-package-description} {{\funarg{p-objid}} {\opt} {\funarg{depth}} {\funarg{p-heap}}}


\Argumentslabel
 \isanobjid{\funarg{p-objid}}
\Purposelabel
 Get the value of slot
 {\bf p-package-description}
 of the persistent-lisproot referenced by \funarg{p-objid}.
\Seealsolabel
 Section \fcite{p-lisproot- ...}.


\endcom

\beginfncom[Internal]{(setf p-lisproot-package-description)}

\Syntaxlabel
\Defun {(setf p-lisproot-package-description)} {{\funarg{t-package-description}} {\funarg{p-objid}} {\opt} {\funarg{depth}} {\funarg{p-heap}}}


\Argumentslabel
 \isa{\funarg{t-package-description}}
      {the package description object}
 \isanobjid{\funarg{p-objid}}
\Purposelabel
 Set the value of slot
 {\bf p-package-description}
 of the persistent-lisproot referenced by
 \funarg{p-objid}\ to \funarg{t-package-description}.
\Seealsolabel
 Section \fcite{p-lisproot- ...}.


\endcom

\beginfncom[Internal]{p-lisproot-pfs}

\Syntaxlabel
\Defun {p-lisproot-pfs} {{\funarg{p-objid}} {\opt} {\funarg{depth}} {\funarg{p-heap}}}


\Argumentslabel
 \isanobjid{\funarg{p-objid}}
\Purposelabel
 Get the value of slot
 {\bf p-pfs}
 of the persistent-lisproot referenced by \funarg{p-objid}.
\Seealsolabel
 Section \fcite{p-lisproot- ...}.


\endcom

\beginfncom[Internal]{(setf p-lisproot-pfs)}

\Syntaxlabel
\Defun {(setf p-lisproot-pfs)} {{\funarg{t-pfs}} {\funarg{p-objid}} {\opt} {\funarg{depth}} {\funarg{p-heap}}}


\Argumentslabel
 \isa{\funarg{t-pfs}}
      {the persistent file system descriptor}
 \isanobjid{\funarg{p-objid}}
\Purposelabel
 Set the value of slot
 {\bf p-pfs}
 of the persistent-lisproot referenced by
 \funarg{p-objid}\ to \funarg{t-pfs}.
\Seealsolabel
 Section \fcite{p-lisproot- ...}.


\endcom

\beginfncom[Internal]{p-lisproot-plob-description}

\Syntaxlabel
\Defun {p-lisproot-plob-description} {{\funarg{p-objid}} {\opt} {\funarg{depth}} {\funarg{p-heap}}}


\Argumentslabel
 \isanobjid{\funarg{p-objid}}
\Purposelabel
 Get the value of slot
 {\bf p-plob-description}
 of the persistent-lisproot referenced by \funarg{p-objid}.
\Seealsolabel
 Section \fcite{p-lisproot- ...}.


\endcom

\beginfncom[Internal]{(setf p-lisproot-plob-description)}

\Syntaxlabel
\Defun {(setf p-lisproot-plob-description)} {{\funarg{t-plob-description}} {\funarg{p-objid}} {\opt} {\funarg{depth}} {\funarg{p-heap}}}


\Argumentslabel
 \isa{\funarg{t-plob-description}}
      {the plob description object}
 \isanobjid{\funarg{p-objid}}
\Purposelabel
 Set the value of slot
 {\bf p-plob-description}
 of the persistent-lisproot referenced by
 \funarg{p-objid}\ to \funarg{t-plob-description}.
\Seealsolabel
 Section \fcite{p-lisproot- ...}.


\endcom

\beginfncom[Internal]{p-lisproot-slot-description}

\Syntaxlabel
\Defun {p-lisproot-slot-description} {{\funarg{p-objid}} {\opt} {\funarg{depth}} {\funarg{p-heap}}}


\Argumentslabel
 \isanobjid{\funarg{p-objid}}
\Purposelabel
 Get the value of slot
 {\bf p-slot-description}
 of the persistent-lisproot referenced by \funarg{p-objid}.
\Seealsolabel
 Section \fcite{p-lisproot- ...}.


\endcom

\beginfncom[Internal]{(setf p-lisproot-slot-description)}

\Syntaxlabel
\Defun {(setf p-lisproot-slot-description)} {{\funarg{t-slot-description}} {\funarg{p-objid}} {\opt} {\funarg{depth}} {\funarg{p-heap}}}


\Argumentslabel
 \isa{\funarg{t-slot-description}}
      {the slot description object}
 \isanobjid{\funarg{p-objid}}
\Purposelabel
 Set the value of slot
 {\bf p-slot-description}
 of the persistent-lisproot referenced by
 \funarg{p-objid}\ to \funarg{t-slot-description}.
\Seealsolabel
 Section \fcite{p-lisproot- ...}.


\endcom

\beginfncom[Internal]{p-lisproot-structure-description}

\Syntaxlabel
\Defun {p-lisproot-structure-description} {{\funarg{p-objid}} {\opt} {\funarg{depth}} {\funarg{p-heap}}}


\Argumentslabel
 \isanobjid{\funarg{p-objid}}
\Purposelabel
 Get the value of slot
 {\bf p-structure-description}
 of the persistent-lisproot referenced by \funarg{p-objid}.
\Seealsolabel
 Section \fcite{p-lisproot- ...}.


\endcom

\beginfncom[Internal]{(setf p-lisproot-structure-description)}

\Syntaxlabel
\Defun {(setf p-lisproot-structure-description)} {{\funarg{t-structure-description}} {\funarg{p-objid}} {\opt} {\funarg{depth}} {\funarg{p-heap}}}


\Argumentslabel
 \isa{\funarg{t-structure-description}}
      {the structure description object}
 \isanobjid{\funarg{p-objid}}
\Purposelabel
 Set the value of slot
 {\bf p-structure-description}
 of the persistent-lisproot referenced by
 \funarg{p-objid}\ to \funarg{t-structure-description}.
\Seealsolabel
 Section \fcite{p-lisproot- ...}.


\endcom

\beginfncom[Internal]{p-lisproot-structure-slot-description}

\Syntaxlabel
\Defun {p-lisproot-structure-slot-description} {{\funarg{p-objid}} {\opt} {\funarg{depth}} {\funarg{p-heap}}}


\Argumentslabel
 \isanobjid{\funarg{p-objid}}
\Purposelabel
 Get the value of slot
 {\bf p-structure-slot-description}
 of the persistent-lisproot referenced by \funarg{p-objid}.
\Seealsolabel
 Section \fcite{p-lisproot- ...}.


\endcom

\beginfncom[Internal]{(setf p-lisproot-structure-slot-description)}

\Syntaxlabel
\Defun {(setf p-lisproot-structure-slot-description)} {{\funarg{t-structure-slot-description}} {\funarg{p-objid}} {\opt} {\funarg{depth}} {\funarg{p-heap}}}


\Argumentslabel
 \isa{\funarg{t-structure-slot-description}}
      {the structure slot description object}
 \isanobjid{\funarg{p-objid}}
\Purposelabel
 Set the value of slot
 {\bf p-structure-slot-description}
 of the persistent-lisproot referenced by
 \funarg{p-objid}\ to \funarg{t-structure-slot-description}.
\Seealsolabel
 Section \fcite{p-lisproot- ...}.


\endcom

\beginfncom[Internal]{p-lisproot-symbol->class-table}

\Syntaxlabel
\Defun {p-lisproot-symbol->class-table} {{\funarg{p-objid}} {\opt} {\funarg{depth}} {\funarg{p-heap}}}


\Argumentslabel
 \isanobjid{\funarg{p-objid}}
\Purposelabel
 Get the value of slot
 {\bf p-symbol->class-table}
 of the persistent-lisproot referenced by \funarg{p-objid}.
\Seealsolabel
 Section \fcite{p-lisproot- ...}.


\endcom

\beginfncom[Internal]{(setf p-lisproot-symbol->class-table)}

\Syntaxlabel
\Defun {(setf p-lisproot-symbol->class-table)} {{\funarg{t-symbol->class-table}} {\funarg{p-objid}} {\opt} {\funarg{depth}} {\funarg{p-heap}}}


\Argumentslabel
 \isabtree{\funarg{t-symbol->class-table}}
 \isanobjid{\funarg{p-objid}}
\Purposelabel
 Set the value of slot
 {\bf p-symbol->class-table}
 of the persistent-lisproot referenced by
 \funarg{p-objid}\ to \funarg{t-symbol->class-table}.
\Seealsolabel
 Section \fcite{p-lisproot- ...}.


\endcom

\beginfncom[Internal]{p-lisproot-time}

\Syntaxlabel
\Defun {p-lisproot-time} {{\funarg{p-objid}} {\opt} {\funarg{depth}} {\funarg{p-heap}}}


\Argumentslabel
 \isanobjid{\funarg{p-objid}}
\Purposelabel
 Get the value of slot
 {\bf p-time}
 of the persistent-lisproot referenced by \funarg{p-objid}.
\Seealsolabel
 Section \fcite{p-lisproot- ...}.


\endcom

\beginfncom[Internal]{(setf p-lisproot-time)}

\Syntaxlabel
\Defun {(setf p-lisproot-time)} {{\funarg{t-time}} {\funarg{p-objid}} {\opt} {\funarg{depth}} {\funarg{p-heap}}}


\Argumentslabel
 \isanumber{\funarg{t-time}}
 \isanobjid{\funarg{p-objid}}
\Purposelabel
 Set the value of slot
 {\bf p-time}
 of the persistent-lisproot referenced by
 \funarg{p-objid}\ to \funarg{t-time}.
\Seealsolabel
 Section \fcite{p-lisproot- ...}.


\endcom

\beginfncom[Internal]{p-lisproot-version}

\Syntaxlabel
\Defun {p-lisproot-version} {{\funarg{p-objid}} {\opt} {\funarg{depth}} {\funarg{p-heap}}}


\Argumentslabel
 \isanobjid{\funarg{p-objid}}
\Purposelabel
 Get the value of slot
 {\bf p-version}
 of the persistent-lisproot referenced by \funarg{p-objid}.
\Seealsolabel
 Section \fcite{p-lisproot- ...}.


\endcom

\beginfncom[Internal]{(setf p-lisproot-version)}

\Syntaxlabel
\Defun {(setf p-lisproot-version)} {{\funarg{t-version}} {\funarg{p-objid}} {\opt} {\funarg{depth}} {\funarg{p-heap}}}


\Argumentslabel
 \isanumber{\funarg{t-version}}
 \isanobjid{\funarg{p-objid}}
\Purposelabel
 Set the value of slot
 {\bf p-version}
 of the persistent-lisproot referenced by
 \funarg{p-objid}\ to \funarg{t-version}.
\Seealsolabel
 Section \fcite{p-lisproot- ...}.


\endcom

\beginfncom[Internal]{p-lisprootp}

\Syntaxlabel
\Defun {p-lisprootp} {{\funarg{p-objid}} {\opt} {\funarg{p-heap}}}


\Argumentslabel
 \isanobjid{\funarg{p-objid}}
\Purposelabel
 Returns \nonnil\ iff \funarg{p-objid}\ references a
 persistent object of \fcite{persistent-lisproot},
 \lispnil\ otherwise.


\endcom

\beginfncom[Internal]{p-marker}

\Syntaxlabel
\Defun {p-marker} {{\funarg{p-heap}} {\funarg{p-objid}} {\funarg{at-location}} {\opt} {\funarg{expecting-type-tag}} {\funarg{expecting-class}}}


\Argumentslabel
 \isanobjid{\funarg{p-objid}}
 \isa{\funarg{at-location}}
      {a fixnum}
 \isatypetag{\funarg{expecting-type-tag}}
\Valueslabel
 Returns the marker object located at position
 \funarg{at-location}\ in \funarg{p-objid}; if no marker
 was found, \lispnil\ is returned.
\Purposelabel
 Read a persistent object of (immediate) type marker.
 The slot value of the persistent object referenced by
 \funarg{p-objid}\ at position \funarg{at-location}\ is
 returned as a marker.
\Remarkslabel

 It is checked if \funarg{at-location}\ is a valid position index
 for the persistent object referenced by \funarg{p-objid}.

 If the object contained at position
 \funarg{at-location}\ in the persistent object referenced by
 \funarg{p-objid}\ is an object of type marker,
 the marker is returned, otherwise \lispnil.

 If \funarg{expecting-type-tag}\ is not \lisp{equal}\ to
 \lisp{+null-type-tag+}, it is checked if
 \funarg{p-objid}\ references a persistent object of type
 \funarg{expecting-type-tag}.

 It is checked if a read-lock is set either on `element'-level
 on position \funarg{at-location}\ in \funarg{p-objid}\ or
 on `vector'-level on \funarg{p-objid}; if neither lock is
 set, an `element'-level read lock is set on position
 \funarg{at-location}\ in \funarg{p-objid}.

\Seealsolabel

 \Fcite{(setf p-marker)}.


\endcom

\beginfncom[Internal]{(setf p-marker)}

\Syntaxlabel
\Defun {(setf p-marker)} {{\funarg{the-p-marker}} {\funarg{p-heap}} {\funarg{p-objid}} {\funarg{at-location}} {\opt} {\funarg{expecting-type-tag}} {\funarg{expecting-class}}}


\Argumentslabel
 \isa{\funarg{the-p-marker}}
      {a marker object, i.e.\ one of the values of the constants
       {\bf +slot-unbound-type-tag+},
       {\bf +unbound-type-tag+} or
       {\bf +unstorable-object-marker+}}
 \isanobjid{\funarg{p-objid}}
 \isa{\funarg{at-location}}
      {a fixnum}
 \isatypetag{\funarg{expecting-type-tag}\ %
              resp.\ \funarg{immediate-type-tag}}
\Valueslabel
 \retoldmode{\funarg{p-heap}}{\funarg{p-objid}}
\Purposelabel
 Write to a persistent object's component; the
 slot value of the persistent object referenced by
 \funarg{p-objid}\ at position \funarg{at-location}\ is
 set to \funarg{the-p-marker}. The possible values of 
 \funarg{the-p-marker}\ have following meanings:
 \begin{description}

 \item[{\bf +slot-unbound-type-tag+}]
  The slot of the persistent object referenced by
  \funarg{p-objid}\ at position \funarg{at-location}\ is
  an unbound slot in the sense of \clos.

 \item[{\bf +unbound-type-tag+}]
  The slot of the persistent object referenced by
  \funarg{p-objid}\ at position \funarg{at-location}\ is
  unbound.

 \item[{\bf +unstorable-object-marker+}]
  The slot of the persistent object referenced by
  \funarg{p-objid}\ at position \funarg{at-location}\ contains
  an unstorable object which cannot be reloaded. These are
  e.g.\ objects whose class-extent is marked as
  \lisp{:transient}; if \plob\ `stores' such an object
  at position \funarg{at-location}\ of the persistent object
  referenced by \funarg{p-objid}, not the transient
  object's representation is stored but a
  {\bf +unstorable-object-marker+}.

 \end{description}
\Remarkslabel
 It is checked if \funarg{at-location}\ is a valid position index
 for the persistent object referenced by \funarg{p-objid}.

 If \funarg{expecting-type-tag}\ is not \lisp{equal}\ to
 \lisp{+null-type-tag+}, it is checked if
 \funarg{p-objid}\ references a persistent object of type
 \funarg{expecting-type-tag}.

 It is checked if a write-lock is set either on `element'-level
 on position \funarg{at-location}\ in \funarg{p-objid}\ or
 on `vector'-level on \funarg{p-objid}; if neither lock is
 set, an `element'-level write lock is set on position
 \funarg{at-location}\ in \funarg{p-objid}.
\Seealsolabel
 \Fcite{p-marker}.


\endcom

\beginmccom[Internal]{p-markerp}

\Syntaxlabel
\Defmac {p-markerp} {{\funarg{type-tag}}}

Check if \funarg{type-tag}\ denominates a marker type.


\endcom

\beginfncom[Internal]{p-markerp-fn}

\Syntaxlabel
\Defun {p-markerp-fn} {{\funarg{type-tag}}}


\endcom

\beginfncom[Internal]{p-method-description}

\Syntaxlabel
\Defun {p-method-description} {{\funarg{p-objid}} {\opt} {\funarg{depth}} {\funarg{p-heap}}}


\Argumentslabel

 \isanobjid{\funarg{p-objid}}

\Purposelabel

 Return a transient representation for the persistent
 method-description
 referenced by \funarg{p-objid}.

\Seealsolabel

 \Fcite{(setf p-method-description)}.


\endcom

\beginfncom[Internal]{(setf p-method-description)}

\Syntaxlabel
\Defun {(setf p-method-description)} {{\funarg{t-descr}} {\opt} {\funarg{p-objid}} {\funarg{depth}} {\funarg{p-heap}}}


\Argumentslabel
 \isa{\funarg{t-descr}}
      {a method-description}
 \isanobjid{\funarg{p-objid}}
\Valueslabel
 \retarg{\funarg{t-descr}}
\Purposelabel
 Store the transient method-description in
 \funarg{t-descr}\ to the
 persistent method-description referenced by \funarg{p-objid}.
\Seealsolabel
 \Fcite{p-method-description}.


\endcom

\begindccom[Method Description Accessors]{p-method-description- ...}

\Purposelabel

 All following functions
 {\bf p-method-description-\textsl{\lt{}slot-name\gt}} and
 {\bf (setf p-method-description-\textsl{\lt{}slot-name\gt}\/)}
 with \textsl{\lt{}slot-name\gt} being one of the slot names of
 \fcite{method-description}\ without the `p-' prefix
 access directly a slot of a persistent \clos\ instance
 of \fcite{method-description}\ in the \sh.

 The accessor functions defined here are merely used in the
 bootstrap phase. After the bootstrap, the persistent objects of
 \fcite{method-description}\ are created and accessed as all
 persistent \clos\ instances by employing their
 class-descriptions, i.e.\ all information needed to create
 a persistent \clos\ instance or to access a persistent
 \clos\ instance's slot is contained in its class-description.

\Seealsolabel

 \Fcite{method-description};
 section \fcite{bootstrap ...}.


\endcom

\beginfncom[Internal]{p-method-description-function}

\Syntaxlabel
\Defun {p-method-description-function} {{\funarg{p-objid}} {\opt} {\funarg{depth}} {\funarg{p-heap}}}


\Argumentslabel

 \isanobjid{\funarg{p-objid}}

\Purposelabel

 Get the value of slot
 {\bf p-function}
 of the persistent method-description referenced by \funarg{p-objid}.

\Seealsolabel

 Section \fcite{p-method-description- ...}.


\endcom

\beginfncom[Internal]{(setf p-method-description-function)}

\Syntaxlabel
\Defun {(setf p-method-description-function)} {{\funarg{t-function}} {\funarg{p-objid}} {\opt} {\funarg{depth}} {\funarg{p-heap}}}


\Argumentslabel

 \isa{\funarg{t-function}}
      {a method function}
 \isanobjid{\funarg{p-objid}}

\Purposelabel

 Set the value of slot
 {\bf p-function}
 of the persistent method-description referenced by
 \funarg{p-objid}\ to \funarg{t-function}.

\Seealsolabel

 Section \fcite{p-method-description- ...}.


\endcom

\beginfncom[Internal]{p-method-description-into}

\Syntaxlabel
\Defun {p-method-description-into} {{\funarg{t-into-descr}} {\funarg{p-objid}} {\opt} {\funarg{depth}} {\funarg{p-heap}}}


\Argumentslabel

 \isa{\funarg{t-into-descr}}
      {a method-description}
 \isanobjid{\funarg{p-objid}}

\Purposelabel

 Read the persistent method-description referenced by
 \funarg{p-objid}\ destructively into \funarg{t-into-descr}.

\Seealsolabel

 \Fcite{p-method-description}.


\endcom

\beginfncom[Internal]{p-method-description-lambda-list}

\Syntaxlabel
\Defun {p-method-description-lambda-list} {{\funarg{p-objid}} {\opt} {\funarg{depth}} {\funarg{p-heap}}}


\Argumentslabel

 \isanobjid{\funarg{p-objid}}

\Purposelabel

 Get the value of slot
 {\bf p-lambda-list}
 of the persistent method-description referenced by \funarg{p-objid}.

\Seealsolabel

 Section \fcite{p-method-description- ...}.


\endcom

\beginfncom[Internal]{(setf p-method-description-lambda-list)}

\Syntaxlabel
\Defun {(setf p-method-description-lambda-list)} {{\funarg{t-lambda-list}} {\funarg{p-objid}} {\opt} {\funarg{depth}} {\funarg{p-heap}}}


\Argumentslabel

 \isa{\funarg{t-lambda-list}}
      {a $\lambda$-list}
 \isanobjid{\funarg{p-objid}}

\Purposelabel

 Set the value of slot
 {\bf p-lambda-list}
 of the persistent method-description referenced by
 \funarg{p-objid}\ to \funarg{t-lambda-list}.

\Seealsolabel

 Section \fcite{p-method-description- ...}.


\endcom

\beginfncom[Internal]{p-method-description-name}

\Syntaxlabel
\Defun {p-method-description-name} {{\funarg{p-objid}} {\opt} {\funarg{depth}} {\funarg{p-heap}}}


\Argumentslabel

 \isanobjid{\funarg{p-objid}}

\Purposelabel

 Get the value of slot
 {\bf p-name}
 of the persistent method-description referenced by \funarg{p-objid}.

\Seealsolabel

 Section \fcite{p-method-description- ...}.


\endcom

\beginfncom[Internal]{(setf p-method-description-name)}

\Syntaxlabel
\Defun {(setf p-method-description-name)} {{\funarg{t-name}} {\funarg{p-objid}} {\opt} {\funarg{depth}} {\funarg{p-heap}}}


\Argumentslabel

 \isa{\funarg{t-name}}
      {a symbol}
 \isanobjid{\funarg{p-objid}}

\Purposelabel

 Set the value of slot
 {\bf p-name}
 of the persistent method-description referenced by
 \funarg{p-objid}\ to \funarg{t-name}.

\Seealsolabel

 Section \fcite{p-method-description- ...}.


\endcom

\beginfncom[Internal]{p-method-description-p}

\Syntaxlabel
\Defun {p-method-description-p} {{\funarg{p-objid}} {\opt} {\funarg{p-heap}}}


\Argumentslabel

 \isanobjid{\funarg{p-objid}}

\Purposelabel

 Returns \nonnil\ iff \funarg{p-objid}\ references a
 persistent object of class
 method-description,
 \lispnil\ otherwise.

\Seealsolabel

 \Fcite{method-description}.


\endcom

\beginfncom[Internal]{p-method-description-qualifiers}

\Syntaxlabel
\Defun {p-method-description-qualifiers} {{\funarg{p-objid}} {\opt} {\funarg{depth}} {\funarg{p-heap}}}


\Argumentslabel

 \isanobjid{\funarg{p-objid}}

\Purposelabel

 Get the value of slot
 {\bf p-qualifiers}
 of the persistent method-description referenced by \funarg{p-objid}.

\Seealsolabel

 Section \fcite{p-method-description- ...}.


\endcom

\beginfncom[Internal]{(setf p-method-description-qualifiers)}

\Syntaxlabel
\Defun {(setf p-method-description-qualifiers)} {{\funarg{t-qualifiers}} {\funarg{p-objid}} {\opt} {\funarg{depth}} {\funarg{p-heap}}}


\Argumentslabel

 \isa{\funarg{t-qualifiers}}
      {a list of qualifying (keyword) symbols}
 \isanobjid{\funarg{p-objid}}

\Purposelabel

 Set the value of slot
 {\bf p-qualifiers}
 of the persistent method-description referenced by
 \funarg{p-objid}\ to \funarg{t-qualifiers}.

\Seealsolabel

 Section \fcite{p-method-description- ...}.


\endcom

\beginfncom[Internal]{p-method-description-specializers}

\Syntaxlabel
\Defun {p-method-description-specializers} {{\funarg{p-objid}} {\opt} {\funarg{depth}} {\funarg{p-heap}}}


\Argumentslabel

 \isanobjid{\funarg{p-objid}}

\Purposelabel

 Get the value of slot
 {\bf p-specializers}
 of the persistent method-description referenced by \funarg{p-objid}.

\Seealsolabel

 Section \fcite{p-method-description- ...}.


\endcom

\beginfncom[Internal]{(setf p-method-description-specializers)}

\Syntaxlabel
\Defun {(setf p-method-description-specializers)} {{\funarg{t-specializers}} {\funarg{p-objid}} {\opt} {\funarg{depth}} {\funarg{p-heap}}}


\Argumentslabel

 \isa{\funarg{t-specializers}}
      {a list of specializer metaobjects}
 \isanobjid{\funarg{p-objid}}

\Purposelabel

 Set the value of slot
 {\bf p-specializers}
 of the persistent method-description referenced by
 \funarg{p-objid}\ to \funarg{t-specializers}.

\Seealsolabel

 Section \fcite{p-method-description- ...}.


\endcom

\beginfncom[Internal]{p-objid}

\Syntaxlabel
\Defun {p-objid} {{\funarg{p-heap}} {\funarg{p-id}} {\funarg{at-location}} {\opt} {\funarg{expecting-type-tag}} {\funarg{expecting-class}}}


\Argumentslabel

 \isanobjid{\funarg{p-id}}
 \isa{\funarg{at-location}}
      {a fixnum}
 \isatypetag{\funarg{expecting-type-tag}}

\Valueslabel

 Returns the \objid\ of the object located at position
 \funarg{at-location}\ in \funarg{p-id}.

\Purposelabel

 Read of a non-immediate persistent object; the
 slot value of the persistent object referenced by
 \funarg{p-id}\ at position \funarg{at-location}\ is
 returned as an \objid.

\Remarkslabel

 It is checked if \funarg{at-location}\ is a valid position index
 for the persistent object referenced by \funarg{p-id}.

 It is checked if the object contained at position
 \funarg{at-location}\ in the persistent object referenced by
 \funarg{p-id}\ is a non-immediate object.

 If \funarg{expecting-type-tag}\ is not \lisp{equal}\ to
 \lisp{+null-type-tag+}, it is checked if
 \funarg{p-id}\ references a persistent object of type
 \funarg{expecting-type-tag}.

 It is checked if a read-lock is set either on `element'-level
 on position \funarg{at-location}\ in \funarg{p-id}\ or
 on `vector'-level on \funarg{p-id}; if neither lock is
 set, an `element'-level read lock is set on position
 \funarg{at-location}\ in \funarg{p-id}.

\Seealsolabel

 \Fcite{(setf p-objid)};
 \fcite{sh-read-objid}.


\endcom

\beginfncom[Internal]{(setf p-objid)}

\Syntaxlabel
\Defun {(setf p-objid)} {{\funarg{the-objid}} {\funarg{p-heap}} {\funarg{p-id}} {\funarg{at-location}} {\opt} {\funarg{expecting-type-tag}} {\funarg{expecting-class}}}


\Argumentslabel
 \isanobjid{\funarg{the-objid}\ resp.\ \funarg{p-id}}
 \isa{\funarg{at-location}}
      {a fixnum}
 \isatypetag{\funarg{expecting-type-tag}}
\Valueslabel
 \retoldmode{\funarg{p-heap}}{\funarg{p-id}}
\Purposelabel
 Write to a persistent object's component; the
 slot value of the persistent object referenced by
 \funarg{p-id}\ at position \funarg{at-location}\ is
 set to \funarg{the-objid}.
\Remarkslabel
 It is checked if \funarg{at-location}\ is a valid position index
 for the persistent object referenced by \funarg{p-id}.

 If \funarg{expecting-type-tag}\ is not \lisp{equal}\ to
 \lisp{+null-type-tag+}, it is checked if
 \funarg{p-id}\ references a persistent object of type
 \funarg{expecting-type-tag}.

 It is checked if a write-lock is set either on `element'-level
 on position \funarg{at-location}\ in \funarg{p-id}\ or
 on `vector'-level on \funarg{p-id}; if neither lock is
 set, an `element'-level write lock is set on position
 \funarg{at-location}\ in \funarg{p-id}.
\Seealsolabel
 \Fcite{p-objid};
 \fcite{sh-write-objid}.


\endcom

\beginfncom[Internal]{p-objid-size}

\Syntaxlabel
\Defun {p-objid-size} {{\funarg{p-objid}} {\opt} {\funarg{p-heap}}}


\Argumentslabel
 \isanobjid{\funarg{p-objid}}
\Purposelabel
 Return the number of words of the reference field
 for the persistent object referenced by \funarg{p-objid}.

 There is {\sl no} {\bf (setf p-objid-size)} because the size of a
 persistent object cannot be changed; it is fix for its lifetime.
\Seealsolabel
 \Fcite{p-value-size};
 \fcite{sh-objid-size};
 \fcite{p-allocate}.


\endcom

\begingfcom[Internal]{p-objid-to-t-object}

\Syntaxlabel
\Defgen {p-objid-to-t-object} {{\funarg{p-objid}} {\funarg{p-objid-type-tag}} {\funarg{depth}} {\funarg{p-heap}}}


\Argumentslabel
 \isa{\funarg{p-objid}}
      {either a numeric immediate value or an \objid}
 \isatypetag{\funarg{p-objid-type-tag}}
\Valueslabel
 A transient representation of the persistent object referenced by
 \funarg{p-objid}\ is returned.
\Purposelabel
 The workhorse for \fcite{load-object}: Loads the persistent object
 referenced by \funarg{p-objid}\ from the \sh\ into a transient
 representation directly usable by \cl.
\Seealsolabel
 \Fcite{load-object};
 \fcite{t-object-to-p-objid}.


\Methodslabel

\flabel{\protect\mtd}{p-objid-to-t-object :around (t t t t)}{}
{\Defmetharound {p-objid-to-t-object} {{\funarg{p-objid}} {\funarg{p-type-tag}} {\funarg{depth}} {\funarg{p-heap}}}}
Handle \funarg{depth}.

\flabel{\protect\mtd}{p-objid-to-t-object (integer t (eql object) t)}{}
{\Defmeth {p-objid-to-t-object} {(\funarg{p-objid}\ \ObjectWithRef{integer}) {\funarg{p-objid-type-tag}} (\funarg{depth}\ \ObjectWithRef{(eql :object)}) {\funarg{p-heap}}}}
%
% No behavior is specified for this method beyond that which is specified
% for the generic function.

\flabel{\protect\mtd}{p-objid-to-t-object (integer t (eql objid) t)}{}
{\Defmeth {p-objid-to-t-object} {(\funarg{p-objid}\ \ObjectWithRef{integer}) {\funarg{p-objid-type-tag}} (\funarg{depth}\ \ObjectWithRef{(eql :objid)}) {\funarg{p-heap}}}}
%
% No behavior is specified for this method beyond that which is specified
% for the generic function.

\flabel{\protect\mtd}{p-objid-to-t-object (persistent-object t (eql object) t)}{}
{\Defmeth {p-objid-to-t-object} {(\funarg{p-objid}\ \ObjectWithRef{persistent-object}) {\funarg{p-objid-type-tag}} (\funarg{depth}\ \ObjectWithRef{(eql :object)}) {\funarg{p-heap}}}}
%
% No behavior is specified for this method beyond that which is specified
% for the generic function.

\flabel{\protect\mtd}{p-objid-to-t-object (persistent-object t (eql objid) t)}{}
{\Defmeth {p-objid-to-t-object} {(\funarg{p-objid}\ \ObjectWithRef{persistent-object}) {\funarg{p-objid-type-tag}} (\funarg{depth}\ \ObjectWithRef{(eql :objid)}) {\funarg{p-heap}}}}
%
% No behavior is specified for this method beyond that which is specified
% for the generic function.

\flabel{\protect\mtd}{p-objid-to-t-object (t (eql +array-type-tag+) t t)}{}
{\Defmeth {p-objid-to-t-object} {{\funarg{p-objid}} (\funarg{p-objid-type-tag}\ \ObjectWithRef{(eql +array-type-tag+)}) {\funarg{depth}} {\funarg{p-heap}}}}
%
% No behavior is specified for this method beyond that which is specified
% for the generic function.

\flabel{\protect\mtd}{p-objid-to-t-object (t (eql +bignum-type-tag+) t t)}{}
{\Defmeth {p-objid-to-t-object} {{\funarg{p-objid}} (\funarg{p-objid-type-tag}\ \ObjectWithRef{(eql +bignum-type-tag+)}) {\funarg{depth}} {\funarg{p-heap}}}}
%
% No behavior is specified for this method beyond that which is specified
% for the generic function.

\flabel{\protect\mtd}{p-objid-to-t-object (t (eql +bit-vector-type-tag+) t t)}{}
{\Defmeth {p-objid-to-t-object} {{\funarg{p-objid}} (\funarg{p-objid-type-tag}\ \ObjectWithRef{(eql +bit-vector-type-tag+)}) {\funarg{depth}} {\funarg{p-heap}}}}
%
% No behavior is specified for this method beyond that which is specified
% for the generic function.

\flabel{\protect\mtd}{p-objid-to-t-object (t (eql +btree-page-tag+) t t)}{}
{\Defmeth {p-objid-to-t-object} {{\funarg{p-objid}} (\funarg{p-objid-type-tag}\ \ObjectWithRef{(eql +btree-page-tag+)}) {\funarg{depth}} {\funarg{p-heap}}}}
Loads a persistent BTree page from the \sh.

\flabel{\protect\mtd}{p-objid-to-t-object (t (eql +btree-type-tag+) t t)}{}
{\Defmeth {p-objid-to-t-object} {{\funarg{p-objid}} (\funarg{p-objid-type-tag}\ \ObjectWithRef{(eql +btree-type-tag+)}) {\funarg{depth}} {\funarg{p-heap}}}}
Loads a persistent BTree from the \sh.

\flabel{\protect\mtd}{p-objid-to-t-object (t (eql +built-in-type-tag+) t t)}{}
{\Defmeth {p-objid-to-t-object} {{\funarg{p-objid}} (\funarg{p-objid-type-tag}\ \ObjectWithRef{(eql +built-in-type-tag+)}) {\funarg{depth}} {\funarg{p-heap}}}}
%
% No behavior is specified for this method beyond that which is specified
% for the generic function.

\flabel{\protect\mtd}{p-objid-to-t-object (t (eql +character-type-tag+) t t)}{}
{\Defmeth {p-objid-to-t-object} {{\funarg{p-objid}} (\funarg{p-objid-type-tag}\ \ObjectWithRef{(eql +character-type-tag+)}) {\funarg{depth}} {\funarg{p-heap}}}}
Returns the \lisp{character}\ of \funarg{p-objid}.

\flabel{\protect\mtd}{p-objid-to-t-object (t (eql +complex-type-tag+) t t)}{}
{\Defmeth {p-objid-to-t-object} {{\funarg{p-objid}} (\funarg{p-objid-type-tag}\ \ObjectWithRef{(eql +complex-type-tag+)}) {\funarg{depth}} {\funarg{p-heap}}}}
%
% No behavior is specified for this method beyond that which is specified
% for the generic function.

\flabel{\protect\mtd}{p-objid-to-t-object (t (eql +cons-type-tag+) t t)}{}
{\Defmeth {p-objid-to-t-object} {{\funarg{p-objid}} (\funarg{p-objid-type-tag}\ \ObjectWithRef{(eql +cons-type-tag+)}) {\funarg{depth}} {\funarg{p-heap}}}}
%
% No behavior is specified for this method beyond that which is specified
% for the generic function.

\flabel{\protect\mtd}{p-objid-to-t-object (t (eql +double-float-type-tag+) t t)}{}
{\Defmeth {p-objid-to-t-object} {{\funarg{p-objid}} (\funarg{p-objid-type-tag}\ \ObjectWithRef{(eql +double-float-type-tag+)}) {\funarg{depth}} {\funarg{p-heap}}}}
%
% No behavior is specified for this method beyond that which is specified
% for the generic function.

\flabel{\protect\mtd}{p-objid-to-t-object (t (eql +fixnum-type-tag+) t t)}{}
{\Defmeth {p-objid-to-t-object} {{\funarg{p-objid}} (\funarg{p-objid-type-tag}\ \ObjectWithRef{(eql +fixnum-type-tag+)}) {\funarg{depth}} {\funarg{p-heap}}}}
Returns \funarg{p-objid}\ itself.

\flabel{\protect\mtd}{p-objid-to-t-object (t (eql +function-type-tag+) t t)}{}
{\Defmeth {p-objid-to-t-object} {{\funarg{p-objid}} (\funarg{p-objid-type-tag}\ \ObjectWithRef{(eql +function-type-tag+)}) {\funarg{depth}} {\funarg{p-heap}}}}
%
% No behavior is specified for this method beyond that which is specified
% for the generic function.

\flabel{\protect\mtd}{p-objid-to-t-object (t (eql +heap-type-tag+) t t)}{}
{\Defmeth {p-objid-to-t-object} {{\funarg{p-objid}} (\funarg{p-objid-type-tag}\ \ObjectWithRef{(eql +heap-type-tag+)}) {\funarg{depth}} {\funarg{p-heap}}}}
%
% No behavior is specified for this method beyond that which is specified
% for the generic function.

\flabel{\protect\mtd}{p-objid-to-t-object (t (eql +instance-type-tag+) t t)}{}
{\Defmeth {p-objid-to-t-object} {{\funarg{p-objid}} (\funarg{p-objid-type-tag}\ \ObjectWithRef{(eql +instance-type-tag+)}) {\funarg{depth}} {\funarg{p-heap}}}}
%
% No behavior is specified for this method beyond that which is specified
% for the generic function.

\flabel{\protect\mtd}{p-objid-to-t-object (t (eql +ivector-type-tag+) t t)}{}
{\Defmeth {p-objid-to-t-object} {{\funarg{p-objid}} (\funarg{p-objid-type-tag}\ \ObjectWithRef{(eql +ivector-type-tag+)}) {\funarg{depth}} {\funarg{p-heap}}}}
%
% No behavior is specified for this method beyond that which is specified
% for the generic function.

\flabel{\protect\mtd}{p-objid-to-t-object (t (eql +machine-type-tag+) t t)}{}
{\Defmeth {p-objid-to-t-object} {{\funarg{p-objid}} (\funarg{p-objid-type-tag}\ \ObjectWithRef{(eql +machine-type-tag+)}) {\funarg{depth}} {\funarg{p-heap}}}}
%
% No behavior is specified for this method beyond that which is specified
% for the generic function.

\flabel{\protect\mtd}{p-objid-to-t-object (t (eql +max-tag+) t t)}{}
{\Defmeth {p-objid-to-t-object} {{\funarg{p-objid}} (\funarg{p-objid-type-tag}\ \ObjectWithRef{(eql +max-tag+)}) {\funarg{depth}} {\funarg{p-heap}}}}
Returns the \fcite{+plob-max-marker+}.

\flabel{\protect\mtd}{p-objid-to-t-object (t (eql +min-tag+) t t)}{}
{\Defmeth {p-objid-to-t-object} {{\funarg{p-objid}} (\funarg{p-objid-type-tag}\ \ObjectWithRef{(eql +min-tag+)}) {\funarg{depth}} {\funarg{p-heap}}}}
Returns the \fcite{+plob-min-marker+}.

\flabel{\protect\mtd}{p-objid-to-t-object (t (eql +ratio-type-tag+) t t)}{}
{\Defmeth {p-objid-to-t-object} {{\funarg{p-objid}} (\funarg{p-objid-type-tag}\ \ObjectWithRef{(eql +ratio-type-tag+)}) {\funarg{depth}} {\funarg{p-heap}}}}
%
% No behavior is specified for this method beyond that which is specified
% for the generic function.

\flabel{\protect\mtd}{p-objid-to-t-object (t (eql +short-objid-tag+) t t)}{}
{\Defmeth {p-objid-to-t-object} {{\funarg{p-objid}} (\funarg{p-objid-type-tag}\ \ObjectWithRef{(eql +short-objid-tag+)}) {\funarg{depth}} {\funarg{p-heap}}}}
Get the `real' type of the persistent object referenced by
 \funarg{p-objid}\ and go on with this \typetag.

\flabel{\protect\mtd}{p-objid-to-t-object (t (eql +single-float-type-tag+) t t)}{}
{\Defmeth {p-objid-to-t-object} {{\funarg{p-objid}} (\funarg{p-objid-type-tag}\ \ObjectWithRef{(eql +single-float-type-tag+)}) {\funarg{depth}} {\funarg{p-heap}}}}
%
% No behavior is specified for this method beyond that which is specified
% for the generic function.

\flabel{\protect\mtd}{p-objid-to-t-object (t (eql +string-type-tag+) t t)}{}
{\Defmeth {p-objid-to-t-object} {{\funarg{p-objid}} (\funarg{p-objid-type-tag}\ \ObjectWithRef{(eql +string-type-tag+)}) {\funarg{depth}} {\funarg{p-heap}}}}
%
% No behavior is specified for this method beyond that which is specified
% for the generic function.

\flabel{\protect\mtd}{p-objid-to-t-object (t (eql +structure-type-tag+) t t)}{}
{\Defmeth {p-objid-to-t-object} {{\funarg{p-objid}} (\funarg{p-objid-type-tag}\ \ObjectWithRef{(eql +structure-type-tag+)}) {\funarg{depth}} {\funarg{p-heap}}}}
%
% No behavior is specified for this method beyond that which is specified
% for the generic function.

\flabel{\protect\mtd}{p-objid-to-t-object (t (eql +symbol-type-tag+) t t)}{}
{\Defmeth {p-objid-to-t-object} {{\funarg{p-objid}} (\funarg{p-objid-type-tag}\ \ObjectWithRef{(eql +symbol-type-tag+)}) {\funarg{depth}} {\funarg{p-heap}}}}
%
% No behavior is specified for this method beyond that which is specified
% for the generic function.

\flabel{\protect\mtd}{p-objid-to-t-object (t (eql +unbound-type-tag+) t t)}{}
{\Defmeth {p-objid-to-t-object} {{\funarg{p-objid}} (\funarg{p-objid-type-tag}\ \ObjectWithRef{(eql +unbound-type-tag+)}) {\funarg{depth}} {\funarg{p-heap}}}}
Returns the \fcite{+plob-unbound-marker+}.

\flabel{\protect\mtd}{p-objid-to-t-object (t (eql +unstorable-object-marker+) t t)}{}
{\Defmeth {p-objid-to-t-object} {{\funarg{p-objid}} (\funarg{p-objid-type-tag}\ \ObjectWithRef{(eql +unstorable-object-marker+)}) {\funarg{depth}} {\funarg{p-heap}}}}
Returns the \fcite{+plob-unstorable-object-marker+}.

\flabel{\protect\mtd}{p-objid-to-t-object (t (eql +vector-type-tag+) t t)}{}
{\Defmeth {p-objid-to-t-object} {{\funarg{p-objid}} (\funarg{p-objid-type-tag}\ \ObjectWithRef{(eql +vector-type-tag+)}) {\funarg{depth}} {\funarg{p-heap}}}}
%
% No behavior is specified for this method beyond that which is specified
% for the generic function.

\flabel{\protect\mtd}{p-objid-to-t-object (t t t t)}{}
{\Defmeth {p-objid-to-t-object} {{\funarg{p-objid}} {\funarg{p-objid-type-tag}} {\funarg{depth}} {\funarg{p-heap}}}}
Signals an error.


\endcom

\beginfncom[Internal]{p-objid-to-t-slot}

\Syntaxlabel
\Defun {p-objid-to-t-slot} {{\funarg{p-objid}} {\funarg{at-location}} {\funarg{depth}} {\funarg{p-heap}} {\funarg{t-set-function}} {\opt} {\funarg{expecting-type-tag}} {\funarg{expecting-class}} {\funarg{p-get-function}}}


\Argumentslabel
 See \fcite{p-objid-to-t-slot-in-transaction}.
\Valueslabel
 See \fcite{p-objid-to-t-slot-in-transaction}.
\Purposelabel
 Calls the \fcite{p-objid-to-t-slot-in-transaction}\ ensuring
 that the call will be embedded into a transaction on
 \funarg{p-heap}.
\Seealsolabel
 \Fcite{p-objid-to-t-slot-in-transaction};
 \fcite{t-slot-to-p-objid}.


\endcom

\beginfncom[Internal]{p-objid-to-t-slot-in-transaction}

\Syntaxlabel
\Defun {p-objid-to-t-slot-in-transaction} {{\funarg{p-objid}} {\funarg{at-location}} {\funarg{depth}} {\funarg{p-heap}} {\funarg{t-set-function}} {\opt} {\funarg{expecting-type-tag}} {\funarg{expecting-class}} {\funarg{p-get-function}}}


\Argumentslabel
 \isanobjid{\funarg{p-objid}}
 \isa{\funarg{at-location}}
      {a fixnum}
 \isatypetag{\funarg{expecting-type-tag}}
\Valueslabel
 Returns three values:
 \begin{enumerate}

 \item The transient representation of the persistent object
  located at position \funarg{at-location}\ in \funarg{p-objid}.

 \item The \objid\ of the persistent object located at position
  \funarg{at-location}\ in \funarg{p-objid}.

 \item The \typetag\ of the persistent object located at position
  \funarg{at-location}\ in \funarg{p-objid}.

 \end{enumerate}

\Purposelabel
 Read a persistent object's component; the
 slot value of the persistent object referenced by
 \funarg{p-objid}\ at position \funarg{at-location}\ is
 returned in its transient representation.
\Seealsolabel
 \Fcite{p-index}.


\endcom

\begindccom[Persistent Package Accessors]{p-package- ...}

\Purposelabel
 All following functions
 {\bf p-package-\textsl{\lt{}slot-name\gt}} and
 {\bf (setf p-package-\textsl{\lt{}slot-name\gt}\/)}
 with \textsl{\lt{}slot-name\gt} being one of the slot names of
 \fcite{persistent-package}\ without the `p-' prefix
 access directly a slot of a persistent structure instance
 of \fcite{persistent-package}\ in the \sh.

 The accessor functions defined here are merely used in the
 bootstrap phase. After the bootstrap, the persistent objects of
 \fcite{persistent-package}\ are created and accessed as all
 persistent structure objects by employing their
 structure-descriptions, i.e.\ all information needed to create
 a persistent structure object or to access a persistent structure
 object's slot is contained in its structure-description.
\Seealsolabel
 \Fcite{persistent-package};
 section \fcite{bootstrap ...}.


\endcom

\beginfncom[Internal]{p-packagep}

\Syntaxlabel
\Defun {p-packagep} {{\funarg{p-objid}} {\opt} {\funarg{p-heap}}}


\Argumentslabel
 \isanobjid{\funarg{p-objid}}
\Purposelabel
 Returns \nonnil\ iff \funarg{p-objid}\ references a
 persistent object of class
 persistent-package,
 \lispnil\ otherwise.
\Seealsolabel
 \Fcite{persistent-package};
 \fcite{packagep}.


\endcom

\beginfncom[Internal]{p-set-lock}

\Syntaxlabel
\Defun {p-set-lock} {{\funarg{p-heap}} {\funarg{p-objid}} {\opt} {\funarg{expecting-type-tag}} {\funarg{lock-mode}} {\funarg{at-location}}}


\Argumentslabel
 \isanobjid{\funarg{p-objid}}
 \isatypetag{\funarg{expecting-type-tag}}
 \isa{\funarg{lock-mode}}
      {a fixnum bitwise-or'ed from
       one of the constant values of
       {\bf *lock-level-\ldots{}*} (figure~\ref{tab:lock-levels}%
       %% 1998/01/07 HK: This makes problems with hyperref:
       %% \fcitepage{\pageref{tab:lock-levels}}%
       ) with
       one of the constant values of {\bf *lock-mode-\ldots{}*}
       (figure~\ref{tab:lock-modes}%
       %% 1998/01/07 HK: This makes problems with hyperref:
       %% \fcitepage{\pageref{tab:lock-modes}}
       )}
 \isa{\funarg{at-location}}
      {a fixnum}
\Valueslabel
 \retoldmode{\funarg{p-heap}}{\funarg{p-objid}}
\Purposelabel
 Set a lock with the level and mode of \funarg{lock-mode}\ to
 \funarg{p-objid}\ or, if the passed \funarg{lock-mode}\ requests
 an `element'-level lock, to the slot of the persistent object
 referenced by \funarg{p-objid}\ at position \funarg{at-location}.
 If there is already such a lock, the lock counter for the passed
 \funarg{lock-mode}\ is incremented.
\Remarkslabel
 If \funarg{expecting-type-tag}\ is not \lisp{equal}\ to
 \lisp{+null-type-tag+}, it is checked if
 \funarg{p-objid}\ references a persistent object of type
 \funarg{expecting-type-tag}.

 If the passed \funarg{lock-mode}\ requests an `element'-level lock,
 it is checked if \funarg{at-location}\ is a valid position index
 for the persistent object referenced by \funarg{p-objid}.
\Seealsolabel
 Section \fcite{locking ...};
 \fcite{p-insert-lock};
 \fcite{p-unlock};
 \fcite{p-unlock-all};
 \fcite{p-unlock-all-all};
 \fcite{sh-set-lock}.


\endcom

\beginfncom[Internal]{p-setf-cdr}

\Syntaxlabel
\Defun {p-setf-cdr} {{\funarg{p-heap}} {\funarg{last-cons-objid}} {\funarg{next-cons}} {\funarg{depth}}}


\Argumentslabel
 \isanobjid{\funarg{last-cons-objid}}
 \isa{\funarg{next-cons}}
      {a transient cons cell}
\Purposelabel
 Tail-recursive function for storing of lists.


\endcom

\begincncom[Internal]{+p-setq-error-prompt+}

\Valuelabel
\begin{CompactCode}
"Cannot p-setq ~S -- not a symbol."
\end{CompactCode}

\Purposelabel
Prompt which is shown in the error message concerning invalid symbols.


\endcom

\beginfncom[Internal]{(setf p-slot-description)}

\Syntaxlabel
\Defun {(setf p-slot-description)} {{\funarg{t-descr}} {\funarg{p-objid}} {\opt} {\funarg{depth}} {\funarg{p-heap}}}


\Argumentslabel
 \isa{\funarg{t-descr}}
      {a slot-description}
 \isanobjid{\funarg{p-objid}}
\Valueslabel
 \retarg{\funarg{t-descr}}
\Purposelabel
 Store the transient slot-description in
 \funarg{t-descr}\ to the
 persistent slot-description referenced by \funarg{p-objid}.
\Seealsolabel
 \Fcite{p-direct-slot-description};
 \fcite{p-effective-slot-description}.


\endcom

\begindccom[Slot Description Accessors]{p-slot-description- ...}

\Purposelabel
 All following functions
 {\bf p-slot-description-\textsl{\lt{}slot-name\gt}} and
 {\bf (setf p-slot-description-\textsl{\lt{}slot-name\gt}\/)}
 with \textsl{\lt{}slot-name\gt} being one of the slot names of
 \fcite{slot-description}, \fcite{direct-slot-description}\ or
 \fcite{effective-slot-description}\ without the `p-' prefix
 access directly a slot of a persistent \clos\ instance
 of one of these classes in the \sh.

 The accessor functions defined here are merely used in the
 bootstrap phase. After the bootstrap, the persistent objects of
 these classes are created and accessed as all
 persistent \clos\ instances by employing their
 class-descriptions, i.e.\ all information needed to create
 a persistent \clos\ instance or to access a persistent
 \clos\ instance's slot is contained in its class-description.
\Seealsolabel
 \Fcite{slot-description};
 \fcite{direct-slot-description};
 \fcite{effective-slot-description};
 section \fcite{bootstrap ...}.


\endcom

\beginfncom[Internal]{p-slot-description-allocation}

\Syntaxlabel
\Defun {p-slot-description-allocation} {{\funarg{p-objid}} {\opt} {\funarg{depth}} {\funarg{p-heap}}}


\Argumentslabel
 \isanobjid{\funarg{p-objid}}
\Purposelabel
 Get the value of slot
 {\bf p-allocation}
 of the persistent slot-description referenced by
 \funarg{p-objid}.
\Seealsolabel
 Section \fcite{p-slot-description- ...}.


\endcom

\beginfncom[Internal]{(setf p-slot-description-allocation)}

\Syntaxlabel
\Defun {(setf p-slot-description-allocation)} {{\funarg{t-allocation}} {\funarg{p-objid}} {\opt} {\funarg{depth}} {\funarg{p-heap}}}


\Argumentslabel
 \isa{\funarg{t-allocation}}
      {a keyword symbol}
 \isanobjid{\funarg{p-objid}}
\Purposelabel
 Set the value of slot
 {\bf p-allocation}
 of the persistent slot-description referenced by
 \funarg{p-objid}\ to \funarg{t-allocation}.
\Seealsolabel
 Section \fcite{p-slot-description- ...}.


\endcom

\beginfncom[Internal]{p-slot-description-deferred}

\Syntaxlabel
\Defun {p-slot-description-deferred} {{\funarg{p-objid}} {\opt} {\funarg{depth}} {\funarg{p-heap}}}


\Argumentslabel
 \isanobjid{\funarg{p-objid}}
\Purposelabel
 Get the value of slot
 {\bf p-deferred}
 of the persistent slot-description referenced by
 \funarg{p-objid}.
\Seealsolabel
 Section \fcite{p-slot-description- ...}.


\endcom

\beginfncom[Internal]{(setf p-slot-description-deferred)}

\Syntaxlabel
\Defun {(setf p-slot-description-deferred)} {{\funarg{t-deferred}} {\funarg{p-objid}} {\opt} {\funarg{depth}} {\funarg{p-heap}}}


\Argumentslabel
 \isa{\funarg{t-deferred}}
      {a (keyword) symbol}
 \isanobjid{\funarg{p-objid}}
\Purposelabel
 Set the value of slot
 {\bf p-deferred}
 of the persistent slot-description referenced by
 \funarg{p-objid}\ to \funarg{t-deferred}.
\Seealsolabel
 Section \fcite{p-slot-description- ...}.


\endcom

\beginfncom[Internal]{p-slot-description-extent}

\Syntaxlabel
\Defun {p-slot-description-extent} {{\funarg{p-objid}} {\opt} {\funarg{depth}} {\funarg{p-heap}}}


\Argumentslabel
 \isanobjid{\funarg{p-objid}}
\Purposelabel
 Get the value of slot
 {\bf p-extent}
 of the persistent slot-description referenced by
 \funarg{p-objid}.
\Seealsolabel
 Section \fcite{p-slot-description- ...}.


\endcom

\beginfncom[Internal]{(setf p-slot-description-extent)}

\Syntaxlabel
\Defun {(setf p-slot-description-extent)} {{\funarg{t-extent}} {\funarg{p-objid}} {\opt} {\funarg{depth}} {\funarg{p-heap}}}


\Argumentslabel
 \isa{\funarg{t-extent}}
      {a (keyword) symbol}
 \isanobjid{\funarg{p-objid}}
\Purposelabel
 Set the value of slot
 {\bf p-extent}
 of the persistent slot-description referenced by
 \funarg{p-objid}\ to \funarg{t-extent}.
\Seealsolabel
 Section \fcite{p-slot-description- ...}.


\endcom

\beginfncom[Internal]{p-slot-description-index}

\Syntaxlabel
\Defun {p-slot-description-index} {{\funarg{p-objid}} {\opt} {\funarg{depth}} {\funarg{p-heap}}}


\Argumentslabel
 \isanobjid{\funarg{p-objid}}
\Purposelabel
 Get the value of slot
 {\bf p-index}
 of the persistent slot-description referenced by
 \funarg{p-objid}.
\Seealsolabel
 Section \fcite{p-slot-description- ...}.


\endcom

\beginfncom[Internal]{(setf p-slot-description-index)}

\Syntaxlabel
\Defun {(setf p-slot-description-index)} {{\funarg{t-index}} {\funarg{p-objid}} {\opt} {\funarg{depth}} {\funarg{p-heap}}}


\Argumentslabel
 \isa{\funarg{t-index}}
      {an index-defining expression }
 \isanobjid{\funarg{p-objid}}
\Purposelabel
 Set the value of slot
 {\bf p-index}
 of the persistent slot-description referenced by
 \funarg{p-objid}\ to \funarg{t-index}.
\Seealsolabel
 Section \fcite{p-slot-description- ...}.


\endcom

\beginfncom[Internal]{p-slot-description-initargs}

\Syntaxlabel
\Defun {p-slot-description-initargs} {{\funarg{p-objid}} {\opt} {\funarg{depth}} {\funarg{p-heap}}}


\Argumentslabel
 \isanobjid{\funarg{p-objid}}
\Purposelabel
 Get the value of slot
 {\bf p-initargs}
 of the persistent slot-description referenced by
 \funarg{p-objid}.
\Seealsolabel
 Section \fcite{p-slot-description- ...}.


\endcom

\beginfncom[Internal]{(setf p-slot-description-initargs)}

\Syntaxlabel
\Defun {(setf p-slot-description-initargs)} {{\funarg{t-initargs}} {\funarg{p-objid}} {\opt} {\funarg{depth}} {\funarg{p-heap}}}


\Argumentslabel
 \isa{\funarg{t-initargs}}
      {a list of (keyword) symbols}
 \isanobjid{\funarg{p-objid}}
\Purposelabel
 Set the value of slot
 {\bf p-initargs}
 of the persistent slot-description referenced by
 \funarg{p-objid}\ to \funarg{t-initarg}.
\Seealsolabel
 Section \fcite{p-slot-description- ...}.


\endcom

\beginfncom[Internal]{p-slot-description-initform}

\Syntaxlabel
\Defun {p-slot-description-initform} {{\funarg{p-objid}} {\opt} {\funarg{depth}} {\funarg{p-heap}}}


\Argumentslabel
 \isanobjid{\funarg{p-objid}}
\Purposelabel
 Get the value of slot
 {\bf p-initform}
 of the persistent slot-description referenced by
 \funarg{p-objid}.
\Seealsolabel
 Section \fcite{p-slot-description- ...}.


\endcom

\beginfncom[Internal]{(setf p-slot-description-initform)}

\Syntaxlabel
\Defun {(setf p-slot-description-initform)} {{\funarg{t-initform}} {\funarg{p-objid}} {\opt} {\funarg{depth}} {\funarg{p-heap}}}


\Argumentslabel
 \isa{\funarg{t-initform}}
      {an expression}
 \isanobjid{\funarg{p-objid}}
\Purposelabel
 Set the value of slot
 {\bf p-initform}
 of the persistent slot-description referenced by
 \funarg{p-objid}\ to \funarg{t-initform}.
\Seealsolabel
 Section \fcite{p-slot-description- ...}.


\endcom

\beginfncom[Internal]{p-slot-description-initfunction}

\Syntaxlabel
\Defun {p-slot-description-initfunction} {{\funarg{p-objid}} {\opt} {\funarg{depth}} {\funarg{p-heap}}}


\Argumentslabel
 \isanobjid{\funarg{p-objid}}
\Purposelabel
 Get the value of slot
 {\bf p-initfunction}
 of the persistent slot-description referenced by
 \funarg{p-objid}.
\Seealsolabel
 Section \fcite{p-slot-description- ...}.


\endcom

\beginfncom[Internal]{(setf p-slot-description-initfunction)}

\Syntaxlabel
\Defun {(setf p-slot-description-initfunction)} {{\funarg{t-initfunction}} {\funarg{p-objid}} {\opt} {\funarg{depth}} {\funarg{p-heap}}}


\Argumentslabel
 \isa{\funarg{t-initfunction}}
      {a function}
 \isanobjid{\funarg{p-objid}}
\Purposelabel
 Set the value of slot
 {\bf p-initfunction}
 of the persistent slot-description referenced by
 \funarg{p-objid}\ to \funarg{t-initfunction}.
\Seealsolabel
 Section \fcite{p-slot-description- ...}.


\endcom

\beginfncom[Internal]{p-slot-description-into}

\Syntaxlabel
\Defun {p-slot-description-into} {{\funarg{t-into-descr}} {\funarg{p-objid}} {\opt} {\funarg{depth}} {\funarg{p-heap}}}


\Argumentslabel
 \isa{\funarg{t-into-descr}}
      {a slot-description}
 \isanobjid{\funarg{p-objid}}
\Purposelabel
 Read the persistent slot-description referenced by
 \funarg{p-objid}\ destructively into \funarg{t-into-descr}.
\Seealsolabel
 \Fcite{p-direct-slot-description};
 \fcite{p-effective-slot-description}.


\endcom

\beginfncom[Internal]{p-slot-description-location}

\Syntaxlabel
\Defun {p-slot-description-location} {{\funarg{p-objid}} {\opt} {\funarg{depth}} {\funarg{p-heap}}}


\Argumentslabel
 \isanobjid{\funarg{p-objid}}
\Purposelabel
 Get the value of slot
 {\bf p-location}
 of the persistent effective-slot-description referenced by
 \funarg{p-objid}.
\Seealsolabel
 Section \fcite{p-slot-description- ...}.


\endcom

\beginfncom[Internal]{(setf p-slot-description-location)}

\Syntaxlabel
\Defun {(setf p-slot-description-location)} {{\funarg{t-location}} {\funarg{p-objid}} {\opt} {\funarg{depth}} {\funarg{p-heap}}}


\Argumentslabel
 \isanobject{\funarg{t-location}}
 \isanobjid{\funarg{p-objid}}
\Purposelabel
 Set the value of slot
 {\bf p-location}
 of the persistent effective-slot-description referenced by
 \funarg{p-objid}\ to \funarg{t-location}.
\Seealsolabel
 Section \fcite{p-slot-description- ...}.


\endcom

\beginfncom[Internal]{p-slot-description-name}

\Syntaxlabel
\Defun {p-slot-description-name} {{\funarg{p-objid}} {\opt} {\funarg{depth}} {\funarg{p-heap}}}


\Argumentslabel
 \isanobjid{\funarg{p-objid}}
\Purposelabel
 Get the value of slot
 {\bf p-name}
 of the persistent slot-description referenced by
 \funarg{p-objid}.
\Seealsolabel
 Section \fcite{p-slot-description- ...}.


\endcom

\beginfncom[Internal]{(setf p-slot-description-name)}

\Syntaxlabel
\Defun {(setf p-slot-description-name)} {{\funarg{t-name}} {\funarg{p-objid}} {\opt} {\funarg{depth}} {\funarg{p-heap}}}


\Argumentslabel
 \isa{\funarg{t-name}}
      {a symbol}
 \isanobjid{\funarg{p-objid}}
\Purposelabel
 Set the value of slot
 {\bf p-name}
 of the persistent slot-description referenced by
 \funarg{p-objid}\ to \funarg{t-name}.
\Seealsolabel
 Section \fcite{p-slot-description- ...}.


\endcom

\beginfncom[Internal]{p-slot-description-readers}

\Syntaxlabel
\Defun {p-slot-description-readers} {{\funarg{p-objid}} {\opt} {\funarg{depth}} {\funarg{p-heap}}}


\Argumentslabel
 \isanobjid{\funarg{p-objid}}
\Purposelabel
 Get the value of slot
 {\bf p-readers}
 of the persistent direct-slot-description referenced by
 \funarg{p-objid}.
\Seealsolabel
 Section \fcite{p-slot-description- ...}.


\endcom

\beginfncom[Internal]{(setf p-slot-description-readers)}

\Syntaxlabel
\Defun {(setf p-slot-description-readers)} {{\funarg{t-readers}} {\funarg{p-objid}} {\opt} {\funarg{depth}} {\funarg{p-heap}}}


\Argumentslabel
 \isa{\funarg{t-readers}}
      {a list of reader function symbol}
 \isanobjid{\funarg{p-objid}}
\Purposelabel
 Set the value of slot
 {\bf p-readers}
 of the persistent direct-slot-description referenced by
 \funarg{p-objid}\ to \funarg{t-readers}.
\Seealsolabel
 Section \fcite{p-slot-description- ...}.


\endcom

\beginfncom[Internal]{p-slot-description-type}

\Syntaxlabel
\Defun {p-slot-description-type} {{\funarg{p-objid}} {\opt} {\funarg{depth}} {\funarg{p-heap}}}


\Argumentslabel
 \isanobjid{\funarg{p-objid}}
\Purposelabel
 Get the value of slot
 {\bf p-type}
 of the persistent slot-description referenced by
 \funarg{p-objid}.
\Seealsolabel
 Section \fcite{p-slot-description- ...}.


\endcom

\beginfncom[Internal]{(setf p-slot-description-type)}

\Syntaxlabel
\Defun {(setf p-slot-description-type)} {{\funarg{t-type}} {\funarg{p-objid}} {\opt} {\funarg{depth}} {\funarg{p-heap}}}


\Argumentslabel
 \isa{\funarg{t-type}}
      {a type specifier}
 \isanobjid{\funarg{p-objid}}
\Purposelabel
 Set the value of slot
 {\bf p-type}
 of the persistent slot-description referenced by
 \funarg{p-objid}\ to \funarg{t-type}.
\Seealsolabel
 Section \fcite{p-slot-description- ...}.


\endcom

\beginfncom[Internal]{p-slot-description-writers}

\Syntaxlabel
\Defun {p-slot-description-writers} {{\funarg{p-objid}} {\opt} {\funarg{depth}} {\funarg{p-heap}}}


\Argumentslabel
 \isanobjid{\funarg{p-objid}}
\Purposelabel
 Get the value of slot
 {\bf p-writers}
 of the persistent direct-slot-description referenced by
 \funarg{p-objid}.
\Seealsolabel
 Section \fcite{p-slot-description- ...}.


\endcom

\beginfncom[Internal]{(setf p-slot-description-writers)}

\Syntaxlabel
\Defun {(setf p-slot-description-writers)} {{\funarg{t-writers}} {\funarg{p-objid}} {\opt} {\funarg{depth}} {\funarg{p-heap}}}


\Argumentslabel
 \isa{\funarg{t-writers}}
      {a list of writer function symbols}
 \isanobjid{\funarg{p-objid}}
\Purposelabel
 Set the value of slot
 {\bf p-writers}
 of the persistent direct-slot-description referenced by
 \funarg{p-objid}\ to \funarg{t-writers}.
\Seealsolabel
 Section \fcite{p-slot-description- ...}.


\endcom

\beginfncom[Internal]{p-structure}

\Syntaxlabel
\Defun {p-structure} {{\funarg{p-objid}} {\opt} {\funarg{depth}} {\funarg{p-heap}}}


\Argumentslabel
 \isanobjid{\funarg{p-objid}}
\Purposelabel
 Return a transient representation for the persistent
 structure object
 referenced by \funarg{p-objid}.
\Seealsolabel
 \Fcite{(setf p-structure)}.


\endcom

\beginfncom[Internal]{(setf p-structure)}

\Syntaxlabel
\Defun {(setf p-structure)} {{\funarg{t-structure}} {\opt} {\funarg{p-objid}} {\funarg{depth}} {\funarg{p-heap}}}


\Argumentslabel
 \isa{\funarg{t-structure}}
      {a structure object}
 \isanobjid{\funarg{p-objid}}
\Valueslabel
 \retarg{\funarg{t-structure}}
\Purposelabel
 Store the transient structure object in \funarg{t-structure}\ to
 the persistent structure object referenced by \funarg{p-objid}.
\Seealsolabel
 \Fcite{p-structure}.


\endcom

\beginfncom[Internal]{p-structure-descr}

\Syntaxlabel
\Defun {p-structure-descr} {{\funarg{p-objid}} {\opt} {\funarg{depth}} {\funarg{p-heap}}}


\Argumentslabel
 \isanobjid{\funarg{p-objid}}
\Purposelabel
 Get the value of slot
 {\bf p-descr}
 of the persistent structure referenced by \funarg{p-objid}.
\Seealsolabel
 \Fcite{(setf p-structure-descr)};
 \fcite{persistent-structure}.


\endcom

\beginfncom[Internal]{(setf p-structure-descr)}

\Syntaxlabel
\Defun {(setf p-structure-descr)} {{\funarg{t-descr}} {\funarg{p-objid}} {\opt} {\funarg{depth}} {\funarg{p-heap}}}


\Argumentslabel
 \isa{\funarg{t-descr}}
      {a structure-description}
 \isanobjid{\funarg{p-objid}}
\Purposelabel
 Set the value of slot
 {\bf p-descr}
 of the persistent structure referenced by
 \funarg{p-objid}\ to \funarg{t-descr}.

 This slot defines the class of the persistent structure
 instance referenced by \funarg{p-objid}.
\Seealsolabel
 \Fcite{p-structure-descr};
 \fcite{persistent-structure}.


\endcom

\begindccom[Structure Description Accessors]{p-structure-description- ...}

\Purposelabel
 All following functions
 {\bf p-structure-description-\textsl{\lt{}slot-name\gt}} and
 {\bf (setf p-structure-description-\textsl{\lt{}slot-name\gt}\/)}
 with \textsl{\lt{}slot-name\gt} being one of the slot names of
 \fcite{structure-description}\ without the `p-' prefix
 access directly a slot of a persistent structure instance
 of \fcite{structure-description}\ in the \sh.

 The accessor functions defined here are merely used in the
 bootstrap phase. After the bootstrap, the persistent objects of
 \fcite{structure-description}\ are created and accessed as all
 persistent structure objects by employing their
 structure-descriptions, i.e.\ all information needed to create
 a persistent structure object or to access a persistent structure
 object's slot is contained in its structure-description.
\Seealsolabel
 \Fcite{structure-description};
 section \fcite{bootstrap ...}.


\endcom

\beginfncom[Internal]{p-structure-description-constructor}

\Syntaxlabel
\Defun {p-structure-description-constructor} {{\funarg{p-objid}} {\opt} {\funarg{depth}} {\funarg{p-heap}}}


\Argumentslabel
 \isanobjid{\funarg{p-objid}}
\Purposelabel
 Get the value of slot
 {\bf p-constructor}
 of the persistent structure-description referenced by \funarg{p-objid}.
\Seealsolabel
 Section \fcite{p-structure-description- ...}.


\endcom

\beginfncom[Internal]{(setf p-structure-description-constructor)}

\Syntaxlabel
\Defun {(setf p-structure-description-constructor)} {{\funarg{t-constructor}} {\funarg{p-objid}} {\opt} {\funarg{depth}} {\funarg{p-heap}}}


\Argumentslabel
 \isa{\funarg{t-constructor}}
      {a symbol bound to a function which generates an instance of
       the class described by the persistent structure description
       referenced by \funarg{p-objid}}
 \isanobjid{\funarg{p-objid}}
\Purposelabel
 Set the value of slot
 {\bf p-constructor}
 of the persistent structure-description referenced by
 \funarg{p-objid}\ to \funarg{t-constructor}.
\Seealsolabel
 Section \fcite{p-structure-description- ...}.


\endcom

\beginfncom[Internal]{p-structure-description-dependent}

\Syntaxlabel
\Defun {p-structure-description-dependent} {{\funarg{p-objid}} {\opt} {\funarg{depth}} {\funarg{p-heap}}}


\Argumentslabel
 \isanobjid{\funarg{p-objid}}
\Purposelabel
 Get the value of slot
 {\bf p-dependent}
 of the persistent structure-description referenced by \funarg{p-objid}.
\Seealsolabel
 Section \fcite{p-structure-description- ...}.


\endcom

\beginfncom[Internal]{(setf p-structure-description-dependent)}

\Syntaxlabel
\Defun {(setf p-structure-description-dependent)} {{\funarg{t-dependent}} {\funarg{p-objid}} {\opt} {\funarg{depth}} {\funarg{p-heap}}}


\Argumentslabel
 \isa{\funarg{t-dependent}}
      {a symbol bound to a function which generates an instance of
       the class described by the persistent structure description
       referenced by \funarg{p-objid}}
 \isanobjid{\funarg{p-objid}}
\Purposelabel
 Set the value of slot
 {\bf p-dependent}
 of the persistent structure-description referenced by
 \funarg{p-objid}\ to \funarg{t-dependent}.
\Seealsolabel
 Section \fcite{p-structure-description- ...}.


\endcom

\beginfncom[Internal]{p-structure-description-into}

\Syntaxlabel
\Defun {p-structure-description-into} {{\funarg{t-into-descr}} {\funarg{p-objid}} {\opt} {\funarg{depth}} {\funarg{p-heap}}}


\Argumentslabel
 \isa{\funarg{t-into-descr}}
      {a structure-description}
 \isanobjid{\funarg{p-objid}}
\Purposelabel
 Read the persistent structure-description referenced by
 \funarg{p-objid}\ destructively into \funarg{t-into-descr}.
\Seealsolabel
 \Fcite{p-structure-description}.


\endcom

\beginfncom[Internal]{p-structure-description-next-generation}

\Syntaxlabel
\Defun {p-structure-description-next-generation} {{\funarg{p-objid}} {\opt} {\funarg{depth}} {\funarg{p-heap}}}


\Argumentslabel
 \isanobjid{\funarg{p-objid}}
\Purposelabel
 Get the value of slot
 {\bf p-next-generation}
 of the persistent structure-description referenced by \funarg{p-objid}.
\Seealsolabel
 Section \fcite{p-structure-description- ...}.


\endcom

\beginfncom[Internal]{(setf p-structure-description-next-generation)}

\Syntaxlabel
\Defun {(setf p-structure-description-next-generation)} {{\funarg{t-next-generation}} {\funarg{p-objid}} {\opt} {\funarg{depth}} {\funarg{p-heap}}}


\Argumentslabel
 \isa{\funarg{t-next-generation}}
      {either \lispnil\ or a structure-description}
 \isanobjid{\funarg{p-objid}}
\Purposelabel
 Set the value of slot
 {\bf p-next-generation}
 of the persistent structure-description referenced by
 \funarg{p-objid}\ to \funarg{t-next-generation}.
\Seealsolabel
 Section \fcite{p-structure-description- ...}.


\endcom

\beginfncom[Internal]{p-structure-description-persistent-slot-numbers}

\Syntaxlabel
\Defun {p-structure-description-persistent-slot-numbers} {{\funarg{p-objid}} {\opt} {\funarg{depth}} {\funarg{p-heap}}}


\Argumentslabel
 \isanobjid{\funarg{p-objid}}
\Purposelabel
 Get the value of slot
 {\bf p-persistent-slot-numbers}
 of the persistent structure-description referenced by \funarg{p-objid}.
\Seealsolabel
 Section \fcite{p-structure-description- ...}.


\endcom

\beginfncom[Internal]{(setf p-structure-description-persistent-slot-numbers)}

\Syntaxlabel
\Defun {(setf p-structure-description-persistent-slot-numbers)} {{\funarg{n-slots}} {\funarg{p-objid}} {\opt} {\funarg{depth}} {\funarg{p-heap}}}


\Argumentslabel
 \isa{\funarg{n-slots}}
      {a fixnum}
 \isanobjid{\funarg{p-objid}}
\Purposelabel
 Set the value of slot
 {\bf p-persistent-slot-numbers}
 of the persistent structure-description referenced by
 \funarg{p-objid}\ to \funarg{n-slots}.
\Seealsolabel
 Section \fcite{p-structure-description- ...}.


\endcom

\beginfncom[Internal]{p-structure-description-schema-evolution}

\Syntaxlabel
\Defun {p-structure-description-schema-evolution} {{\funarg{p-objid}} {\opt} {\funarg{depth}} {\funarg{p-heap}}}


\Argumentslabel
 \isanobjid{\funarg{p-objid}}
\Purposelabel
 Get the value of slot
 {\bf p-schema-evolution}
 of the persistent structure-description referenced by \funarg{p-objid}.
\Seealsolabel
 Section \fcite{p-structure-description- ...}.


\endcom

\beginfncom[Internal]{(setf p-structure-description-schema-evolution)}

\Syntaxlabel
\Defun {(setf p-structure-description-schema-evolution)} {{\funarg{t-schema-evolution}} {\funarg{p-objid}} {\opt} {\funarg{depth}} {\funarg{p-heap}}}


\Argumentslabel
 \isa{\funarg{t-schema-evolution}}
      {a keyword symbol}
 \isanobjid{\funarg{p-objid}}
\Purposelabel
 Set the value of slot
 {\bf p-schema-evolution}
 of the persistent structure-description referenced by
 \funarg{p-objid}\ to \funarg{t-schema-evolution}.
\Seealsolabel
 Section \fcite{p-structure-description- ...}.


\endcom

\beginfncom[Internal]{p-structure-description-slot-numbers}

\Syntaxlabel
\Defun {p-structure-description-slot-numbers} {{\funarg{p-objid}} {\opt} {\funarg{depth}} {\funarg{p-heap}}}


\Argumentslabel
 \isanobjid{\funarg{p-objid}}
\Purposelabel
 Get the value of slot
 {\bf p-slot-numbers}
 of the persistent structure-description referenced by \funarg{p-objid}.
\Seealsolabel
 Section \fcite{p-structure-description- ...}.


\endcom

\beginfncom[Internal]{(setf p-structure-description-slot-numbers)}

\Syntaxlabel
\Defun {(setf p-structure-description-slot-numbers)} {{\funarg{n-slots}} {\funarg{p-objid}} {\opt} {\funarg{depth}} {\funarg{p-heap}}}


\Argumentslabel
 \isa{\funarg{n-slots}}
      {a fixnum}
 \isanobjid{\funarg{p-objid}}
\Purposelabel
 Set the value of slot
 {\bf p-slot-numbers}
 of the persistent structure-description referenced by
 \funarg{p-objid}\ to \funarg{n-slots}.
\Seealsolabel
 Section \fcite{p-structure-description- ...}.


\endcom

\beginfncom[Internal]{p-structure-description-time-stamp}

\Syntaxlabel
\Defun {p-structure-description-time-stamp} {{\funarg{p-objid}} {\opt} {\funarg{depth}} {\funarg{p-heap}}}


\Argumentslabel
 \isanobjid{\funarg{p-objid}}
\Purposelabel
 Get the value of slot
 {\bf p-time-stamp}
 of the persistent structure-description referenced by \funarg{p-objid}.
\Seealsolabel
 Section \fcite{p-structure-description- ...}.


\endcom

\beginfncom[Internal]{(setf p-structure-description-time-stamp)}

\Syntaxlabel
\Defun {(setf p-structure-description-time-stamp)} {{\funarg{t-time-stamp}} {\funarg{p-objid}} {\opt} {\funarg{depth}} {\funarg{p-heap}}}


\Argumentslabel
 \isa{\funarg{t-time-stamp}}
      {a time stamp in \cl\ Universal Time divided by 60,
       i.e.\ the time is in minutes, not in seconds.}
 \isanobjid{\funarg{p-objid}}
\Purposelabel
 Set the value of slot
 {\bf p-time-stamp}
 of the persistent structure-description referenced by
 \funarg{p-objid}\ to \funarg{t-time-stamp}.
\Seealsolabel
 Section \fcite{p-structure-description- ...}.


\endcom

\beginfncom[Internal]{p-structure-description-version-number}

\Syntaxlabel
\Defun {p-structure-description-version-number} {{\funarg{p-objid}} {\opt} {\funarg{depth}} {\funarg{p-heap}}}


\Argumentslabel
 \isanobjid{\funarg{p-objid}}
\Purposelabel
 Get the value of slot
 {\bf p-version-number}
 of the persistent structure-description referenced by \funarg{p-objid}.
\Seealsolabel
 Section \fcite{p-structure-description- ...}.


\endcom

\beginfncom[Internal]{(setf p-structure-description-version-number)}

\Syntaxlabel
\Defun {(setf p-structure-description-version-number)} {{\funarg{t-version-number}} {\funarg{p-objid}} {\opt} {\funarg{depth}} {\funarg{p-heap}}}


\Argumentslabel
 \isa{\funarg{t-version-number}}
      {a fixnum}
 \isanobjid{\funarg{p-objid}}
\Purposelabel
 Set the value of slot
 {\bf p-version-number}
 of the persistent structure-description referenced by
 \funarg{p-objid}\ to \funarg{t-version-number}.
\Seealsolabel
 Section \fcite{p-structure-description- ...}.


\endcom

\begindccom[Structure Slot Description Accessors]{p-structure-slot-description- ...}

\Purposelabel
 All following functions
 {\bf p-structure-slot-description-\textsl{\lt{}slot-name\gt}} and
 {\bf (setf p-structure-slot-description-\textsl{\lt{}slot-name\gt}\/)}
 with textsl{\lt{}slot-name\gt} being one of the slot names of
 \fcite{structure-slot-description}\ without the `p-' prefix
 access directly a slot of a persistent structure instance
 of \fcite{structure-description}\ in the \sh.

 The accessor functions defined here are merely used in the
 bootstrap phase. After the bootstrap, the persistent objects of
 \fcite{structure-slot-description}\ are created and accessed as all
 persistent structure objects by employing their
 structure-descriptions, i.e.\ all information needed to create
 a persistent structure object or to access a persistent structure
 object's slot is contained in its structure-description.
\Seealsolabel
 \Fcite{structure-slot-description};
 section \fcite{bootstrap ...}.


\endcom

\beginfncom[Internal]{p-structure-slot-description-deferred}

\Syntaxlabel
\Defun {p-structure-slot-description-deferred} {{\funarg{p-objid}} {\opt} {\funarg{depth}} {\funarg{p-heap}}}


\Argumentslabel
 \isanobjid{\funarg{p-objid}}
\Purposelabel
 Get the value of slot
 {\bf p-deferred}
 of the persistent structure-slot-description referenced by
 \funarg{p-objid}.
\Seealsolabel
 Section \fcite{p-structure-slot-description- ...}.


\endcom

\beginfncom[Internal]{(setf p-structure-slot-description-deferred)}

\Syntaxlabel
\Defun {(setf p-structure-slot-description-deferred)} {{\funarg{t-deferred}} {\funarg{p-objid}} {\opt} {\funarg{depth}} {\funarg{p-heap}}}


\Argumentslabel
 \isa{\funarg{t-deferred}}
      {either \lispnil\ or a fixnum}
 \isanobjid{\funarg{p-objid}}
\Purposelabel
 Set the value of slot
 {\bf p-deferred}
 of the persistent structure-slot-description referenced by
 \funarg{p-objid}\ to \funarg{t-deferred}.
\Seealsolabel
 Section \fcite{p-structure-slot-description- ...}.


\endcom

\beginfncom[Internal]{p-structure-slot-description-extent}

\Syntaxlabel
\Defun {p-structure-slot-description-extent} {{\funarg{p-objid}} {\opt} {\funarg{depth}} {\funarg{p-heap}}}


\Argumentslabel
 \isanobjid{\funarg{p-objid}}
\Purposelabel
 Get the value of slot
 {\bf p-extent}
 of the persistent structure-slot-description referenced by
 \funarg{p-objid}.
\Seealsolabel
 Section \fcite{p-structure-slot-description- ...}.


\endcom

\beginfncom[Internal]{(setf p-structure-slot-description-extent)}

\Syntaxlabel
\Defun {(setf p-structure-slot-description-extent)} {{\funarg{t-extent}} {\funarg{p-objid}} {\opt} {\funarg{depth}} {\funarg{p-heap}}}


\Argumentslabel
 \isa{\funarg{t-extent}}
      {a (keyword) symbol}
 \isanobjid{\funarg{p-objid}}
\Purposelabel
 Set the value of slot
 {\bf p-extent}
 of the persistent structure-slot-description referenced by
 \funarg{p-objid}\ to \funarg{t-extent}.
\Seealsolabel
 Section \fcite{p-structure-slot-description- ...}.


\endcom

\beginfncom[Internal]{p-structure-slot-description-initarg}

\Syntaxlabel
\Defun {p-structure-slot-description-initarg} {{\funarg{p-objid}} {\opt} {\funarg{depth}} {\funarg{p-heap}}}


\Argumentslabel
 \isanobjid{\funarg{p-objid}}
\Purposelabel
 Get the value of slot
 {\bf p-initarg}
 of the persistent structure-slot-description referenced by
 \funarg{p-objid}.
\Seealsolabel
 Section \fcite{p-structure-slot-description- ...}.


\endcom

\beginfncom[Internal]{(setf p-structure-slot-description-initarg)}

\Syntaxlabel
\Defun {(setf p-structure-slot-description-initarg)} {{\funarg{t-initarg}} {\funarg{p-objid}} {\opt} {\funarg{depth}} {\funarg{p-heap}}}


\Argumentslabel
 \isa{\funarg{t-initarg}}
      {a (keyword) symbol}
 \isanobjid{\funarg{p-objid}}
\Purposelabel
 Set the value of slot
 {\bf p-initarg}
 of the persistent structure-slot-description referenced by
 \funarg{p-objid}\ to \funarg{t-initarg}.
\Seealsolabel
 Section \fcite{p-structure-slot-description- ...}.


\endcom

\beginfncom[Internal]{p-structure-slot-description-into}

\Syntaxlabel
\Defun {p-structure-slot-description-into} {{\funarg{t-into-descr}} {\funarg{p-objid}} {\opt} {\funarg{depth}} {\funarg{p-heap}}}


\Argumentslabel
 \isa{\funarg{t-into-descr}}
      {a structure-slot-description}
 \isanobjid{\funarg{p-objid}}
\Purposelabel
 Read the persistent structure-slot-description referenced by
 \funarg{p-objid}\ destructively into \funarg{t-into-descr}.
\Seealsolabel
 \Fcite{p-structure-slot-description}.


\endcom

\beginfncom[Internal]{p-structure-slot-description-location}

\Syntaxlabel
\Defun {p-structure-slot-description-location} {{\funarg{p-objid}} {\opt} {\funarg{depth}} {\funarg{p-heap}}}


\Argumentslabel
 \isanobjid{\funarg{p-objid}}
\Purposelabel
 Get the value of slot
 {\bf p-location}
 of the persistent structure-slot-description referenced by
 \funarg{p-objid}.
\Seealsolabel
 Section \fcite{p-structure-slot-description- ...}.


\endcom

\beginfncom[Internal]{(setf p-structure-slot-description-location)}

\Syntaxlabel
\Defun {(setf p-structure-slot-description-location)} {{\funarg{t-location}} {\funarg{p-objid}} {\opt} {\funarg{depth}} {\funarg{p-heap}}}


\Argumentslabel
 \isa{\funarg{t-location}}
      {a fixnum}
 \isanobjid{\funarg{p-objid}}
\Purposelabel
 Set the value of slot
 {\bf p-location}
 of the persistent structure-slot-description referenced by
 \funarg{p-objid}\ to \funarg{t-location}.
\Seealsolabel
 Section \fcite{p-structure-slot-description- ...}.


\endcom

\beginfncom[Internal]{p-structure-slot-description-reader}

\Syntaxlabel
\Defun {p-structure-slot-description-reader} {{\funarg{p-objid}} {\opt} {\funarg{depth}} {\funarg{p-heap}}}


\Argumentslabel
 \isanobjid{\funarg{p-objid}}
\Purposelabel
 Get the value of slot
 {\bf p-reader}
 of the persistent structure-slot-description referenced by
 \funarg{p-objid}.
\Seealsolabel
 Section \fcite{p-structure-slot-description- ...}.


\endcom

\beginfncom[Internal]{(setf p-structure-slot-description-reader)}

\Syntaxlabel
\Defun {(setf p-structure-slot-description-reader)} {{\funarg{t-reader}} {\funarg{p-objid}} {\opt} {\funarg{depth}} {\funarg{p-heap}}}


\Argumentslabel
 \isa{\funarg{t-reader}}
      {a symbol}
 \isanobjid{\funarg{p-objid}}
\Purposelabel
 Set the value of slot
 {\bf p-reader}
 of the persistent structure-slot-description referenced by
 \funarg{p-objid}\ to \funarg{t-reader}.
\Seealsolabel
 Section \fcite{p-structure-slot-description- ...}.


\endcom

\beginfncom[Internal]{p-unlock}

\Syntaxlabel
\Defun {p-unlock} {{\funarg{p-heap}} {\funarg{p-objid}} {\opt} {\funarg{lock-mode}} {\funarg{at-location}}}


\Argumentslabel
 \isanobjid{\funarg{p-objid}}
 \isa{\funarg{lock-mode}}
      {a fixnum bitwise-or'ed from
       one of the constant values of
       {\bf *lock-level-\ldots{}*} (figure~\ref{tab:lock-levels}%
       %% 1998/01/07 HK: This makes problems with hyperref:
       %% \fcitepage{\pageref{tab:lock-levels}}
       ) with
       one of the constant values of {\bf *lock-mode-\ldots{}*}
       (figure~\ref{tab:lock-modes}%
       %% 1998/01/07 HK: This makes problems with hyperref:
       %% \fcitepage{\pageref{tab:lock-modes}}
       )}
 \isa{\funarg{at-location}}
      {a fixnum}
\Valueslabel
 \retoldmode{\funarg{p-heap}}{\funarg{p-objid}}
\Purposelabel
 Remove the lock with the level and mode of
 \funarg{lock-mode}\ held by \funarg{p-heap}\ from
 \funarg{p-objid}\ or, if the passed \funarg{lock-mode}\ requests
 an `element'-level lock, from the slot of the persistent object
 referenced by \funarg{p-objid}\ at position \funarg{at-location}.
\Remarkslabel
 If the passed \funarg{lock-mode}\ requests an `element'-level unlock,
 it is checked if \funarg{at-location}\ is a valid position index
 for the persistent object referenced by \funarg{p-objid}.
\Seealsolabel
 Section \fcite{locking ...};
 \fcite{p-unlock-all};
 \fcite{p-unlock-all-all};
 \fcite{p-set-lock};
 \fcite{p-insert-lock};
 \fcite{sh-unlock}.


\endcom

\beginfncom[Internal]{p-unlock-all}

\Syntaxlabel
\Defun {p-unlock-all} {{\funarg{p-heap}} {\funarg{p-objid}}}


\Argumentslabel
 \isanobjid{\funarg{p-objid}}
\Valueslabel
 \retoldmode{\funarg{p-heap}}{\funarg{p-objid}}
\Purposelabel
 Remove all locks held by \funarg{p-heap}\ from
 the persistent object referenced by \funarg{p-objid}.
\Seealsolabel
 Section \fcite{locking ...};
 \fcite{p-unlock};
 \fcite{p-unlock-all-all};
 \fcite{sh-unlock-all}.


\endcom

\beginfncom[Internal]{p-unlock-all-all}

\Syntaxlabel
\Defun {p-unlock-all-all} {{\funarg{p-objid}} {\opt} {\funarg{p-heap}}}


\Argumentslabel
 \isanobjid{\funarg{p-objid}}
\Valueslabel
 Returns the number of locks removed.
\Purposelabel
 Remove all locks held by any object from \funarg{p-objid}.
 This is a brute-force `emergency exit' if \funarg{p-objid}\ is
 locked by another unknown object and this lock blocks any other
 lock requests. Calling this function for \funarg{p-objid}\ enables
 locking of the object again.
\Seealsolabel
 Section \fcite{locking ...};
 \fcite{p-unlock};
 \fcite{p-unlock-all};
 \fcite{with-handle-lock-conflict};
 \fcite{sh-unlock-all-all}.


\endcom

\beginfncom[Internal]{p-upgraded-array-element-tag}

\Syntaxlabel
\Defun {p-upgraded-array-element-tag} {{\funarg{t-type}}}


\Argumentslabel
 \isa{\funarg{t-type}}
      {a \cl\ type specifier}
\Valueslabel
 Returns a \typetag.
\Purposelabel
 See \fcite{upgraded-array-element-type}; the only difference is
 that not a \cl\ type specifier but a \typetag\ is returned.
\Seealsolabel
 \Fcite{t-type-tag-of}.


\endcom

\beginfncom[Internal]{p-value-size}

\Syntaxlabel
\Defun {p-value-size} {{\funarg{p-objid}} {\opt} {\funarg{p-heap}}}


\Argumentslabel

 \isanobjid{\funarg{p-objid}}

\Purposelabel

 Return the number of words of the value field
 for the persistent object referenced by \funarg{p-objid}.

 There is no {\bf (setf p-value-size)} because the size of a
 persistent object cannot be changed; it is fix for its lifetime.

\Seealsolabel

 \Fcite{p-objid-size};
 \fcite{sh-value-size};
 \fcite{p-allocate}.


\endcom

\beginfncom[Internal]{(setf p-values)}

\Syntaxlabel
\Defun {(setf p-values)} {{\funarg{from-t-object}} {\funarg{p-heap}} {\funarg{p-objid}} {\funarg{element-type-tag}} {\funarg{number-of-words}} {\opt} {\funarg{expecting-type-tag}} {\funarg{expecting-class}}}


\Argumentslabel
 \isa{\funarg{from-t-object}}
      {a simple vector}
 \isanobjid{\funarg{p-objid}}
 \isa{\funarg{number-of-words}}
      {a fixnum}
 \isatypetag{\funarg{expecting-type-tag}}
\Valueslabel
 Returns either a negative error number or the number of words
 actually written.
\Purposelabel
 Write to the persistent object's value field referenced by
 \funarg{p-objid}\ from the transient
 \funarg{from-t-simple-vector}\ exact
 \funarg{number-of-words}\ words.
\Remarkslabel
 If \funarg{expecting-type-tag}\ is not \lisp{equal}\ to
 \lisp{+null-type-tag+}, it is checked if
 \funarg{p-objid}\ references a persistent object of type
 \funarg{expecting-type-tag}.

 It is checked if a write-lock is set
 on `vector'-level on \funarg{p-objid}; if no lock is
 set, a `vector'-level write lock is set on \funarg{p-objid}.
\Seealsolabel
 \Fcite{p-values-into};
 \fcite{sh-write-values}.


\endcom

\beginfncom[Internal]{p-values-into}

\Syntaxlabel
\Defun {p-values-into} {{\funarg{p-heap}} {\funarg{p-objid}} {\funarg{element-type-tag}} {\funarg{into-t-object}} {\funarg{number-of-elements}} {\opt} {\funarg{expecting-type-tag}} {\funarg{expecting-class}}}


\Argumentslabel
 \isanobjid{\funarg{p-objid}}
 \isa{\funarg{into-t-object}}
      {a simple vector}
 \isa{\funarg{number-of-elements}}
      {a fixnum}
 \isatypetag{\funarg{expecting-type-tag}}
\Valueslabel
 Returns either a negative error number or the number of elements
 actually read.
\Purposelabel
 Read from the persistent object's value field referenced by
 \funarg{p-objid}\ destructively into the transient
 \funarg{into-t-object}\ a maximum of
 \funarg{number-of-elements}\ elements.
\Remarkslabel
 If \funarg{expecting-type-tag}\ is not \lisp{equal}\ to
 \lisp{+null-type-tag+}, it is checked if
 \funarg{p-objid}\ references a persistent object of type
 \funarg{expecting-type-tag}.

 It is checked if a read-lock is set
 on `vector'-level on \funarg{p-objid}; if no lock is
 set, a `vector'-level read lock is set on \funarg{p-objid}.
\Seealsolabel
 \Fcite{p-allocate};
 \fcite{(setf p-values)};
 \fcite{sh-read-values};
 \shcite{function}{SH\us{}read\us{}words}{5}.


\endcom

\beginfncom[Internal]{p-vector-into}

\Syntaxlabel
\Defun {p-vector-into} {{\funarg{into-vector}} {\funarg{p-objid}} {\opt} {\funarg{depth}} {\funarg{p-heap}}}


\Argumentslabel
 \isa{\funarg{into-vector}}
      {a vector}
 \isanobjid{\funarg{p-objid}}
\Purposelabel
 Read the persistent vector referenced by
 \funarg{p-objid}\ destructively into \funarg{into-vector}.
\Seealsolabel
 \Fcite{p-vector}.


\endcom

\beginfncom[Internal]{p-vector-into-internal}

\Syntaxlabel
\Defun {p-vector-into-internal} {{\funarg{p-heap}} {\funarg{p-objid}} {\funarg{into-vector}} {\funarg{depth}}}


\Argumentslabel
 See \fcite{p-vector-into}.
\Purposelabel
 Internal used function for \fcite{p-vector-into}.


\endcom

\beginvrcom[Internal]{*package->extent-table*}

\Initialvaluelabel
\begin{CompactCode}
(make-hash-table :test #'eq)
\end{CompactCode}

\Purposelabel
 A variable used for mapping package objects to their
 extents.
\Seealsolabel
 \Fcite{(setf package-extent)};
 \fcite{package-extent}.


\endcom

\begincncom[Internal]{+package-class+}

\Valuelabel
\begin{CompactCode}
(find-class 'package)
\end{CompactCode}

\Purposelabel
The \clsmo\ of structure class \class{package}.


\endcom

\beginvrcom[Internal]{*package-description*}

\Initialvaluelabel
\begin{CompactCode}
nil
\end{CompactCode}

\Purposelabel
 Contains a persistent object of
 \fcite{structure-description}\ describing the
 \fcite{persistent-package}.
\Seealsolabel
 \Fcite{*package-description-objid*}.


\endcom

\beginvrcom[Internal]{*package-description-objid*}

\Initialvaluelabel
\begin{CompactCode}
nil
\end{CompactCode}

\Purposelabel
 Contains the \objid\ of the value of the
 \fcite{*package-description*}.
\Seealsolabel
 \Fcite{*package-description*}.


\endcom

\beginfncom[Internal]{patch-class-metaobject}

\Syntaxlabel
\Defun {patch-class-metaobject} {{\funarg{the-class}} {\funarg{class-descr}}}


\Argumentslabel
 \isacls{\funarg{the-class}}
 \isa{\funarg{class-descr}}
      {a class-description}
\Purposelabel
 Does some \horrible\ things with the
 \clsmo\ \funarg{the-class}\ necessary to cope with some
 missing \mop\ support of \lw\ \clos:
 the \horrible\ functions {\bf patch-class-methods} and
 {\bf patch-class-slots} are called when necessary;
 it is necessary if the class represented by
 \funarg{the-class}\ has at least one slot.
\Remarkslabel
 \sysdep{function}
\Seealsolabel
 \Fcite{patch-class-methods};
 \fcite{patch-class-slots};
 \fcite{patch-class-wrapper}.


\endcom

\beginfncom[Internal]{patch-class-methods}

\Syntaxlabel
\Defun {patch-class-methods} {{\funarg{the-class}}}


\Argumentslabel
 \isacls{\funarg{the-class}}
 \isa{\funarg{clos-effective-slots}}
      {a list of \eff\ \sltmo{}s}
 \isa{\funarg{plob-effective-slots}}
      {a vector with effective-slot-descriptions}
\Purposelabel
 Does some \horrible\ things with the
 \clsmo\ \funarg{the-class}\ necessary to cope with some
 missing \mop\ support of \lw\ \clos.

 For \clos\ slots whose corresponding \plob\ slot
 has an \lisp{:extent :persistent}, the reader and writer
 methods are replaced with instances of my own \mtdmo{}s
 of \fcite{persistent-reader-method}\ resp.\ %
 \fcite{persistent-writer-method}. These in turn always call
 the \fcite{slot-value-using-class}\ resp.\ %
 the \fcite{(setf slot-value-using-class)}\ to access a slot.
\Remarkslabel
 \sysdep{function}
\Seealsolabel
 \Fcite{(setf slot-extent)};
 \fcite{patch-class-metaobject};
 \fcite{patch-class-slots};
 \fcite{patch-class-wrapper}.


\endcom

\beginfncom[Internal]{patch-class-slots}

\Syntaxlabel
\Defun {patch-class-slots} {{\funarg{the-class}} {\funarg{clos-effective-slots}} {\funarg{plob-effective-slots}}}


\Argumentslabel
 \isacls{\funarg{the-class}}
 \isa{\funarg{clos-effective-slots}}
      {a list of \eff\ \sltmo{}s}
 \isa{\funarg{plob-effective-slots}}
      {a vector with effective-slot-descriptions}
\Purposelabel
 Does some \horrible\ things with the
 \clsmo\ \funarg{the-class}\ necessary to cope with some
 missing \mop\ support of \lw\ \clos:
 \begin{itemize}

 \item The number of transient \clos\ slots is decremented for
  each slot with an \lisp{:extent :persistent}.

 \item Therefore, the locations of the \clos\ slots must be
   adjusted to meet non-existent transient \clos\ slots;
   the class wrapper vectors containing the instance-and
   class-slot-names must be rebuild also to match the changed
   locations.

 \end{itemize}
\Remarkslabel
 \sysdep{function}
\Seealsolabel
 \Fcite{(setf slot-extent)};
 \fcite{patch-class-metaobject};
 \fcite{patch-class-methods};
 \fcite{patch-class-wrapper}.


\endcom

\beginfncom[Internal]{patch-class-slots-p}

\Syntaxlabel
\Defun {patch-class-slots-p} {{\funarg{the-class}}}


\Purposelabel
 Check if \funarg{the-class-descr}\ needs a patch for a correct
 transient representing for persistent objects. A patch is needed
 if at least one slot is declared as being \lisp{:persistent}\ and
 therefore not being represented in transient memory.


\endcom

\beginfncom[Internal]{patch-class-wrapper}

\Syntaxlabel
\Defun {patch-class-wrapper} {{\funarg{the-class}} {\funarg{list-of-instance-slot-names}} {\funarg{list-of-class-slot-names}}}


\Argumentslabel
 \isacls{\funarg{the-class}}
 \isa{\funarg{list-of-instance-slot-names}}
      {a list of instance slot name symbols naming the instance
       slots of \funarg{the-class}}
 \isa{\funarg{list-of-class-slot-names}}
      {a list of slot name symbols naming the slots of
       \funarg{the-class} with \lisp{:allocation :class}}
\Purposelabel
 Does some \horrible\ things with the class wrapper
 of the \clsmo\ \funarg{the-class}\ necessary to cope with
 some missing \mop\ support of \lw\ \clos.

 The list of instance slot names of the class wrapper of class
 \funarg{the-class}\ is set to
 \funarg{list-of-instance-slot-names}.
 The list of slot names of the class wrapper of class
 \funarg{the-class}\ with the names of the slots which
 have an \lisp{:allocation :class}\ is ordered so that its
 ordering is the same as given by
 \funarg{list-of-class-slot-names}.

 This is done to keep the \lw\ methods
 {\bf slot-value-using-class (t t t)} and
 {\bf (setf slot-value-using-class) (t t t)} working despite
 the changes done by \plob\ to the \clsmo;
 they use the ordering established in the list of slot names
 to do a low-level access to an object slot's value.
\Remarkslabel
 \sysdep{function}
\Seealsolabel
 \Fcite{(setf slot-extent)};
 \fcite{patch-class-metaobject};
 \fcite{patch-class-methods};
 \fcite{patch-class-slots}.


\endcom

\beginclcom[Internal Structure]{persistent-btree}

\Purposelabel
 A structure for representing persistent BTrees in the transient
 \cl\ system.
\Seealsolabel
 \Fcite{make-btree};
 \fcite{cached-btree}.


\Directsuperclasseslabel
\Defmethod{}{\tt}{\ObjectWithRef{persistent-object}}{}


\Classoptionslabel
\Defmethod{}{\tt}{:constructor make-persistent-btree (\&optional objid)}{}


\endcom

\beginclcom[Internal Structure]{persistent-btree-mapper}

\Purposelabel
 A structure for representing persistent BTree mappers in the transient
 \cl\ system.
\Seealsolabel
 \Fcite{make-btree-mapper}.


\Directsuperclasseslabel
\Defmethod{}{\tt}{\ObjectWithRef{persistent-object}}{}


\Classoptionslabel
\Defmethod{}{\tt}{:constructor make-persistent-btree-mapper (\&optional objid)}{}


\endcom

\beginclcom[Internal]{persistent-clos-object}

\Purposelabel
 This is the class from which all classes with their class being
 \fcite{persistent-metaclass}\ (by using the class option
 \lisp{(:metaclass persistent-metaclass)}\ in the
 \lisp{defclass}\ statement) inherit.
\Seealsolabel
 \Fcite{persistent-metaclass}.


\Directslotslabel

\Defdslot {objid} {:accessor persistent-object-objid\newline :extent :transient\newline :initarg :objid\newline :initform nil}


 The (numeric) \objid\ of the persistent object.


\Metaclasslabel
\Defmethod{}{\tt}{\ObjectWithRef{persistent-metaclass}}{}


\Classoptionslabel
\Defmethod{}{\tt}{:extent :transient}{}


\endcom

\begincncom[Internal]{+persistent-clos-object-class+}

\Valuelabel
\begin{CompactCode}
(let ((the-class (find-class 'persistent-clos-object nil)))
  (if the-class
      the-class
    (ensure-class 'persistent-clos-object
                  :metaclass
                  'persistent-metaclass)))
\end{CompactCode}

\Purposelabel
The \clsmo\ of \fcite{persistent-clos-object}.


\endcom

\beginclcom[Internal]{persistent-direct-slot-definition}

\Purposelabel
 A slot metaclass for direct slot descriptions.
\Remarkslabel
 It looks as if in \lw\ multiple inheritance for subclasses of
 \class{standard-direct-slot-definition}\ and
 \class{standard-effective-slot-definition}\ is
 not possible; so the \spc\ \sltmc{}es are declared for each
 \class{persistent-\{direct,effective\}-slot-definition}\ seperately.
 When I used multiple
 inheritance, very strange errors occured when classes using these
 \spc\ \sltmc{}es were defined (\lw\ tried to finalize a
 class which was not used at all by the \sltmc{}es defined here;
 this looks to me like internal problems with multiple inheritance on
 (at least \spc\ \slt-) \mc[es]).
\Seealsolabel
 \Fcite{persistent-effective-slot-definition}.


\Directsuperclasseslabel
\Defmethod{}{\tt}{(\ObjectWithRef{standard-direct-slot-definition})}{}


\Directslotslabel

\Defdslot {t-extent} {:accessor persistent-slot-definition-extent\newline :initarg :extent\newline :initform nil}


 The extent of the slot. This is the value of the
 \lisp{:extent}\ slot option given in the
 \lisp{defclass}\ statement.

\Defdslot {t-deferred} {:accessor persistent-slot-definition-deferred\newline :initarg :deferred\newline :initform nil}


 The deferred option of the slot. This is the value of the
 \lisp{:deferred}\ slot option given in the
 \lisp{defclass}\ statement.

\Defdslot {t-index} {:accessor persistent-slot-definition-index\newline :initarg :index\newline :initform nil}


 The index to maintain for the slot. This is the value of the
 \lisp{:index}\ slot option given in the
 \lisp{defclass}\ statement.

\Defdslot {t-location} {:accessor persistent-slot-definition-location\newline :initarg :location\newline :initform nil}


 The location of the slot in the low-level representation.
 This is the value of the \lisp{:location}\ slot option given
 in the \lisp{defclass}\ statement. The \lisp{:location}\ slot
 option must only be specified for the built-in predefined classes.

\Defdslot {description} {:accessor persistent-slot-definition-description\newline :initform nil}


 The persistent slot description object
 of the slot, an instance of \fcite{direct-slot-description}.


\endcom

\begincncom[Internal]{+persistent-direct-slot-definition-class+}

\Valuelabel
\begin{CompactCode}
(find-class 'persistent-direct-slot-definition)
\end{CompactCode}

\Purposelabel
The \clsmo\ of \fcite{persistent-direct-slot-definition}.


\endcom

\beginclcom[Internal]{persistent-effective-slot-definition}

\Purposelabel
 A slot metaclass for effective slot descriptions.
\Seealsolabel
 \Fcite{persistent-direct-slot-definition}.


\Directsuperclasseslabel
\Defmethod{}{\tt}{(\ObjectWithRef{standard-effective-slot-definition})}{}


\Directslotslabel

\Defdslot {t-extent} {:accessor persistent-slot-definition-extent\newline :initform nil}


 See slot {\bf t-extent} of
 \fcite{persistent-direct-slot-definition}.

\Defdslot {t-deferred} {:accessor persistent-slot-definition-deferred\newline :initform nil}


 See slot {\bf t-deferred} of
 \fcite{persistent-direct-slot-definition}.

\Defdslot {t-index} {:accessor persistent-slot-definition-index\newline :initform nil}


 See slot {\bf t-index} of
 \fcite{persistent-direct-slot-definition}.

\Defdslot {t-location} {:accessor persistent-slot-definition-location\newline :initform nil}


 See slot {\bf t-location} of
 \fcite{persistent-direct-slot-definition}.

\Defdslot {t-allocation} {:accessor persistent-slot-definition-allocation\newline :initform nil}


 The allocation
 of the transient standard-effective-slot definition.

\Defdslot {description} {:accessor persistent-slot-definition-description\newline :initform nil}


 The persistent slot description object
 of the slot, an instance of
 \fcite{effective-slot-description}.


\endcom

\begincncom[Internal]{+persistent-effective-slot-definition-class+}

\Valuelabel
\begin{CompactCode}
(find-class 'persistent-effective-slot-definition)
\end{CompactCode}

\Purposelabel
The \clsmo\ of \fcite{persistent-effective-slot-definition}.


\endcom

\beginclcom[Internal Structure]{persistent-hash-table}

\Purposelabel
  A structure holding a persistent hash table.


\Directsuperclasseslabel
\Defmethod{}{\tt}{\ObjectWithRef{persistent-object}}{}


\Directslotslabel

\Defdslot {test} {nil}


 The test mode of the hash table,
 see \fcite{hash-table-test}.

\Defdslot {count} {nil}


 The number of elements in the hash table,
 see \fcite{hash-table-count}.

\Defdslot {size} {nil}


 The size of the hash table, see \fcite{hash-table-size}.

\Defdslot {rehash-size} {nil}


 The rehash size of the hash table, see \fcite{hash-table-rehash-size}.

\Defdslot {rehash-threshold} {nil}


 The rehash threshols of the hash table,
 see \fcite{hash-table-rehash-threshold}.

\Defdslot {key-table} {nil}


 The key table of the hash table.

\Defdslot {value-table} {nil}


 The value table of the hash table.


\endcom

\beginclcom[Internal Structure]{persistent-immediate-object}

\Purposelabel
 A structure for representing persistent objects in the transient
 \cl\ system. This structure can represent non-immediate and 
 immediate objects.
\Remarkslabel
 \basecls{persistent-immediate-object}


\Directsuperclasseslabel
\Defmethod{}{\tt}{\ObjectWithRef{persistent-object}}{}


\Directslotslabel

\Defdslot {type-tag} {nil}


 The (numeric) \typetag\ of the persistent object.


\Classoptionslabel
\Defmethod{}{\tt}{:constructor make-persistent-immediate-object (\&optional objid (type-tag +short-objid-tag+))\newline :print-function {\rm\sl omitted here}}{}


\endcom

\beginclcom[Internal Structure]{persistent-lisproot}

\Purposelabel
 A transient structure representing persistent LISP root objects.
\Remarkslabel
 \basecls{persistent-lisproot}


\Directsuperclasseslabel
\Defmethod{}{\tt}{\ObjectWithRef{persistent-structure}}{}


\Directslotslabel

\Defdslot {p-version} {nil}


 The lisproot version represented by a fixnum.

\Defdslot {p-formatted} {nil}


 The LISP system which formatted the LISP root
 represented by a keyword symbol.

\Defdslot {p-time} {nil}


 The time and date the LISP root was formatted
 represented in Common LISP Universal Time, i.e. a bignum.

\Defdslot {p-name->package-table} {nil}


 A table mapping names to packages.

\Defdslot {p-symbol->class-table} {nil}


 A table mapping symbols to
 structure resp. class descriptions.

\Defdslot {p-structure-description} {nil}


 The structure description object.

\Defdslot {p-structure-slot-description} {nil}


 The structure slot description object.

\Defdslot {p-package-description} {nil}


 The package description object.

\Defdslot {p-plob-description} {nil}


 The plob description object.

\Defdslot {p-class-description} {nil}


 The class description object.

\Defdslot {p-slot-description} {nil}


 The slot description object.

\Defdslot {p-direct-slot-description} {nil}


 The direct slot description object.

\Defdslot {p-effective-slot-description} {nil}


 The effective slot description object.

\Defdslot {p-method-description} {nil}


 The method description object.

\Defdslot {p-pfs} {nil}


 The object representing the Persistent File System.


\endcom

\begincncom[Internal]{+persistent-lisproot-class+}

\Valuelabel
\begin{CompactCode}
(find-class 'persistent-lisproot)
\end{CompactCode}

\Purposelabel
The \clsmo\ of structure \fcite{persistent-lisproot}.


\endcom

\begincncom[Internal]{+persistent-metaclass-class+}

\Valuelabel
\begin{CompactCode}
(find-class 'persistent-metaclass)
\end{CompactCode}

\Purposelabel
The \clsmo\ of \fcite{persistent-metaclass}.


\endcom

\begincncom[Internal]{+persistent-object-class+}

\Valuelabel
\begin{CompactCode}
(find-class 'persistent-object)
\end{CompactCode}

\Purposelabel
The \clsmo\ of \fcite{persistent-object}.


\endcom

\message{^^JGeneric function persistent-object-objid has no methods.^^J}
\message{^^JGeneric function (setf persistent-object-objid) has no methods.^^J}
\beginclcom[Internal Structure]{persistent-package}

\Purposelabel
 A transient structure representing persistent packages.
 In the sense of \cl, this class corresponds roughly to the
 class \class{package}.
\Remarkslabel
 \basecls{persistent-package}


\Directsuperclasseslabel
\Defmethod{}{\tt}{\ObjectWithRef{persistent-structure}}{}


\Directslotslabel

\Defdslot {p-package-name} {nil}


 The package name as a string; comparable with the returned
 value from
 \fcite{package-name}.

\Defdslot {p-internals} {nil}


 A table (i.e.\ BTree) with the internal symbols of the package.
 Currently all persistent \plob\ symbols are intern symbols of their
 persistent package; there are no export, use-package etc.\ functions
 defined in \plob. Instead, the transient symbols found in the
 \cl\ system are mapped to the appropiate \plob\ symbols
 (i.e.\ a transient \cl\ package is mapped to a persistent
 \plob\ p-package and a transient \cl\ symbol is mapped to a
 persistent \plob\ p-symbol; the mapping is in `both ways'). 
 The conflict resolution necessary for exporting
 symbols and using packages is done in the transient \cl\ system,
 so there is (currently) no need for \plob\ to do this.

\Defdslot {p-externals} {nil}


 A table (i.e.\ BTree) with the external symbols of the package.
 This table is not used in the moment.


\endcom

\beginclcom[Internal]{persistent-reader-method}

\Purposelabel
 A method metaclass for reader methods for persistent
 classes.


\Directsuperclasseslabel
\Defmethod{}{\tt}{(\ObjectWithRef{standard-reader-method})}{}


\endcom

\begincncom[Internal]{+persistent-reader-method-class+}

\Valuelabel
\begin{CompactCode}
(find-class 'persistent-reader-method)
\end{CompactCode}

\Purposelabel
The \clsmo\ of \fcite{persistent-reader-method}.


\endcom

\beginfncom[Internal]{persistent-slot-boundp-using-class}

\Syntaxlabel
\Defun {persistent-slot-boundp-using-class} {{\funarg{the-class}} {\funarg{p-objid}} {\funarg{slot-name}} {\funarg{next-method}} {\opt} {\funarg{p-heap}}}


\Argumentslabel
 \isacls{\funarg{the-class}}
 \isanobjid{\funarg{p-objid}}
 \isa{\funarg{slot-name}}
      {a symbol naming an effective slot of \funarg{the-class}}
\Purposelabel
 Check if the slot named \funarg{slot-name}\ of the persistent
 \clos\ instance referenced by \funarg{p-objid}\ of class
 \funarg{the-class}\ is bound.
\Seealsolabel
 \Fcite{load-slot-boundp-using-class};
 %% \fcite{slot-boundp-using-class (built-in-class integer t)};
 \fcite{slot-boundp-using-class (structure-class persistent-object t)}.


\endcom

\message{^^JGeneric function plob::persistent-slot-definition-allocation has no methods.^^J}
\message{^^JGeneric function (setf plob::persistent-slot-definition-allocation) has no methods.^^J}
\message{^^JGeneric function plob::persistent-slot-definition-deferred has no methods.^^J}
\message{^^JGeneric function (setf plob::persistent-slot-definition-deferred) has no methods.^^J}
\message{^^JGeneric function plob::persistent-slot-definition-description has no methods.^^J}
\message{^^JGeneric function (setf plob::persistent-slot-definition-description) has no methods.^^J}
\message{^^JGeneric function plob::persistent-slot-definition-extent has no methods.^^J}
\message{^^JGeneric function (setf plob::persistent-slot-definition-extent) has no methods.^^J}
\message{^^JGeneric function plob::persistent-slot-definition-index has no methods.^^J}
\message{^^JGeneric function (setf plob::persistent-slot-definition-index) has no methods.^^J}
\begingfcom[Internal]{persistent-slot-definition-location}

\Syntaxlabel
\Defgen {persistent-slot-definition-location} {{\funarg{instance}}}

\GfCreatedByOption{reader}{:accessor}{t-location}{persistent-direct-slot-definition}


\Methodslabel

\flabel{\protect\mtd}{persistent-slot-definition-location (standard-effective-slot-definition)}{}
{\Defmeth {persistent-slot-definition-location} {(\funarg{slot-definition}\ \ObjectWithRef{standard-effective-slot-definition})}}
%
% No behavior is specified for this method beyond that which is specified
% for the generic function.


\endcom

\message{^^JGeneric function (setf plob::persistent-slot-definition-location) has no methods.^^J}
\beginfncom[Internal]{persistent-slot-value-using-class}

\Syntaxlabel
\Defun {persistent-slot-value-using-class} {{\funarg{the-class}} {\funarg{p-objid}} {\funarg{slot-name}} {\funarg{next-method}} {\opt} {\funarg{depth}} {\funarg{p-heap}}}


\Argumentslabel
 \isacls{\funarg{the-class}}
 \isanobjid{\funarg{p-objid}}
 \isa{\funarg{slot-name}}
      {a symbol naming an effective slot of \funarg{the-class}}
\Purposelabel
 Load the slot named \funarg{slot-name}\ of the persistent
 \clos\ instance referenced by \funarg{p-objid}\ of class
 \funarg{the-class}.
\Seealsolabel
 \Fcite{load-slot-value-using-class};
 %% \fcite{slot-value-using-class (built-in-class integer t)};
 \fcite{slot-value-using-class (structure-class persistent-object t)}.


\endcom

\begincncom[Internal]{+persistent-structure-class+}

\Valuelabel
\begin{CompactCode}
(find-class 'persistent-structure)
\end{CompactCode}

\Purposelabel
The \clsmo\ of \fcite{persistent-structure}.


\endcom

\beginfncom[Internal]{persistent-structure-slot-p}

\Syntaxlabel
\Defun {persistent-structure-slot-p} {{\funarg{slot}}}

Check if \funarg{slot}\ is a member of the slots found in
 \fcite{+structure-persistent-slot-names+}.


\endcom

\beginfncom[Internal]{persistent-symbol-reader}

\Syntaxlabel
\Defun {persistent-symbol-reader} {{\funarg{stream}} {\funarg{subchar}} {\funarg{arg}}}


\Argumentslabel
 As specified for the \funarg{function}\ argument of
 \fcite{set-dispatch-macro-character}.
\Purposelabel
 This function handles the macro reader character \#! (hash sign
 followed by an exclamation mark).

 The identifier following the macro character is interpreted as the
 name of a persistent symbol; the expansion returned is
 \begin{quote}\tt
  (p-symbol-value \textsl{\lt{}persistent-symbol-name\gt}\/)
 \end{quote}
 This form can be used to read the value of a persistent symbol;
 the \lisp{setf}-form can be used to set the value of a persistent
 symbol; see section \fcite{symbol ...}\ for examples.
\Seealsolabel
 Section \fcite{symbol ...};
 \fcite{set-dispatch-macro-character}.


\endcom

\beginclcom[Internal]{persistent-writer-method}

\Purposelabel
 A method metaclass for writer methods for persistent
 classes.


\Directsuperclasseslabel
\Defmethod{}{\tt}{(\ObjectWithRef{standard-writer-method})}{}


\endcom

\begincncom[Internal]{+persistent-writer-method-class+}

\Valuelabel
\begin{CompactCode}
(find-class 'persistent-writer-method)
\end{CompactCode}

\Purposelabel
The \clsmo\ of \fcite{persistent-writer-method}.


\endcom

\beginvrcom[Internal]{*plob-base-objects*}

\Initialvaluelabel
\begin{CompactCode}
nil
\end{CompactCode}

\Purposelabel
 Contains the \plob\ objects which {\sl must} be under all
 circumstances be found in the \plob\ root cache.
 It contains a list with a-cons'es
 \lisp{(\objid\ .
 \textrm{\textsl{\lt{}transient \cl\ object\gt}}\/)}.
\Seealsolabel
 \Fcite{*root-persistent-heap-objid->object-cache*};
 \fcite{*root-persistent-heap-object->objid-cache*}.


\endcom

\begincncom[Internal]{+plob-bin-directory+}

\Valuelabel
\begin{CompactCode}
(logical-pathname "PLOB:BIN;")
\end{CompactCode}

\Purposelabel
 Directory containing some auxiliary binary files.


\endcom

\beginclcom[Internal]{plob-description}

\Purposelabel
 An abstract superclass for class- and slot-descriptions defined
 for \plob. This class roughly corresponds to the
 \clos\ \mc\ \class{metaobject}.
\Remarkslabel
 \basecls{plob-description}


\Directsuperclasseslabel
\Defmethod{}{\tt}{(\ObjectWithRef{persistent-clos-object})}{}


\Metaclasslabel
\Defmethod{}{\tt}{\ObjectWithRef{persistent-metaclass}}{}


\Classoptionslabel
\Defmethod{}{\tt}{:extent :cached\newline :schema-evolution :no-evolution}{}


\endcom

\beginvrcom[Internal]{*plob-description*}

\Initialvaluelabel
\begin{CompactCode}
nil
\end{CompactCode}

\Purposelabel
 Contains a persistent object of
 \fcite{class-description}\ describing the
 \fcite{plob-description}.
\Seealsolabel
 \Fcite{*plob-description-objid*}.


\endcom

\begincncom[Internal]{+plob-description-class+}

\Valuelabel
\begin{CompactCode}
(let ((the-class (find-class 'plob-description nil)))
  (if the-class
      the-class
    (ensure-class 'plob-description :metaclass 'persistent-metaclass)))
\end{CompactCode}

\Purposelabel
The \clsmo\ of \fcite{plob-description}.


\endcom

\beginvrcom[Internal]{*plob-description-objid*}

\Initialvaluelabel
\begin{CompactCode}
nil
\end{CompactCode}

\Purposelabel
 Contains the \objid\ of the value of the variable
 {\bf *plob-description*}.
\Seealsolabel
 \Fcite{*plob-description*}.


\endcom

\begincncom[Internal]{+plob-slot-extents+}

\Valuelabel
\begin{CompactCode}
'(:transient :cached :cached-write-through :persistent :object :objid)
\end{CompactCode}

\Purposelabel
 List with allowed slot extents for \plob\ \clos\ classes,
 i.e.\ for \clos\ classes with a
 \lisp{(:metaclass persistent-metaclass)}\ class option.
\Seealsolabel
 \Fcite{(setf slot-extent)};
 \fcite{+clos-slot-extents+};
 \fcite{+plob-slot-write-through-extents+};
 \fcite{+plob-slot-represented-extents+};
\fcite{+structure-slot-extents+}.


\endcom

\begincncom[Internal]{+plob-slot-represented-extents+}

\Valuelabel
\begin{CompactCode}
'(:transient :cached :cached-write-through :object :objid)
\end{CompactCode}
\Purposelabel
 List with slot extents of persistent objects which are represented
 in transient instances. The elements in
 lisp{+plob-slot-represented-extents+}\ must be a
 subset of the values of the list in \fcite{+plob-slot-extents+}.
\Seealsolabel
 \Fcite{+plob-slot-extents+};
 \fcite{+plob-slot-write-through-extents+}.


\endcom

\begincncom[Internal]{+plob-slot-write-through-extents+}

\Valuelabel
\begin{CompactCode}
'(:cached-write-through :persistent :object :objid)
\end{CompactCode}

 \Purposelabel
  List with slot extents which are handled as write-through slots. The
  elements in \lisp{+plob-slot-write-through-extents+}\ must be a
  subset of the values of the list in \fcite{+plob-slot-extents+}.
 \Seealsolabel
  \Fcite{+plob-slot-extents+};
  \fcite{+plob-slot-represented-extents+}.


\endcom

\begincncom[Internal]{+poi-tag+}

\Valuelabel
\begin{CompactCode}
(or low:tag-and)
\end{CompactCode}

\Purposelabel
 A mask for adressing a LISP object directly from within C code with
 the help of an \lisp{:as-is}\ parameter of the \lw\ foreign language
 interface passed down to a C function.
 This is the bitmask which must be used in C for unmasking a C
 \lisp{:as-is}\ parameter
 before using that \lisp{:as-is}\ parameter in C as a pointer to a
 LISP object; the masked-out bits are a type tag. If they are
 not masked out, a bus error is raised when de-referencing the
 bignum from within a C function.
\Remarkslabel
 \sysdep{constant}


\endcom

\begincncom[Internal]{+pprint-buffer-size+}

\Valuelabel
\begin{CompactCode}
512
\end{CompactCode}

\Purposelabel
 Size of the string buffer used for printing a persistent object into
 a string by the \plob\ low-level print function.
\Seealsolabel
 \Fcite{sh-pprint-objid};
 \fcite{sh-pprint-symbol}.


\endcom

\beginfncom[Internal]{pretty-print-symbol}

\Syntaxlabel
\Defun {pretty-print-symbol} {{\funarg{t-symbol}}}

Pretty print a symbol.


\endcom

\beginfncom[Internal]{print-persistent-immediate-object}

\Syntaxlabel
\Defun {print-persistent-immediate-object} {{\funarg{object}} {\funarg{type-tag}} {\funarg{stream}} {\opt} {\funarg{p-heap}}}


\endcom

\begindccom[Process Functions]{process ...}

 Although there is no standard defined on \cl\ processes, many
 \cl\ systems (including \lw) implement the
 \symbolics\ multi-processing interface. The \plob\ functions
 {\bf is-on-idle-sleep-hook}, {\bf make-process-variable},
 {\bf process-alive-p}, {\bf process-pid},
 {\bf process-wait-with-timeout}, {\bf push-to-idle-sleep-hook} and
 {\bf remove-from-idle-sleep-hook} are implemented using that
 \symbolics\ pseudo-standard multi-processing interface.
\Remarkslabel
 A lisp-internal process is also called a `session' in this document to
 distinguish it from the \cl\ process in the sense of \unix.
\Seealsolabel
 \Fcite{ensure-process-cleanup};
 \fcite{is-on-idle-sleep-hook};
 \fcite{make-process-variable};
 \fcite{process-alive-p};
 \fcite{process-pid};
 \fcite{process-wait-with-timeout};
 \fcite{push-to-idle-sleep-hook};
 \fcite{remove-from-idle-sleep-hook}.


\endcom

\beginfncom[Internal]{process-alive-p}

\Syntaxlabel
\Defun {process-alive-p} {{\funarg{the-process}}}


\Argumentslabel
 \isa{\funarg{the-process}}
      {a process object}
\Purposelabel
 Test if the lisp-internal session represented by
 \funarg{the-process}\ is alive.
\Remarkslabel
 \sysdep{function}
\Seealsolabel
 Section \fcite{process ...}.


\endcom

\beginfncom[Internal]{process-name}

\Syntaxlabel
\Defun {process-name} {{\opt} {\funarg{pid}}}


\Argumentslabel
  \isa{\funarg{pid}}
      {a process object}
\Purposelabel
 Return the lisp-internal process name of the \cl\ process
 identified by \funarg{pid}.
\Remarkslabel
 \sysdep{function}
\Seealsolabel
 Section \fcite{process ...};
 \fcite{process-pid};
 \lw\ structure slot accessor {\bf mp:process-name}.


\endcom

\beginfncom[Internal]{process-pid}

\Syntaxlabel
\Defun {process-pid} {}


\Purposelabel
 Return the lisp-internal PID ({\sl P}\/rocess {\sl ID}\/entifier)
 of the current \cl\ session.
\Remarkslabel
 \sysdep{function}
\Seealsolabel
 Section \fcite{process ...};
 \fcite{process-name};
 \lw\ variable {\bf mp:*current-process*}.


\endcom

\beginfncom[Internal]{process-wait-with-timeout}

\Syntaxlabel
\Defun {process-wait-with-timeout} {{\funarg{reason}} {\funarg{timeout}} {\opt} {\funarg{end-wait-predicate}} {\rest} {\funarg{end-wait-predicate-args}}}


\Argumentslabel
 \isa{\funarg{reason}}
      {a string}
 \isa{\funarg{timeout}}
      {a fixnum}
 \isa{\funarg{end-wait-predicate}}
      {a function taking
       \lisp{(length \funarg{end-wait-predicate-args})}\ arguments}
 \isa{\funarg{end-wait-predicate-arg}}
      {an argument list for \funarg{end-wait-predicate}}
\Purposelabel
 Wait until \funarg{timeout}\ seconds have been passed or
 \funarg{end-wait-predicate}\ applied
 to \funarg{end-wait-predicate-args}\ becomes \lispt.
\Remarkslabel
 \sysdep{function}
\Seealsolabel
 Section \fcite{process ...};
 \lw\ function {\bf mp::process-wait-with-timeout}.


\endcom

\beginfncom[Internal]{prompt-for}

\Syntaxlabel
\Defun {prompt-for} {{\opt} {\funarg{type-name}} {\rest} {\funarg{format-and-args}}}


\Argumentslabel
 \isa{\funarg{type-name}}
      {a symbol denoting a valid \cl\ type name}
 \isa{\funarg{format-and-args}}
      {an argument list as accepted by the
       \fcite{format}\ without the
       {\sl destination} argument}
\Valueslabel
 Returns the evaluation of an expression entered by the user whose
 type matches \funarg{type-name}.
\Purposelabel
 Prompt the user with \funarg{format-and-args}\ and ask for an
 expression whose type matches \funarg{type-name}.
\Remarkslabel
 \sysdep{function}
\Seealsolabel
 \Fcite{prompt-for}.


\endcom

\beginmccom[Internal]{push-on-end}

\Syntaxlabel
\Defmac {push-on-end} {{\funarg{value}} {\funarg{location}}}


\Argumentslabel
  \isa{\funarg{value}}
       {an expression}
  \isa{\funarg{location}}
       {a \lisp{setf}-able expression}
\Purposelabel
 {\bf push-on-end} is like the \fcite{push}\ except
 it uses the other end.
\Seealsolabel
 \Fcite{push-on-end}; \fcite{push}.


\endcom

\beginfncom[Internal]{push-to-idle-sleep-hook}

\Syntaxlabel
\Defun {push-to-idle-sleep-hook} {{\funarg{function-symbol}}}


\Argumentslabel
 \isa{\funarg{function-symbol}}
      {the name of a function taking no arguments}
\Purposelabel
 Pushes \funarg{function-symbol}\ to the idle sleep hook.
 The symbol-function of \funarg{function-symbol}\ is called
 each time when the process goes idle.
\Remarkslabel
 \sysdep{function}

 Hint for portability:
 If the \cl\ system has no idle sleep hook, raise an error when this
 function is called.
\Seealsolabel
 \Fcite{remove-from-idle-sleep-hook};
 \fcite{is-on-idle-sleep-hook};
 section \fcite{process ...}.


\endcom

\beginfncom[Internal]{re-and-initialize-persistent-metaclass-instance}

\Syntaxlabel
\Defun {re-and-initialize-persistent-metaclass-instance} {{\funarg{class}} {\funarg{direct-superclasses}} {\funarg{constructor}} {\funarg{dependent}} {\funarg{extent}} {\funarg{schema-evolution}} {\funarg{call-next-method}} {\funarg{all-keys}}}


 \Argumentslabel
  \isacls{class}
  \isa{\funarg{direct-superclasses}}
       {a list of \clsmo{}s.}
  \isa{\funarg{call-next-method}}
       {a function.}
  \isa{\funarg{all-key}}
       {a keyword argument list}
 \Purposelabel
  Stores the values of the extra class options and inserts
  \fcite{persistent-clos-object}\ into the list of the class
  direct' superclasses.
 \Remarkslabel
  Hint for \allegro:
  The arguments of extra class options are put into a list by \allegro;
  in \lw, they are passed `plain' (so for \lw, a class option can have
  only one argument).

  1998/11/19: Jon Dyte had the idea to put the code of this function
  into \fcite{shared-initialize}\ specialized to
  \fcite{persistent-metaclass}; this does not work in \allegrocl\ 5.x,
  the list of direct-superclasses will not be extended.
 \Seealsolabel
  \Fcite{initialize-instance (persistent-metaclass)};
  \fcite{reinitialize-instance (persistent-metaclass)}.


\endcom

\beginfncom[Internal]{read-lock}

\Syntaxlabel
\Defun {read-lock} {{\funarg{p-heap}} {\funarg{p-objid}} {\funarg{depth}} {\funarg{expecting-type-tag}} {\opt} {\funarg{force-read}} {\funarg{lock-mode}} {\funarg{at-location}}}


\Argumentslabel
 \isanobjid{\funarg{p-objid}}
 \isatypetag{\funarg{expecting-type-tag}}
 \isa{\funarg{lock-mode}}
      {a fixnum bitwise-or'ed from
       one of the constant values of
       {\bf *lock-level-\ldots{}*} (figure~\ref{tab:lock-levels}%
       %% 1998/01/07 HK: This makes problems with hyperref:
       %% \fcitepage{\pageref{tab:lock-levels}}
       ) with
       the constant value of {\bf +lock-mode-read+}}
\Valueslabel
 If there was already a read-lock placed  by
 \funarg{p-heap}\ onto the persistent object
 referenced by \funarg{p-objid}, \lispnil\ is returned;
 \nonnil\ otherwise.
\Purposelabel
 Set a read lock onto the persistent object referenced by
 \funarg{p-objid}; the level and mode of locking
 are determined by \funarg{lock-mode}\ (see section
 \fcite{locking ...}\ for details).
\Remarkslabel
 \begin{enumerate}

 \item This function can only be executed within an active
  transaction on \funarg{p-heap}, so e.g.\ embed a call to it
  into an expansion of \fcite{with-transaction}\ if appropiate or
  make otherwise sure that at call-time there is an active
  transaction.

 \item Do not call this function direct; use the
  \fcite{with-read-lock}\ instead.

 \end{enumerate}
\Seealsolabel
 Section \fcite{locking ...};
 \fcite{with-transaction};
 \fcite{with-read-lock};
 \fcite{write-lock}.


\endcom

\beginfncom[Internal]{read-objid-buffer}

\Syntaxlabel
\Defun {read-objid-buffer} {{\funarg{objid-buffer}} {\funarg{at-index}}}


 Read an \objid\ and a \typetag\ from \funarg{objid-buffer}.
\Seealsolabel
  \Fcite{objid-buffer}


\endcom

\beginvrcom[Internal]{*reader->class-and-slot-table*}

\Initialvaluelabel
\begin{CompactCode}
(make-hash-table :test #'eq)
\end{CompactCode}

\Purposelabel
The reverse
mapping for \fcite{*class-and-slot->reader-table*}.
Used in \fcite{establish-all-slot-loaders}.


\endcom

\beginfncom[Internal]{register-all-type-tags}

\Syntaxlabel
\Defun {register-all-type-tags} {}


\Purposelabel
 Read in all \plob\ built-in data classes and store them to
 internal tables; these are used later for
 \fcite{p-upgraded-array-element-tag}.
\Seealsolabel
 \Fcite{sh-map-class-info};
 \fcite{p-upgraded-array-element-tag};
 \fcite{t-type-tag-of}.


\endcom

\beginfncom[Internal]{register-class}

\Syntaxlabel
\Defun {register-class} {{\funarg{class-descr}} {\opt} {\funarg{p-heap}}}


\Argumentslabel
 \isa{\funarg{class-descr}}
      {a class description}
\Purposelabel
 Registers \funarg{class-descr}\ to the \plob\ class table
 contained in the \fcite{*symbol->class-table*}.


\endcom

\beginfncom[Internal]{register-package}

\Syntaxlabel
\Defun {register-package} {{\funarg{p-objid}} {\opt} {\funarg{p-heap}}}


\Argumentslabel
 \isanobjid{\funarg{p-objid}}
\Purposelabel
 Registers the persistent-package referenced by
 \funarg{p-objid}\ to the \plob\ package table
 contained in the \fcite{*name->package-table*}.


\endcom

\beginfncom[Internal]{register-to-base-cache}

\Syntaxlabel
\Defun {register-to-base-cache} {{\funarg{p-objid}} {\funarg{t-object}} {\opt} {\funarg{clobber-old-entry}}}


\Argumentslabel
 \isanobjid{\funarg{p-objid}}
 \isanobject{\funarg{t-object}}
 \isabool{\funarg{clobber-old-entry}}
\Valueslabel
 See \fcite{register-to-cache}.
\Purposelabel
 At first, see \fcite{register-to-cache}.

 Additionally, the persistent object referenced by
 \funarg{p-objid}\ and its transient representation given by
 \funarg{t-object}\ are registered as being \plob\ base objects
 which are always found in the cache, even after a call to
 \fcite{clear-cache}. This is done to prevent loading these
 objects and their refrenced objects more than once from the
 \sh, either of problems with endless recursion of
 self-describing persistent objects or of efficency reasons
 (because base objects are used very often and should be loaded
 always from the cache).
\Seealsolabel
 \Fcite{register-to-cache}.


\endcom

\beginfncom[Internal]{register-to-cache}

\Syntaxlabel
\Defun {register-to-cache} {{\funarg{p-objid}} {\funarg{t-object}} {\opt} {\funarg{clobber-old-entry}}}


\Argumentslabel
 \isanobjid{\funarg{p-objid}}
 \isanobject{\funarg{t-object}}
 \isabool{\funarg{clobber-old-entry}}
\Valueslabel
 Iff \funarg{p-objid}\ and \funarg{t-object}\ are newly registered,
 \nonnil\ is returned, \lispnil\ otherwise.
\Purposelabel
 Associates the persistent object referenced by
 \funarg{p-objid}\ as having currently a transient
 representation of \funarg{t-object}\ and vice versa;
 this association is done by registering \funarg{p-objid}\ and
 \funarg{t-object} into the root caches.
\Seealsolabel
 \Fcite{*root-persistent-heap-object->objid-cache*};
 \fcite{is-registered-objid};
 \fcite{*root-persistent-heap-objid->object-cache*};
 \fcite{is-registered-object}.


\endcom

\beginfncom[Internal]{registered-objid-p}

\Syntaxlabel
\Defun {registered-objid-p} {{\funarg{p-objid}}}


\Argumentslabel
 \isanobjid{\funarg{p-objid}}
\Valueslabel
 Returns two values. If there is a transient object associated to
 \funarg{p-objid}, \funarg{p-objid}\ is returned as first
 and the transient object as second value. If there is no association
 to \funarg{p-objid}, both values returned ar \lispnil.
\Purposelabel
 Check if \funarg{p-objid}\ is associated to a transient object.
\Seealsolabel
 \Fcite{register-to-cache};
 \fcite{is-registered-objid};
 \fcite{is-registered-object}.


\endcom

\begingfcom[Internal]{remindex}

\Syntaxlabel
\Defgen {remindex} {{\funarg{key-slot-value}} {\funarg{the-table}} {\opt} {\funarg{p-heap}}}


\Argumentslabel
 \isanobject{\funarg{key-slot-value}}
 \isaidxtable{\funarg{the-table}}
\Purposelabel
 \idxadmfn:
 Remove \funarg{key-slot-value}\ from \funarg{the-table}.
\Seealsolabel
 \Fcite{remindex-by-objid};
 section \fcite{index ...}.


\Methodslabel

\flabel{\protect\mtd}{remindex (t persistent-btree)}{}
{\Defmeth {remindex} {{\funarg{key-slot-value}} (\funarg{the-table}\ \ObjectWithRef{persistent-btree}) {\opt} {\funarg{p-heap}}}}
Trapped to \fcite{rembtree}.


\endcom

\begingfcom[Internal]{remindex-by-objid}

\Syntaxlabel
\Defgen {remindex-by-objid} {{\funarg{key-slot-value}} {\funarg{the-table}} {\opt} {\funarg{p-heap}}}


\Argumentslabel
 \isanobjid{\funarg{key-slot-value}}
 \isaidxtable{\funarg{the-table}}
\Purposelabel
 \idxadmfn:
 Remove objid funarg{key-slot-value}\ from \funarg{the-table}.
\Seealsolabel
 \Fcite{remindex};
 section \fcite{index ...}.


\Methodslabel

\flabel{\protect\mtd}{remindex-by-objid (t persistent-btree)}{}
{\Defmeth {remindex-by-objid} {{\funarg{key-slot-value}} (\funarg{the-table}\ \ObjectWithRef{persistent-btree}) {\opt} {\funarg{p-heap}}}}
Trapped to \fcite{rembtree-by-objid}.


\endcom

\beginfncom[Internal]{remindex-by-tag}

\Syntaxlabel
\Defun {remindex-by-tag} {{\funarg{key-slot-value-objid}} {\funarg{key-slot-value-type-tag}} {\funarg{the-table}} {\opt} {\funarg{p-heap}}}


\Argumentslabel
 \isa{\funarg{key-slot-value-objid}}
      {either an immediate value or an \objid}
 \isatypetag{\funarg{key-slot-value-type-tag}}
 \isaidxtable{\funarg{the-table}}
\Valueslabel
 See \fcite{remindex}\ resp.\ \fcite{remindex-by-objid}.
\Purposelabel
 The action done by this function depends on the value of the 
 \funarg{key-slot-value-type-tag}\ argument, i.e.\ if it
 references an immediate or a non-immediate \plob\ type:
 \begin{description}

 \item [immediate type]
  In this case \funarg{key-slot-value-objid}\ is not an
  \objid\ but an immediate value; {\bf remindex} is called
  with that value as key argument.

 \item [non-immediate type]
  In this case \funarg{key-slot-value-objid}\ is an
  \objid; {\bf remindex-by-objid} is called with that
  \objid\ as key argument.

 \end{description}
\Seealsolabel
 \Fcite{remindex};
 \fcite{remindex-by-objid};
 section \fcite{index ...}.


\endcom

\beginfncom[Internal]{remove-from-idle-sleep-hook}

\Syntaxlabel
\Defun {remove-from-idle-sleep-hook} {{\funarg{function-symbol}}}


\Argumentslabel
 \isa{\funarg{function-symbol}}
      {the name of a function taking no arguments}
\Purposelabel
 Remove \funarg{function-symbol}\ from the idle sleep hook.
\Remarkslabel
 \sysdep{function}
\Seealsolabel
 \Fcite{push-to-idle-sleep-hook};
 \fcite{is-on-idle-sleep-hook};
 section \fcite{process ...}.


\endcom

\beginfncom[Internal]{remove-metaclass-p}

\Syntaxlabel
\Defun {remove-metaclass-p} {{\funarg{the-class}}}

Check if \funarg{the-class}\ is a non-standard metaobject class
 which should not be considered for storing into the database.
 This is the case for classes being no standard metaobject class
 as defined by a call to \fcite{standard-metaclass-p}\ and which
 do not inherit from \class{standard-class},
 \class{standard-direct-slot-definition}\ or
 \class{standard-effective-slot-definition}. Subclasses of
 these classes are allowed to store user-defined metaobject classes.


\endcom

\beginfncom[Internal]{remove-non-standard-metaclasses}

\Syntaxlabel
\Defun {remove-non-standard-metaclasses} {{\funarg{metaclass-p}} {\funarg{classes}}}


\endcom

\beginfncom[Internal]{return-nil}

\Syntaxlabel
\Defun {return-nil} {}


\Purposelabel
 Return always \lispnil.


\endcom

\beginfncom[Internal]{return-t}

\Syntaxlabel
\Defun {return-t} {}


\Purposelabel
 Return always \lispt.


\endcom

\begincncom[Internal]{+reverse-structure-persistent-slot-names+}

\Valuelabel
\begin{CompactCode}
(reverse +structure-persistent-slot-names+)
\end{CompactCode}

\Purposelabel
The reverse list of the value of
 \fcite{+structure-persistent-slot-names+}.


\endcom

\beginvrcom[Internal]{*root*}

\Initialvaluelabel
\begin{CompactCode}
(make-persistent-object-internal)
\end{CompactCode}

\Purposelabel
 The \plob\ root object. Try loading it into the \lw\ inspector,
 you'll like it \ldots


\endcom

\beginvrcom[Internal]{*root-persistent-heap*}

\Initialvaluelabel
\begin{CompactCode}
nil
\end{CompactCode}

\Purposelabel
 The persistent heap object which is used at bootstrap in
 \fcite{open-heap}\ and whose cache is used for caching all
 transient \cl\ objects seen by \plob.
 {\bf *root-persistent-heap*} contains an instance of
 \fcite{cached-heap}.

 This heap is also used for storing and loading of metaobjects.
\Seealsolabel

 \Fcite{cached-heap};
 \fcite{open-heap}.


\endcom

\beginvrcom[Internal]{*root-persistent-heap-object->objid-cache*}

\Initialvaluelabel
\begin{CompactCode}
nil
\end{CompactCode}

\Purposelabel
 Contains the {\bf object->objid-cache} cache of the value of the
 variable {\bf *root-persistent-heap*}\ directly for faster access.
\Seealsolabel
 \Fcite{*root-persistent-heap*}.


\endcom

\beginvrcom[Internal]{*root-persistent-heap-objid*}

\Initialvaluelabel
\begin{CompactCode}
nil
\end{CompactCode}

\Purposelabel
 Contains the \objid\ of the value of the
 \fcite{*root-persistent-heap*}.


\endcom

\beginvrcom[Internal]{*root-persistent-heap-objid->object-cache*}

\Initialvaluelabel
\begin{CompactCode}
nil
\end{CompactCode}

\Purposelabel
 Contains the {\bf objid->object-cache} cache of the value of the
 variable {\bf *root-persistent-heap*}\ directly for faster access.
\Seealsolabel
 \Fcite{*root-persistent-heap*}.


\endcom

\beginfncom[Internal]{search-extent}

\Syntaxlabel
\Defun {search-extent} {{\funarg{the-slot}} {\funarg{the-class}}}


\Argumentslabel
 \isa{\funarg{the-slot}}
      {a symbol naming a slot of \funarg{the-class}}
 \isacls{\funarg{the-class}}
\Valueslabel
 Returns an extent for \funarg{the-slot}.
\Purposelabel
 Tries to find an extent for the slot named \funarg{the-slot} by
 looking for the class extent of \funarg{the-class}. If
 \funarg{the-class}\ has no class extent set, the search is continued
 in the superclasses of \funarg{the-class}.


\endcom

\beginfncom[Internal]{search-location}

\Syntaxlabel
\Defun {search-location} {{\funarg{the-slot}} {\funarg{the-class}}}


\Argumentslabel
 \isa{\funarg{the-slot}}
      {a symbol naming a slot of \funarg{the-class}}
 \isacls{\funarg{the-class}}
\Valueslabel
 Returns an location for \funarg{the-slot}.
\Purposelabel
 Tries to find an location for the slot named \funarg{the-slot}. If
 there is no location set in \funarg{the-class}, the search is
 continued in the superclasses of \funarg{the-class}.


\endcom

\beginvrcom[Internal]{*sessions*}

\Initialvaluelabel
\begin{CompactCode}
(make-hash-table :test 'eql)
\end{CompactCode}

\Purposelabel
A hash table containing all open sessions.


\endcom

\beginfncom[Internal]{set-slot-extent}

\Syntaxlabel
\Defun {set-slot-extent} {{\funarg{extent}} {\funarg{the-slot}} {\funarg{the-class}}}


\Argumentslabel
 \isa{\funarg{extent}}
      {a (keyword) symbol}
 \isa{\funarg{the-slot}}
      {a symbol naming a slot of \funarg{the-class}}
 \isacls{\funarg{the-class}}
\Purposelabel
 Store the slot extent of the slot named \funarg{the-slot}\ of
 class \funarg{the-class}.
\Seealsolabel
 \Fcite{*class->slot-extent-table*};
 \fcite{get-slot-extent}.


\endcom

\beginfncom[Internal]{sh-begin-transaction}

\Syntaxlabel
\Defun {sh-begin-transaction} {{\funarg{p-heap-objid}} {\opt} {\funarg{ignore-error}}}


\Argumentslabel
 \isanobjid{\funarg{p-heap-objid}}
 Rest see \fcite{begin-transaction}.
\Valueslabel
 See \fcite{begin-transaction}.
\Purposelabel
 C interface function for \fcite{begin-transaction}.
\Remarkslabel
 It is checked if \funarg{p-heap-objid}\ references a persistent
 object of \fcite{persistent-heap}.

 To start a transaction, do not call this function interactively;
 use the \fcite{begin-transaction}.
\Seealsolabel
 \Fcite{begin-transaction}.


\endcom

\beginfncom[Internal]{sh-btree-clear}

\Syntaxlabel
\Defun {sh-btree-clear} {{\funarg{p-heap-objid}} {\funarg{p-objid-btree}}}


\Argumentslabel
 \isanobjid{\funarg{p-heap-objid}\ resp.\ \funarg{p-objid-btree}}
\Valueslabel
 Returns \lispt\ if the persistent BTree referenced by
 \funarg{p-objid-btree}\ was already empty,
 \nonnil\ otherwise.
\Purposelabel
 C interface function for \fcite{clrbtree (t)}.
\Remarkslabel
 It is checked if \funarg{p-heap-objid}\ references a persistent
 object of \fcite{persistent-heap}. It is checked if there is
 an active transaction on \funarg{p-heap-objid}.

 It is checked if \funarg{p-objid-btree}\ references a persistent
 object of \fcite{persistent-btree}\ and if it's an empty BTree; otherwise
 an error is signalled.
\Seealsolabel
 \Fcite{clrbtree (t)}.


\endcom

\beginfncom[Internal]{sh-btree-delete}

\Syntaxlabel
\Defun {sh-btree-delete} {{\funarg{p-heap-objid}} {\funarg{p-objid-btree}} {\funarg{immediate-key-value}} {\funarg{immediate-key-type-tag}}}


\Argumentslabel
 \isanobjid{\funarg{p-heap-objid}\ resp.\ \funarg{p-objid-btree}}
 \isa{\funarg{immediate-key-value}}
      {either an immediate value or an \objid}
 \isatypetag{\funarg{immediate-key-type-tag}}
\Purposelabel
 C interface function for various methods of \fcite{rembtree}.
\Remarkslabel
 It is checked if \funarg{p-heap-objid}\ references a persistent
 object of \fcite{persistent-heap}. It is checked if there is
 an active transaction on \funarg{p-heap-objid}.

 It is checked if \funarg{p-objid-btree}\ references a persistent
 object of \fcite{persistent-btree}.
\Seealsolabel
 \Fcite{rembtree}.


\endcom

\beginfncom[Internal]{sh-btree-delete-by-double}

\Syntaxlabel
\Defun {sh-btree-delete-by-double} {{\funarg{p-heap-objid}} {\funarg{p-objid-btree}} {\funarg{immediate-key-double-float}}}


\Argumentslabel
 \isanobjid{\funarg{p-heap-objid}\ resp.\ \funarg{p-objid-btree}}
 \isa{\funarg{immediate-key-double-float}}
      {a double float}
\Purposelabel
 C interface function for \fcite{rembtree (float t)}.
\Remarkslabel
 It is checked if \funarg{p-heap-objid}\ references a persistent
 object of \fcite{persistent-heap}. It is checked if there is
 an active transaction on \funarg{p-heap-objid}.

 It is checked if \funarg{p-objid-btree}\ references a persistent
 object of \fcite{persistent-btree}.
\Seealsolabel
 \Fcite{rembtree (float t)}.


\endcom

\beginfncom[Internal]{sh-btree-delete-by-float}

\Syntaxlabel
\Defun {sh-btree-delete-by-float} {{\funarg{p-heap-objid}} {\funarg{p-objid-btree}} {\funarg{immediate-key-single-float}}}


\Argumentslabel
 \isanobjid{\funarg{p-heap-objid}\ resp.\ \funarg{p-objid-btree}}
 \isa{\funarg{immediate-key-single-float}}
      {a single float}
\Purposelabel
 C interface function for \fcite{rembtree (float t)}.
\Remarkslabel
 It is checked if \funarg{p-heap-objid}\ references a persistent
 object of \fcite{persistent-heap}. It is checked if there is
 an active transaction on \funarg{p-heap-objid}.

 It is checked if \funarg{p-objid-btree}\ references a persistent
 object of \fcite{persistent-btree}.
\Seealsolabel
 \Fcite{rembtree (float t)}.


\endcom

\beginfncom[Internal]{sh-btree-delete-by-string}

\Syntaxlabel
\Defun {sh-btree-delete-by-string} {{\funarg{p-heap-objid}} {\funarg{p-objid-btree}} {\funarg{immediate-key-vector}}}


\Argumentslabel
 \isanobjid{\funarg{p-heap-objid}\ resp.\ \funarg{p-objid-btree}}
 \isa{\funarg{immediate-key-vector}}
      {a string}
\Purposelabel
 C interface function for various methods of \fcite{rembtree}.
\Remarkslabel
 It is checked if \funarg{p-heap-objid}\ references a persistent
 object of \fcite{persistent-heap}. It is checked if there is
 an active transaction on \funarg{p-heap-objid}.

 It is checked if \funarg{p-objid-btree}\ references a persistent
 object of \fcite{persistent-btree}.
\Seealsolabel
 \Fcite{rembtree (string t)};
 \fcite{rembtree (symbol t)}.


\endcom

\beginfncom[Internal]{sh-btree-delete-return-value}

\Syntaxlabel
\Defun {sh-btree-delete-return-value} {{\funarg{deleted}}}


\Argumentslabel
  \isa{\funarg{deleted}}
       {one of the values of the constants
        {\bf +btree-deleted+} or {\bf +btree-not-found+}}
\Valueslabel
 If \funarg{deleted}\ is {\bf +btree-deleted+}, return \lispt;
 if \funarg{deleted}\ is {\bf +btree-not-found+}, return \lispnil;
 otherwise, signal an error.
\Purposelabel
 Canonicalize the low-level return value \funarg{deleted}\ returned
 from one of the {\bf sh-btree-delete\ldots} functions so that it
 matches the return value of \fcite{remhash}.
\Seealsolabel
 Return value of \fcite{remhash}.


\endcom

\beginfncom[Internal]{sh-btree-insert}

\Syntaxlabel
\Defun {sh-btree-insert} {{\funarg{p-heap-objid}} {\funarg{p-objid-btree}} {\funarg{immediate-key-value}} {\funarg{immediate-key-type-tag}} {\funarg{immediate-data-value}} {\funarg{immediate-data-type-tag}}}


\Argumentslabel
 \isanobjid{\funarg{p-heap-objid}\ resp.\ \funarg{p-objid-btree}}
 \isa{\funarg{immediate-key-value}}
      {either an immediate value or an \objid}
 \isatypetag{\funarg{immediate-key-type-tag}}
 \isa{\funarg{immediate-data-value}}
      {either an immediate value or an \objid}
 \isatypetag{\funarg{immediate-data-type-tag}}
\Purposelabel
 C interface function for many methods of
 \fcite{(setf getbtree-with-data)}.
\Remarkslabel
 It is checked if \funarg{p-heap-objid}\ references a persistent
 object of \fcite{persistent-heap}. It is checked if there is
 an active transaction on \funarg{p-heap-objid}.

 It is checked if \funarg{p-objid-btree}\ references a persistent
 object of \fcite{persistent-btree}.
\Seealsolabel
 \Fcite{(setf getbtree-with-data)}.


\endcom

\beginfncom[Internal]{sh-btree-insert-by-double}

\Syntaxlabel
\Defun {sh-btree-insert-by-double} {{\funarg{p-heap-objid}} {\funarg{p-objid-btree}} {\funarg{immediate-key-double-float}} {\funarg{immediate-data-value}} {\funarg{immediate-data-type-tag}}}


\Argumentslabel
 \isanobjid{\funarg{p-heap-objid}\ resp.\ \funarg{p-objid-btree}}
 \isa{\funarg{immediate-key-double-float}}
      {a double float}
 \isa{\funarg{immediate-data-value}}
      {either an immediate value or an \objid}
 \isatypetag{\funarg{immediate-data-type-tag}}
\Purposelabel
 C interface function for
 \fcite{(setf getbtree-with-data) (t float t t t t t)}.
\Remarkslabel
 It is checked if \funarg{p-heap-objid}\ references a persistent
 object of \fcite{persistent-heap}. It is checked if there is
 an active transaction on \funarg{p-heap-objid}.

 It is checked if \funarg{p-objid-btree}\ references a persistent
 object of \fcite{persistent-btree}.
\Seealsolabel
 \Fcite{(setf getbtree-with-data) (t float t t t t t)}.


\endcom

\beginfncom[Internal]{sh-btree-insert-by-float}

\Syntaxlabel
\Defun {sh-btree-insert-by-float} {{\funarg{p-heap-objid}} {\funarg{p-objid-btree}} {\funarg{immediate-key-single-float}} {\funarg{immediate-data-value}} {\funarg{immediate-data-type-tag}}}


\Argumentslabel
 \isanobjid{\funarg{p-heap-objid}\ resp.\ \funarg{p-objid-btree}}
 \isa{\funarg{immediate-key-single-float}}
      {a single float}
 \isa{\funarg{immediate-data-value}}
      {either an immediate value or an \objid}
 \isatypetag{\funarg{immediate-data-type-tag}}
\Purposelabel
 C interface function for
 \fcite{(setf getbtree-with-data) (t float t t t t t)}.
\Remarkslabel
 It is checked if \funarg{p-heap-objid}\ references a persistent
 object of \fcite{persistent-heap}. It is checked if there is
 an active transaction on \funarg{p-heap-objid}.

 It is checked if \funarg{p-objid-btree}\ references a persistent
 object of \fcite{persistent-btree}.
\Seealsolabel
 \Fcite{(setf getbtree-with-data) (t float t t t t t)}.


\endcom

\beginfncom[Internal]{sh-btree-insert-by-string}

\Syntaxlabel
\Defun {sh-btree-insert-by-string} {{\funarg{p-heap-objid}} {\funarg{p-objid-btree}} {\funarg{immediate-key-vector}} {\funarg{immediate-data-value}} {\funarg{immediate-data-type-tag}}}


\Argumentslabel
 \isanobjid{\funarg{p-heap-objid}\ resp.\ \funarg{p-objid-btree}}
 \isa{\funarg{immediate-key-vector}}
      {a string}
 \isa{\funarg{immediate-data-value}}
      {either an immediate value or an \objid}
 \isatypetag{\funarg{immediate-data-type-tag}}
\Purposelabel
 C interface function for various methods of
 \fcite{(setf getbtree-with-data)}.
\Remarkslabel
 It is checked if \funarg{p-heap-objid}\ references a persistent
 object of \fcite{persistent-heap}. It is checked if there is
 an active transaction on \funarg{p-heap-objid}.

 It is checked if \funarg{p-objid-btree}\ references a persistent
 object of \fcite{persistent-btree}.
\Seealsolabel
 \Fcite{(setf getbtree-with-data) (t string t t t t t)};
 \fcite{(setf getbtree-with-data) (t symbol t t t t t)}.


\endcom

\beginfncom[Internal]{sh-btree-insert-return-value}

\Syntaxlabel
\Defun {sh-btree-insert-return-value} {{\funarg{inserted}}}


\Argumentslabel
  \isa{\funarg{inserted}}
       {one of the values of the constants
        {\bf +btree-inserted+} or {\bf +btree-not-found+}}
\Valueslabel
 If \funarg{inserted}\ is {\bf +btree-inserted+}, return \lispnil;
 if \funarg{inserted}\ is {\bf +btree-updated+}, return \lispt;
 otherwise, signal an error.
\Purposelabel
 Canonicalize the low-level return value \funarg{inserted}\ returned
 from one of the {\bf sh-btree-insert\ldots} functions so that it
 matches the return value of \fcite{(setf gethash)}.
\Seealsolabel
 Return value of \fcite{(setf gethash)}.


\endcom

\beginfncom[Internal]{sh-btree-map}

\Syntaxlabel
\Defun {sh-btree-map} {{\funarg{p-heap-objid}} {\funarg{p-objid-btree}} {\funarg{map-function}} {\opt} {\funarg{immediate-key-start-value}} {\funarg{immediate-key-start-type-tag}} {\funarg{compare-start-key}} {\funarg{immediate-key-end-value}} {\funarg{immediate-key-end-type-tag}} {\funarg{compare-end-key}} {\funarg{descending}} {\funarg{p-objid-filter}}}


\Argumentslabel
 \isanobjid{\funarg{p-heap-objid}\ resp.\ \funarg{p-objid-btree}}
 \isa{\funarg{immediate-key-start-value}\ resp.\ %
       \funarg{immediate-key-end-value}}
      {either an immediate value or an \objid}
 \isatypetag{\funarg{immediate-key-start-type-tag}\ resp.\ %
              \funarg{immediate-key-end-type-tag}}
\Purposelabel
 C interface function for
 \fcite{mapbtree-internal (t t integer t integer t t)}\ and
 \fcite{mapbtree-internal (t t persistent-object t t t t)}.
\Remarkslabel
 It is checked if \funarg{p-heap-objid}\ references a persistent
 object of \fcite{persistent-heap}. It is checked if there is
 an active transaction on \funarg{p-heap-objid}.

 It is checked if \funarg{p-objid-btree}\ references a persistent
 object of \fcite{persistent-btree}.
\Seealsolabel
 \Fcite{mapbtree-internal (t t integer t integer t t)};
 \fcite{mapbtree-internal (t t persistent-object t t t t)}.


\endcom

\beginfncom[Internal]{sh-btree-map-by-double}

\Syntaxlabel
\Defun {sh-btree-map-by-double} {{\funarg{p-heap-objid}} {\funarg{p-objid-btree}} {\funarg{map-function}} {\opt} {\funarg{immediate-key-start-double-float}} {\funarg{immediate-key-start-type-tag}} {\funarg{compare-start-key}} {\funarg{immediate-key-end-double-float}} {\funarg{immediate-key-end-type-tag}} {\funarg{compare-end-key}} {\funarg{descending}} {\funarg{p-objid-filter}}}


\Argumentslabel
 \isanobjid{\funarg{p-heap-objid}\ resp.\ \funarg{p-objid-btree}}
 \isa{\funarg{immediate-key-start-double-float}\ resp.\ %
       \funarg{immediate-key-end-double-float}}
      {a double float}
 \isatypetag{\funarg{immediate-key-start-type-tag}\ resp.\ %
              \funarg{immediate-key-end-type-tag}}
\Purposelabel
 C interface function for
 \fcite{mapbtree-internal (t t float t float t t)}.
\Remarkslabel
 It is checked if \funarg{p-heap-objid}\ references a persistent
 object of \fcite{persistent-heap}. It is checked if there is
 an active transaction on \funarg{p-heap-objid}.

 It is checked if \funarg{p-objid-btree}\ references a persistent
 object of \fcite{persistent-btree}.
\Seealsolabel
 \Fcite{mapbtree-internal (t t float t float t t)}.


\endcom

\beginfncom[Internal]{sh-btree-map-by-float}

\Syntaxlabel
\Defun {sh-btree-map-by-float} {{\funarg{p-heap-objid}} {\funarg{p-objid-btree}} {\funarg{map-function}} {\opt} {\funarg{immediate-key-start-single-float}} {\funarg{immediate-key-start-type-tag}} {\funarg{compare-start-key}} {\funarg{immediate-key-end-single-float}} {\funarg{immediate-key-end-type-tag}} {\funarg{compare-end-key}} {\funarg{descending}} {\funarg{p-objid-filter}}}


\Argumentslabel
 \isanobjid{\funarg{p-heap-objid}\ resp.\ \funarg{p-objid-btree}}
 \isa{\funarg{immediate-key-start-single-float}\ resp.\ %
       \funarg{immediate-key-end-single-float}}
      {a single float}
 \isatypetag{\funarg{immediate-key-start-type-tag}\ resp.\ %
              \funarg{immediate-key-end-type-tag}}
\Purposelabel
 C interface function for
 \fcite{mapbtree-internal (t t float t float t t)}.
\Remarkslabel
 It is checked if \funarg{p-heap-objid}\ references a persistent
 object of \fcite{persistent-heap}. It is checked if there is
 an active transaction on \funarg{p-heap-objid}.

 It is checked if \funarg{p-objid-btree}\ references a persistent
 object of \fcite{persistent-btree}.
\Seealsolabel
 \Fcite{mapbtree-internal (t t float t float t t)}.


\endcom

\beginfncom[Internal]{sh-btree-map-by-string}

\Syntaxlabel
\Defun {sh-btree-map-by-string} {{\funarg{p-heap-objid}} {\funarg{p-objid-btree}} {\funarg{map-function}} {\opt} {\funarg{immediate-key-start-vector}} {\funarg{immediate-key-start-type-tag}} {\funarg{compare-start-key}} {\funarg{immediate-key-end-vector}} {\funarg{immediate-key-end-type-tag}} {\funarg{compare-end-key}} {\funarg{descending}} {\funarg{p-objid-filter}}}


\Argumentslabel
 \isanobjid{\funarg{p-heap-objid}\ resp.\ \funarg{p-objid-btree}}
 \isa{\funarg{immediate-key-start-vector}\ resp.\ %
       \funarg{immediate-key-end-vector}}
      {a string}
 \isatypetag{\funarg{immediate-key-start-type-tag}\ resp.\ %
              \funarg{immediate-key-end-type-tag}}
\Purposelabel
 C interface function for
 \fcite{mapbtree-internal (t t string t string t t)}.
\Remarkslabel
 It is checked if \funarg{p-heap-objid}\ references a persistent
 object of \fcite{persistent-heap}. It is checked if there is
 an active transaction on \funarg{p-heap-objid}.

 It is checked if \funarg{p-objid-btree}\ references a persistent
 object of \fcite{persistent-btree}.
\Seealsolabel
 \Fcite{mapbtree-internal (t t string t string t t)}.


\endcom

\beginfncom[Internal]{sh-btree-map-search}

\Syntaxlabel
\Defun {sh-btree-map-search} {{\funarg{p-heap-objid}} {\funarg{p-objid-mapper}} {\funarg{p-objid-btree}} {\opt} {\funarg{immediate-key-start-value}} {\funarg{immediate-key-start-type-tag}} {\funarg{compare-start-key}} {\funarg{immediate-key-end-value}} {\funarg{immediate-key-end-type-tag}} {\funarg{compare-end-key}} {\funarg{descending}} {\funarg{p-objid-filter}}}


\endcom

\beginfncom[Internal]{sh-btree-map-search-by-double}

\Syntaxlabel
\Defun {sh-btree-map-search-by-double} {{\funarg{p-heap-objid}} {\funarg{p-objid-mapper}} {\funarg{p-objid-btree}} {\opt} {\funarg{immediate-key-start-double-float}} {\funarg{immediate-key-start-type-tag}} {\funarg{compare-start-key}} {\funarg{immediate-key-end-double-float}} {\funarg{immediate-key-end-type-tag}} {\funarg{compare-end-key}} {\funarg{descending}} {\funarg{p-objid-filter}}}


\endcom

\beginfncom[Internal]{sh-btree-map-search-by-float}

\Syntaxlabel
\Defun {sh-btree-map-search-by-float} {{\funarg{p-heap-objid}} {\funarg{p-objid-mapper}} {\funarg{p-objid-btree}} {\opt} {\funarg{immediate-key-start-single-float}} {\funarg{immediate-key-start-type-tag}} {\funarg{compare-start-key}} {\funarg{immediate-key-end-single-float}} {\funarg{immediate-key-end-type-tag}} {\funarg{compare-end-key}} {\funarg{descending}} {\funarg{p-objid-filter}}}


\endcom

\beginfncom[Internal]{sh-btree-map-search-by-string}

\Syntaxlabel
\Defun {sh-btree-map-search-by-string} {{\funarg{p-heap-objid}} {\funarg{p-objid-mapper}} {\funarg{p-objid-btree}} {\opt} {\funarg{immediate-key-start-string}} {\funarg{immediate-key-start-type-tag}} {\funarg{compare-start-key}} {\funarg{immediate-key-end-string}} {\funarg{immediate-key-end-type-tag}} {\funarg{compare-end-key}} {\funarg{descending}} {\funarg{p-objid-filter}}}


\endcom

\beginfncom[Internal]{sh-btree-map-seek}

\Syntaxlabel
\Defun {sh-btree-map-seek} {{\funarg{p-heap-objid}} {\funarg{p-objid-mapper}} {\funarg{increment}} {\funarg{origin}}}


\endcom

\beginfncom[Internal]{sh-btree-map-seek-set}

\Syntaxlabel
\Defun {sh-btree-map-seek-set} {{\funarg{p-heap-objid}} {\funarg{p-objid-mapper}} {\funarg{increment}} {\funarg{origin}} {\funarg{immediate-data-value}} {\funarg{immediate-data-type-tag}}}


\endcom

\beginfncom[Internal]{sh-btree-page-count}

\Syntaxlabel
\Defun {sh-btree-page-count} {{\funarg{p-heap-objid}} {\funarg{p-objid-btree-page}}}


\Purposelabel
  Get the number of elements of a single BTree page.
  Used only for inspecting a BTree.


\endcom

\beginfncom[Internal]{sh-btree-page-map}

\Syntaxlabel
\Defun {sh-btree-page-map} {{\funarg{p-heap-objid}} {\funarg{p-objid-btree-page}} {\funarg{map-function}}}


\Purposelabel
  Get the elements of a single BTree page.
  Used only for inspecting a BTree.


\endcom

\beginfncom[Internal]{sh-btree-page-parent}

\Syntaxlabel
\Defun {sh-btree-page-parent} {{\funarg{p-heap-objid}} {\funarg{p-objid-btree-page}}}


\Purposelabel
  Get the parent object of a single BTree page.
  Used only for inspecting a BTree.


\endcom

\beginfncom[Internal]{sh-btree-root}

\Syntaxlabel
\Defun {sh-btree-root} {{\funarg{p-heap-objid}} {\funarg{p-objid-btree}}}


\Purposelabel
  Get the root BTree page of a BTree.
  Used only for inspecting a BTree.


\endcom

\beginfncom[Internal]{sh-btree-search}

\Syntaxlabel
\Defun {sh-btree-search} {{\funarg{p-heap-objid}} {\funarg{p-objid-btree}} {\funarg{immediate-key-value}} {\funarg{immediate-key-type-tag}}}


\Argumentslabel
 \isanobjid{\funarg{p-heap-objid}\ resp.\ \funarg{p-objid-btree}}
 \isa{\funarg{immediate-key-value}}
      {either an immediate value or an \objid}
 \isatypetag{\funarg{immediate-key-type-tag}}
\Purposelabel
 C interface function for many methods of
 \fcite{getbtree-with-data}.
\Remarkslabel
 It is checked if \funarg{p-heap-objid}\ references a persistent
 object of \fcite{persistent-heap}. It is checked if there is
 an active transaction on \funarg{p-heap-objid}.

 It is checked if \funarg{p-objid-btree}\ references a persistent
 object of \fcite{persistent-btree}.
\Seealsolabel
 \Fcite{getbtree-with-data}.


\endcom

\beginfncom[Internal]{sh-btree-search-by-double}

\Syntaxlabel
\Defun {sh-btree-search-by-double} {{\funarg{p-heap-objid}} {\funarg{p-objid-btree}} {\funarg{immediate-key-double-float}}}


\Argumentslabel
 \isanobjid{\funarg{p-heap-objid}\ resp.\ \funarg{p-objid-btree}}
 \isa{\funarg{immediate-key-double-float}}
      {a double float}
\Purposelabel
 C interface function for \fcite{getbtree-with-data (float t t t)}.
\Remarkslabel
 It is checked if \funarg{p-heap-objid}\ references a persistent
 object of \fcite{persistent-heap}. It is checked if there is
 an active transaction on \funarg{p-heap-objid}.

 It is checked if \funarg{p-objid-btree}\ references a persistent
 object of \fcite{persistent-btree}.
\Seealsolabel
 \Fcite{getbtree-with-data (float t t t)}.


\endcom

\beginfncom[Internal]{sh-btree-search-by-float}

\Syntaxlabel
\Defun {sh-btree-search-by-float} {{\funarg{p-heap-objid}} {\funarg{p-objid-btree}} {\funarg{immediate-key-single-float}}}


\Argumentslabel
 \isanobjid{\funarg{p-heap-objid}\ resp.\ \funarg{p-objid-btree}}
 \isa{\funarg{immediate-key-single-float}}
      {a single float}
\Purposelabel
 C interface function for \fcite{getbtree-with-data (float t t t)}.
\Remarkslabel
 It is checked if \funarg{p-heap-objid}\ references a persistent
 object of \fcite{persistent-heap}. It is checked if there is
 an active transaction on \funarg{p-heap-objid}.

 It is checked if \funarg{p-objid-btree}\ references a persistent
 object of \fcite{persistent-btree}.
\Seealsolabel
 \Fcite{getbtree-with-data (float t t t)}.


\endcom

\beginfncom[Internal]{sh-btree-search-by-string}

\Syntaxlabel
\Defun {sh-btree-search-by-string} {{\funarg{p-heap-objid}} {\funarg{p-objid-btree}} {\funarg{immediate-key-vector}} {\opt} {\funarg{immediate-key-type-tag}}}


\Argumentslabel
 \isanobjid{\funarg{p-heap-objid}\ resp.\ \funarg{p-objid-btree}}
 \isa{\funarg{immediate-key-vector}}
      {a simple vector}
 \isatypetag{\funarg{immediate-key-type-tag}}
\Purposelabel
 C interface function for various methods of
 \fcite{(setf getbtree-with-data)}.
\Remarkslabel
 It is checked if \funarg{p-heap-objid}\ references a persistent
 object of \fcite{persistent-heap}. It is checked if there is
 an active transaction on \funarg{p-heap-objid}.

 It is checked if \funarg{p-objid-btree}\ references a persistent
 object of \fcite{persistent-btree}.
\Seealsolabel
 \Fcite{getbtree-with-data (string t t t)};
 \fcite{getbtree-with-data (symbol t t t)}.


\endcom

\beginfncom[Internal]{sh-btree-search-return-value}

\Syntaxlabel
\Defun {sh-btree-search-return-value} {{\funarg{found}} {\funarg{immediate-key-value}} {\funarg{immediate-key-type-tag}} {\funarg{immediate-data-value}} {\funarg{immediate-data-type-tag}}}


\Argumentslabel
  \isa{\funarg{found}}
       {one of the values of the constants
        {\bf +btree-found+} or {\bf +btree-not-found+}}
  \isa{\funarg{immediate-data-value}}
      {either an immediate value or an \objid}
  \isatypetag{\funarg{immediate-data-type-tag}}
\Valueslabel
 If \funarg{found}\ is {\bf +btree-found+}, return \lispnil;
 if \funarg{found}\ is {\bf +btree-not-found+}, return
 the three values \lispnil, \funarg{immediate-data-value}\ and
 \funarg{immediate-data-type-tag};
 otherwise, signal an error.
\Purposelabel
 Canonicalize the low-level return value \funarg{found}\ returned
 from one of the {\bf sh-btree-search\ldots} functions so that it
 matches the return value of \fcite{gethash}.
\Seealsolabel
 Return value of \fcite{gethash}.


\endcom

\beginfncom[Internal]{sh-btree-test-mode}

\Syntaxlabel
\Defun {sh-btree-test-mode} {{\funarg{p-heap-objid}} {\funarg{p-objid-btree}} {\opt} {\funarg{new-test-mode}}}


\Argumentslabel
 \isanobjid{\funarg{p-objid-btree}}
\Purposelabel
 C interface function for \fcite{btree-test (t)}\ and
 \fcite{(setf btree-test) (t t)}.
\Seealsolabel
 \Fcite{btree-test};
 \fcite{(setf btree-test)}.


\endcom

\beginfncom[Internal]{sh-can-modify}

\Syntaxlabel
\Defun {sh-can-modify} {{\funarg{p-heap-objid}} {\funarg{p-objid}}}


\Seealsolabel
 \shcite{function}{SH\us{}can\us{}modify}{2}.


\endcom

\beginfncom[Internal]{sh-cancel-transaction}

\Syntaxlabel
\Defun {sh-cancel-transaction} {{\funarg{p-heap-objid}} {\opt} {\funarg{ignore-error}}}


\Argumentslabel
 \isanobjid{\funarg{p-heap-objid}}
 Rest see \fcite{cancel-transaction}.
\Valueslabel
 See \fcite{cancel-transaction}.
\Purposelabel
 C interface function for \fcite{cancel-transaction}.
\Remarkslabel
 It is checked if \funarg{p-heap-objid}\ references a persistent
 object of \fcite{persistent-heap}. It is checked if there is
 an active transaction on \funarg{p-heap-objid}.

 To cancel a transaction, do not call this function interactively;
 use the \fcite{cancel-transaction}.
\Seealsolabel
 \Fcite{cancel-transaction}.


\endcom

\beginfncom[Internal]{sh-compare}

\Syntaxlabel
\Defun {sh-compare} {{\funarg{p-heap-objid}} {\funarg{immediate-value-1}} {\funarg{immediate-type-tag-1}} {\funarg{immediate-value-2}} {\funarg{immediate-type-tag-2}}}


\endcom

\beginfncom[Internal]{sh-compile-regex}

\Syntaxlabel
\Defun {sh-compile-regex} {{\funarg{p-heap-objid}} {\funarg{p-regex-objid}}}


\endcom

\beginfncom[Internal]{sh-configuration}

\Syntaxlabel
\Defun {sh-configuration} {{\funarg{p-heap-objid}}}


\Purposelabel
 Returns an instance of \fcite{stableheap-configuration}\ containing
 \sh\ configuration informations.
\Seealsolabel
 \Fcite{stableheap-configuration};
 \fcite{sh-statistics};
 \shcite{function}{SH\us{}configuration}{3}.


\endcom

\beginfncom[Internal]{sh-create-instance}

\Syntaxlabel
\Defun {sh-create-instance} {{\funarg{p-heap-objid}} {\funarg{p-objid-class-description}}}

C interface function for \fcite{p-allocate-instance}.


\endcom

\beginfncom[Internal]{sh-create-machine}

\Syntaxlabel
\Defun {sh-create-machine} {{\funarg{p-heap-objid}} {\funarg{machine-addr}} {\funarg{loginp}}}


\Purposelabel
 Returns an instance of class \class{machine}.


\endcom

\beginfncom[Internal]{sh-create-object}

\Syntaxlabel
\Defun {sh-create-object} {{\funarg{p-heap-objid}} {\funarg{type-tag}} {\opt} {\funarg{number-of-extra-objids}} {\funarg{extra-values-type-tag}} {\funarg{number-of-extra-values}}}

C interface function for \fcite{p-allocate}.


\endcom

\beginfncom[Internal]{sh-create-structure}

\Syntaxlabel
\Defun {sh-create-structure} {{\funarg{p-heap-objid}} {\funarg{p-objid-structure-description}}}

C interface function for \fcite{p-allocate-structure}.


\endcom

\beginfncom[Internal]{sh-delete-machine}

\Syntaxlabel
\Defun {sh-delete-machine} {{\funarg{p-heap-objid}} {\funarg{machine-addr}}}


\Purposelabel
 Delete \funarg{machine}\ from the internal list of known machines.


\endcom

\beginfncom[Internal]{sh-destroy-object}

\Syntaxlabel
\Defun {sh-destroy-object} {{\funarg{p-heap-objid}} {\funarg{p-objid}}}


\Argumentslabel
 See \fcite{p-destroy}.
\Purposelabel
 See \fcite{p-destroy}.
\Seealsolabel
 \shcite{fn}{SH\us{}destroy\us{}object}{3}.


\endcom

\beginfncom[Internal]{sh-end-transaction}

\Syntaxlabel
\Defun {sh-end-transaction} {{\funarg{p-heap-objid}} {\opt} {\funarg{ignore-error}}}


\Argumentslabel
 \isanobjid{\funarg{p-heap-objid}}
 Rest see \fcite{end-transaction}.
\Valueslabel
 See \fcite{end-transaction}.
\Purposelabel
 C interface function for \fcite{end-transaction}.
\Remarkslabel
 It is checked if \funarg{p-heap-objid}\ references a persistent
 object of \fcite{persistent-heap}. It is checked if there is
 an active transaction on \funarg{p-heap-objid}.

 To end a transaction, do not call this function interactively;
 use the \fcite{end-transaction}.
\Seealsolabel
 \Fcite{end-transaction}.


\endcom

\beginfncom[Internal]{sh-error-callback}

\Syntaxlabel
\Defun {sh-error-callback} {{\funarg{error-level}} {\funarg{continue-message}} {\funarg{error-message}}}


\Argumentslabel
 \isa{\funarg{continue-message}\ resp.\ \funarg{error-message}}
      {a string}
\Purposelabel
 The \lwcl\ callback called when a continuable error occurres in
 the C level of \plob.
\Seealsolabel
 \Fcite{sh-signal-cerror}.


\endcom

\beginfncom[Internal]{sh-exit}

\Syntaxlabel
\Defun {sh-exit} {{\funarg{p-heap-objid}} {\opt} {\funarg{force}}}


\Purposelabel
 Exit the \plob\ daemon server process.


\endcom

\beginfncom[Internal]{sh-flush-object}

\Syntaxlabel
\Defun {sh-flush-object} {{\funarg{p-heap-objid}} {\funarg{p-objid}} {\funarg{remove-from-cache-p}}}


 \Purposelabel
  Flush the object referenced by \funarg{p-objid}.
 \Seealsolabel
  \Fcite{flush-object}.


\endcom

\beginfncom[Internal]{sh-get-host-addr}

\Syntaxlabel
\Defun {sh-get-host-addr} {{\funarg{name}}}

Convert \funarg{name}\ into a numeric Internet address.


\endcom

\beginfncom[Internal]{sh-in-transaction-p}

\Syntaxlabel
\Defun {sh-in-transaction-p} {{\funarg{p-heap-objid}} {\opt} {\funarg{transaction-id}}}


\Argumentslabel
 \isanobjid{\funarg{p-heap-objid}}
 \isa{\funarg{transaction-id}}
      {a numeric transaction ID}
\Valueslabel
 See \fcite{in-transaction-p}.

 If \funarg{transaction-id}\ is optionally
 passed, the numeric transaction ID is only returned iff it's
 \lisp{equal}\ to \funarg{transaction-id}; \lispnil\ otherwise.
\Purposelabel
 C interface function for \fcite{in-transaction-p}.
\Remarkslabel
 It is checked if \funarg{p-heap-objid}\ references a persistent
 object of \fcite{persistent-heap}.

 To check for an active transaction, do not call this function
 interactively; use the \fcite{in-transaction-p}.
\Seealsolabel
 \Fcite{in-transaction-p}.


\endcom

\beginfncom[Internal]{sh-insert-lock}

\Syntaxlabel
\Defun {sh-insert-lock} {{\funarg{p-heap-objid}} {\funarg{p-objid}} {\funarg{expecting-type-tag}} {\funarg{lock-mode}} {\funarg{at-index}}}


\Argumentslabel
 \isanobjid{\funarg{p-heap-objid}}
 Rest see \fcite{p-insert-lock}.
\Valueslabel
 See \fcite{p-insert-lock}.
\Purposelabel
 C interface function for \fcite{p-insert-lock}.
\Remarkslabel
 It is checked if \funarg{p-heap-objid}\ references a persistent
 object of \fcite{persistent-heap}. It is checked if there is
 an active transaction on \funarg{p-heap-objid}.
\Seealsolabel
 \Fcite{p-insert-lock};
 \fcite{sh-set-lock}.


\endcom

\beginfncom[Internal]{sh-insert-machine}

\Syntaxlabel
\Defun {sh-insert-machine} {{\funarg{p-heap-objid}} {\funarg{machine}}}


\Purposelabel
 Insert \funarg{machine}\ into the internal list of known machines.


\endcom

\beginfncom[Internal]{sh-machine-addr}

\Syntaxlabel
\Defun {sh-machine-addr} {{\funarg{p-heap-objid}} {\funarg{machine}}}


\Purposelabel
 Get the Internet address of \funarg{machine}


\endcom

\beginfncom[Internal]{sh-machine-loginp}

\Syntaxlabel
\Defun {sh-machine-loginp} {{\funarg{p-heap-objid}} {\funarg{machine}} {\funarg{loginp}}}


\Purposelabel
 Set resp.\ get login flag of \funarg{machine}


\endcom

\beginfncom[Internal]{sh-machines}

\Syntaxlabel
\Defun {sh-machines} {{\funarg{p-heap-objid}}}


\Purposelabel
 Returns an instance containing all known machines.
 Currently, this is a BTree.


\endcom

\beginfncom[Internal]{sh-make-bignum}

\Syntaxlabel
\Defun {sh-make-bignum} {{\funarg{p-heap-objid}} {\funarg{from}}}


\Argumentslabel
 See \fcite{p-make-bignum}.
\Valueslabel
 See \fcite{p-make-bignum}.
\Purposelabel
 C interface function for \fcite{p-make-bignum}.
\Remarkslabel
 It is checked if \funarg{p-heap-objid}\ references a persistent
 object of \fcite{persistent-heap}. It is checked if there is
 an active transaction on \funarg{p-heap-objid}.
\Seealsolabel
 \Fcite{p-make-bignum}.


\endcom

\beginfncom[Internal]{sh-make-double-float}

\Syntaxlabel
\Defun {sh-make-double-float} {{\funarg{p-heap-objid}} {\funarg{from}}}


\Argumentslabel
 See \fcite{p-make-double-float}.
\Valueslabel
 See \fcite{p-make-double-float}.
\Purposelabel
 C interface function for \fcite{p-make-double-float}.
\Remarkslabel
 It is checked if \funarg{p-heap-objid}\ references a persistent
 object of \fcite{persistent-heap}. It is checked if there is
 an active transaction on \funarg{p-heap-objid}.
\Seealsolabel
 \Fcite{p-make-double-float};
 \fcite{sh-write-double-float}.


\endcom

\beginfncom[Internal]{sh-make-regex}

\Syntaxlabel
\Defun {sh-make-regex} {{\funarg{p-heap-objid}} {\funarg{pattern}} {\funarg{regcomp-flags}} {\funarg{regexec-flags}}}


\endcom

\beginfncom[Internal]{sh-make-single-float}

\Syntaxlabel
\Defun {sh-make-single-float} {{\funarg{p-heap-objid}} {\funarg{from}}}


\Argumentslabel
 See \fcite{p-make-single-float}.
\Valueslabel
 See \fcite{p-make-single-float}.
\Purposelabel
 C interface function for \fcite{p-make-single-float}.
\Remarkslabel
 It is checked if \funarg{p-heap-objid}\ references a persistent
 object of \fcite{persistent-heap}. It is checked if there is
 an active transaction on \funarg{p-heap-objid}.
\Seealsolabel
 \Fcite{p-make-single-float};
 \fcite{sh-write-single-float}.


\endcom

\beginfncom[Internal]{sh-map-class-info}

\Syntaxlabel
\Defun {sh-map-class-info} {{\funarg{enum-function}}}


\Argumentslabel
 The \funarg{enum-function}\ argument is
 a function taking four arguments:
 \begin{description}
 \item[\funarg{type-tag}]
   This is the \typetag\ of the \plob\ C level
   built-in class.
 \item[\funarg{type-name}]
   This is a string naming the type identified by
   \funarg{type-tag}.
 \item[\funarg{objid-size}]
   This is the number of reference words in units of bits for
   instances of the type identified by \funarg{type-tag}.
   This value is always a multiple of~32.
 \item[\funarg{value-size}]
   This is the number of value bits for instances of
   the type identified by \funarg{type-tag}.
 \end{description}
\Purposelabel
 The \funarg{enum-function}\ is called for each \plob\ C level
 built-in class.


\endcom

\beginfncom[Internal]{sh-objid-size}

\Syntaxlabel
\Defun {sh-objid-size} {{\funarg{p-heap-objid}} {\funarg{p-objid}}}

See \fcite{p-objid-size}.


\endcom

\beginfncom[Internal]{sh-objid-valid-p}

\Syntaxlabel
\Defun {sh-objid-valid-p} {{\funarg{p-objid}}}


\Purposelabel
 Return \nonnil\ if \funarg{p-objid}\ is a valid \objid,
 \lispnil\ otherwise.


\endcom

\beginfncom[Internal]{sh-open}

\Syntaxlabel
\Defun {sh-open} {{\opt} {\funarg{url}} {\funarg{description}}}


\Argumentslabel
  \isa{\funarg{url}}
       {an URL naming the database to open}
\Purposelabel
 Low-level open of the database.
\Remarkslabel
 Do not call this function interactively; \plob\ cares for correct
 opening the \sh\ the first time this action will be necessary.
 If you want to open a \plob\ session explicitely, call the
 \fcite{open-session}.

\Seealsolabel
 \Fcite{open-session};
 \shcite{function}{SH\us{}open}{4}.


\endcom

\beginfncom[Internal]{sh-open-p}

\Syntaxlabel
\Defun {sh-open-p} {}


\Purposelabel
 Check if the \sh\ is open at all.
\Seealsolabel
 \Fcite{assert-sh-open-p}.


\endcom

\beginfncom[Internal]{sh-pprint-objid}

\Syntaxlabel
\Defun {sh-pprint-objid} {{\funarg{p-heap-objid}} {\funarg{p-objid}} {\funarg{type-tag}}}


\Argumentslabel
 \isanobjid{\funarg{p-heap-objid}}
 \isanobjid{\funarg{p-objid}}
 \isatypetag{\funarg{type-tag}}
\Valueslabel
 A string with a printed representation for \funarg{p-objid}.
\Purposelabel
 Print a persistent object into a string.
\Seealsolabel
 \Fcite{sh-pprint-symbol};
 \fcite{+pprint-buffer-size+}.


\endcom

\beginfncom[Internal]{sh-pprint-symbol}

\Syntaxlabel
\Defun {sh-pprint-symbol} {{\funarg{p-heap-objid}} {\funarg{p-objid}}}


\Argumentslabel
 \isanobjid{\funarg{p-heap-objid}}
 \isanobjid{\funarg{p-objid}}
\Valueslabel
 A string with a printed representation for \funarg{p-objid}.
\Purposelabel
 Print a persistent symbol into a string.
\Seealsolabel
 \Fcite{sh-pprint-objid};
 \fcite{+pprint-buffer-size+}.


\endcom

\beginfncom[Internal]{sh-read-bignum}

\Syntaxlabel
\Defun {sh-read-bignum} {{\funarg{p-heap-objid}} {\funarg{p-objid}}}


\Argumentslabel
 See \fcite{p-bignum}.
\Valueslabel
 See \fcite{p-bignum}.
\Purposelabel
 C interface function for \fcite{p-bignum}.
\Remarkslabel
 It is checked if \funarg{p-heap-objid}\ references a persistent
 object of \fcite{persistent-heap}. It is checked if there is
 an active transaction on \funarg{p-heap-objid}.

 It is checked if \funarg{p-objid}\ references a persistent object
 of type \class{bignum}.

 It is checked if a read-lock is set
 on `vector'-level on \funarg{p-objid}; if no lock is
 set, a `vector'-level read lock is set on \funarg{p-objid}.
\Seealsolabel
 \Fcite{p-bignum};
 \fcite{sh-write-bignum}.


\endcom

\beginfncom[Internal]{sh-read-chars}

\Syntaxlabel
\Defun {sh-read-chars} {{\funarg{p-heap-objid}} {\funarg{p-objid}} {\funarg{to-string}} {\funarg{number-of-characters}}}


\Argumentslabel
 \isa{\funarg{to-string}}
      {a string}
 Rest see \fcite{p-chars-into}.
\Valueslabel
 See \fcite{p-chars-into}.
\Purposelabel
 C interface function for \fcite{p-chars-into}.
\Remarkslabel
 It is checked if \funarg{p-heap-objid}\ references a persistent
 object of \fcite{persistent-heap}. It is checked if there is
 an active transaction on \funarg{p-heap-objid}.
\Seealsolabel
 \Fcite{p-chars-into};
 \fcite{sh-write-chars};
 \shcite{function}{SH\us{}read\us{}words}{5}.


\endcom

\beginfncom[Internal]{sh-read-double-float}

\Syntaxlabel
\Defun {sh-read-double-float} {{\funarg{p-heap-objid}} {\funarg{p-objid}}}


\Argumentslabel
 See \fcite{p-double-float}.
\Valueslabel
 See \fcite{p-double-float}.
\Purposelabel
 C interface function for \fcite{p-double-float}.
\Remarkslabel
 It is checked if \funarg{p-heap-objid}\ references a persistent
 object of \fcite{persistent-heap}. It is checked if there is
 an active transaction on \funarg{p-heap-objid}.

 It is checked if \funarg{p-objid}\ references a persistent
 object of type \class{double-float}.

 It is checked if a read-lock is set
 on `vector'-level on \funarg{p-objid}; if no lock is
 set, a `vector'-level read lock is set on \funarg{p-objid}.
\Seealsolabel
 \Fcite{p-double-float};
 \fcite{sh-write-double-float}.


\endcom

\beginfncom[Internal]{sh-read-fixnum}

\Syntaxlabel
\Defun {sh-read-fixnum} {{\funarg{p-heap-objid}} {\funarg{p-objid}} {\funarg{at-index}} {\funarg{expecting-class}} {\funarg{expecting-type-tag}}}


\Argumentslabel
 See \fcite{p-fixnum}.
\Valueslabel
 See \fcite{p-fixnum}.
\Purposelabel
 C interface function for \fcite{p-fixnum}.
\Remarkslabel
 It is checked if \funarg{p-heap-objid}\ references a persistent
 object of \fcite{persistent-heap}. It is checked if there is
 an active transaction on \funarg{p-heap-objid}.
\Seealsolabel
 \Fcite{p-fixnum};
 \fcite{sh-write-fixnum}.


\endcom

\beginfncom[Internal]{sh-read-index}

\Syntaxlabel
\Defun {sh-read-index} {{\funarg{p-heap-objid}} {\funarg{p-objid}} {\funarg{at-index}} {\funarg{expecting-class}} {\funarg{expecting-type-tag}}}


\Argumentslabel
 See \fcite{p-index}.
\Valueslabel
 See \fcite{p-index}.
\Purposelabel
 C interface function for \fcite{p-index}.
\Remarkslabel
 It is checked if \funarg{p-heap-objid}\ references a persistent
 object of \fcite{persistent-heap}. It is checked if there is
 an active transaction on \funarg{p-heap-objid}.
\Seealsolabel
 \Fcite{p-index};
 \fcite{sh-write-index}.


\endcom

\beginfncom[Internal]{sh-read-indices-into}

\Syntaxlabel
\Defun {sh-read-indices-into} {{\funarg{p-heap-objid}} {\funarg{p-objid}} {\funarg{start-index}} {\funarg{number-of-objids}} {\funarg{objids}} {\funarg{type-tags}} {\funarg{expecting-class}} {\funarg{expecting-type-tag}}}


\Purposelabel
 Read the \objid{}s of \funarg{number-of-objids}\ slots of the
 persistent object \funarg{p-objid}\ starting at slot index
 \funarg{start-index}\ into \funarg{objids}\ and the
 corresponding \typetag{}s\ into \funarg{type-tags}.
\Remarkslabel
 It is checked if \funarg{p-heap-objid}\ references a persistent
 object of \fcite{persistent-heap}. It is checked if there is
 an active transaction on \funarg{p-heap-objid}.


\endcom

\beginfncom[Internal]{sh-read-objid}

\Syntaxlabel
\Defun {sh-read-objid} {{\funarg{p-heap-objid}} {\funarg{p-objid}} {\funarg{at-index}} {\funarg{expecting-class}} {\funarg{expecting-type-tag}}}


\Argumentslabel
 See \fcite{p-objid}.
\Valueslabel
 See \fcite{p-objid}.
\Purposelabel
 C interface function for \fcite{p-objid}.
\Remarkslabel
 It is checked if \funarg{p-heap-objid}\ references a persistent
 object of \fcite{persistent-heap}. It is checked if there is
 an active transaction on \funarg{p-heap-objid}.
\Seealsolabel
 \Fcite{p-objid};
 \fcite{sh-write-objid}.


\endcom

\beginfncom[Internal]{sh-read-only}

\Syntaxlabel
\Defun {sh-read-only} {{\funarg{p-heap-objid}} {\funarg{p-objid}} {\funarg{read-only-p}}}


\Argumentslabel
 \isanobjid{\funarg{p-objid}}
 \isa{\funarg{read-only-p}}
      {a fixnum with one of the constant values of
       {\bf +read-only+}, {\bf +read-write+} or {\bf +read-only-p+}}
\Valueslabel
 Returns the old read-only state of \funarg{p-objid}, one of the
 constant values of {\bf +read-only+} or {\bf +read-write+}.
\Purposelabel
 The actions done by {\bf sh-read-only} depend on the value of
 \funarg{read-only-p}:
 \begin{description}
 \item[{\bf +read-only+}]
  Lock the persistent object referenced by \funarg{p-objid}\ as
  read-only; no further write locks will be accepted for
  \funarg{p-objid}. No error is signalled if there was already
  a read-only lock set to \funarg{p-objid}.
 \item[{\bf +read-write+}]
  Remove the read-only lock from the persistent object referenced
  by \funarg{p-objid}. No error is signalled if there was no
  read-only lock set at all to \funarg{p-objid}.
 \item[{\bf +read-only-p+}]
  Return the current read-only lock status of the persistent object
  referenced by \funarg{p-objid}.
 \end{description}
\Seealsolabel
 \Fcite{p-read-only};
 \fcite{(setf p-read-only)}.


\endcom

\beginfncom[Internal]{sh-read-root}

\Syntaxlabel
\Defun {sh-read-root} {{\funarg{p-heap-objid}}}


\Valueslabel
 The \objid\ of the \plob\ root object is returned.
\Purposelabel
 Low-level read of the \plob\ root object.
\Seealsolabel
 \Fcite{sh-write-root}.


\endcom

\beginfncom[Internal]{sh-read-single-float}

\Syntaxlabel
\Defun {sh-read-single-float} {{\funarg{p-heap-objid}} {\funarg{p-objid}}}


\Argumentslabel
 See \fcite{p-single-float}.
\Valueslabel
 See \fcite{p-single-float}.
\Purposelabel
 C interface function for \fcite{p-single-float}.
\Remarkslabel
 It is checked if \funarg{p-heap-objid}\ references a persistent
 object of \fcite{persistent-heap}. It is checked if there is
 an active transaction on \funarg{p-heap-objid}.

 It is checked if \funarg{p-objid}\ references a persistent
 object of type \class{single-float}.

 It is checked if a read-lock is set
 on `vector'-level on \funarg{p-objid}; if no lock is
 set, a `vector'-level read lock is set on \funarg{p-objid}.
\Seealsolabel
 \Fcite{p-single-float};
 \fcite{sh-write-single-float}.


\endcom

\beginfncom[Internal]{sh-read-values}

\Syntaxlabel
\Defun {sh-read-values} {{\funarg{p-heap-objid}} {\funarg{p-objid}} {\funarg{element-type-tag}} {\funarg{to-t-simple-vector}} {\funarg{number-of-elements}} {\funarg{expecting-class}} {\funarg{expecting-type-tag}}}


\Argumentslabel
 \isa{\funarg{to-t-simple-vector}}
      {a simple vector}
 Rest see \fcite{p-values-into}.
\Valueslabel
 See \fcite{p-values-into}.
\Purposelabel
 C interface function for \fcite{p-values-into}.
\Remarkslabel
 It is checked if \funarg{p-heap-objid}\ references a persistent
 object of \fcite{persistent-heap}. It is checked if there is
 an active transaction on \funarg{p-heap-objid}.

 This function uses the \lw\ specific feature that the C code with
 a foreign-function argument of type simple-vector receives
 a pointer to the simple vector's data area.
\Seealsolabel
 \Fcite{p-values-into};
 \fcite{sh-write-values};
 \shcite{function}{SH\us{}read\us{}words}{5}.


\endcom

\beginfncom[Internal]{sh-reset}

\Syntaxlabel
\Defun {sh-reset} {{\funarg{p-heap-objid}} {\opt} {\funarg{force}}}


\Purposelabel
 Reset the \plob\ daemon server process.


\endcom

\beginfncom[Internal]{sh-restart}

\Syntaxlabel
\Defun {sh-restart} {{\funarg{p-heap-objid}} {\opt} {\funarg{force}}}


\Purposelabel
 Restart the \plob\ daemon server process.


\endcom

\beginfncom[Internal]{sh-resume}

\Syntaxlabel
\Defun {sh-resume} {}


\Purposelabel
 Resume the \plob\ daemon server process.


\endcom

\beginfncom[Internal]{sh-search-machine}

\Syntaxlabel
\Defun {sh-search-machine} {{\funarg{p-heap-objid}} {\funarg{machine-addr}}}


\Purposelabel
 Search \funarg{machine}\ in the internal list of known machines.


\endcom

\beginfncom[Internal]{sh-sessions}

\Syntaxlabel
\Defun {sh-sessions} {{\funarg{p-heap-objid}}}


\Purposelabel
 Returns an instance containing all active sessions. Currently, this is
 a BTree.


\endcom

\beginfncom[Internal]{sh-set-lock}

\Syntaxlabel
\Defun {sh-set-lock} {{\funarg{p-heap-objid}} {\funarg{p-objid}} {\funarg{expecting-type-tag}} {\funarg{lock-mode}} {\funarg{at-index}}}


\Argumentslabel
 \isanobjid{\funarg{p-heap-objid}}
 Rest see \fcite{p-set-lock}.
\Valueslabel
 See \fcite{p-set-lock}.
\Purposelabel
 C interface function for \fcite{p-set-lock}.
\Remarkslabel
 It is checked if \funarg{p-heap-objid}\ references a persistent
 object of \fcite{persistent-heap}. It is checked if there is
 an active transaction on \funarg{p-heap-objid}.
\Seealsolabel
 \Fcite{p-set-lock};
 \fcite{sh-insert-lock}.


\endcom

\beginfncom[Internal]{sh-signal-error}

\Syntaxlabel
\Defun {sh-signal-error} {{\funarg{error-level}} {\funarg{continue-message}} {\funarg{error-message}}}


\Argumentslabel
 \isa{\funarg{error-level}}
      {a fixnum}
 \isa{\funarg{continue-message}}
      {a string}
 \isa{\funarg{error-message}}
      {a string}
\Purposelabel
 The \cl\ callback called when an error occurres in
 the C level of \plob.
\Seealsolabel
 \Fcite{sh-signal-cerror}, \fcite{sh-signal-serror}.


\endcom

\beginfncom[Internal]{sh-stabilise}

\Syntaxlabel
\Defun {sh-stabilise} {{\funarg{p-heap-objid}}}


\Purposelabel
 Low-level flush of the \sh.
\Seealsolabel
 \Fcite{plob-flush};
 \shcite{function}{SH\us{}stabilise}{6}.


\endcom

\beginfncom[Internal]{sh-statistics}

\Syntaxlabel
\Defun {sh-statistics} {{\funarg{p-heap-objid}}}


\Purposelabel
 Returns an instance of \fcite{stableheap-statistics}\ containing some
 \sh\ statistics.
\Seealsolabel
 \Fcite{stableheap-statistics};
 \fcite{sh-configuration};
 \shcite{function}{SH\us{}statistics}{6}.


\endcom

\beginfncom[Internal]{sh-suspend}

\Syntaxlabel
\Defun {sh-suspend} {{\funarg{p-heap-objid}} {\opt} {\funarg{description}}}


\Purposelabel
 Suspend the \plob\ daemon server process.


\endcom

\beginfncom[Internal]{sh-type-tag-of}

\Syntaxlabel
\Defun {sh-type-tag-of} {{\funarg{p-heap-objid}} {\funarg{p-objid}}}


\Argumentslabel
 \isanobjid{\funarg{p-objid}}
\Purposelabel
 See \fcite{p-type-tag-of}.


\endcom

\beginfncom[Internal]{sh-type-tag-to-string}

\Syntaxlabel
\Defun {sh-type-tag-to-string} {{\funarg{type-tag}}}


\Argumentslabel
 \isatypetag{\funarg{type-tag}}
\Purposelabel
 Convert the \funarg{type-tag}\ into string form.
\Exampleslabel
 Convert the \typetag\ \lisp{+heap-type-tag+}\ to a string:
 \begin{lispcode}
(sh-type-tag-to-string +heap-type-tag+) ==> "heap"
 \end{lispcode}
\Seealsolabel
 \Fcite{sh-type-tag-of}.


\endcom

\beginfncom[Internal]{sh-unlock}

\Syntaxlabel
\Defun {sh-unlock} {{\funarg{p-heap-objid}} {\funarg{p-objid}} {\funarg{lock-mode}} {\funarg{at-index}}}


\Argumentslabel
 \isanobjid{\funarg{p-heap-objid}}
 Rest see \fcite{p-unlock}.
\Valueslabel
 See \fcite{p-unlock}.
\Purposelabel
 C interface function for \fcite{p-unlock}.
\Remarkslabel
 It is checked if \funarg{p-heap-objid}\ references a persistent
 object of \fcite{persistent-heap}. It is checked if there is
 an active transaction on \funarg{p-heap-objid}.
\Seealsolabel
 \Fcite{p-unlock};
 \fcite{sh-set-lock};
 \fcite{sh-insert-lock}.


\endcom

\beginfncom[Internal]{sh-unlock-all}

\Syntaxlabel
\Defun {sh-unlock-all} {{\funarg{p-heap-objid}} {\funarg{p-objid}}}


\Argumentslabel
 \isanobjid{\funarg{p-heap-objid}}
 Rest see \fcite{p-unlock-all}.
\Valueslabel
 See \fcite{p-unlock-all}.
\Purposelabel
 C interface function for \fcite{p-unlock-all}.
\Remarkslabel
 It is checked if \funarg{p-heap-objid}\ references a persistent
 object of \fcite{persistent-heap}. It is checked if there is
 an active transaction on \funarg{p-heap-objid}.
\Seealsolabel
 \Fcite{p-unlock-all};
 \fcite{sh-unlock};
 \fcite{sh-unlock-all-all}.


\endcom

\beginfncom[Internal]{sh-unlock-all-all}

\Syntaxlabel
\Defun {sh-unlock-all-all} {{\funarg{p-heap-objid}} {\funarg{p-objid}}}


\Argumentslabel
 See \fcite{p-unlock-all-all}.
\Valueslabel
 See \fcite{p-unlock-all-all}.
\Purposelabel
 C interface function for \fcite{p-unlock-all-all}.
\Seealsolabel
 \Fcite{p-unlock-all};
 \fcite{sh-unlock};
 \fcite{sh-unlock-all-all}.


\endcom

\beginfncom[Internal]{sh-value-size}

\Syntaxlabel
\Defun {sh-value-size} {{\funarg{p-heap-objid}} {\funarg{p-objid}}}

See \Fcite{p-value-size}.


\endcom

\beginfncom[Internal]{sh-write-bignum}

\Syntaxlabel
\Defun {sh-write-bignum} {{\funarg{p-heap-objid}} {\funarg{p-objid}} {\funarg{the-bignum}}}


\Argumentslabel
 See \fcite {(setf p-bignum)}.
\Valueslabel
 \retoldmode{\funarg{p-heap-objid}}{\funarg{p-objid}}
\Purposelabel
 C interface function for \fcite{(setf p-bignum)}.
\Remarkslabel
 It is checked if \funarg{p-heap-objid}\ references a persistent
 object of \fcite{persistent-heap}. It is checked if there is
 an active transaction on \funarg{p-heap-objid}.

 It is checked if \funarg{p-objid}\ references a persistent object
 of type \class{bignum}.

 It is checked if a write-lock is set
 on `vector'-level on \funarg{p-objid}; if no lock is
 set, a `vector'-level write lock is set on \funarg{p-objid}.
\Seealsolabel
 \Fcite{(setf p-bignum)};
 \fcite{sh-read-bignum}.


\endcom

\beginfncom[Internal]{sh-write-chars}

\Syntaxlabel
\Defun {sh-write-chars} {{\funarg{p-heap-objid}} {\funarg{p-objid}} {\funarg{from-string}} {\funarg{number-of-characters}}}


\Argumentslabel
 \isa{\funarg{from-string}}
      {a string}
 Rest see \fcite{(setf p-chars)}.
\Valueslabel
 See \fcite{(setf p-chars)}.
\Purposelabel
 C interface function for \fcite{(setf p-chars)}.
\Remarkslabel
 It is checked if \funarg{p-heap-objid}\ references a persistent
 object of \fcite{persistent-heap}. It is checked if there is
 an active transaction on \funarg{p-heap-objid}.
\Seealsolabel
 \Fcite{(setf p-chars)};
 \fcite{sh-read-chars};
 \shcite{function}{SH\us{}write\us{}words}{5}.


\endcom

\beginfncom[Internal]{sh-write-double-float}

\Syntaxlabel
\Defun {sh-write-double-float} {{\funarg{p-heap-objid}} {\funarg{p-objid}} {\funarg{the-double-float}}}


\Argumentslabel
 See \fcite{(setf p-double-float)}.
\Valueslabel
 \retoldmode{\funarg{p-heap-objid}}{\funarg{p-objid}}
\Purposelabel
 C interface function for \fcite{(setf p-double-float)}.
\Remarkslabel
 It is checked if \funarg{p-heap-objid}\ references a persistent
 object of \fcite{persistent-heap}. It is checked if there is
 an active transaction on \funarg{p-heap-objid}.

 It is checked if \funarg{p-objid}\ references a persistent object
 of type \class{double-float}.

 It is checked if a write-lock is set
 on `vector'-level on \funarg{p-objid}; if no lock is
 set, a `vector'-level write lock is set on \funarg{p-objid}.
\Seealsolabel
 \Fcite{(setf p-double-float)};
 \fcite{sh-read-double-float}.


\endcom

\beginfncom[Internal]{sh-write-fixnum}

\Syntaxlabel
\Defun {sh-write-fixnum} {{\funarg{p-heap-objid}} {\funarg{p-objid}} {\funarg{at-index}} {\funarg{expecting-class}} {\funarg{expecting-type-tag}} {\funarg{the-fixnum}}}


\Argumentslabel
 See \fcite{(setf p-fixnum)}.
\Valueslabel
 \retoldmode{\funarg{p-heap-objid}}{\funarg{p-objid}}
\Purposelabel
 C interface function for \fcite{(setf p-fixnum)}.
\Remarkslabel
 It is checked if \funarg{p-heap-objid}\ references a persistent
 object of \fcite{persistent-heap}. It is checked if there is
 an active transaction on \funarg{p-heap-objid}.
\Seealsolabel
 \Fcite{(setf p-fixnum)};
 \fcite{sh-read-fixnum}.


\endcom

\beginfncom[Internal]{sh-write-index}

\Syntaxlabel
\Defun {sh-write-index} {{\funarg{p-heap-objid}} {\funarg{p-objid}} {\funarg{at-index}} {\funarg{expecting-class}} {\funarg{expecting-type-tag}} {\funarg{immediate-value}} {\funarg{immediate-type-tag}}}


\Argumentslabel
 See \fcite{(setf p-index)}.
\Valueslabel
 See \fcite{(setf p-index)}.
\Purposelabel
 C interface function for \fcite{(setf p-index)}.
\Remarkslabel
 It is checked if \funarg{p-heap-objid}\ references a persistent
 object of \fcite{persistent-heap}. It is checked if there is
 an active transaction on \funarg{p-heap-objid}.
\Seealsolabel
 \Fcite{(setf p-index)};
 \fcite{sh-read-index}.


\endcom

\beginfncom[Internal]{sh-write-indices}

\Syntaxlabel
\Defun {sh-write-indices} {{\funarg{p-heap-objid}} {\funarg{p-objid}} {\funarg{start-index}} {\funarg{number-of-objids}} {\funarg{objids}} {\funarg{type-tags}} {\funarg{expecting-class}} {\funarg{expecting-type-tag}}}


\Purposelabel
 Write the \objid{}s of \funarg{number-of-objids}\ slots of the
 persistent object \funarg{p-objid}\ starting at slot index
 \funarg{start-index}\ from \funarg{objids}\ and the
 corresponding \typetag{}s\ from \funarg{type-tags}.
\Remarkslabel
 It is checked if \funarg{p-heap-objid}\ references a persistent
 object of \fcite{persistent-heap}. It is checked if there is
 an active transaction on \funarg{p-heap-objid}.


\endcom

\beginfncom[Internal]{sh-write-instance-data}

\Syntaxlabel
\Defun {sh-write-instance-data} {{\funarg{p-heap-objid}} {\funarg{p-objid-instance}} {\funarg{p-objid-data}}}

Write \funarg{p-objid-data}\ to the instance data slot of
 \funarg{p-objid-instance}.


\endcom

\beginfncom[Internal]{sh-write-instance-wrapper}

\Syntaxlabel
\Defun {sh-write-instance-wrapper} {{\funarg{p-heap-objid}} {\funarg{p-objid-instance}} {\funarg{p-objid-wrapper}}}

Write \funarg{p-objid-wrapper}\ to the class wrapper slot of
 \funarg{p-objid-instance}.


\endcom

\beginfncom[Internal]{sh-write-objid}

\Syntaxlabel
\Defun {sh-write-objid} {{\funarg{p-heap-objid}} {\funarg{p-objid}} {\funarg{at-index}} {\funarg{expecting-class}} {\funarg{expecting-type-tag}} {\funarg{the-p-objid}}}


\Argumentslabel
 See \fcite{(setf p-objid)}.
\Valueslabel
 See \fcite{(setf p-objid)}.
\Purposelabel
 C interface function for \fcite{(setf p-objid)}.
\Remarkslabel
 It is checked if \funarg{p-heap-objid}\ references a persistent
 object of \fcite{persistent-heap}. It is checked if there is
 an active transaction on \funarg{p-heap-objid}.
\Seealsolabel
 \Fcite{(setf p-objid)};
 \fcite{sh-read-objid}.


\endcom

\beginfncom[Internal]{sh-write-root}

\Syntaxlabel
\Defun {sh-write-root} {{\funarg{p-heap-objid}} {\funarg{p-objid}}}


\Purposelabel
 Low-level set of the \plob\ root object to \funarg{p-objid}.
\Remarkslabel
 {\sl A note of caution:}
 Calling this function with inappropiate arguments will make
 the root object which \plob\ expects inaccessible and makes
 therefore also the persistent objects contained in the persistent
 heap inaccessible.
\Seealsolabel
 \Fcite{sh-read-root}.


\endcom

\beginfncom[Internal]{sh-write-single-float}

\Syntaxlabel
\Defun {sh-write-single-float} {{\funarg{p-heap-objid}} {\funarg{p-objid}} {\funarg{the-single-float}}}


\Argumentslabel
 See \fcite{(setf p-single-float)}.
\Valueslabel
 \retoldmode{\funarg{p-heap-objid}}{\funarg{p-objid}}
\Purposelabel
 C interface function for \fcite{(setf p-single-float)}.
\Remarkslabel
 It is checked if \funarg{p-heap-objid}\ references a persistent
 object of \fcite{persistent-heap}. It is checked if there is
 an active transaction on \funarg{p-heap-objid}.

 It is checked if \funarg{p-objid}\ references a persistent object
 of type \class{single-float}.

 It is checked if a write-lock is set
 on `vector'-level on \funarg{p-objid}; if no lock is
 set, a `vector'-level write lock is set on \funarg{p-objid}.
\Seealsolabel
 \Fcite{(setf p-single-float)};
 \fcite{sh-read-single-float}.


\endcom

\beginfncom[Internal]{sh-write-values}

\Syntaxlabel
\Defun {sh-write-values} {{\funarg{p-heap-objid}} {\funarg{p-objid}} {\funarg{expecting-class}} {\funarg{expecting-type-tag}} {\funarg{element-type-tag}} {\funarg{from-t-simple-vector}} {\funarg{number-of-elements}}}


\Argumentslabel
 \isa{\funarg{from-t-simple-vector}}
      {a simple vector}
 Rest see \fcite{(setf p-values)}.
\Valueslabel
 See \fcite{(setf p-values)}.
\Purposelabel
 C interface function for \fcite{(setf p-values)}.
\Remarkslabel
 It is checked if \funarg{p-heap-objid}\ references a persistent
 object of \fcite{persistent-heap}. It is checked if there is
 an active transaction on \funarg{p-heap-objid}.

 This function uses the \lw\ specific feature that the C code with
 a foreign-function argument of type simple-vector receives
 a pointer to the simple vector's data area.
\Seealsolabel
 \Fcite{(setf p-values)};
 \fcite{sh-read-values};
 \shcite{function}{SH\us{}write\us{}words}{5}.


\endcom

\beginfncom[Internal]{signal-obsolete-instance-error}

\Syntaxlabel
\Defun {signal-obsolete-instance-error} {{\funarg{class}}}


\Argumentslabel
 \isacls{\funarg{class}}
\Purposelabel
 Signal an obsolete instance error; called always from
 \fcite{obsolete-instance-trap-internal (persistent-metaclass t t)}.
\Seealsolabel
 \Fcite{obsolete-instance-trap-internal (persistent-metaclass t t)}.


\endcom

\begincncom[Internal]{+simple-vector-header-size+}

\Valuelabel
\begin{CompactCode}
(or 0)
\end{CompactCode}

\Purposelabel
The header size of a simple-vector.


\endcom

\message{^^JGeneric function slot-definition-location has no methods.^^J}
\message{^^JGeneric function slot-definition-readers has no methods.^^J}
\message{^^JGeneric function slot-definition-writers has no methods.^^J}
\beginvrcom[Internal]{*slot-description*}

\Initialvaluelabel
\begin{CompactCode}
nil
\end{CompactCode}

\Purposelabel
 Contains a persistent object of
 \fcite{class-description}\ describing the
 \fcite{slot-description}.
\Seealsolabel
 \Fcite{*slot-description-objid*}.


\endcom

\begingfcom[Internal]{slot-description-deferred}

\Syntaxlabel
\Defgen {slot-description-deferred} {{\funarg{slot-description}}}


\Argumentslabel
 \isa{\funarg{slot-description}}
      {a structure-slot-description or a slot-description}
\Purposelabel
 Returns the deferred option of \funarg{slot-description}.
\Seealsolabel
 Slot {\bf p-deferred} of \fcite{structure-slot-description}\ resp.\ %
 \fcite{slot-description}.


\Methodslabel

\flabel{\protect\mtd}{slot-description-deferred (structure-slot-description)}{}
{\Defmeth {slot-description-deferred} {(\funarg{slot-description}\ \ObjectWithRef{structure-slot-description})}}
Calls to this method are trapped to the system-generated
 structure reader function
 {\bf structure-slot-description-p-deferred}; see also
 \fcite{structure-slot-description}.


\endcom

\begingfcom[Internal]{(setf slot-description-deferred)}

\Syntaxlabel
\Defgen {(setf slot-description-deferred)} {{\funarg{deferred}} {\funarg{slot-description}}}


\Argumentslabel
 \isa{\funarg{deferred}}
      {either \lispnil\ or a number}
 \isa{\funarg{slot-description}}
      {a structure-slot-description or a slot-description}
\Purposelabel
 Set the deferred option of
 \funarg{slot-description}\ to
 \funarg{deferred}.
\Seealsolabel
 Slot {\bf p-deferred} of \fcite{structure-slot-description}\ resp.\ %
 \fcite{slot-description}.


\Methodslabel

\flabel{\protect\mtd}{(setf slot-description-deferred) (t structure-slot-description)}{}
{\Defmeth {(setf slot-description-deferred)} {{\funarg{deferred}} (\funarg{slot-description}\ \ObjectWithRef{structure-slot-description})}}
Calls to this method are trapped to the system-generated
 structure writer function
 {\bf (setf structure-slot-description-p-deferred)}; see also
 \fcite{structure-slot-description}.


\endcom

\begingfcom[Internal]{slot-description-equal-p}

\Syntaxlabel
\Defgen {slot-description-equal-p} {{\funarg{t-slot-descr}} {\funarg{p-slot-descr}} {\opt} {\funarg{verbose}}}


\Argumentslabel
 \isa{\funarg{t-slot-descr}\ resp.\ \funarg{p-slot-descr}}
      {a slot description}
\Purposelabel
 Check if the (transient) slot description \funarg{t-slot-descr}\ and
 the (persistent) slot description \funarg{p-slot-descr}\ are
 \lisp{equal}.
\Seealsolabel
 \Fcite{structure-slot-description};
 \fcite{slot-description}.


\Methodslabel

\flabel{\protect\mtd}{slot-description-equal-p (direct-slot-description direct-slot-description)}{}
{\Defmeth {slot-description-equal-p} {(\funarg{t-slot-descr}\ \ObjectWithRef{direct-slot-description}) (\funarg{p-slot-descr}\ \ObjectWithRef{direct-slot-description}) {\opt} {\funarg{verbose}}}}
%
% No behavior is specified for this method beyond that which is specified
% for the generic function.

\flabel{\protect\mtd}{slot-description-equal-p (effective-slot-description effective-slot-description)}{}
{\Defmeth {slot-description-equal-p} {(\funarg{t-slot-descr}\ \ObjectWithRef{effective-slot-description}) (\funarg{p-slot-descr}\ \ObjectWithRef{effective-slot-description}) {\opt} {\funarg{verbose}}}}
%
% No behavior is specified for this method beyond that which is specified
% for the generic function.

\flabel{\protect\mtd}{slot-description-equal-p (structure-slot-description structure-slot-description)}{}
{\Defmeth {slot-description-equal-p} {(\funarg{t-slot-descr}\ \ObjectWithRef{structure-slot-description}) (\funarg{p-slot-descr}\ \ObjectWithRef{structure-slot-description}) {\opt} {\funarg{verbose}}}}
%
% No behavior is specified for this method beyond that which is specified
% for the generic function.

\flabel{\protect\mtd}{slot-description-equal-p (t t)}{}
{\Defmeth {slot-description-equal-p} {{\funarg{t-slot-descr}} {\funarg{p-slot-descr}} {\opt} {\funarg{verbose}}}}
%
% No behavior is specified for this method beyond that which is specified
% for the generic function.


\endcom

\beginfncom[Internal]{slot-description-equal-p-1}

\Syntaxlabel
\Defun {slot-description-equal-p-1} {{\funarg{t-slot-descr}} {\funarg{p-slot-descr}} {\funarg{next-method}} {\opt} {\funarg{verbose}}}


\Argumentslabel
 \isa{\funarg{t-slot-descr}\ resp.\ \funarg{p-slot-descr}}
      {a slot description}
 \isa{\funarg{next-method}}
      {a function taking no arguments}
\Valueslabel
 See \fcite{slot-description-equal-p}.
\Purposelabel
 A workhorse for different methods of \fcite{slot-description-equal-p}.
\Seealsolabel
 \Fcite{slot-description-equal-p}.


\endcom

\message{^^JGeneric function slot-description-location has no methods.^^J}
\message{^^JGeneric function (setf slot-description-location) has no methods.^^J}
\beginvrcom[Internal]{*slot-description-objid*}

\Initialvaluelabel
\begin{CompactCode}
nil
\end{CompactCode}

\Purposelabel
 Contains the \objid\ of the value of the variable
 {\bf *slot-description*}.
\Seealsolabel
 \Fcite{*slot-description*}.


\endcom

\message{^^JGeneric function plob::slot-description-readers has no methods.^^J}
\message{^^JGeneric function (setf plob::slot-description-readers) has no methods.^^J}
\message{^^JGeneric function plob::slot-description-writers has no methods.^^J}
\message{^^JGeneric function (setf plob::slot-description-writers) has no methods.^^J}
\beginfncom[Internal]{slot-initarg}

\Syntaxlabel
\Defun {slot-initarg} {{\funarg{the-slot}} {\funarg{the-class}}}


\Argumentslabel
 \isa{\funarg{the-slot}}
      {a symbol naming a slot of \funarg{the-class}}
 \isacls{\funarg{the-class}}
\Purposelabel
 The value of the initialization argument of the slot named
 \funarg{the-slots}\ in \funarg{the-class}\ is returned.
\Seealsolabel
 \Fcite{(setf slot-initarg)}.


\endcom

\beginfncom[Internal]{(setf slot-initarg)}

\Syntaxlabel
\Defun {(setf slot-initarg)} {{\funarg{initarg}} {\funarg{the-slot}} {\funarg{the-class}}}


\Argumentslabel
 \isa{\funarg{initarg}}
      {a keyword symbol}
 \isa{\funarg{the-slot}}
      {a symbol naming a slot of \funarg{the-class}}
 \isacls{\funarg{the-class}}
\Valueslabel
 \retarg{\funarg{initarg}}
\Purposelabel
 Sets the initialization argument of the slot described by
 \funarg{the-slot}\ of \funarg{the-class}\ to
 \funarg{initarg}. The initialization argument is used when the
 transient representation of a persistent object is created by
 \plob\ when loading a persistent object;
 it is used as a keyword to initialize the transient slots at
 object creation time similar to the \lisp{:initarg}\ slot option
 used in the \lisp{defclass}-statement of \clos.
\Exampleslabel
 This call changes the slot initialization argument of the slot named
 \lisp{system::kind}\ of class \class{hash-table}\ from its default
 value of \lisp{:kind}\ (i.e.\ the slot name interned into the
 \lisp{:keyword}\ package) to \lisp{:test}:
 \begin{lispcode}
(setf (slot-initarg 'system::kind (find-class 'hash-table)) :test)
 \end{lispcode}
\Seealsolabel
 \Fcite{slot-initarg}.


\endcom

\beginclcom[Internal Structure]{slot-load-on-demand}

\Purposelabel
 A transient structure for slots to be loaded on demand.
 A transient structure slot to be loaded on demand is filled
 with an instance of this class and the transient structure slot
 accessor function is modified to `remember' these instances;
 when a structure accessor function is called, the
 {\bf slot-load-on-demand}\ instance loads the object from the
 stable heap.
\Remarkslabel
 This structure is only for \plob\ internal use.
\Seealsolabel
 \Fcite{load-structure-slot}.


\Directsuperclasseslabel
\Defmethod{}{\tt}{\ObjectWithRef{persistent-immediate-object}}{}


\Classoptionslabel
\Defmethod{}{\tt}{:constructor make-slot-load-on-demand (objid \&optional (type-tag +short-objid-tag+))}{}


\endcom

\begincncom[Internal]{+slot-load-on-demand-class+}

\Valuelabel
\begin{CompactCode}
(find-class 'slot-load-on-demand)
\end{CompactCode}

\Purposelabel
The \clsmo\ of \fcite{slot-load-on-demand}.


\endcom

\begingfcom[Internal]{slot-location}

\Syntaxlabel
\Defgen {slot-location} {{\funarg{the-slot}} {\funarg{the-class}}}


\Argumentslabel
 \isa{\funarg{the-slot}}
      {either a symbol naming a slot of \funarg{the-class}\ or a \sltmo}
 \isacls{\funarg{the-class}}
\Purposelabel
 Return the location of the slot described by
 \funarg{the-slot}\ of \funarg{the-class}.
\Seealsolabel
 \Fcite{(setf slot-location)}.


\Methodslabel

\flabel{\protect\mtd}{slot-location (persistent-direct-slot-definition t)}{}
{\Defmeth {slot-location} {(\funarg{slot-definition}\ \ObjectWithRef{persistent-direct-slot-definition}) {\funarg{the-class}}}}

 Returns the location stored in slot {\bf t-location} of
 \funarg{slot-definition}.

\flabel{\protect\mtd}{slot-location (persistent-effective-slot-definition t)}{}
{\Defmeth {slot-location} {(\funarg{slot-definition}\ \ObjectWithRef{persistent-effective-slot-definition}) {\funarg{the-class}}}}
%
% No behavior is specified for this method beyond that which is specified
% for the generic function.

\flabel{\protect\mtd}{slot-location (symbol structure-class)}{}
{\Defmeth {slot-location} {(\funarg{the-slot}\ \ObjectWithRef{symbol}) (\funarg{the-class}\ \ObjectWithRef{structure-class})}}
%
% No behavior is specified for this method beyond that which is specified
% for the generic function.

\flabel{\protect\mtd}{slot-location (t structure-class)}{}
{\Defmeth {slot-location} {{\funarg{the-slot}} (\funarg{the-class}\ \ObjectWithRef{structure-class})}}
%
% No behavior is specified for this method beyond that which is specified
% for the generic function.


\endcom

\begingfcom[Internal]{(setf slot-location)}

\Syntaxlabel
\Defgen {(setf slot-location)} {{\funarg{location}} {\funarg{the-slot}} {\funarg{the-class}}}


\Argumentslabel
 \isa{\funarg{location}}
      {either \lispnil\ or a number}
 \isa{\funarg{the-slot}}
      {either a symbol naming a slot of \funarg{the-class}\ or a \sltmo}
 \isacls{\funarg{the-class}}
\Valueslabel
 \retarg{\funarg{location}}
\Purposelabel
 Sets the location of the slot described by
 \funarg{the-slot}\ of \funarg{the-class}\ to
 \funarg{location}. This is the location used in the low-level
 functions for storing the slot's state.
\Seealsolabel
 \Fcite{slot-location}.


\Methodslabel

\flabel{\protect\mtd}{(setf slot-location) (t persistent-direct-slot-definition t)}{}
{\Defmeth {(setf slot-location)} {{\funarg{location}} (\funarg{slot-definition}\ \ObjectWithRef{persistent-direct-slot-definition}) {\funarg{the-class}}}}

 Stores the \funarg{location}\ in slot {\bf t-location} of
 \funarg{slot-definition}.

\flabel{\protect\mtd}{(setf slot-location) (t persistent-effective-slot-definition t)}{}
{\Defmeth {(setf slot-location)} {{\funarg{location}} (\funarg{slot-definition}\ \ObjectWithRef{persistent-effective-slot-definition}) {\funarg{the-class}}}}
%
% No behavior is specified for this method beyond that which is specified
% for the generic function.

\flabel{\protect\mtd}{(setf slot-location) (t symbol t)}{}
{\Defmeth {(setf slot-location)} {{\funarg{location}} (\funarg{the-slot}\ \ObjectWithRef{symbol}) {\funarg{the-class}}}}
%
% No behavior is specified for this method beyond that which is specified
% for the generic function.

\flabel{\protect\mtd}{(setf slot-location) (t t t)}{}
{\Defmeth {(setf slot-location)} {{\funarg{location}} {\funarg{the-slot}} {\funarg{the-class}}}}
%
% No behavior is specified for this method beyond that which is specified
% for the generic function.

\flabel{\protect\mtd}{(setf slot-location) :after (t t t)}{}
{\Defmetha {(setf slot-location)} {{\funarg{location}} {\funarg{the-slot}} {\funarg{the-class}}}}
%
% No behavior is specified for this method beyond that which is specified
% for the generic function.


\endcom

\beginfncom[Internal]{slot-option}

\Syntaxlabel
\Defun {slot-option} {{\funarg{table}} {\funarg{the-slot}} {\funarg{the-class}}}


\Argumentslabel
 \isa{\funarg{table}}
      {a hash-table}
 \isa{\funarg{the-slot}}
      {a symbol naming a slot of \funarg{the-class}}
 \isacls{\funarg{the-class}}
\Purposelabel
 Get the slot-option's value of the slot named \funarg{the-slot}\ of
 class \funarg{the-class}\ from \funarg{table}.
 The \funarg{table}\ argument is a hash
 table allocated for each extra slot option.
\Seealsolabel
 \Fcite{(setf slot-option)}.


\endcom

\beginfncom[Internal]{(setf slot-option)}

\Syntaxlabel
\Defun {(setf slot-option)} {{\funarg{option}} {\funarg{table}} {\funarg{the-slot}} {\funarg{the-class}}}


\Argumentslabel
 \isanobject{\funarg{option}}
 \isa{\funarg{table}}
      {a hash-table}
 \isa{\funarg{the-slot}}
      {a symbol naming a slot of \funarg{the-class}}
 \isacls{\funarg{the-class}}
\Purposelabel
 Store the slot-option's value \funarg{option}\ of the slot named
 \funarg{the-slot}\ of class \funarg{the-class}\ to
 \funarg{table}. The \funarg{table}\ argument is a hash
 table allocated for each extra slot option.
\Seealsolabel
 \Fcite{slot-option}.


\endcom

\beginfncom[Internal]{slot-write-through-extent-p}

\Syntaxlabel
\Defun {slot-write-through-extent-p} {{\funarg{slot-extent}}}


 Check if \funarg{slot-extent}\ names a slot extent which is handled
 as write-through.


\endcom

\beginfncom[Internal]{split-url}

\Syntaxlabel
\Defun {split-url} {{\funarg{url}}}


\Purposelabel
  Split an URL into its components transport, host and directory.
\Valueslabel
  Three values are returned:
  \begin{enumerate}
  \item The transport protocol specified in \funarg{url}.
  \item The host name specified in \funarg{url}.
  \item The directory name specified in \funarg{url}.
  \end{enumerate}
  If any of these fields is missing in \funarg{url}, \lispnil\ is
  returned.
\Seealsolabel
  \Fcite{url}.


\endcom

\begincncom[Internal]{+standard-accessor-method-class+}

\Valuelabel
\begin{CompactCode}
(find-class 'standard-accessor-method)
\end{CompactCode}

\Purposelabel
The \clsmo\ of class \class{standard-accessor-method}.


\endcom

\begincncom[Internal]{+standard-class-class+}

\Valuelabel
\begin{CompactCode}
(find-class 'standard-class)
\end{CompactCode}

\Purposelabel
The \clsmo\ of class \class{standard-class}.


\endcom

\begincncom[Internal]{+standard-direct-slot-definition-class+}

\Valuelabel
\begin{CompactCode}
(find-class 'standard-direct-slot-definition)
\end{CompactCode}

\Purposelabel
The \clsmo\ of class \class{standard-direct-slot-definition}.


\endcom

\begincncom[Internal]{+standard-effective-slot-definition-class+}

\Valuelabel
\begin{CompactCode}
(find-class 'standard-effective-slot-definition)
\end{CompactCode}

\Purposelabel
The \clsmo\ of class \class{standard-effective-slot-definition}.


\endcom

\beginfncom[Internal]{standard-metaclass-p}

\Syntaxlabel
\Defun {standard-metaclass-p} {{\funarg{the-class}}}

Check if \funarg{the-class}\ is a standard metaobject class
 as defined in \cite{bib:AMOP}.


\endcom

\begincncom[Internal]{+standard-metaobject-classes+}

\Valuelabel
\begin{CompactCode}
(mapcar #'find-class
        '(t
          standard-object
          metaobject
          class
          built-in-class
          standard-class
          slot-definition
          standard-slot-definition
          standard-direct-slot-definition
          standard-effective-slot-definition
          method
          standard-method
          standard-accessor-method
          standard-reader-method
          standard-writer-method
          method-combination))
\end{CompactCode}

\Purposelabel
A list containing all standard CLOS metaobject classes.


\endcom

\begincncom[Internal]{+standard-object-class+}

\Valuelabel
\begin{CompactCode}
(find-class 'standard-object)
\end{CompactCode}

\Purposelabel
The \clsmo\ of class \class{standard-object}.


\endcom

\begincncom[Internal]{+standard-reader-method-class+}

\Valuelabel
\begin{CompactCode}
(find-class 'standard-reader-method)
\end{CompactCode}

\Purposelabel
The \clsmo\ of class \class{standard-reader-method}.


\endcom

\begincncom[Internal]{+standard-writer-method-class+}

\Valuelabel
\begin{CompactCode}
(find-class 'standard-writer-method)
\end{CompactCode}

\Purposelabel
The \clsmo\ of class \class{standard-writer-method}.


\endcom

\beginfncom[Internal]{store-array}

\Syntaxlabel
\Defun {store-array} {{\funarg{t-array}} {\funarg{p-objid}} {\funarg{depth}} {\funarg{p-heap}}}


\Argumentslabel
 \isa{\funarg{t-array}}
      {an array}
 \isanobjid{\funarg{p-objid}}
\Valueslabel
 \retarg{\funarg{t-array}}
\Purposelabel
 Store the transient array in \funarg{t-array}\ to the
 persistent array referenced by \funarg{p-objid}.
\Seealsolabel
 \Fcite{p-array}.


\endcom

\beginfncom[Internal]{store-bit-vector}

\Syntaxlabel
\Defun {store-bit-vector} {{\funarg{t-bit-vector}} {\funarg{p-objid}} {\funarg{depth}} {\funarg{p-heap}}}


\Argumentslabel
 \isa{\funarg{t-bit-vector}}
      {a bit vector}
 \isanobjid{\funarg{p-objid}}
\Valueslabel
 \retarg{\funarg{t-bit-vector}}
\Purposelabel
 Store the transient bit vector in \funarg{t-bit-vector}\ to the
 persistent bit vector referenced by \funarg{p-objid}.
\Seealsolabel
 \Fcite{p-bit-vector}.


\endcom

\beginfncom[Internal]{store-class-description}

\Syntaxlabel
\Defun {store-class-description} {{\funarg{t-descr}} {\funarg{p-objid}} {\funarg{depth}} {\funarg{p-heap}}}


\Argumentslabel
 \isa{\funarg{t-descr}}
      {a class-description}
 \isanobjid{\funarg{p-objid}}
\Valueslabel
 \retarg{\funarg{t-descr}}
\Purposelabel
 Store the transient class-description in
 \funarg{t-descr}\ to the
 persistent class-description referenced by \funarg{p-objid}.
\Seealsolabel
 \Fcite{p-class-description}.


\endcom

\beginfncom[Internal]{store-complex}

\Syntaxlabel
\Defun {store-complex} {{\funarg{t-complex}} {\funarg{p-objid}} {\funarg{p-heap}}}


\Argumentslabel
 \isa{\funarg{t-complex}}
      {a complex number}
 \isanobjid{\funarg{p-objid}}
\Valueslabel
 \retarg{\funarg{t-complex}}
\Purposelabel
 Store the transient complex number in \funarg{t-complex}\ to the
 persistent complex number referenced by \funarg{p-objid}.
\Seealsolabel
 \Fcite{p-complex}.


\endcom

\beginfncom[Internal]{store-direct-slot-description}

\Syntaxlabel
\Defun {store-direct-slot-description} {{\funarg{t-descr}} {\funarg{p-objid}} {\funarg{depth}} {\funarg{p-heap}}}


\Argumentslabel
 \isa{\funarg{t-descr}}
      {a direct-slot-description}
 \isanobjid{\funarg{p-objid}}
\Valueslabel
 \retarg{\funarg{t-descr}}
\Purposelabel
 Store the transient direct-slot-description in
 \funarg{t-descr}\ to the
 persistent direct-slot-description referenced by \funarg{p-objid}.
\Seealsolabel
 \Fcite{p-direct-slot-description};
 \fcite{p-effective-slot-description}.


\endcom

\beginfncom[Internal]{store-effective-slot-description}

\Syntaxlabel
\Defun {store-effective-slot-description} {{\funarg{t-descr}} {\funarg{p-objid}} {\funarg{depth}} {\funarg{p-heap}}}


\Argumentslabel
 \isa{\funarg{t-descr}}
      {an effective-slot-description}
 \isanobjid{\funarg{p-objid}}
\Valueslabel
 \retarg{\funarg{t-descr}}
\Purposelabel
 Store the transient effective-slot-description in
 \funarg{t-descr}\ to the
 persistent effective-slot-description referenced by \funarg{p-objid}.
\Seealsolabel
 \Fcite{p-direct-slot-description};
 \fcite{p-effective-slot-description}.


\endcom

\beginfncom[Internal]{store-function}

\Syntaxlabel
\Defun {store-function} {{\funarg{t-function}} {\funarg{p-objid}} {\funarg{depth}} {\funarg{p-heap}}}


\Argumentslabel
 \isa{\funarg{t-function}}
      {a function}
 \isanobjid{\funarg{p-objid}}
\Valueslabel
 \retarg{\funarg{t-function}}
\Purposelabel
 Store the transient function in \funarg{t-function}\ to the
 persistent function referenced by \funarg{p-objid}.
\Remarkslabel
 \plob\ cannot store code because of relocation and binder
 problems which would occure when the code is subject to be
 loaded again; instead, a function is stored by its name.
 At function load time \plob\ tries to find an \lisp{equal}\ named
 function in the \cl\ image.
\Seealsolabel
 \Fcite{p-function};
 \fcite{get-function-name}.


\endcom

\beginfncom[Internal]{store-hash-table}

\Syntaxlabel
\Defun {store-hash-table} {{\funarg{t-hash-table}} {\funarg{p-objid}} {\funarg{depth}} {\funarg{p-heap}}}


\Argumentslabel
 \isanobject{\funarg{t-hash-table}}
 \isanobjid{\funarg{p-objid}}
\Valueslabel
 \retarg{\funarg{t-hash-table}}
\Purposelabel
 Store the transient hash table \funarg{t-hash-table}\ to
 \funarg{p-objid}.
\Seealsolabel
 \stcite{435--441}.


\endcom

\beginfncom[Internal]{store-instance}

\Syntaxlabel
\Defun {store-instance} {{\funarg{t-instance}} {\funarg{p-objid}} {\funarg{depth}} {\funarg{p-heap}}}


\Argumentslabel
 \isaclosobject{\funarg{t-instance}}
 \isanobjid{\funarg{p-objid}}
\Valueslabel
 \retarg{\funarg{t-instance}}
\Purposelabel
 Store the transient \clos\ instance in \funarg{t-instance}\ to
 the persistent \clos\ instance referenced by \funarg{p-objid}.

 Only the slots with \lisp{:extent :cached}\ are stored here;
 the slots with other extents are stored by calls to the
 \fcite{(setf slot-value-using-class) (t standard-class t effective-slot-description)}.
\Seealsolabel
 \Fcite{p-instance}.


\endcom

\beginfncom[Internal]{store-ivector}

\Syntaxlabel
\Defun {store-ivector} {{\funarg{t-ivector}} {\funarg{p-objid}} {\funarg{depth}} {\funarg{p-heap}}}


\Argumentslabel
 \isa{\funarg{t-ivector}}
      {an immediate vector}
 \isanobjid{\funarg{p-objid}}
\Valueslabel
 \retarg{\funarg{t-vector}}
\Purposelabel
 Store the transient immmediate vector in \funarg{t-ivector}\ to the
 persistent immediate vector referenced by \funarg{p-objid}.
\Seealsolabel
 \Fcite{p-ivector}.


\endcom

\beginfncom[Internal]{store-list}

\Syntaxlabel
\Defun {store-list} {{\funarg{t-list}} {\funarg{p-objid}} {\funarg{depth}} {\funarg{p-heap}}}


\Argumentslabel
 \isanobject{\funarg{t-list}}
 \isanobjid{\funarg{p-objid}}
\Valueslabel
 \retarg{\funarg{t-list}}
\Purposelabel
 Make \lisp{(car \funarg{t-list})}\ the car and
 \lisp{(cdr \funarg{t-list})}\ the cdr of
 the persistent cons cell referenced by \funarg{p-objid}.
\Seealsolabel
 \Fcite{p-list}.


\endcom

\beginfncom[Internal]{store-method-description}

\Syntaxlabel
\Defun {store-method-description} {{\funarg{t-descr}} {\funarg{p-objid}} {\funarg{depth}} {\funarg{p-heap}}}


\Argumentslabel
 \isa{\funarg{t-descr}}
      {a method-description}
 \isanobjid{\funarg{p-objid}}
\Valueslabel
 \retarg{\funarg{t-descr}}
\Purposelabel
 Store the transient method-description in
 \funarg{t-descr}\ to the
 persistent method-description referenced by \funarg{p-objid}.
\Seealsolabel
 \Fcite{p-method-description}.


\endcom

\beginfncom[Internal]{store-package}

\Syntaxlabel
\Defun {store-package} {{\funarg{t-package}} {\funarg{p-objid}} {\funarg{depth}} {\funarg{p-heap}}}


\Argumentslabel
 \isa{\funarg{t-package}}
      {a transient package}
 \isanobjid{\funarg{p-objid}}
\Valueslabel
 \retarg{\funarg{t-package}}
\Purposelabel
 Store the transient package in
 \funarg{t-package}\ to the
 persistent-package referenced by \funarg{p-objid}.
\Remarkslabel
 Only the package name is copied from \funarg{t-package}\ into
 the persistent-package; the symbol tables etc.\ are not copied.
\Seealsolabel
 \Fcite{p-package};
 \fcite{persistent-package}.


\endcom

\beginfncom[Internal]{store-ratio}

\Syntaxlabel
\Defun {store-ratio} {{\funarg{t-ratio}} {\funarg{p-objid}} {\funarg{p-heap}}}


\Argumentslabel
 \isa{\funarg{t-ratio}}
      {a ratio number}
 \isanobjid{\funarg{p-objid}}
\Valueslabel
 \retarg{\funarg{t-ratio}}
\Purposelabel
 Store the transient ratio number in \funarg{t-ratio}\ to the
 persistent ratio number referenced by \funarg{p-objid}.
\Seealsolabel
 \Fcite{p-ratio}.


\endcom

\beginfncom[Internal]{store-slot-unbound-using-class}

\Syntaxlabel
\Defun {store-slot-unbound-using-class} {{\funarg{the-class}} {\funarg{the-object}} {\funarg{slot-description}} {\funarg{call-next-method}} {\opt} {\funarg{p-heap}}}


\Purposelabel
  Workhorse for \textbf{slot-makunbound-using-class}.



\endcom

\beginfncom[Internal]{store-slot-value-using-class}

\Syntaxlabel
\Defun {store-slot-value-using-class} {{\funarg{new-value}} {\funarg{the-class}} {\funarg{the-object}} {\funarg{slot-description}} {\funarg{call-next-method}} {\opt} {\funarg{depth}} {\funarg{p-heap}}}


\Purposelabel
  Workhorse for \textbf{slot-value-using-class}.



\endcom

\beginfncom[Internal]{store-string}

\Syntaxlabel
\Defun {store-string} {{\funarg{t-string}} {\funarg{p-objid}} {\funarg{p-heap}}}


\Argumentslabel
 \isa{\funarg{t-string}}
      {a string}
 \isanobjid{\funarg{p-objid}}
\Valueslabel
 \retarg{\funarg{t-string}}
\Purposelabel
 Store the transient string in \funarg{t-string}\ to the
 persistent string referenced by \funarg{p-objid}.
\Seealsolabel
 \Fcite{p-string}.


\endcom

\beginfncom[Internal]{store-structure}

\Syntaxlabel
\Defun {store-structure} {{\funarg{t-structure}} {\funarg{p-objid}} {\funarg{depth}} {\funarg{p-heap}}}


\Argumentslabel
 \isa{\funarg{t-structure}}
      {a structure object}
 \isanobjid{\funarg{p-objid}}
\Valueslabel
 \retarg{\funarg{t-structure}}
\Purposelabel
 Store the transient structure object in \funarg{t-structure}\ to
 the persistent structure object referenced by \funarg{p-objid}.
\Seealsolabel
 \Fcite{p-structure}.


\endcom

\beginfncom[Internal]{store-structure-description}

\Syntaxlabel
\Defun {store-structure-description} {{\funarg{t-descr}} {\funarg{p-objid}} {\funarg{depth}} {\funarg{p-heap}}}


\Argumentslabel
 \isa{\funarg{t-descr}}
      {a structure-description}
 \isanobjid{\funarg{p-objid}}
\Valueslabel
 \retarg{\funarg{t-descr}}
\Purposelabel
 Store the transient structure-description in
 \funarg{t-descr}\ to the
 persistent structure-description referenced by \funarg{p-objid}.
\Seealsolabel
 \Fcite{p-structure-description}.


\endcom

\beginfncom[Internal]{store-structure-in-transaction}

\Syntaxlabel
\Defun {store-structure-in-transaction} {{\funarg{t-structure}} {\funarg{p-objid}} {\funarg{p-struct-descr}} {\funarg{depth}} {\funarg{p-heap}}}

Store \funarg{t-structure}\ to the Stable Heap.


\endcom

\beginfncom[Internal]{store-structure-slot-description}

\Syntaxlabel
\Defun {store-structure-slot-description} {{\funarg{t-descr}} {\funarg{p-objid}} {\funarg{depth}} {\funarg{p-heap}}}


\Argumentslabel
 \isa{\funarg{t-descr}}
      {a structure-slot-description}
 \isanobjid{\funarg{p-objid}}
\Valueslabel
 \retarg{\funarg{t-descr}}
\Purposelabel
 Store the transient structure-slot-description in
 \funarg{t-descr}\ to the
 persistent structure-slot-description referenced by \funarg{p-objid}.
\Seealsolabel
 \Fcite{p-structure-slot-description}.


\endcom

\beginfncom[Internal]{store-symbol}

\Syntaxlabel
\Defun {store-symbol} {{\funarg{t-symbol}} {\funarg{p-objid}} {\funarg{depth}} {\funarg{p-heap}}}


\Argumentslabel
 \isa{\funarg{t-symbol}}
      {a symbol}
 \isanobjid{\funarg{p-objid}}
\Valueslabel
 \retarg{\funarg{t-symbol}}
\Purposelabel
 Store the transient symbol in \funarg{t-symbol}\ to the
 persistent symbol referenced by \funarg{p-objid}.
\Seealsolabel
 \Fcite{p-symbol}.


\endcom

\beginfncom[Internal]{store-vector}

\Syntaxlabel
\Defun {store-vector} {{\funarg{t-vector}} {\funarg{p-objid}} {\funarg{depth}} {\funarg{p-heap}}}


\Argumentslabel
 \isa{\funarg{t-vector}}
      {a vector}
 \isanobjid{\funarg{p-objid}}
\Valueslabel
 \retarg{\funarg{t-vector}}
\Purposelabel
 Store the transient vector in \funarg{t-vector}\ to the
 persistent vector referenced by \funarg{p-objid}.
\Seealsolabel
 \Fcite{p-vector}.


\endcom

\begincncom[Internal]{+string-buffer-size+}

\Valuelabel
\begin{CompactCode}
256
\end{CompactCode}

\Purposelabel
 Size of the string buffers used for returning strings from
 the \plob\ low-level functions.


\endcom

\begindccom[Structure Information Functions]{structure ...}

 Similar to arrays (see section \fcite{array ...}) there are {\sl no}
 well-defined information functions at all about types resp.\ classes
 created by \lisp{defstruct}\ statements; so I well-define the information
 functions about \lisp{defstruct}\/s I found in \lw\ as
 well-defined information functions, in particular these are the functions
 {\bf class-constructor}, {\bf (setf class-constructor)},
 method {\bf class-slots (structure-class)}, the functions
 {\bf structure-slot-reader},
 {\bf structure-slot-default-init} and {\bf structure-slot-type}.

 Because the \cl\ standard defines that for each
 \lisp{defstruct}\ there has to be a corresponding instance of
 \class{structure-class}, this \lisp{defstruct}\ class representations
 have to be passed as arguments. Since the \cl\ LISP standard defines
 no classes for \lisp{defstruct}\ slots, they are passed by their
 symbolic names. Most of the \lisp{defstruct}\ options and
 \lisp{defstruct}\ slot options are not considered since they do not
 seem to be very useful to me. The only slot options handled are the
 slot's default initialization and the slot's type.

\Remarkslabel
 \note\ In \lw, certain \lisp{defstruct}\ options affect
 directly the \lisp{defstruct}-specific functions which are
 created at evaluating the \lisp{defstruct}, e.g.\ the
 \lisp{defstruct}\ \lisp{:type}\ option
 \cite[\citepage{481}]{bib:CLtLII} leads to the generation of a totally
 different constructor function compared to the same
 \lisp{defstruct}\ created with no \lisp{:type}\ option.
 Furthermore, these options are not
 explicitly represented in \lw\ \lisp{defstruct}\ descriptions.

 Hint for non-\lw: If you are adapting these functions to a
 non-\lwcl\ and you cannot locate the sub-functions used in the
 \lw\ version, try to generate a very new structure instance,
 \lisp{format}\ it into a string, and parse that string for the
 slot names and the slot default initializations (very onerous,
 but this should work at least).
\Seealsolabel
 \Fcite{class-constructor};
 \fcite{(setf class-constructor)};
 \fcite{class-slots (structure-class)};
 \fcite{structure-slot-reader};
 \fcite{structure-slot-default-init};
 \fcite{structure-slot-type}.


\endcom

\begincncom[Internal]{+structure-class-class+}

\Valuelabel
\begin{CompactCode}
(find-class 'structure-class)
\end{CompactCode}

\Purposelabel
The \clsmo\ of class \class{structure-class}.


\endcom

\beginfncom[Internal]{structure-constructor-internal}

\Syntaxlabel
\Defun {structure-constructor-internal} {{\funarg{the-class}}}


\Argumentslabel
 \isastrcls{\funarg{the-class}}
\Purposelabel
 Returns the symbol bound to the constructor function of
 \funarg{the-class}.
\Remarkslabel
 \sysdep{function}
\Seealsolabel
 \Fcite{class-constructor};
 section \fcite{structure ...};
 argument \keyarg{constructor}\ of \fcite{defstruct}.


\endcom

\beginclcom[Internal Structure]{structure-description}

\Purposelabel
 A transient structure representing persistent structure descriptions.
 In the sense of \clos, this class corresponds roughly to the
 \std\ \clsmc\ \class{standard-class}.
\Remarkslabel
 \basecls{structure-description}


\Directsuperclasseslabel
\Defmethod{}{\tt}{\ObjectWithRef{persistent-structure}}{}


\Directslotslabel

\Defdslot {p-name} {nil}


 The name of the structure as a symbol.

\Defdslot {p-version-number} {100\newline :type fixnum}


 A schema evolution version number; 100 means version 1.00.
 The number is incremented by 1 for each new version.

\Defdslot {p-time-stamp} {(floor (get-universal-time) 60)\newline :type integer}


 A time stamp when the structure description was created. The time stamp
 is in \cl\ Universal Time divided by 60, i.e.\ the time is in
 minutes, not in seconds.

\Defdslot {p-schema-evolution} {*default-structure-schema-evolution*}


 A symbol describing the type of schema evolution to use for the
 structure;
 see \fcite{schema-evolution}\ and
 \fcite{(setf schema-evolution)}.

\Defdslot {p-next-generation} {nil}


 The next generation of the structure description;
 this is either \lispnil\ or a pointer to an instance of class
 \class{structure-description}\ with a higher version number.

\Defdslot {p-constructor} {nil}


 The name of the structure constructor function as a symbol;
 see \fcite{class-constructor}\ and
 \fcite{(setf class-constructor)}.

\Defdslot {p-dependent} {nil}


 The dependent flag of the structure as a symbol;
 see \fcite{class-dependent}\ and
 \fcite{(setf class-dependent)}.

\Defdslot {p-persistent-slot-numbers} {0\newline :type fixnum}


 The number of persistent slots of the described structure.

\Defdslot {p-slot-numbers} {0\newline :type fixnum}


 The total number of slots of the described structure.

\Defdslot {p-slots} {nil}


 A vector with instances of
 \fcite{structure-slot-description}\ for each slot of the
 described structure.

\Defdslot {t-name->slot-cache} {(make-hash-table :test (function eq))}


 A transient slot with a hash table mapping slot names to
 instances of \fcite{slot-description}. It is used for fast
 mapping of a slot name to its corresponding instance of
 \fcite{structure-slot-description}\ in various methods
 of \fcite{slot-value-using-class}\ and
 \fcite{(setf slot-value-using-class)}.


\Classoptionslabel
\Defmethod{}{\tt}{:constructor make-structure-description-internal\newline :copier copy-structure-description-internal}{}


\endcom

\beginvrcom[Internal]{*structure-description*}

\Initialvaluelabel
\begin{CompactCode}
nil
\end{CompactCode}

\Purposelabel
 Contains a persistent object of
 \fcite{structure-description}\ describing the
 \fcite{structure-description}.
\Seealsolabel
 \Fcite{*structure-description-objid*}.


\endcom

\beginvrcom[Internal]{*structure-description-objid*}

\Initialvaluelabel
\begin{CompactCode}
nil
\end{CompactCode}

\Purposelabel
 Contains the \objid\ of the value of the variable
 {\bf *structure-description*}.
\Seealsolabel
 \Fcite{*structure-description*}.


\endcom

\begincncom[Internal]{+structure-persistent-slot-names+}

\Valuelabel
\begin{CompactCode}
(loop for slot in (class-slots +persistent-structure-class+)
      if (symbolp slot)
        collect slot
      else
        collect (slot-definition-name slot))
\end{CompactCode}

\Purposelabel
 A list with all non-transient,
 i.e.\ persistent slots of \fcite{persistent-structure}.
\Seealsolabel
 \Fcite{+reverse-structure-persistent-slot-names+}.


\endcom

\beginfncom[Internal]{structure-slot-default-init}

\Syntaxlabel
\Defun {structure-slot-default-init} {{\funarg{class-of-structure}} {\funarg{slot-name-symbol}}}


\Argumentslabel
 \isastrcls{\funarg{class-of-structure}}
 \isa{\funarg{slot-name-symbol}}
      {a symbol naming a slot of \funarg{class-of-structure}}
\Purposelabel
 Return the slot default initialization value for
 \funarg{slot-name-symbol}\ in \funarg{class-of-structure}.
\Remarkslabel
 \sysdep{function}
\Seealsolabel
 Section \fcite{structure ...};
 structure slot default initialization as described for the
 \fcite{defstruct}.


\endcom

\beginclcom[Internal Structure]{structure-slot-description}

\Purposelabel
 A transient structure representing persistent structure slot
 descriptions.
 In the sense of \clos, this class corresponds roughly to the
 \std\ \sltmc\ \class{standard-effective-slot-definition}.
\Remarkslabel
 \basecls{structure-slot-description}


\Directsuperclasseslabel
\Defmethod{}{\tt}{\ObjectWithRef{persistent-structure}}{}


\Directslotslabel

\Defdslot {p-name} {nil}


 The name of the slot as a symbol.

\Defdslot {p-initarg} {nil}


 The initialization argument for initializing the slot
 at instance creation;
 default is the {\bf p-name} of the slot interned
 to the \lisp{:keyword}\ package. For non-standard
 initialization arguments see \fcite{(setf slot-initarg)}.

\Defdslot {p-reader} {nil}


 The slot reader function's symbol.

\Defdslot {p-location} {nil}


 The index of the slot into the stable heap vector.

\Defdslot {p-init} {nil}


 The init-form of the slot. This is the {\sl default-init}
 of the slot as specified for \fcite{defstruct},
 definition of structure slots.

\Defdslot {p-type} {t}


 The type of the slot. This is the value of the
 \lisp{:type}\ structure slot option as specified for
 \fcite{defstruct}, definition of structure slots.

\Defdslot {p-extent} {nil}


 The extent of the slot;
 see \fcite{slot-extent}\ and, for possible values,
 \fcite{(setf slot-extent)}.

\Defdslot {p-deferred} {nil}


 The deferred option of the slot;
 see \fcite{slot-deferred}\ and, for possible values,
 \fcite{(setf slot-deferred)}.

\Defdslot {t-writer} {nil}


 The slot writer function's symbol.


\Classoptionslabel
\Defmethod{}{\tt}{:constructor make-structure-slot-description-internal}{}


\endcom

\beginvrcom[Internal]{*structure-slot-description*}

\Initialvaluelabel
\begin{CompactCode}
nil
\end{CompactCode}

\Purposelabel
 Contains a persistent object of
 \fcite{structure-description}\ describing the
 \fcite{structure-slot-description}.
\Seealsolabel
 \Fcite{*structure-slot-description-objid*}.


\endcom

\beginvrcom[Internal]{*structure-slot-description-objid*}

\Initialvaluelabel
\begin{CompactCode}
nil
\end{CompactCode}

\Purposelabel
 Contains the \objid\ of the value of the
 \fcite{*structure-slot-description*}.
\Seealsolabel
 \Fcite{*structure-slot-description*}.


\endcom

\beginfncom[Internal]{structure-slot-description-writer}

\Syntaxlabel
\Defun {structure-slot-description-writer} {{\funarg{struct-slot-descr}}}


\Argumentslabel
 \isa{\funarg{struct-slot-descr}}
      {a structure-slot-description}
\Purposelabel
 Returns a symbol bound to a function which writes a value to the
 transient structure slot described by \funarg{struct-slot-descr}.
\Seealsolabel
 \Fcite{call-structure-slot-description-writer}.


\endcom

\begincncom[Internal]{+structure-slot-extents+}

\Valuelabel
\begin{CompactCode}
'(:transient :cached :cached-demand-load)
\end{CompactCode}

\Purposelabel
 List with allowed structure slot extents.
\Seealsolabel
 \Fcite{(setf slot-extent)};
 \fcite{+clos-slot-extents+};
 \fcite{+plob-slot-extents+}.


\endcom

\beginfncom[Internal]{structure-slot-reader}

\Syntaxlabel
\Defun {structure-slot-reader} {{\funarg{class-of-structure}} {\funarg{slot-name-symbol}}}


\Argumentslabel
 \isastrcls{\funarg{class-of-structure}}
 \isa{\funarg{slot-name-symbol}}
      {a symbol naming a slot of \funarg{class-of-structure}}
\Purposelabel
 Return the symbol bound to the slot reading function for
 \funarg{slot-name-symbol}\ in \funarg{class-of-structure}.
\Remarkslabel
 \sysdep{function}

 Hint for \allegro:
 For now, this function creates a symbolic name for the
 structure slot reader
 function regardless of a specified \lisp{:conc-name}. A better
 idea would be to look if the
 structure slot reader
 is represented somewhere associated with the structure's \clsmo.
\Seealsolabel
 Section \fcite{structure ...};
 structure slot readers as described for the
 \fcite{defstruct};
 argument \keyarg{conc-name}\ of
 \fcite{defstruct}.


\endcom

\beginfncom[Internal]{structure-slot-type}

\Syntaxlabel
\Defun {structure-slot-type} {{\funarg{class-of-structure}} {\funarg{slot-name-symbol}}}


\Argumentslabel
 \isastrcls{\funarg{class-of-structure}}
 \isa{\funarg{slot-name-symbol}}
      {a symbol naming a slot of \funarg{class-of-structure}}
\Purposelabel
 Return the slot type for
 \funarg{slot-name-symbol}\ in \funarg{class-of-structure}.
 This is the value of the structure slot option
 \lisp{:type}\ specified in the \lisp{defstruct}\ statement of
 \funarg{class-of-structure}\ for the structure slot named
 \funarg{slot-name-symbol};
 if no such option was specifed, type \lispt\ is assumed.
\Remarkslabel
 \sysdep{function}
\Seealsolabel
 Section \fcite{structure ...};
 structure slot options as described for the
 \fcite{defstruct}.


\endcom

\beginfncom[Internal]{substitute-newline}

\Syntaxlabel
\Defun {substitute-newline} {{\funarg{message}} {\opt} {\funarg{replace-by}}}


 Substitute sequences of newlines followed by spaces into a newline
 followed by two semicolons.


\endcom

\begincncom[Internal]{+substitute-newline-default+}

\Valuelabel
\begin{CompactCode}
";;; "
\end{CompactCode}

\Purposelabel
The default to be used in \fcite{substitute-newline}.


\endcom

\beginpmcom[Internal]{*suspend-timeout*}

\Initialvaluelabel
\begin{CompactCode}
2
\end{CompactCode}

\Purposelabel
 Maximum time to wait in seconds when the \cl\ session receives
 a suspend request.
%% \Seealsolabel
%%  \Fcite{sh-suspend-callback}.



\endcom

\beginvrcom[Internal]{*symbol->class-table*}

\Initialvaluelabel
\begin{CompactCode}
(make-cached-btree)
\end{CompactCode}

\Purposelabel
 The persistent class table.
 Maps a persistent symbol to a persistent class description object.
\Seealsolabel
 \Fcite{p-find-class}.


\endcom

\begincncom[Internal]{+t-class+}

\Valuelabel
\begin{CompactCode}
(find-class t)
\end{CompactCode}

\Purposelabel
The \clsmo\ of class \class{t}.


\endcom

\beginfncom[Internal]{t-ivectorp}

\Syntaxlabel
\Defun {t-ivectorp} {{\funarg{the-vector}}}


\Argumentslabel
 \isa{\funarg{the-vector}}
      {a vector}
\Purposelabel
 Check if \funarg{the-vector}\ is a transient immediate vector,
 i.e.\ a vector holding only immediate values.
\Remarkslabel
 \sysdep{function}

 Hint for portability:
 If this cannot be determined, \lispnil\ should be returned;
 this will slow down \plob\ for arrays with its element type
 specialized to an immediate type (e.g.\ arrays created by
 \lisp{(make-array ... :element-type 'single-float \ldots)}).

 Hint for \allegro:
 Looks as if in \allegro\ the `immediate vectors' are called
 fixed size vectors (see e.g.\ the definitions in
 \lisp{/opt/cl/Franz-ACL-4.3/home/misc/lisp.h}), but for now it
 is unclear how a LISP vector is checked to be such a fixed size
 vector.


\endcom

\begingfcom[Internal]{t-object-to-p-objid}

\Syntaxlabel
\Defgen {t-object-to-p-objid} {{\funarg{t-object}} {\funarg{depth}} {\funarg{to-p-heap}}}


\Argumentslabel
 \isanobject{\funarg{t-object}}
\Valueslabel
 Two values are returned:
 \begin{enumerate}

 \item The \objid\ of the stored object \funarg{t-object}.

 \item The \typetag\ of the stored object \funarg{t-object}.
  If the second value is \lispnil, the first value references a
  non-immediate persistent object; its
  \typetag\ can therefore assumed to be {\bf +short-objid-tag+}.

 \end{enumerate}
\Purposelabel
 The workhorse for \fcite{store-object}: Stores
 \funarg{t-object}\ to the stable heap.
\Seealsolabel
 \Fcite{store-object};
 \fcite{t-object-to-p-objid-using-class};
 \fcite{p-objid-to-t-object}.


\Methodslabel

\flabel{\protect\mtd}{t-object-to-p-objid :around (t t t)}{}
{\Defmetharound {t-object-to-p-objid} {{\funarg{t-object}} {\funarg{depth}} {\funarg{to-p-heap}}}}
Handle \funarg{depth}.

\flabel{\protect\mtd}{t-object-to-p-objid (bit-vector t t)}{}
{\Defmeth {t-object-to-p-objid} {(\funarg{t-object}\ \ObjectWithRef{bit-vector}) {\funarg{depth}} {\funarg{to-p-heap}}}}
%
% No behavior is specified for this method beyond that which is specified
% for the generic function.

\flabel{\protect\mtd}{t-object-to-p-objid (character t t)}{}
{\Defmeth {t-object-to-p-objid} {(\funarg{t-object}\ \ObjectWithRef{character}) {\funarg{depth}} {\funarg{to-p-heap}}}}
Returns the \lisp{char-code}\ of \funarg{t-object}.

\flabel{\protect\mtd}{t-object-to-p-objid (complex t t)}{}
{\Defmeth {t-object-to-p-objid} {(\funarg{t-object}\ \ObjectWithRef{complex}) {\funarg{depth}} {\funarg{p-heap}}}}
%
% No behavior is specified for this method beyond that which is specified
% for the generic function.

\flabel{\protect\mtd}{t-object-to-p-objid (cons t t)}{}
{\Defmeth {t-object-to-p-objid} {(\funarg{t-object}\ \ObjectWithRef{cons}) {\funarg{depth}} {\funarg{to-p-heap}}}}
%
% No behavior is specified for this method beyond that which is specified
% for the generic function.

\flabel{\protect\mtd}{t-object-to-p-objid (float t t)}{}
{\Defmeth {t-object-to-p-objid} {(\funarg{t-object}\ \ObjectWithRef{float}) {\funarg{depth}} {\funarg{p-heap}}}}
%
% No behavior is specified for this method beyond that which is specified
% for the generic function.

\flabel{\protect\mtd}{t-object-to-p-objid (function t t)}{}
{\Defmeth {t-object-to-p-objid} {(\funarg{t-object}\ \ObjectWithRef{function}) {\funarg{depth}} {\funarg{to-p-heap}}}}
%
% No behavior is specified for this method beyond that which is specified
% for the generic function.

\flabel{\protect\mtd}{t-object-to-p-objid (integer (eql objid) t)}{}
{\Defmeth {t-object-to-p-objid} {(\funarg{t-object}\ \ObjectWithRef{integer}) (\funarg{depth}\ \ObjectWithRef{(eql :objid)}) {\funarg{to-p-heap}}}}
Returns \funarg{t-object}\ type-marked as \objid.

\flabel{\protect\mtd}{t-object-to-p-objid (integer t t)}{}
{\Defmeth {t-object-to-p-objid} {(\funarg{t-object}\ \ObjectWithRef{integer}) {\funarg{depth}} {\funarg{p-heap}}}}
%
% No behavior is specified for this method beyond that which is specified
% for the generic function.

\flabel{\protect\mtd}{t-object-to-p-objid (package t t)}{}
{\Defmeth {t-object-to-p-objid} {(\funarg{t-object}\ \ObjectWithRef{package}) {\funarg{depth}} {\funarg{to-p-heap}}}}
%
% No behavior is specified for this method beyond that which is specified
% for the generic function.

\flabel{\protect\mtd}{t-object-to-p-objid (persistent-clos-object (eql object) t)}{}
{\Defmeth {t-object-to-p-objid} {(\funarg{t-object}\ \ObjectWithRef{persistent-clos-object}) (\funarg{depth}\ \ObjectWithRef{(eql :object)}) {\funarg{to-p-heap}}}}
%
% No behavior is specified for this method beyond that which is specified
% for the generic function.

\flabel{\protect\mtd}{t-object-to-p-objid (persistent-clos-object (eql objid) t)}{}
{\Defmeth {t-object-to-p-objid} {(\funarg{t-object}\ \ObjectWithRef{persistent-clos-object}) (\funarg{depth}\ \ObjectWithRef{(eql :objid)}) {\funarg{to-p-heap}}}}
%
% No behavior is specified for this method beyond that which is specified
% for the generic function.

\flabel{\protect\mtd}{t-object-to-p-objid (slot-load-on-demand t t)}{}
{\Defmeth {t-object-to-p-objid} {(\funarg{t-object}\ \ObjectWithRef{slot-load-on-demand}) {\funarg{depth}} {\funarg{p-heap}}}}
Return the \objid\ stored within \funarg{t-object}.
 Since \funarg{t-object}\ is a reference to a non-loaded persistent
 object, its state is never stored.

\flabel{\protect\mtd}{t-object-to-p-objid (persistent-immediate-object (eql objid) t)}{}
{\Defmeth {t-object-to-p-objid} {(\funarg{t-object}\ \ObjectWithRef{persistent-immediate-object}) (\funarg{depth}\ \ObjectWithRef{(eql :objid)}) {\funarg{to-p-heap}}}}
%
% No behavior is specified for this method beyond that which is specified
% for the generic function.

\flabel{\protect\mtd}{t-object-to-p-objid (persistent-immediate-object t t)}{}
{\Defmeth {t-object-to-p-objid} {(\funarg{t-object}\ \ObjectWithRef{persistent-immediate-object}) {\funarg{depth}} {\funarg{p-heap}}}}
Return the \objid\ stored within \funarg{t-object}.
 Since \funarg{t-object}\ is a reference to a non-loaded persistent
 object, its state is never stored.

\flabel{\protect\mtd}{t-object-to-p-objid (persistent-object (eql object) t)}{}
{\Defmeth {t-object-to-p-objid} {(\funarg{t-object}\ \ObjectWithRef{persistent-object}) (\funarg{depth}\ \ObjectWithRef{(eql :object)}) {\funarg{to-p-heap}}}}
Returns \funarg{t-object}.

\flabel{\protect\mtd}{t-object-to-p-objid (persistent-object (eql objid) t)}{}
{\Defmeth {t-object-to-p-objid} {(\funarg{t-object}\ \ObjectWithRef{persistent-object}) (\funarg{depth}\ \ObjectWithRef{(eql :objid)}) {\funarg{to-p-heap}}}}
%
% No behavior is specified for this method beyond that which is specified
% for the generic function.

\flabel{\protect\mtd}{t-object-to-p-objid (ratio t t)}{}
{\Defmeth {t-object-to-p-objid} {(\funarg{t-object}\ \ObjectWithRef{ratio}) {\funarg{depth}} {\funarg{p-heap}}}}
%
% No behavior is specified for this method beyond that which is specified
% for the generic function.

\flabel{\protect\mtd}{t-object-to-p-objid (string t t)}{}
{\Defmeth {t-object-to-p-objid} {(\funarg{t-object}\ \ObjectWithRef{string}) {\funarg{depth}} {\funarg{to-p-heap}}}}
%
% No behavior is specified for this method beyond that which is specified
% for the generic function.

\flabel{\protect\mtd}{t-object-to-p-objid (array t t)}{}
{\Defmeth {t-object-to-p-objid} {(\funarg{t-object}\ \ObjectWithRef{array}) {\funarg{depth}} {\funarg{to-p-heap}}}}
%
% No behavior is specified for this method beyond that which is specified
% for the generic function.

\flabel{\protect\mtd}{t-object-to-p-objid (symbol t t)}{}
{\Defmeth {t-object-to-p-objid} {(\funarg{t-object}\ \ObjectWithRef{symbol}) {\funarg{depth}} {\funarg{to-p-heap}}}}
%
% No behavior is specified for this method beyond that which is specified
% for the generic function.

\flabel{\protect\mtd}{t-object-to-p-objid (vector t t)}{}
{\Defmeth {t-object-to-p-objid} {(\funarg{t-object}\ \ObjectWithRef{vector}) {\funarg{depth}} {\funarg{to-p-heap}}}}
%
% No behavior is specified for this method beyond that which is specified
% for the generic function.

\flabel{\protect\mtd}{t-object-to-p-objid (t t t)}{}
{\Defmeth {t-object-to-p-objid} {{\funarg{t-object}} {\funarg{depth}} {\funarg{to-p-heap}}}}
%
% No behavior is specified for this method beyond that which is specified
% for the generic function.


\endcom

\begingfcom[Internal]{t-object-to-p-objid-using-class}

\Syntaxlabel
\Defgen {t-object-to-p-objid-using-class} {{\funarg{t-object}} {\funarg{t-class}} {\funarg{depth}} {\funarg{p-heap}}}


\Argumentslabel
 \isacls{\funarg{t-class}}
 Rest see \fcite{t-object-to-p-objid}.
\Valueslabel
 See \fcite{t-object-to-p-objid}.
\Purposelabel
 Workhorse for \fcite{t-object-to-p-objid}; it is called when no
 other method for \fcite{t-object-to-p-objid}\ was found.
 The \funarg{t-class}\ argument is the class object of
 \funarg{t-object}.
\Seealsolabel
 \Fcite{t-object-to-p-objid}.


\Methodslabel

\flabel{\protect\mtd}{t-object-to-p-objid-using-class (class standard-class t t)}{}
{\Defmeth {t-object-to-p-objid-using-class} {(\funarg{t-object}\ \ObjectWithRef{class}) (\funarg{t-class}\ \ObjectWithRef{standard-class}) {\funarg{depth}} {\funarg{p-heap}}}}
Stores \funarg{t-object}\ as an instance of
 \fcite{class-description}.

\flabel{\protect\mtd}{t-object-to-p-objid-using-class (direct-slot-definition standard-class t t)}{}
{\Defmeth {t-object-to-p-objid-using-class} {(\funarg{t-object}\ \ObjectWithRef{direct-slot-definition}) (\funarg{t-class}\ \ObjectWithRef{standard-class}) {\funarg{depth}} {\funarg{p-heap}}}}
Stores \funarg{t-object}\ as an instance of
 \fcite{direct-slot-description}.

\flabel{\protect\mtd}{t-object-to-p-objid-using-class (effective-slot-definition standard-class t t)}{}
{\Defmeth {t-object-to-p-objid-using-class} {(\funarg{t-object}\ \ObjectWithRef{effective-slot-definition}) (\funarg{t-class}\ \ObjectWithRef{standard-class}) {\funarg{depth}} {\funarg{p-heap}}}}
Stores \funarg{t-object}\ as an instance of
 \fcite{effective-slot-description}.

\flabel{\protect\mtd}{t-object-to-p-objid-using-class (hash-table structure-class t t)}{}
{\Defmeth {t-object-to-p-objid-using-class} {(\funarg{t-object}\ \ObjectWithRef{hash-table}) (\funarg{t-class}\ \ObjectWithRef{structure-class}) {\funarg{depth}} {\funarg{p-heap}}}}
%
% No behavior is specified for this method beyond that which is specified
% for the generic function.

\flabel{\protect\mtd}{t-object-to-p-objid-using-class (method standard-class t t)}{}
{\Defmeth {t-object-to-p-objid-using-class} {(\funarg{t-object}\ \ObjectWithRef{method}) (\funarg{t-class}\ \ObjectWithRef{standard-class}) {\funarg{depth}} {\funarg{p-heap}}}}
Stores \funarg{t-object}\ as an instance of
 \fcite{method-description}.

\flabel{\protect\mtd}{t-object-to-p-objid-using-class (metaobject standard-class t t)}{}
{\Defmeth {t-object-to-p-objid-using-class} {(\funarg{t-object}\ \ObjectWithRef{metaobject}) (\funarg{t-class}\ \ObjectWithRef{standard-class}) {\funarg{depth}} {\funarg{p-heap}}}}
Signals an error.

\flabel{\protect\mtd}{t-object-to-p-objid-using-class (standard-object standard-class t t)}{}
{\Defmeth {t-object-to-p-objid-using-class} {(\funarg{t-object}\ \ObjectWithRef{standard-object}) (\funarg{t-class}\ \ObjectWithRef{standard-class}) {\funarg{depth}} {\funarg{p-heap}}}}
%
% No behavior is specified for this method beyond that which is specified
% for the generic function.

\flabel{\protect\mtd}{t-object-to-p-objid-using-class (t structure-class t t)}{}
{\Defmeth {t-object-to-p-objid-using-class} {{\funarg{t-object}} (\funarg{t-class}\ \ObjectWithRef{structure-class}) {\funarg{depth}} {\funarg{p-heap}}}}
%
% No behavior is specified for this method beyond that which is specified
% for the generic function.

\flabel{\protect\mtd}{t-object-to-p-objid-using-class (t t t t)}{}
{\Defmeth {t-object-to-p-objid-using-class} {{\funarg{t-object}} {\funarg{t-class}} {\funarg{depth}} {\funarg{p-heap}}}}
Return a lisp{+unstorable-object-marker+}


\endcom

\beginfncom[Internal]{t-slot-to-p-objid}

\Syntaxlabel
\Defun {t-slot-to-p-objid} {{\funarg{t-slot-value}} {\funarg{depth}} {\funarg{p-heap}} {\funarg{p-objid}} {\funarg{at-location}} {\funarg{t-set-function}} {\opt} {\funarg{expecting-type-tag}} {\funarg{expecting-class}} {\funarg{p-set-function}}}


\Argumentslabel
 See \fcite{t-slot-to-p-objid-in-transaction}.
\Valueslabel
 See \fcite{t-slot-to-p-objid-in-transaction}.
\Purposelabel
 Calls the \fcite{t-slot-to-p-objid-in-transaction}\ ensuring
 that the call will be embedded into a transaction on
 \funarg{p-heap}.
\Seealsolabel
 \Fcite{t-slot-to-p-objid-in-transaction};
 \fcite{p-objid-to-t-slot}.


\endcom

\beginfncom[Internal]{t-slot-to-p-objid-in-transaction}

\Syntaxlabel
\Defun {t-slot-to-p-objid-in-transaction} {{\funarg{t-slot-value}} {\funarg{depth}} {\funarg{p-heap}} {\funarg{p-objid}} {\funarg{at-location}} {\funarg{t-set-function}} {\opt} {\funarg{expecting-type-tag}} {\funarg{expecting-class}} {\funarg{p-set-function}}}


\Argumentslabel
 \isanobject{\funarg{t-slot-value}}
 \isanobjid{\funarg{p-objid}}
 \isa{\funarg{at-location}}
      {a fixnum}
 \isatypetag{\funarg{expecting-type-tag}}
\Valueslabel
 Returns three values:
 \begin{enumerate}

 \item The value of \funarg{t-slot-value}\ is returned as
  the first value.

 \item The \objid\ of storing
  \funarg{t-slot-value}\ to the \sh\ is returned as
  the second value.

 \item The \typetag\ of \funarg{t-slot-value}\ is returned as
  the third value.

 \end{enumerate}
\Purposelabel
 Write to a persistent object's component; the
 slot value of the persistent object referenced by
 \funarg{p-objid}\ at position \funarg{at-location}\ is
 set to the persistent object created by storing
 \funarg{t-slot-value}\ to the \sh.
\Seealsolabel
 \Fcite{(setf p-index)}.


\endcom

\beginfncom[Internal]{t-type-tag-of}

\Syntaxlabel
\Defun {t-type-tag-of} {{\funarg{t-object}}}


\Argumentslabel
 \isanobject{\funarg{t-object}}
\Purposelabel
 Return the most specific \typetag\ for \funarg{t-object}.
\Seealsolabel
 \Fcite{p-upgraded-array-element-tag}.


\endcom

\beginvrcom[Internal]{*transient-slot-value*}

\Initialvaluelabel
\begin{CompactCode}
nil
\end{CompactCode}

\Purposelabel
 The value of this variable affects the overall slot handling done.
 For a value being \lispnil, all \textbf{slot-\ldots-using-class}
 methods implemented in \plob\ will work on both the transient and,
 if appropriate, the persistent representation.
 For a value being \nonnil, all \textbf{slot-\ldots-using-class}
 methods implemented in \plob\ will work on only the transient
 representation. This is for example used at object loading, when
 a new transient representation is allocated by a call to
 \fcite{make-instance}, which in turn calls
 \fcite{initialize-instance}, which calls \fcite{shared-initialize}.
 This call chain would normally store the object into the persistent
 heap again; to suppress this behavior, \fcite{*transient-slot-value*}
 is set to \nonnil.


\endcom

\beginclcom[Internal Structure]{type-info}

\Purposelabel
 A structure containing informations about
 \plob\ built-in types.


\Directslotslabel

\Defdslot {name} {""}


 The type name.

\Defdslot {tag} {0}


 The numeric \typetag.

\Defdslot {objid-size} {0}


 The number of bits of the reference field
 of the type with \typetag\ {\bf tag}.

\Defdslot {value-size} {0}


 The number of bits of the value field
 of the type with \typetag\ {\bf tag}.


\Classoptionslabel
\Defmethod{}{\tt}{:constructor make-type-info (name tag objid-size value-size)}{}


\endcom

\begincncom[Internal]{+type-name-buffer-size+}

\Valuelabel
\begin{CompactCode}
128
\end{CompactCode}

\Purposelabel
Max.\ number of characters in a type name.


\endcom

\beginvrcom[Internal]{*type-tag->type-info*}

\Initialvaluelabel
\begin{CompactCode}
(make-hash-table :test #'eql)
\end{CompactCode}

\Purposelabel
 A variable used for mapping \typetag[s]\ to type infos.
\Seealsolabel
 \Fcite{type-info}.


\endcom

\beginfncom[Internal]{unregister-by-object}

\Syntaxlabel
\Defun {unregister-by-object} {{\funarg{t-object}}}


\Argumentslabel
 \isanobject{\funarg{t-object}}
\Valueslabel
 Returns \nonnil\ if \funarg{t-oject}\ was registered in
 and removed from the root caches; \lispnil\ otherwise.
\Purposelabel
 Remove the transient object \funarg{t-object}\ from
 the root caches.
\Seealsolabel
 \Fcite{is-registered-object};
 \fcite{unregister-by-objid}.


\endcom

\beginfncom[Internal]{unregister-by-objid}

\Syntaxlabel
\Defun {unregister-by-objid} {{\funarg{p-objid}}}


\Argumentslabel
 \isanobjid{\funarg{p-objid}}
\Valueslabel
 Returns \nonnil\ if the there was an oject found registered under
 \funarg{p-objid}\ and removed from the root caches;
 \lispnil\ otherwise.
\Purposelabel
 Remove the transient object associated to \funarg{p-objid}\ from
 the root caches.
\Seealsolabel
 \Fcite{is-registered-objid};
 \fcite{unregister-by-object}.


\endcom

\begingfcom[Internal]{update-class}

\Syntaxlabel
\Defgen {update-class} {{\funarg{class-descr}} {\opt} {\funarg{p-heap}}}


\Argumentslabel
 \isa{\funarg{class-descr}}
      {a class description}
\Purposelabel
 Updates a class description in the \sh.
\Seealsolabel
 \Fcite{structure-description};
 \fcite{class-description}.


\Methodslabel

\flabel{\protect\mtd}{update-class :around (class-description)}{}
{\Defmetharound {update-class} {(\funarg{class-descr}\ \ObjectWithRef{class-description}) {\opt} {\funarg{p-heap}}}}
Ensure that the slots
 with \lisp{:allocation :class}\ are allocated on the \sh.

\flabel{\protect\mtd}{update-class (t)}{}
{\Defmeth {update-class} {{\funarg{class-descr}} {\opt} {\funarg{p-heap}}}}
Updates \funarg{class-descr}\ in the \plob\ class table
 contained in the \fcite{*symbol->class-table*}.

\flabel{\protect\mtd}{update-class :after (class-description)}{}
{\Defmetha {update-class} {(\funarg{class-descr}\ \ObjectWithRef{class-description}) {\opt} {\funarg{p-heap}}}}
%
% No behavior is specified for this method beyond that which is specified
% for the generic function.

\flabel{\protect\mtd}{update-class :after (structure-description)}{}
{\Defmetha {update-class} {(\funarg{class-descr}\ \ObjectWithRef{structure-description}) {\opt} {\funarg{p-heap}}}}
%
% No behavior is specified for this method beyond that which is specified
% for the generic function.


\endcom

\beginfncom[Internal]{update-instance-for-redefined-description}

\Syntaxlabel
\Defun {update-instance-for-redefined-description} {{\funarg{old-class-descr}} {\funarg{new-class-descr}} {\funarg{p-objid}} {\opt} {\funarg{p-heap}}}


\Argumentslabel
 \isa{\funarg{old-class-descr}\ resp.\ \funarg{new-class-descr}}
      {a class-description}
 \isanobjid{\funarg{p-objid}}
\Purposelabel
 The persistent \clos\ instance referenced by \funarg{p-objid}\ is
 migrated (or `schema-evoluted') from its current
 \funarg{old-class-descr}\ (found in the persistent \clos\ instance's
 class-wrapper) to the global actual
 \funarg{new-class-descr}\ (as now contained in the class table,
 i.e.\ the class-description as returned by
 \fcite{p-find-class}).
\Seealsolabel
 \Fcite{load-instance-for-redefined-class}.


\endcom

\beginclcom[Internal Structure]{url}

\Purposelabel
 A class representing URLs naming databases. An URL has the form
\begin{IndentedCompactCode}
  [<transport>:][//<host>][/directory]
\end{IndentedCompactCode}

\Seealsolabel
  \Fcite{make-url-from-string}, \fcite{merge-urls},
  \fcite{split-url}, \fcite{write-url}.


\Directslotslabel

\Defdslot {transport} {nil}


 The transport interface to use for accessing the database. Most
 \unix\ system implement only \lisp{tcp}\ as the one and only
 transport interface. Do not try to use \lisp{udp}.

\Defdslot {host} {nil}


 The host where the database resides.

\Defdslot {directory} {nil}


 The directory on host which contains the database.


\Classoptionslabel
\Defmethod{}{\tt}{:print-function {\rm\sl omitted here}}{}


\endcom

\beginfncom[Internal]{vector-to-int-vector}

\Syntaxlabel
\Defun {vector-to-int-vector} {{\funarg{vector}} {\opt} {\funarg{dynamic}}}

Return \funarg{vector}\ converted into a int-vector.


\endcom

\beginvrcom[Internal]{*verbose*}

\Initialvaluelabel
\begin{CompactCode}
4
\end{CompactCode}

\Purposelabel
 A variable indicating the amount of messaging to provide by \plob.
 Following values are defined:
 \begin{description}
 \item[0 \protect\textrm{or} \protect\lispnil]
  Do not show any messages at all and suppress all warnings. All
  cerrors are continued.
 \item[1] Show all warnings; cerrors will be raised.
 \item[2] Show the storing and updating of class metaobjects.
  Those messages will have a `;;;;;' prefix.
 \item[3] Show the bootstrap messages.
  Those messages will have a `;;;;' prefix.
 \item[4] Show all messages returned from the server.
  Those messages will have a `;;;' prefix.
 \item[5] Show the storing and loading of structure and
  \clos\ instances. Those messages will have a `;;' prefix.
 \item[6] Show the storing and loading of non-structure and
  non-\clos\ instances. Those messages will have a `;' prefix.
 \item[7] Show the storing and loading of \clos\ slots.
  Those messages will have a `;' prefix, too.
 \end{description}


\endcom

\begincncom[Internal]{+version-layers+}

\Valuelabel
\begin{CompactCode}
'(:database :server :client :api)
\end{CompactCode}

\Purposelabel
The symbolic names of all layers of which a version number
 can be retrieved.


\endcom

\beginfncom[Internal]{with-direct-representation-p}

\Syntaxlabel
\Defun {with-direct-representation-p} {{\funarg{depth}}}


 Check if \funarg{depth}\ has a value indicating working directly on
 a persistent object.


\endcom

\beginmccom[Internal]{with-dynamic-int-vectors}

\Syntaxlabel
\Defmac {with-dynamic-int-vectors} {{\funarg{bindings}} {\body} {\funarg{body}}}

Handle dynamic extent on int vectors.
\Seealsolabel
 \Fcite{make-int-vector}; \fcite{free-int-vector}.


\endcom

\beginmccom[Internal]{with-handle-lock-conflict}

\Syntaxlabel
\Defmac {with-handle-lock-conflict} {{\funarg{lock-expression}} {\funarg{p-heap-objid}} {\funarg{p-objid}}}


\Argumentslabel
 \isa{\funarg{lock-expression}}
      {a function taking one argument}
 \isanobjid{\funarg{p-objid}}
\Valueslabel
 The value returned by evaluating \funarg{lock-expression}.
\Purposelabel
 Evaluates \funarg{lock-expression}\ and checks if a lock failure
 occurred; if yes, \fcite{handle-lock-conflict}\ is called.
\Seealsolabel
 \Fcite{handle-lock-conflict}.


\endcom

\beginmccom[Internal]{with-objid-buffer}

\Syntaxlabel
\Defmac {with-objid-buffer} {(\funarg{objid-buffer}\ \ObjectWithRef{p-objid}) {\body} {\funarg{body}}}

Make an environment for \funarg{body}\ where
 \funarg{objid-buffer}\ references an open \objid\ buffer.
\Seealsolabel
  \Fcite{objid-buffer}


\endcom

\beginmccom[Internal]{with-read-lock}

\Syntaxlabel
\Defmac {with-read-lock} {(\funarg{p-heap}\ \ObjectWithRef{p-objid}) {\rest} {\funarg{forms}}}


\Argumentslabel
 \isanobjid{\funarg{p-objid}}
 \isatypetag{\funarg{expecting-type-tag}}
 \isa{\funarg{forms}}
      {an implicit \lisp{progn}\ expression
       with calls to read from the persistent object
       referenced by \funarg{p-objid}}
\Valueslabel
 Returns either the value of evaluating \funarg{forms}\ or
 \lispnil.
\Purposelabel
 The \funarg{forms}\ are only evaluated iff there was no previous
 read-lock set onto the persistent object referenced by
 \funarg{p-objid}. This is done to prevent a non-terminating
 recursion when loading self-referencing persistent objects:
 the reading done in \funarg{forms}\ will stop as soon as
 \funarg{forms}\ should be evaluated a second time for an already
 `seen' persistent object.
\Remarkslabel
 The granted read lock is released at the end of
 the transaction active on \funarg{p-heap};
 see \fcite{end-transaction}.
\Seealsolabel
 \Fcite{read-lock};
 \fcite{with-write-lock}.


\endcom

\beginmccom[Internal]{with-write-lock}

\Syntaxlabel
\Defmac {with-write-lock} {(\funarg{p-heap}\ \ObjectWithRef{p-objid}) {\rest} {\funarg{forms}}}


\Argumentslabel
 \isanobjid{\funarg{p-objid}}
 \isatypetag{\funarg{expecting-type-tag}}
 \isa{\funarg{forms}}
      {an implicit \lisp{progn}\ expression
       with calls to write to the persistent object
       referenced by \funarg{p-objid}}
\Valueslabel
 Returns either the value of evaluating \funarg{forms}\ or
 \lispnil.
\Purposelabel
 The \funarg{forms}\ are only evaluated iff there was no previous
 write-lock set onto the persistent object referenced by
 \funarg{p-objid}. This is done to prevent a non-terminating
 recursion when writing self-referencing persistent objects:
 the writing done in \funarg{forms}\ will stop as soon as
 \funarg{forms}\ should be evaluated a second time for an
 already `written-to' persistent object.
\Remarkslabel
 The granted write lock is released at the end of
 the transaction active on \funarg{p-heap};
 see \fcite{end-transaction}.
\Seealsolabel
 \Fcite{write-lock};
 \fcite{with-read-lock}.


\endcom

\begincncom[Internal]{+wrapper-class-slots-index+}

\Valuelabel
\begin{CompactCode}
2
\end{CompactCode}

\Purposelabel
 The index into the class wrapper vector which contains the list
 of the conses used for holding the values of the slots with
 \lisp{:allocation :class}.
\Remarkslabel
 \sysdep{constant}
\Seealsolabel
 \Fcite{+wrapper-instance-slots-index+}.


\endcom

\begincncom[Internal]{+wrapper-instance-slots-index+}

\Valuelabel
\begin{CompactCode}
1
\end{CompactCode}

\Purposelabel
 The index into the class wrapper vector which contains the list
 of instance slot names.
\Remarkslabel
 \sysdep{constant}
\Seealsolabel
 \Fcite{+wrapper-class-slots-index+}.


\endcom

\beginfncom[Internal]{write-lock}

\Syntaxlabel
\Defun {write-lock} {{\funarg{p-heap}} {\funarg{p-objid}} {\funarg{t-object}} {\funarg{depth}} {\funarg{expecting-type-tag}} {\opt} {\funarg{force-write}} {\funarg{lock-mode}} {\funarg{at-location}}}


\Argumentslabel
 \isanobjid{\funarg{p-objid}}
 \isatypetag{\funarg{expecting-type-tag}}
 \isa{\funarg{lock-mode}}
      {a fixnum bitwise-or'ed from
       one of the constant values of
       {\bf *lock-level-\ldots{}*} (figure~\ref{tab:lock-levels}%
       %% 1998/01/07 HK: This makes problems with hyperref:
       %% \fcitepage{\pageref{tab:lock-levels}}
       ) with the constant value of {\bf +lock-mode-write+}}
\Valueslabel
 If there was already a write-lock placed  by
 \funarg{p-heap}\ onto the persistent object
 referenced by \funarg{p-objid}, \lispnil\ is returned;
 \nonnil\ otherwise.
\Purposelabel
 Set a write lock onto the persistent object referenced by
 \funarg{p-objid}; the level and mode of locking
 are determined by \funarg{lock-mode}\ (see section
 \fcite{locking ...}\ for details).
\Remarkslabel
 \begin{enumerate}

 \item This function can only be executed within an active
  transaction on \funarg{p-heap}, so e.g.\ embed a call to it
  into an expansion of \fcite{with-transaction}\ if appropiate or
  make otherwise sure that at call-time there is an active
  transaction.

 \item Do not call this function direct; use the
  \fcite{with-write-lock}\ instead.

 \end{enumerate}
\Seealsolabel
 Section \fcite{locking ...};
 \fcite{with-transaction};
 \fcite{with-write-lock};
 \fcite{read-lock}.


\endcom

\beginfncom[Internal]{write-objid-buffer}

\Syntaxlabel
\Defun {write-objid-buffer} {{\funarg{objid-buffer}} {\funarg{at-index}} {\funarg{objid}} {\funarg{type-tag}}}

Write an \objid\ and a \typetag\ to \funarg{objid-buffer}.
\Seealsolabel
  \Fcite{objid-buffer}


\endcom

\beginfncom[Internal]{write-url}

\Syntaxlabel
\Defun {write-url} {{\funarg{object}} {\opt} {\funarg{stream}}}


\Purposelabel
  Write an instance of \fcite{url}\ to \funarg{stream}.
  If \funarg{stream}\ is \lispnil, a string with the print
  representation is returned.


\endcom

