
;;;; -*- Mode: LISP; Syntax: ANSI-Common-Lisp -*-----------------------------
;;;; NOTE: This Common LISP file was generated by c2lisp
;;;; ===== on "Feb 13 2001" "10:35:27"
;;;; Changes done directly to this file will be lost!
;;;; ------------------------------------------------------------------------


(in-package  :plob)

;;;; -------------------------------------------------------------------------
;;;; For further comments look into file plobtype.h
;;;; -------------------------------------------------------------------------


  (eval-when (:compile-toplevel    :load-toplevel    :execute)
          (progn
          (defvar
            *COMPARETAG*
            (make-hash-table  :test    (quote  equal))
           	"Variable defined by C macro BeginEnum.")
          (clrhash   *COMPARETAG*)
          (let ((last-enum-hash-table   *COMPARETAG*))
  (setf  (gethash     4     last-enum-hash-table)
	       "Compare like LISP equal.")

  (eval-when
          (:compile-toplevel    :load-toplevel    :execute)
           	 (defconstant
            #.(read-from-string     "+equal+")
           	   4
           	   	       "Compare like LISP equal."))

  (setf  (gethash     0     last-enum-hash-table)
	       "Compare like LISP eql.")

  (eval-when
          (:compile-toplevel    :load-toplevel    :execute)
           	 (defconstant
            #.(read-from-string     "+eql+")
           	   0
           	   	       "Compare like LISP eql."))

  (setf  (gethash     3     last-enum-hash-table)
	       "Compare like LISP eq.")

  (eval-when
          (:compile-toplevel    :load-toplevel    :execute)
           	 (defconstant
            #.(read-from-string     "+eq+")
           	   3
           	   	       "Compare like LISP eq."))

  (setf  (gethash     9     last-enum-hash-table)
	       "Compare result:element 1 not equal element 2.")

  (eval-when
          (:compile-toplevel    :load-toplevel    :execute)
           	 (defconstant
            #.(read-from-string     "+not-equal+")
           	   9
           	   	       "Compare result:element 1 not equal element 2."))

  (setf  (gethash     5     last-enum-hash-table)
	       "Compare result:element 1 not eql element 2.")

  (eval-when
          (:compile-toplevel    :load-toplevel    :execute)
           	 (defconstant
            #.(read-from-string     "+not-eql+")
           	   5
           	   	       "Compare result:element 1 not eql element 2."))

  (setf  (gethash     8     last-enum-hash-table)
	       "Compare result:element 1 not eq element 2.")

  (eval-when
          (:compile-toplevel    :load-toplevel    :execute)
           	 (defconstant
            #.(read-from-string     "+not-eq+")
           	   8
           	   	       "Compare result:element 1 not eq element 2."))

  (setf  (gethash     -2     last-enum-hash-table)
	       "Compare result:element 1 <= element 2.")

  (eval-when
          (:compile-toplevel    :load-toplevel    :execute)
           	 (defconstant
            #.(read-from-string     "+less-equal+")
           	   -2
           	   	       "Compare result:element 1 <= element 2."))

  (setf  (gethash     -1     last-enum-hash-table)
	       "Compare result:element 1 < element 2.")

  (eval-when
          (:compile-toplevel    :load-toplevel    :execute)
           	 (defconstant
            #.(read-from-string     "+less+")
           	   -1
           	   	       "Compare result:element 1 < element 2."))

  (setf  (gethash     1     last-enum-hash-table)
	       "Compare result:element 1 > element 2.")

  (eval-when
          (:compile-toplevel    :load-toplevel    :execute)
           	 (defconstant
            #.(read-from-string     "+greater+")
           	   1
           	   	       "Compare result:element 1 > element 2."))

  (setf  (gethash     2     last-enum-hash-table)
	       "Compare result:element 1 >= element 2.")

  (eval-when
          (:compile-toplevel    :load-toplevel    :execute)
           	 (defconstant
            #.(read-from-string     "+greater-equal+")
           	   2
           	   	       "Compare result:element 1 >= element 2."))
)))

  (eval-when
          (:compile-toplevel    :load-toplevel    :execute)
           	 (defconstant
           C2L_COMPARETAG
           	:fixnum
           	"Constant defined by C macro EndEnum."))     ;


  (eval-when (:compile-toplevel    :load-toplevel    :execute)
          (progn
          (defvar
            *TYPEFLAGS*
            (make-hash-table  :test    (quote  equal))
           	"Variable defined by C macro BeginEnum.")
          (clrhash   *TYPEFLAGS*)
          (let ((last-enum-hash-table   *TYPEFLAGS*))
  (setf  (gethash    			(parse-integer  "00" :radix    16)         last-enum-hash-table)
	       "Empty type flag.")

  (eval-when
          (:compile-toplevel    :load-toplevel    :execute)
           	 (defconstant
            #.(read-from-string     "+type-no-flags+")
           	  			(parse-integer  "00" :radix    16)
           	   	       "Empty type flag."))

  (setf  (gethash    		(parse-integer  "01" :radix    16)         last-enum-hash-table)
	       "Immediate type")

  (eval-when
          (:compile-toplevel    :load-toplevel    :execute)
           	 (defconstant
            #.(read-from-string     "+type-immediate-p+")
           	  		(parse-integer  "01" :radix    16)
           	   	       "Immediate type"))

  (setf  (gethash    	(parse-integer  "02" :radix    16)         last-enum-hash-table)
	       "Object cant be allocated persistently.")

  (eval-when
          (:compile-toplevel    :load-toplevel    :execute)
           	 (defconstant
            #.(read-from-string     "+type-not-alloctable-p+")
           	  	(parse-integer  "02" :radix    16)
           	   	       "Object cant be allocated persistently."))

  (setf  (gethash    		(parse-integer  "04" :radix    16)         last-enum-hash-table)
	       "Instances of the type are transient.")

  (eval-when
          (:compile-toplevel    :load-toplevel    :execute)
           	 (defconstant
            #.(read-from-string     "+type-transient-p+")
           	  		(parse-integer  "04" :radix    16)
           	   	       "Instances of the type are transient."))

  (setf  (gethash    	(parse-integer  "08" :radix    16)         last-enum-hash-table)
	       "Type with variable sized objid field.")

  (eval-when
          (:compile-toplevel    :load-toplevel    :execute)
           	 (defconstant
            #.(read-from-string     "+type-var-size-objid-p+")
           	  	(parse-integer  "08" :radix    16)
           	   	       "Type with variable sized objid field."))

  (setf  (gethash    	(parse-integer  "10" :radix    16)         last-enum-hash-table)
	       "Type with an attached value field.")

  (eval-when
          (:compile-toplevel    :load-toplevel    :execute)
           	 (defconstant
            #.(read-from-string     "+type-var-size-value-p+")
           	  	(parse-integer  "10" :radix    16)
           	   	       "Type with an attached value field."))

  (setf  (gethash    		(parse-integer  "20" :radix    16)         last-enum-hash-table)
	       "Destroyed objects are recycled for create.")

  (eval-when
          (:compile-toplevel    :load-toplevel    :execute)
           	 (defconstant
            #.(read-from-string     "+type-recycle-p+")
           	  		(parse-integer  "20" :radix    16)
           	   	       "Destroyed objects are recycled for create."))

  (setf  (gethash    			(parse-integer  "40" :radix    16)         last-enum-hash-table)
	       "Mark for not yet implemented/limited supported types.")

  (eval-when
          (:compile-toplevel    :load-toplevel    :execute)
           	 (defconstant
            #.(read-from-string
	       "+type-not-yet-implemented")
           	  			(parse-integer  "40" :radix    16)
           	   	       "Mark for not yet implemented/limited supported types."))

  (setf  (gethash    				(parse-integer  "80" :radix    16)         last-enum-hash-table)
	       "Instances of this type must not be allocated in a client's cache.")

  (eval-when
          (:compile-toplevel    :load-toplevel    :execute)
           	 (defconstant
            #.(read-from-string
	       "+type-not-cachable-p")
           	  				(parse-integer  "80" :radix    16)
           	   	       "Instances of this type must not be allocated in a client's cache."))

)))

  (eval-when
          (:compile-toplevel    :load-toplevel    :execute)
           	 (defconstant
           C2L_TYPEFLAGS
           	:fixnum
           	"Constant defined by C macro EndEnum."))     ;


  (define-foreign-function
            #.C2L_BOOL
           	"fnShortObjIdValidP"
           	 #.(read-from-string    "c-sh-objid-valid-p")
      
		 ( (oShortObjId    #.C2L_SHORTOBJID      :value-in)
                   ))    ;


  (define-foreign-function
            #.:fixnum
           	"fnClientDbTypeTagName"
           	 #.(read-from-string    "c-sh-type-string")
      
		 ( (nTypeTag    #.C2L_SHTYPETAG      :value-in)
             

		   (pszBuffer    #.:string          :vector-out)
             

		   (nBuffer    #.:fixnum           :value-in)
                   ))    ;


  (define-foreign-function
            #.:fixnum
           	"fnClientObjectPrettyPrint"
           	 #.(read-from-string    "c-sh-pprint-objid")
      
		 ( (oShortObjIdHeap    #.C2L_SHORTOBJID      :value-in)
             

		   (oShortObjId    #.C2L_SHORTOBJID      :value-in)
             

		   (nTypeTag    #.C2L_SHTYPETAG      :value-in)
             

		   (lpszBuffer    #.:string
			      :vector-out)
             

		   (nBuffer    #.:fixnum           :value-in)
                   ))    ;


  (define-foreign-function
            #.:fixnum
           	"fnShortPrintSymbol"
           	 #.(read-from-string    "c-sh-pprint-symbol")
      
	         ( (oShortObjIdHeap    #.C2L_SHORTOBJID      :value-in)
             

		   (oShortSymbol    #.C2L_SHORTOBJID      :value-in)
             

		   (lpszBuffer    #.:string
			      :vector-out)
             

		   (nBuffer    #.:fixnum           :value-in)
                   ))    ;


  (define-foreign-function
            #.C2L_BOOL
           	"fnLISPmapClassInfoFirst"
           	 #.(read-from-string    "c-sh-map-class-info-first")
      
		 ( (pnTypeTag    #.C2L_SHTYPETAG      :value-out)
             

		   (lpszTypeName    #.:string
			      :vector-out)
             

		   (nTypeName    #.:fixnum           :value-in)
             

		   (pnObjIdSize    #.:fixnum           :value-out)
             

		   (pnValueSize   #.:fixnum           :value-out)
             

		   (pnTypeFlags    #.C2L_TYPEFLAGS      :value-out)
                   ))    ;


  (define-foreign-function
            #.C2L_BOOL
           	"fnLISPmapClassInfoNext"
           	 #.(read-from-string    "c-sh-map-class-info-next")
      
		 ( (pnTypeTag    #.C2L_SHTYPETAG      :value-out)
             

		   (lpszTypeName    #.:string
			      :vector-out)
             

		   (nTypeName    #.:fixnum           :value-in)
             

		   (pnObjIdSize    #.:fixnum           :value-out)
             

		   (pnValueSize    #.:fixnum           :value-out)
             

		   (pnTypeFlags    #.C2L_TYPEFLAGS      :value-out)
                   ))    ;

