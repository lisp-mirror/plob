#include <rpc/rpc.h>
#include "plobd.h"

/* ------------------------------------------------------------------------
| plobd.x generated by c2rpc on Mon Jun 21 22:59:02  1999
| c2rpc (C) 1996/09/19 Heiko Kirschke kirschke@informatik.uni-hamburg.de
 ----------------------------------------------------------------------- */

#if RPC_HDR
#include <rpc/rpc.h>
typedef CLIENT * PCLIENT;
#include <global.h>
#endif
#if 1 || RPC_SVC
#include <string.h>
#endif
#ifndef as_is
#define as_is void
#endif
#ifndef ABS
#define ABS(x) (((x)<0)?-(x):(x))
#endif
#ifndef MIN
#define MIN(x,y) (((x)<(y))?(x):(y))
#endif
#ifndef MAX
#define MAX(x,y) (((x)>(y))?(x):(y))
#endif
#ifndef PASTE
#define PASTE(token1,token2) token1##token2
#endif
#ifndef PASTE2
#define PASTE2(token1,token2) PASTE(token1,token2)
#endif
#ifndef EMPTY
#define EMPTY
#endif
#ifndef _SVCSUFFIX
#if LINUX
#define _SVCSUFFIX _svc
#else
#define _SVCSUFFIX EMPTY
#endif
#endif
#if !defined(DLLEXPORT)
#if WIN32
#if (BUILDDLL+0)
#define DLLEXPORT __attribute__(( dllexport )) __attribute__((__cdecl__))
#else
#define DLLEXPORT __attribute__(( dllimport )) __attribute__((__cdecl__))
#endif
#else
#define DLLEXPORT
#endif
#endif
#if !defined(DLLEXPORTVAR)
#if WIN32
#if (BUILDDLL+0)
#define DLLEXPORTVAR __attribute__(( dllexport ))
#else
#define DLLEXPORTVAR __attribute__(( dllimport ))
#endif
#else
#define DLLEXPORTVAR
#endif
#endif


#if ! defined(AlignBitsToWords)
#define AlignBitsToWords( nSizeInBits ) (int ) ( ( (nSizeInBits) + nSizeOfPostoreWord * nBitsPerByte -1 ) / ( nSizeOfPostoreWord * nBitsPerByte ) )
#endif



extern DLLEXPORTVAR int __bInitializePlob__ ;
extern DLLEXPORTVAR int __bDeinitializePlob__ ;
void fnServerInitializePlob ( int argc,char * argv [] );
#if ! defined(INITIALIZEPLOB)
void fnInitializePlob ( void );
#define INITIALIZEPLOB ((__bInitializePlob__)? (fnInitializePlob(),TRUE):FALSE)
#endif

#if (RPC_SVC+0)

extern DLLEXPORTVAR int nGlobalStored;
extern DLLEXPORTVAR OBJID oGlobalSession;

#if !defined(UNSTORESESSION)
#define UNSTORESESSION() (__bJmpBufErrorValid__=FALSE,nGlobalStored=0,oGlobalSession=NULLOBJID)
#endif
#if !defined(UnstoreSession)
#define UnstoreSession() ((--nGlobalStored==0)?(UNSTORESESSION(),TRUE):FALSE)
#endif

extern DLLEXPORTVAR LPCSTR __lpszErrorMessage__;
extern DLLEXPORTVAR ERRLVL __nErrorLevel__;


#define RPC_SERVER_INITIALIZE(argc,argv) fnServerInitializePlob(argc,argv)


#define RPC_SERVER_ENTRY() { UNSTORESESSION (); __nErrorLevel__ = errLvl0; if ( __lpszErrorMessage__ != NULL ) { free ( (LPVOID) __lpszErrorMessage__ ); __lpszErrorMessage__ = (LPCSTR) NULL; } INITIALIZEPLOB;}
#define RPC_SERVER_ERRLVL() ((__bDeinitializePlob__)?0:__nErrorLevel__)
#define RPC_SERVER_ERRMSG() ((__bDeinitializePlob__)?(LPCSTR) NULL:__lpszErrorMessage__)

#include <rpc/rpc.h>
#include <rpc/svc.h>

void fnInitializeAfterRegister ( void );
static void fnSvcRun ( void )
{
 INITIALIZEPLOB;
 fnInitializeAfterRegister ();
 svc_run();
}

#ifdef svc_run
#undef svc_run
#endif
#define svc_run fnSvcRun

#endif

#if (1+0)

#define RPC_CLIENT_INITIALIZE() INITIALIZEPLOB

extern PCLIENT fnClientCreate ( LPCSTR pszHost,
 LPCSTR pszTransport );
#define RPC_CLIENT_CREATE(host,transport) fnClientCreate ( host,transport )

extern PCLIENT fnClientDestroy ( PCLIENT pClient );
#define RPC_CLIENT_DESTROY(pclient) fnClientDestroy ( pclient )

#define RPC_CLIENT_ERROR(msg) ((__bDeinitializePlob__)? FALSE: (fnLISPerrorCallback(errLvlError,NULL,msg),TRUE))
#define RPC_CLIENT_CERROR(cont,msg) ((__bDeinitializePlob__)? FALSE: (fnLISPerrorCallback(errLvlCError,cont,msg),TRUE))
#define RPC_CLIENT_SERROR(lvl,proc,msg) ((__bDeinitializePlob__)? FALSE: (fnLISPserrorCallback(lvl,proc,msg),TRUE))

#endif

#if (RPC_SVC+0)||(1+0)

#define xdr_fnServerObjectReadValues_rets xdr_fnPatchedServerObjectReadValues_rets
#define xdr_fnServerObjectWriteValues_args xdr_fnPatchedServerObjectWriteValues_args
#define xdr_fnServerObjectPeekValues_rets xdr_fnPatchedServerObjectPeekValues_rets
#define xdr_fnServerObjectPoke_args xdr_fnPatchedServerObjectPoke_args
#include "plobpxdr.h"

#endif



#define	SIZEOF(type)((sizeof(type)<1)?1:sizeof(type))

static RPCVERSION __Version__ = 1;

RPCVERSION DLLEXPORT	fnPlobdGetVersion	( void )
{
  return __Version__;
} /* fnPlobdGetVersion */

RPCVERSION DLLEXPORT	fnPlobdSetVersion	( RPCVERSION	lVersionNew )
{
  RPCVERSION	lVersionOld	= __Version__;
  __Version__	= lVersionNew;
  return lVersionOld;
} /* fnPlobdSetVersion */

static const RPCPORT __PortOffset__ = 0x20506E62;
static RPCPORT __Port__ = 0;

RPCPORT DLLEXPORT	fnPlobdGetPortOffset	( void )
{
  return __PortOffset__;
} /* fnPlobdGetPortOffset */

RPCPORT DLLEXPORT	fnPlobdGetPort	( void )
{
  return __Port__;
} /* fnPlobdGetPort */

RPCPORT DLLEXPORT	fnPlobdSetPort	( RPCPORT	lPortNew )
{
  RPCPORT	lPortOld	= __Port__;
  __Port__	= lPortNew;
  return lPortOld;
} /* fnPlobdSetPort */

#ifdef PLOBD
#undef PLOBD
#endif /* PLOBD */
#define PLOBD	((u_long)fnPlobdGetPortOffset()+(u_long)fnPlobdGetPort())

#ifdef PLOBDVERS
#undef PLOBDVERS
#endif /* PLOBDVERS */
#define PLOBDVERS	((u_long)fnPlobdGetVersion())

 /* static char		szEmpty []	= ""; */


static bool_t	__bClientInitialize__	= TRUE;
static char	__szHost__ [ 256 ]	= "";
static char	__szTransport__ [ 256 ]	= "";
static PCLIENT	__pClient__	= NULL;

static const char	szFormatNullPassed []	=
"%s: A NULL pointer was passed for the %s argument.";
static const char	szContNullPassed []	=
"Set associated buffer size to 0.";

static const char	szFormatNullString []	=
"%s: A NULL string was passed for the %s argument.";
static const char	szContNullString []	=
"Handle as empty string of length 0.";

static const char	szContNullOutPassed []	=
"Dont copy back the values returned from the server.";

static const char	szFormatNoServer []	=
"%s: No connection to server established.";
static const char	szContNoServer []	=
"(Re)try to connect to a server.";

static const char	szFormatRpcFailed []	=
"%s: RPC call failed:\n       %s";
static const char	szContRpcFailed []	=
"Return from client procedure.";

static const char	szFormatBufferOverflow []	=
"%s: Output buffer size for argument %s is %d, server returned a buffer size of %d.";
static const char	szContBufferOverflow []	=
"Ignore the additional values returned from server.";

static struct timeval	NullTimeout	= {  0, 0 };
static struct timeval	DefaultTimeout	= { 20, 0 };

#ifndef	RPC_CLIENT_CREATE
#define	RPC_CLIENT_CREATE(host,transport)	fnClientPlobdCreate ( host, transport )
#define	CLIENT_CREATE_BY_USER	0
#else
#define	CLIENT_CREATE_BY_USER	1
#endif	/* ! RPC_CLIENT_CREATE */

#ifndef	RPC_CLIENT_DESTROY
#define	RPC_CLIENT_DESTROY(pclient)	fnClientPlobdDestroy ( pclient )
#endif	/* ! RPC_CLIENT_DESTROY */

#ifndef	RPC_CLIENT_INITIALIZE
#define	RPC_CLIENT_INITIALIZE()
#endif	/* ! RPC_CLIENT_INITIALIZE */

#ifndef	RPC_CLIENT_ERROR
#define	RPC_CLIENT_ERROR(msg)\
	{fprintf(stderr,"Error: %s\n",msg);clnt_perror(__pClient__,__szHost__);exit(1);}
#endif	/* ! RPC_CLIENT_ERROR */

#ifndef	RPC_CLIENT_CERROR
static const char	szFormatCError []	=
"Continuable error: %s\n%s\n";
#define	RPC_CLIENT_CERROR(cont,msg)	fprintf(stderr,szFormatCError,msg,cont)
#endif	/* ! RPC_CLIENT_CERROR */

#ifndef	RPC_CLIENT_SERROR
static const char	szFormatSError []	=
"%s: Server error, level %d: %s\n";
#define	RPC_CLIENT_SERROR(lvl,proc,msg)	fprintf(stderr,szFormatSError,proc,lvl,msg)
#endif	/* ! RPC_CLIENT_SERROR */



PCLIENT DLLEXPORT fnClientPlobdCreate
	( LPCSTR pszHost, LPCSTR pszTransport )
{

  fnClientPlobdDestroy ( __pClient__ );
  strncpy ( __szHost__, pszHost, sizeof ( __szHost__ ) );
  strncpy ( __szTransport__, pszTransport,
            sizeof ( __szTransport__ ) );
  __pClient__    = clnt_create ( pszHost, PLOBD,
                                    PLOBDVERS, pszTransport );
  return __pClient__;
} /* fnClientPlobdCreate */

PCLIENT DLLEXPORT fnClientPlobd	( void )
{
  return __pClient__;
} /* fnClientPlobd */

LPCSTR DLLEXPORT fnClientPlobdHost	( void )
{
  return __szHost__;
} /* fnClientPlobdHost */

LPCSTR DLLEXPORT fnClientPlobdTransport	( void )
{
  return __szTransport__;
} /* fnClientPlobdTransport */

bool_t DLLEXPORT fnClientPlobdFlush	( PCLIENT pClient )
{
  enum clnt_stat	nState;

  if ( pClient == NULL ) {
    pClient	= __pClient__;
  }
  if ( pClient != NULL ) {
    nState = clnt_call ( pClient, NULLPROC,
                         (xdrproc_t) xdr_void, (caddr_t) NULL,
                         (xdrproc_t) xdr_void, (caddr_t) NULL,
                         DefaultTimeout );
    return ( nState == RPC_SUCCESS );
  }
  return FALSE;
} /* fnClientPlobdFlush */

PCLIENT DLLEXPORT fnClientPlobdDestroy	( PCLIENT pClient )
{
  if ( pClient == NULL ) {
    pClient	= __pClient__;
  }
  if ( pClient != NULL ) {
    auth_destroy ( pClient->cl_auth );
    clnt_destroy ( pClient );
  }
  if ( __pClient__ == pClient ) {
    __pClient__	= NULL;
  }
  pClient	= NULL;
  return pClient;
} /* fnClientPlobdDestroy */




SHORTOBJID DLLEXPORT fnClientDbReadRoot
	(SHORTOBJID oShortObjIdHeap)
{
  static const char	__procedure__[]	= "client:fnClientDbReadRoot";
  static fnClientDbReadRoot_rets	ZeroResult;
  fnClientDbReadRoot_rets		* pResult = NULL;
  fnClientDbReadRoot_rets		Result = ZeroResult;

  /* Client initialization: */
  if ( __bClientInitialize__ ) {
    __bClientInitialize__	= FALSE;
    RPC_CLIENT_INITIALIZE();
  }

#if	CLIENT_CREATE_BY_USER
  if ( __pClient__ == NULL ) {
    __pClient__	= RPC_CLIENT_CREATE ( __szHost__, __szTransport__ );
    if ( __pClient__ == NULL ) {
      /* Error handling for a not connected client: */
      char	szError [ 256 ];
      sprintf ( szError, szFormatNoServer, __procedure__ );
      RPC_CLIENT_ERROR ( szError );
      return Result.ReturnValue;
    }
  }
#else
  while ( __pClient__ == NULL ) {
    __pClient__	= RPC_CLIENT_CREATE ( __szHost__, __szTransport__ );
    if ( __pClient__ == NULL ) {
      /* Error handling for a not connected client: */
      char	szError [ 256 ];
      sprintf ( szError, szFormatNoServer, __procedure__ );
      RPC_CLIENT_CERROR ( szContNoServer, szError );
    }
  }
#endif	/* CLIENT_CREATE_BY_USER */

  pResult	=
#ifdef MULTITHREAD
    (
#else
    (fnClientDbReadRoot_rets *)
#endif
    fnrpc_fnclientdbreadroot_1 (
	&oShortObjIdHeap,
#ifdef MULTITHREAD
	&Result,
#endif
	__pClient__ )
#ifdef MULTITHREAD
	== RPC_SUCCESS ) ? &Result : NULL
#endif
	;

  if ( pResult == NULL ) {
    /* Error handling for a failed RPC call, */
    /* i.e. the server did not respond: */
    char	szError [ 256 ];
    sprintf ( szError, szFormatRpcFailed, __procedure__,
              clnt_sperror ( __pClient__, __szHost__ ) );
    __pClient__	= RPC_CLIENT_DESTROY ( __pClient__ );
    RPC_CLIENT_CERROR ( szContRpcFailed, szError );
    Result	= ZeroResult;
    return Result.ReturnValue;
  }
#ifndef MULTITHREAD
  Result	= * pResult;
#endif


  if ( pResult && pResult->nErrorLvl ) {
    /* Server returned a user error message: */
    char	szErrorMsg [ 1024 ];
    strncpy ( szErrorMsg,
              ( pResult->pszErrorMsg && pResult->pszErrorMsg [ 0 ] ) ?
              (LPCSTR) pResult->pszErrorMsg : (LPCSTR) szEmpty,
              sizeof ( szErrorMsg ) );
    szErrorMsg [ sizeof ( szErrorMsg ) - 1 ]	= (char) 0;
    xdr_free ( (xdrproc_t) xdr_fnClientDbReadRoot_rets, (char *) pResult );
    RPC_CLIENT_SERROR ( pResult->nErrorLvl, __procedure__,
                        szErrorMsg );
  } else {
    xdr_free ( (xdrproc_t) xdr_fnClientDbReadRoot_rets, (char *) pResult );
  }

  return Result.ReturnValue;

} /* fnClientDbReadRoot */



SHORTOBJID DLLEXPORT fnServerDbWriteRoot
	(SHORTOBJID oShortObjIdHeap ,
	  SHORTOBJID oShortObjId)
{
  static const char	__procedure__[]	= "client:fnServerDbWriteRoot";
  static fnServerDbWriteRoot_rets	ZeroResult;
  fnServerDbWriteRoot_rets		* pResult = NULL;
  fnServerDbWriteRoot_rets		Result = ZeroResult;
  fnServerDbWriteRoot_args	InArguments;

  /* Client initialization: */
  if ( __bClientInitialize__ ) {
    __bClientInitialize__	= FALSE;
    RPC_CLIENT_INITIALIZE();
  }

#if	CLIENT_CREATE_BY_USER
  if ( __pClient__ == NULL ) {
    __pClient__	= RPC_CLIENT_CREATE ( __szHost__, __szTransport__ );
    if ( __pClient__ == NULL ) {
      /* Error handling for a not connected client: */
      char	szError [ 256 ];
      sprintf ( szError, szFormatNoServer, __procedure__ );
      RPC_CLIENT_ERROR ( szError );
      return Result.ReturnValue;
    }
  }
#else
  while ( __pClient__ == NULL ) {
    __pClient__	= RPC_CLIENT_CREATE ( __szHost__, __szTransport__ );
    if ( __pClient__ == NULL ) {
      /* Error handling for a not connected client: */
      char	szError [ 256 ];
      sprintf ( szError, szFormatNoServer, __procedure__ );
      RPC_CLIENT_CERROR ( szContNoServer, szError );
    }
  }
#endif	/* CLIENT_CREATE_BY_USER */

  /* Copy in the oShortObjIdHeap argument: */
  InArguments.oShortObjIdHeap	= oShortObjIdHeap;
  /* Copy in the oShortObjId argument: */
  InArguments.oShortObjId	= oShortObjId;

  pResult	=
#ifdef MULTITHREAD
    (
#else
    (fnServerDbWriteRoot_rets *)
#endif
    fnrpc_fnserverdbwriteroot_1 (
	&InArguments,
#ifdef MULTITHREAD
	&Result,
#endif
	__pClient__ )
#ifdef MULTITHREAD
	== RPC_SUCCESS ) ? &Result : NULL
#endif
	;

  if ( pResult == NULL ) {
    /* Error handling for a failed RPC call, */
    /* i.e. the server did not respond: */
    char	szError [ 256 ];
    sprintf ( szError, szFormatRpcFailed, __procedure__,
              clnt_sperror ( __pClient__, __szHost__ ) );
    __pClient__	= RPC_CLIENT_DESTROY ( __pClient__ );
    RPC_CLIENT_CERROR ( szContRpcFailed, szError );
    Result	= ZeroResult;
    return Result.ReturnValue;
  }
#ifndef MULTITHREAD
  Result	= * pResult;
#endif


  if ( pResult && pResult->nErrorLvl ) {
    /* Server returned a user error message: */
    char	szErrorMsg [ 1024 ];
    strncpy ( szErrorMsg,
              ( pResult->pszErrorMsg && pResult->pszErrorMsg [ 0 ] ) ?
              (LPCSTR) pResult->pszErrorMsg : (LPCSTR) szEmpty,
              sizeof ( szErrorMsg ) );
    szErrorMsg [ sizeof ( szErrorMsg ) - 1 ]	= (char) 0;
    xdr_free ( (xdrproc_t) xdr_fnServerDbWriteRoot_rets, (char *) pResult );
    RPC_CLIENT_SERROR ( pResult->nErrorLvl, __procedure__,
                        szErrorMsg );
  } else {
    xdr_free ( (xdrproc_t) xdr_fnServerDbWriteRoot_rets, (char *) pResult );
  }

  return Result.ReturnValue;

} /* fnServerDbWriteRoot */



SHORTOBJID DLLEXPORT fnClientDbSessions
	(SHORTOBJID oShortObjIdHeap)
{
  static const char	__procedure__[]	= "client:fnClientDbSessions";
  static fnClientDbSessions_rets	ZeroResult;
  fnClientDbSessions_rets		* pResult = NULL;
  fnClientDbSessions_rets		Result = ZeroResult;

  /* Client initialization: */
  if ( __bClientInitialize__ ) {
    __bClientInitialize__	= FALSE;
    RPC_CLIENT_INITIALIZE();
  }

#if	CLIENT_CREATE_BY_USER
  if ( __pClient__ == NULL ) {
    __pClient__	= RPC_CLIENT_CREATE ( __szHost__, __szTransport__ );
    if ( __pClient__ == NULL ) {
      /* Error handling for a not connected client: */
      char	szError [ 256 ];
      sprintf ( szError, szFormatNoServer, __procedure__ );
      RPC_CLIENT_ERROR ( szError );
      return Result.ReturnValue;
    }
  }
#else
  while ( __pClient__ == NULL ) {
    __pClient__	= RPC_CLIENT_CREATE ( __szHost__, __szTransport__ );
    if ( __pClient__ == NULL ) {
      /* Error handling for a not connected client: */
      char	szError [ 256 ];
      sprintf ( szError, szFormatNoServer, __procedure__ );
      RPC_CLIENT_CERROR ( szContNoServer, szError );
    }
  }
#endif	/* CLIENT_CREATE_BY_USER */

  pResult	=
#ifdef MULTITHREAD
    (
#else
    (fnClientDbSessions_rets *)
#endif
    fnrpc_fnclientdbsessions_1 (
	&oShortObjIdHeap,
#ifdef MULTITHREAD
	&Result,
#endif
	__pClient__ )
#ifdef MULTITHREAD
	== RPC_SUCCESS ) ? &Result : NULL
#endif
	;

  if ( pResult == NULL ) {
    /* Error handling for a failed RPC call, */
    /* i.e. the server did not respond: */
    char	szError [ 256 ];
    sprintf ( szError, szFormatRpcFailed, __procedure__,
              clnt_sperror ( __pClient__, __szHost__ ) );
    __pClient__	= RPC_CLIENT_DESTROY ( __pClient__ );
    RPC_CLIENT_CERROR ( szContRpcFailed, szError );
    Result	= ZeroResult;
    return Result.ReturnValue;
  }
#ifndef MULTITHREAD
  Result	= * pResult;
#endif


  if ( pResult && pResult->nErrorLvl ) {
    /* Server returned a user error message: */
    char	szErrorMsg [ 1024 ];
    strncpy ( szErrorMsg,
              ( pResult->pszErrorMsg && pResult->pszErrorMsg [ 0 ] ) ?
              (LPCSTR) pResult->pszErrorMsg : (LPCSTR) szEmpty,
              sizeof ( szErrorMsg ) );
    szErrorMsg [ sizeof ( szErrorMsg ) - 1 ]	= (char) 0;
    xdr_free ( (xdrproc_t) xdr_fnClientDbSessions_rets, (char *) pResult );
    RPC_CLIENT_SERROR ( pResult->nErrorLvl, __procedure__,
                        szErrorMsg );
  } else {
    xdr_free ( (xdrproc_t) xdr_fnClientDbSessions_rets, (char *) pResult );
  }

  return Result.ReturnValue;

} /* fnClientDbSessions */



int DLLEXPORT fnServerGetVersion
	(SHORTOBJID oShortObjIdHeap ,
	  GETVERSION eWhat)
{
  static const char	__procedure__[]	= "client:fnServerGetVersion";
  static fnServerGetVersion_rets	ZeroResult;
  fnServerGetVersion_rets		* pResult = NULL;
  fnServerGetVersion_rets		Result = ZeroResult;
  fnServerGetVersion_args	InArguments;

  /* Client initialization: */
  if ( __bClientInitialize__ ) {
    __bClientInitialize__	= FALSE;
    RPC_CLIENT_INITIALIZE();
  }

#if	CLIENT_CREATE_BY_USER
  if ( __pClient__ == NULL ) {
    __pClient__	= RPC_CLIENT_CREATE ( __szHost__, __szTransport__ );
    if ( __pClient__ == NULL ) {
      /* Error handling for a not connected client: */
      char	szError [ 256 ];
      sprintf ( szError, szFormatNoServer, __procedure__ );
      RPC_CLIENT_ERROR ( szError );
      return Result.ReturnValue;
    }
  }
#else
  while ( __pClient__ == NULL ) {
    __pClient__	= RPC_CLIENT_CREATE ( __szHost__, __szTransport__ );
    if ( __pClient__ == NULL ) {
      /* Error handling for a not connected client: */
      char	szError [ 256 ];
      sprintf ( szError, szFormatNoServer, __procedure__ );
      RPC_CLIENT_CERROR ( szContNoServer, szError );
    }
  }
#endif	/* CLIENT_CREATE_BY_USER */

  /* Copy in the oShortObjIdHeap argument: */
  InArguments.oShortObjIdHeap	= oShortObjIdHeap;
  /* Copy in the eWhat argument: */
  InArguments.eWhat	= eWhat;

  pResult	=
#ifdef MULTITHREAD
    (
#else
    (fnServerGetVersion_rets *)
#endif
    fnrpc_fnservergetversion_1 (
	&InArguments,
#ifdef MULTITHREAD
	&Result,
#endif
	__pClient__ )
#ifdef MULTITHREAD
	== RPC_SUCCESS ) ? &Result : NULL
#endif
	;

  if ( pResult == NULL ) {
    /* Error handling for a failed RPC call, */
    /* i.e. the server did not respond: */
    char	szError [ 256 ];
    sprintf ( szError, szFormatRpcFailed, __procedure__,
              clnt_sperror ( __pClient__, __szHost__ ) );
    __pClient__	= RPC_CLIENT_DESTROY ( __pClient__ );
    RPC_CLIENT_CERROR ( szContRpcFailed, szError );
    Result	= ZeroResult;
    return Result.ReturnValue;
  }
#ifndef MULTITHREAD
  Result	= * pResult;
#endif


  if ( pResult && pResult->nErrorLvl ) {
    /* Server returned a user error message: */
    char	szErrorMsg [ 1024 ];
    strncpy ( szErrorMsg,
              ( pResult->pszErrorMsg && pResult->pszErrorMsg [ 0 ] ) ?
              (LPCSTR) pResult->pszErrorMsg : (LPCSTR) szEmpty,
              sizeof ( szErrorMsg ) );
    szErrorMsg [ sizeof ( szErrorMsg ) - 1 ]	= (char) 0;
    xdr_free ( (xdrproc_t) xdr_fnServerGetVersion_rets, (char *) pResult );
    RPC_CLIENT_SERROR ( pResult->nErrorLvl, __procedure__,
                        szErrorMsg );
  } else {
    xdr_free ( (xdrproc_t) xdr_fnServerGetVersion_rets, (char *) pResult );
  }

  return Result.ReturnValue;

} /* fnServerGetVersion */



SHORTOBJID DLLEXPORT fnClientDbCreateMachine
	(SHORTOBJID oShortObjIdHeap ,
	  int * /* _vector_t<4> */ nAddr ,
	  MACHLOGINP eLoginP)
{
  static const char	__procedure__[]	= "client:fnClientDbCreateMachine";
  static fnClientDbCreateMachine_rets	ZeroResult;
  fnClientDbCreateMachine_rets		* pResult = NULL;
  fnClientDbCreateMachine_rets		Result = ZeroResult;
  fnClientDbCreateMachine_args	InArguments;

  /* Client initialization: */
  if ( __bClientInitialize__ ) {
    __bClientInitialize__	= FALSE;
    RPC_CLIENT_INITIALIZE();
  }

#if	CLIENT_CREATE_BY_USER
  if ( __pClient__ == NULL ) {
    __pClient__	= RPC_CLIENT_CREATE ( __szHost__, __szTransport__ );
    if ( __pClient__ == NULL ) {
      /* Error handling for a not connected client: */
      char	szError [ 256 ];
      sprintf ( szError, szFormatNoServer, __procedure__ );
      RPC_CLIENT_ERROR ( szError );
      return Result.ReturnValue;
    }
  }
#else
  while ( __pClient__ == NULL ) {
    __pClient__	= RPC_CLIENT_CREATE ( __szHost__, __szTransport__ );
    if ( __pClient__ == NULL ) {
      /* Error handling for a not connected client: */
      char	szError [ 256 ];
      sprintf ( szError, szFormatNoServer, __procedure__ );
      RPC_CLIENT_CERROR ( szContNoServer, szError );
    }
  }
#endif	/* CLIENT_CREATE_BY_USER */

  /* Copy in the oShortObjIdHeap argument: */
  InArguments.oShortObjIdHeap	= oShortObjIdHeap;
  /* Copy in the nAddr argument: */
  InArguments.nAddr.int_vector_t_len	= 4;
  InArguments.nAddr.int_vector_t_val	= nAddr;
  if ( InArguments.nAddr.int_vector_t_len != 0 && nAddr == NULL ) {
    /* Error handling for passing a NULL pointer on */
    /* VECTOR declared in argument: */
    char	szError [ 256 ];
    InArguments.nAddr.int_vector_t_len	= 0;
    sprintf ( szError, szFormatNullPassed,
              __procedure__, "nAddr" );
    RPC_CLIENT_CERROR ( szContNullPassed, szError );
  }
  /* Copy in the eLoginP argument: */
  InArguments.eLoginP	= eLoginP;

  pResult	=
#ifdef MULTITHREAD
    (
#else
    (fnClientDbCreateMachine_rets *)
#endif
    fnrpc_fnclientdbcreatemachine_1 (
	&InArguments,
#ifdef MULTITHREAD
	&Result,
#endif
	__pClient__ )
#ifdef MULTITHREAD
	== RPC_SUCCESS ) ? &Result : NULL
#endif
	;

  if ( pResult == NULL ) {
    /* Error handling for a failed RPC call, */
    /* i.e. the server did not respond: */
    char	szError [ 256 ];
    sprintf ( szError, szFormatRpcFailed, __procedure__,
              clnt_sperror ( __pClient__, __szHost__ ) );
    __pClient__	= RPC_CLIENT_DESTROY ( __pClient__ );
    RPC_CLIENT_CERROR ( szContRpcFailed, szError );
    Result	= ZeroResult;
    return Result.ReturnValue;
  }
#ifndef MULTITHREAD
  Result	= * pResult;
#endif


  if ( pResult && pResult->nErrorLvl ) {
    /* Server returned a user error message: */
    char	szErrorMsg [ 1024 ];
    strncpy ( szErrorMsg,
              ( pResult->pszErrorMsg && pResult->pszErrorMsg [ 0 ] ) ?
              (LPCSTR) pResult->pszErrorMsg : (LPCSTR) szEmpty,
              sizeof ( szErrorMsg ) );
    szErrorMsg [ sizeof ( szErrorMsg ) - 1 ]	= (char) 0;
    xdr_free ( (xdrproc_t) xdr_fnClientDbCreateMachine_rets, (char *) pResult );
    RPC_CLIENT_SERROR ( pResult->nErrorLvl, __procedure__,
                        szErrorMsg );
  } else {
    xdr_free ( (xdrproc_t) xdr_fnClientDbCreateMachine_rets, (char *) pResult );
  }

  return Result.ReturnValue;

} /* fnClientDbCreateMachine */



MACHLOGINP DLLEXPORT fnClientMachineLoginP
	(SHORTOBJID oShortObjIdHeap ,
	  SHORTOBJID oShortMachine ,
	  MACHLOGINP eLoginP)
{
  static const char	__procedure__[]	= "client:fnClientMachineLoginP";
  static fnClientMachineLoginP_rets	ZeroResult;
  fnClientMachineLoginP_rets		* pResult = NULL;
  fnClientMachineLoginP_rets		Result = ZeroResult;
  fnClientMachineLoginP_args	InArguments;

  /* Client initialization: */
  if ( __bClientInitialize__ ) {
    __bClientInitialize__	= FALSE;
    RPC_CLIENT_INITIALIZE();
  }

#if	CLIENT_CREATE_BY_USER
  if ( __pClient__ == NULL ) {
    __pClient__	= RPC_CLIENT_CREATE ( __szHost__, __szTransport__ );
    if ( __pClient__ == NULL ) {
      /* Error handling for a not connected client: */
      char	szError [ 256 ];
      sprintf ( szError, szFormatNoServer, __procedure__ );
      RPC_CLIENT_ERROR ( szError );
      return Result.ReturnValue;
    }
  }
#else
  while ( __pClient__ == NULL ) {
    __pClient__	= RPC_CLIENT_CREATE ( __szHost__, __szTransport__ );
    if ( __pClient__ == NULL ) {
      /* Error handling for a not connected client: */
      char	szError [ 256 ];
      sprintf ( szError, szFormatNoServer, __procedure__ );
      RPC_CLIENT_CERROR ( szContNoServer, szError );
    }
  }
#endif	/* CLIENT_CREATE_BY_USER */

  /* Copy in the oShortObjIdHeap argument: */
  InArguments.oShortObjIdHeap	= oShortObjIdHeap;
  /* Copy in the oShortMachine argument: */
  InArguments.oShortMachine	= oShortMachine;
  /* Copy in the eLoginP argument: */
  InArguments.eLoginP	= eLoginP;

  pResult	=
#ifdef MULTITHREAD
    (
#else
    (fnClientMachineLoginP_rets *)
#endif
    fnrpc_fnclientmachineloginp_1 (
	&InArguments,
#ifdef MULTITHREAD
	&Result,
#endif
	__pClient__ )
#ifdef MULTITHREAD
	== RPC_SUCCESS ) ? &Result : NULL
#endif
	;

  if ( pResult == NULL ) {
    /* Error handling for a failed RPC call, */
    /* i.e. the server did not respond: */
    char	szError [ 256 ];
    sprintf ( szError, szFormatRpcFailed, __procedure__,
              clnt_sperror ( __pClient__, __szHost__ ) );
    __pClient__	= RPC_CLIENT_DESTROY ( __pClient__ );
    RPC_CLIENT_CERROR ( szContRpcFailed, szError );
    Result	= ZeroResult;
    return Result.ReturnValue;
  }
#ifndef MULTITHREAD
  Result	= * pResult;
#endif


  if ( pResult && pResult->nErrorLvl ) {
    /* Server returned a user error message: */
    char	szErrorMsg [ 1024 ];
    strncpy ( szErrorMsg,
              ( pResult->pszErrorMsg && pResult->pszErrorMsg [ 0 ] ) ?
              (LPCSTR) pResult->pszErrorMsg : (LPCSTR) szEmpty,
              sizeof ( szErrorMsg ) );
    szErrorMsg [ sizeof ( szErrorMsg ) - 1 ]	= (char) 0;
    xdr_free ( (xdrproc_t) xdr_fnClientMachineLoginP_rets, (char *) pResult );
    RPC_CLIENT_SERROR ( pResult->nErrorLvl, __procedure__,
                        szErrorMsg );
  } else {
    xdr_free ( (xdrproc_t) xdr_fnClientMachineLoginP_rets, (char *) pResult );
  }

  return Result.ReturnValue;

} /* fnClientMachineLoginP */



bool_t DLLEXPORT fnClientMachineAddr
	(SHORTOBJID oShortObjIdHeap ,
	  SHORTOBJID oShortMachine ,
	  int * /* _vector_t<4> */  pnAddr)
{
  static const char	__procedure__[]	= "client:fnClientMachineAddr";
  static fnClientMachineAddr_rets	ZeroResult;
  fnClientMachineAddr_rets		* pResult = NULL;
  fnClientMachineAddr_rets		Result = ZeroResult;
  fnClientMachineAddr_args	InArguments;

  /* Client initialization: */
  if ( __bClientInitialize__ ) {
    __bClientInitialize__	= FALSE;
    RPC_CLIENT_INITIALIZE();
  }

#if	CLIENT_CREATE_BY_USER
  if ( __pClient__ == NULL ) {
    __pClient__	= RPC_CLIENT_CREATE ( __szHost__, __szTransport__ );
    if ( __pClient__ == NULL ) {
      /* Error handling for a not connected client: */
      char	szError [ 256 ];
      sprintf ( szError, szFormatNoServer, __procedure__ );
      RPC_CLIENT_ERROR ( szError );
      return Result.ReturnValue;
    }
  }
#else
  while ( __pClient__ == NULL ) {
    __pClient__	= RPC_CLIENT_CREATE ( __szHost__, __szTransport__ );
    if ( __pClient__ == NULL ) {
      /* Error handling for a not connected client: */
      char	szError [ 256 ];
      sprintf ( szError, szFormatNoServer, __procedure__ );
      RPC_CLIENT_CERROR ( szContNoServer, szError );
    }
  }
#endif	/* CLIENT_CREATE_BY_USER */

  /* Copy in the oShortObjIdHeap argument: */
  InArguments.oShortObjIdHeap	= oShortObjIdHeap;
  /* Copy in the oShortMachine argument: */
  InArguments.oShortMachine	= oShortMachine;
  InArguments.pnAddrSize	= 4;

  pResult	=
#ifdef MULTITHREAD
    (
#else
    (fnClientMachineAddr_rets *)
#endif
    fnrpc_fnclientmachineaddr_1 (
	&InArguments,
#ifdef MULTITHREAD
	&Result,
#endif
	__pClient__ )
#ifdef MULTITHREAD
	== RPC_SUCCESS ) ? &Result : NULL
#endif
	;

  if ( pResult == NULL ) {
    /* Error handling for a failed RPC call, */
    /* i.e. the server did not respond: */
    char	szError [ 256 ];
    sprintf ( szError, szFormatRpcFailed, __procedure__,
              clnt_sperror ( __pClient__, __szHost__ ) );
    __pClient__	= RPC_CLIENT_DESTROY ( __pClient__ );
    RPC_CLIENT_CERROR ( szContRpcFailed, szError );
    Result	= ZeroResult;
    return Result.ReturnValue;
  }
#ifndef MULTITHREAD
  Result	= * pResult;
#endif

  /* Copy out the pnAddr argument: */
  if ( ! ( 
       pResult->pnAddr.int_vector_t_len != 0 &&
       pnAddr == NULL ) ) {
    memcpy ( pnAddr,
             pResult->pnAddr.int_vector_t_val,
             MIN ( pResult->pnAddr.int_vector_t_len,
                   4 ) *
             SIZEOF ( *(pResult->pnAddr.int_vector_t_val) ) );
  }

  if ( pResult && pResult->nErrorLvl ) {
    /* Server returned a user error message: */
    char	szErrorMsg [ 1024 ];
    strncpy ( szErrorMsg,
              ( pResult->pszErrorMsg && pResult->pszErrorMsg [ 0 ] ) ?
              (LPCSTR) pResult->pszErrorMsg : (LPCSTR) szEmpty,
              sizeof ( szErrorMsg ) );
    szErrorMsg [ sizeof ( szErrorMsg ) - 1 ]	= (char) 0;
    xdr_free ( (xdrproc_t) xdr_fnClientMachineAddr_rets, (char *) pResult );
    RPC_CLIENT_SERROR ( pResult->nErrorLvl, __procedure__,
                        szErrorMsg );
  } else {
    xdr_free ( (xdrproc_t) xdr_fnClientMachineAddr_rets, (char *) pResult );
  }
  if ( 
       pResult->pnAddr.int_vector_t_len != 0 &&
       pnAddr == NULL ) {
    /* Error handling for passing a NULL pointer on */
    /* out argument: */
    char	szError [ 256 ];
    sprintf ( szError, szFormatNullPassed,
              __procedure__, "pnAddr" );
    RPC_CLIENT_CERROR ( szContNullOutPassed, szError );
  } else if ( pResult->pnAddr.int_vector_t_len > 4 ) {
      /* Error handling for an output buffer overflow, */
      /* i.e. the buffer size passed is too small: */
      /* For example, signal a CERROR here ... */
      char	szError [ 256 ];
      sprintf ( szError, szFormatBufferOverflow,
                __procedure__, "pnAddr", 
                4, 
                pResult->pnAddr.int_vector_t_len );
      RPC_CLIENT_CERROR ( szContBufferOverflow, szError );
  }

  return Result.ReturnValue;

} /* fnClientMachineAddr */



SHORTOBJID DLLEXPORT fnClientDbMachineSearch
	(SHORTOBJID oShortObjIdHeap ,
	  int * /* _vector_t<4> */ nAddr)
{
  static const char	__procedure__[]	= "client:fnClientDbMachineSearch";
  static fnClientDbMachineSearch_rets	ZeroResult;
  fnClientDbMachineSearch_rets		* pResult = NULL;
  fnClientDbMachineSearch_rets		Result = ZeroResult;
  fnClientDbMachineSearch_args	InArguments;

  /* Client initialization: */
  if ( __bClientInitialize__ ) {
    __bClientInitialize__	= FALSE;
    RPC_CLIENT_INITIALIZE();
  }

#if	CLIENT_CREATE_BY_USER
  if ( __pClient__ == NULL ) {
    __pClient__	= RPC_CLIENT_CREATE ( __szHost__, __szTransport__ );
    if ( __pClient__ == NULL ) {
      /* Error handling for a not connected client: */
      char	szError [ 256 ];
      sprintf ( szError, szFormatNoServer, __procedure__ );
      RPC_CLIENT_ERROR ( szError );
      return Result.ReturnValue;
    }
  }
#else
  while ( __pClient__ == NULL ) {
    __pClient__	= RPC_CLIENT_CREATE ( __szHost__, __szTransport__ );
    if ( __pClient__ == NULL ) {
      /* Error handling for a not connected client: */
      char	szError [ 256 ];
      sprintf ( szError, szFormatNoServer, __procedure__ );
      RPC_CLIENT_CERROR ( szContNoServer, szError );
    }
  }
#endif	/* CLIENT_CREATE_BY_USER */

  /* Copy in the oShortObjIdHeap argument: */
  InArguments.oShortObjIdHeap	= oShortObjIdHeap;
  /* Copy in the nAddr argument: */
  InArguments.nAddr.int_vector_t_len	= 4;
  InArguments.nAddr.int_vector_t_val	= nAddr;
  if ( InArguments.nAddr.int_vector_t_len != 0 && nAddr == NULL ) {
    /* Error handling for passing a NULL pointer on */
    /* VECTOR declared in argument: */
    char	szError [ 256 ];
    InArguments.nAddr.int_vector_t_len	= 0;
    sprintf ( szError, szFormatNullPassed,
              __procedure__, "nAddr" );
    RPC_CLIENT_CERROR ( szContNullPassed, szError );
  }

  pResult	=
#ifdef MULTITHREAD
    (
#else
    (fnClientDbMachineSearch_rets *)
#endif
    fnrpc_fnclientdbmachinesearch_1 (
	&InArguments,
#ifdef MULTITHREAD
	&Result,
#endif
	__pClient__ )
#ifdef MULTITHREAD
	== RPC_SUCCESS ) ? &Result : NULL
#endif
	;

  if ( pResult == NULL ) {
    /* Error handling for a failed RPC call, */
    /* i.e. the server did not respond: */
    char	szError [ 256 ];
    sprintf ( szError, szFormatRpcFailed, __procedure__,
              clnt_sperror ( __pClient__, __szHost__ ) );
    __pClient__	= RPC_CLIENT_DESTROY ( __pClient__ );
    RPC_CLIENT_CERROR ( szContRpcFailed, szError );
    Result	= ZeroResult;
    return Result.ReturnValue;
  }
#ifndef MULTITHREAD
  Result	= * pResult;
#endif


  if ( pResult && pResult->nErrorLvl ) {
    /* Server returned a user error message: */
    char	szErrorMsg [ 1024 ];
    strncpy ( szErrorMsg,
              ( pResult->pszErrorMsg && pResult->pszErrorMsg [ 0 ] ) ?
              (LPCSTR) pResult->pszErrorMsg : (LPCSTR) szEmpty,
              sizeof ( szErrorMsg ) );
    szErrorMsg [ sizeof ( szErrorMsg ) - 1 ]	= (char) 0;
    xdr_free ( (xdrproc_t) xdr_fnClientDbMachineSearch_rets, (char *) pResult );
    RPC_CLIENT_SERROR ( pResult->nErrorLvl, __procedure__,
                        szErrorMsg );
  } else {
    xdr_free ( (xdrproc_t) xdr_fnClientDbMachineSearch_rets, (char *) pResult );
  }

  return Result.ReturnValue;

} /* fnClientDbMachineSearch */



SHORTOBJID DLLEXPORT fnClientDbMachineDelete
	(SHORTOBJID oShortObjIdHeap ,
	  int * /* _vector_t<4> */ nAddr)
{
  static const char	__procedure__[]	= "client:fnClientDbMachineDelete";
  static fnClientDbMachineDelete_rets	ZeroResult;
  fnClientDbMachineDelete_rets		* pResult = NULL;
  fnClientDbMachineDelete_rets		Result = ZeroResult;
  fnClientDbMachineDelete_args	InArguments;

  /* Client initialization: */
  if ( __bClientInitialize__ ) {
    __bClientInitialize__	= FALSE;
    RPC_CLIENT_INITIALIZE();
  }

#if	CLIENT_CREATE_BY_USER
  if ( __pClient__ == NULL ) {
    __pClient__	= RPC_CLIENT_CREATE ( __szHost__, __szTransport__ );
    if ( __pClient__ == NULL ) {
      /* Error handling for a not connected client: */
      char	szError [ 256 ];
      sprintf ( szError, szFormatNoServer, __procedure__ );
      RPC_CLIENT_ERROR ( szError );
      return Result.ReturnValue;
    }
  }
#else
  while ( __pClient__ == NULL ) {
    __pClient__	= RPC_CLIENT_CREATE ( __szHost__, __szTransport__ );
    if ( __pClient__ == NULL ) {
      /* Error handling for a not connected client: */
      char	szError [ 256 ];
      sprintf ( szError, szFormatNoServer, __procedure__ );
      RPC_CLIENT_CERROR ( szContNoServer, szError );
    }
  }
#endif	/* CLIENT_CREATE_BY_USER */

  /* Copy in the oShortObjIdHeap argument: */
  InArguments.oShortObjIdHeap	= oShortObjIdHeap;
  /* Copy in the nAddr argument: */
  InArguments.nAddr.int_vector_t_len	= 4;
  InArguments.nAddr.int_vector_t_val	= nAddr;
  if ( InArguments.nAddr.int_vector_t_len != 0 && nAddr == NULL ) {
    /* Error handling for passing a NULL pointer on */
    /* VECTOR declared in argument: */
    char	szError [ 256 ];
    InArguments.nAddr.int_vector_t_len	= 0;
    sprintf ( szError, szFormatNullPassed,
              __procedure__, "nAddr" );
    RPC_CLIENT_CERROR ( szContNullPassed, szError );
  }

  pResult	=
#ifdef MULTITHREAD
    (
#else
    (fnClientDbMachineDelete_rets *)
#endif
    fnrpc_fnclientdbmachinedelete_1 (
	&InArguments,
#ifdef MULTITHREAD
	&Result,
#endif
	__pClient__ )
#ifdef MULTITHREAD
	== RPC_SUCCESS ) ? &Result : NULL
#endif
	;

  if ( pResult == NULL ) {
    /* Error handling for a failed RPC call, */
    /* i.e. the server did not respond: */
    char	szError [ 256 ];
    sprintf ( szError, szFormatRpcFailed, __procedure__,
              clnt_sperror ( __pClient__, __szHost__ ) );
    __pClient__	= RPC_CLIENT_DESTROY ( __pClient__ );
    RPC_CLIENT_CERROR ( szContRpcFailed, szError );
    Result	= ZeroResult;
    return Result.ReturnValue;
  }
#ifndef MULTITHREAD
  Result	= * pResult;
#endif


  if ( pResult && pResult->nErrorLvl ) {
    /* Server returned a user error message: */
    char	szErrorMsg [ 1024 ];
    strncpy ( szErrorMsg,
              ( pResult->pszErrorMsg && pResult->pszErrorMsg [ 0 ] ) ?
              (LPCSTR) pResult->pszErrorMsg : (LPCSTR) szEmpty,
              sizeof ( szErrorMsg ) );
    szErrorMsg [ sizeof ( szErrorMsg ) - 1 ]	= (char) 0;
    xdr_free ( (xdrproc_t) xdr_fnClientDbMachineDelete_rets, (char *) pResult );
    RPC_CLIENT_SERROR ( pResult->nErrorLvl, __procedure__,
                        szErrorMsg );
  } else {
    xdr_free ( (xdrproc_t) xdr_fnClientDbMachineDelete_rets, (char *) pResult );
  }

  return Result.ReturnValue;

} /* fnClientDbMachineDelete */



SHORTOBJID DLLEXPORT fnClientDbMachineInsert
	(SHORTOBJID oShortObjIdHeap ,
	  SHORTOBJID oShortMachine)
{
  static const char	__procedure__[]	= "client:fnClientDbMachineInsert";
  static fnClientDbMachineInsert_rets	ZeroResult;
  fnClientDbMachineInsert_rets		* pResult = NULL;
  fnClientDbMachineInsert_rets		Result = ZeroResult;
  fnClientDbMachineInsert_args	InArguments;

  /* Client initialization: */
  if ( __bClientInitialize__ ) {
    __bClientInitialize__	= FALSE;
    RPC_CLIENT_INITIALIZE();
  }

#if	CLIENT_CREATE_BY_USER
  if ( __pClient__ == NULL ) {
    __pClient__	= RPC_CLIENT_CREATE ( __szHost__, __szTransport__ );
    if ( __pClient__ == NULL ) {
      /* Error handling for a not connected client: */
      char	szError [ 256 ];
      sprintf ( szError, szFormatNoServer, __procedure__ );
      RPC_CLIENT_ERROR ( szError );
      return Result.ReturnValue;
    }
  }
#else
  while ( __pClient__ == NULL ) {
    __pClient__	= RPC_CLIENT_CREATE ( __szHost__, __szTransport__ );
    if ( __pClient__ == NULL ) {
      /* Error handling for a not connected client: */
      char	szError [ 256 ];
      sprintf ( szError, szFormatNoServer, __procedure__ );
      RPC_CLIENT_CERROR ( szContNoServer, szError );
    }
  }
#endif	/* CLIENT_CREATE_BY_USER */

  /* Copy in the oShortObjIdHeap argument: */
  InArguments.oShortObjIdHeap	= oShortObjIdHeap;
  /* Copy in the oShortMachine argument: */
  InArguments.oShortMachine	= oShortMachine;

  pResult	=
#ifdef MULTITHREAD
    (
#else
    (fnClientDbMachineInsert_rets *)
#endif
    fnrpc_fnclientdbmachineinsert_1 (
	&InArguments,
#ifdef MULTITHREAD
	&Result,
#endif
	__pClient__ )
#ifdef MULTITHREAD
	== RPC_SUCCESS ) ? &Result : NULL
#endif
	;

  if ( pResult == NULL ) {
    /* Error handling for a failed RPC call, */
    /* i.e. the server did not respond: */
    char	szError [ 256 ];
    sprintf ( szError, szFormatRpcFailed, __procedure__,
              clnt_sperror ( __pClient__, __szHost__ ) );
    __pClient__	= RPC_CLIENT_DESTROY ( __pClient__ );
    RPC_CLIENT_CERROR ( szContRpcFailed, szError );
    Result	= ZeroResult;
    return Result.ReturnValue;
  }
#ifndef MULTITHREAD
  Result	= * pResult;
#endif


  if ( pResult && pResult->nErrorLvl ) {
    /* Server returned a user error message: */
    char	szErrorMsg [ 1024 ];
    strncpy ( szErrorMsg,
              ( pResult->pszErrorMsg && pResult->pszErrorMsg [ 0 ] ) ?
              (LPCSTR) pResult->pszErrorMsg : (LPCSTR) szEmpty,
              sizeof ( szErrorMsg ) );
    szErrorMsg [ sizeof ( szErrorMsg ) - 1 ]	= (char) 0;
    xdr_free ( (xdrproc_t) xdr_fnClientDbMachineInsert_rets, (char *) pResult );
    RPC_CLIENT_SERROR ( pResult->nErrorLvl, __procedure__,
                        szErrorMsg );
  } else {
    xdr_free ( (xdrproc_t) xdr_fnClientDbMachineInsert_rets, (char *) pResult );
  }

  return Result.ReturnValue;

} /* fnClientDbMachineInsert */



SHORTOBJID DLLEXPORT fnClientDbMachines
	(SHORTOBJID oShortObjIdHeap)
{
  static const char	__procedure__[]	= "client:fnClientDbMachines";
  static fnClientDbMachines_rets	ZeroResult;
  fnClientDbMachines_rets		* pResult = NULL;
  fnClientDbMachines_rets		Result = ZeroResult;

  /* Client initialization: */
  if ( __bClientInitialize__ ) {
    __bClientInitialize__	= FALSE;
    RPC_CLIENT_INITIALIZE();
  }

#if	CLIENT_CREATE_BY_USER
  if ( __pClient__ == NULL ) {
    __pClient__	= RPC_CLIENT_CREATE ( __szHost__, __szTransport__ );
    if ( __pClient__ == NULL ) {
      /* Error handling for a not connected client: */
      char	szError [ 256 ];
      sprintf ( szError, szFormatNoServer, __procedure__ );
      RPC_CLIENT_ERROR ( szError );
      return Result.ReturnValue;
    }
  }
#else
  while ( __pClient__ == NULL ) {
    __pClient__	= RPC_CLIENT_CREATE ( __szHost__, __szTransport__ );
    if ( __pClient__ == NULL ) {
      /* Error handling for a not connected client: */
      char	szError [ 256 ];
      sprintf ( szError, szFormatNoServer, __procedure__ );
      RPC_CLIENT_CERROR ( szContNoServer, szError );
    }
  }
#endif	/* CLIENT_CREATE_BY_USER */

  pResult	=
#ifdef MULTITHREAD
    (
#else
    (fnClientDbMachines_rets *)
#endif
    fnrpc_fnclientdbmachines_1 (
	&oShortObjIdHeap,
#ifdef MULTITHREAD
	&Result,
#endif
	__pClient__ )
#ifdef MULTITHREAD
	== RPC_SUCCESS ) ? &Result : NULL
#endif
	;

  if ( pResult == NULL ) {
    /* Error handling for a failed RPC call, */
    /* i.e. the server did not respond: */
    char	szError [ 256 ];
    sprintf ( szError, szFormatRpcFailed, __procedure__,
              clnt_sperror ( __pClient__, __szHost__ ) );
    __pClient__	= RPC_CLIENT_DESTROY ( __pClient__ );
    RPC_CLIENT_CERROR ( szContRpcFailed, szError );
    Result	= ZeroResult;
    return Result.ReturnValue;
  }
#ifndef MULTITHREAD
  Result	= * pResult;
#endif


  if ( pResult && pResult->nErrorLvl ) {
    /* Server returned a user error message: */
    char	szErrorMsg [ 1024 ];
    strncpy ( szErrorMsg,
              ( pResult->pszErrorMsg && pResult->pszErrorMsg [ 0 ] ) ?
              (LPCSTR) pResult->pszErrorMsg : (LPCSTR) szEmpty,
              sizeof ( szErrorMsg ) );
    szErrorMsg [ sizeof ( szErrorMsg ) - 1 ]	= (char) 0;
    xdr_free ( (xdrproc_t) xdr_fnClientDbMachines_rets, (char *) pResult );
    RPC_CLIENT_SERROR ( pResult->nErrorLvl, __procedure__,
                        szErrorMsg );
  } else {
    xdr_free ( (xdrproc_t) xdr_fnClientDbMachines_rets, (char *) pResult );
  }

  return Result.ReturnValue;

} /* fnClientDbMachines */



int DLLEXPORT fnServerGetPortByDirectory
	(string_t /* string_t<@conststring@> */ szDirectory ,
	  GETACTION eAction)
{
  static const char	__procedure__[]	= "client:fnServerGetPortByDirectory";
  static fnServerGetPortByDirectory_rets	ZeroResult;
  fnServerGetPortByDirectory_rets		* pResult = NULL;
  fnServerGetPortByDirectory_rets		Result = ZeroResult;
  fnServerGetPortByDirectory_args	InArguments;

  /* Client initialization: */
  if ( __bClientInitialize__ ) {
    __bClientInitialize__	= FALSE;
    RPC_CLIENT_INITIALIZE();
  }

#if	CLIENT_CREATE_BY_USER
  if ( __pClient__ == NULL ) {
    __pClient__	= RPC_CLIENT_CREATE ( __szHost__, __szTransport__ );
    if ( __pClient__ == NULL ) {
      /* Error handling for a not connected client: */
      char	szError [ 256 ];
      sprintf ( szError, szFormatNoServer, __procedure__ );
      RPC_CLIENT_ERROR ( szError );
      return Result.ReturnValue;
    }
  }
#else
  while ( __pClient__ == NULL ) {
    __pClient__	= RPC_CLIENT_CREATE ( __szHost__, __szTransport__ );
    if ( __pClient__ == NULL ) {
      /* Error handling for a not connected client: */
      char	szError [ 256 ];
      sprintf ( szError, szFormatNoServer, __procedure__ );
      RPC_CLIENT_CERROR ( szContNoServer, szError );
    }
  }
#endif	/* CLIENT_CREATE_BY_USER */

  /* Copy in the szDirectory argument: */
  InArguments.szDirectory	= szDirectory;
  if ( szDirectory == NULL ) {
    /* Error handling for passing a NULL string pointer: */
    char	szError [ 256 ];
    InArguments.szDirectory	= (LPSTR) szEmpty;
    sprintf ( szError, szFormatNullString,
              __procedure__, "szDirectory" );
    RPC_CLIENT_CERROR ( szContNullString, szError );
  }
  /* Copy in the eAction argument: */
  InArguments.eAction	= eAction;

  pResult	=
#ifdef MULTITHREAD
    (
#else
    (fnServerGetPortByDirectory_rets *)
#endif
    fnrpc_fnservergetportbydirectory_1 (
	&InArguments,
#ifdef MULTITHREAD
	&Result,
#endif
	__pClient__ )
#ifdef MULTITHREAD
	== RPC_SUCCESS ) ? &Result : NULL
#endif
	;

  if ( pResult == NULL ) {
    /* Error handling for a failed RPC call, */
    /* i.e. the server did not respond: */
    char	szError [ 256 ];
    sprintf ( szError, szFormatRpcFailed, __procedure__,
              clnt_sperror ( __pClient__, __szHost__ ) );
    __pClient__	= RPC_CLIENT_DESTROY ( __pClient__ );
    RPC_CLIENT_CERROR ( szContRpcFailed, szError );
    Result	= ZeroResult;
    return Result.ReturnValue;
  }
#ifndef MULTITHREAD
  Result	= * pResult;
#endif


  if ( pResult && pResult->nErrorLvl ) {
    /* Server returned a user error message: */
    char	szErrorMsg [ 1024 ];
    strncpy ( szErrorMsg,
              ( pResult->pszErrorMsg && pResult->pszErrorMsg [ 0 ] ) ?
              (LPCSTR) pResult->pszErrorMsg : (LPCSTR) szEmpty,
              sizeof ( szErrorMsg ) );
    szErrorMsg [ sizeof ( szErrorMsg ) - 1 ]	= (char) 0;
    xdr_free ( (xdrproc_t) xdr_fnServerGetPortByDirectory_rets, (char *) pResult );
    RPC_CLIENT_SERROR ( pResult->nErrorLvl, __procedure__,
                        szErrorMsg );
  } else {
    xdr_free ( (xdrproc_t) xdr_fnServerGetPortByDirectory_rets, (char *) pResult );
  }

  return Result.ReturnValue;

} /* fnServerGetPortByDirectory */



int DLLEXPORT fnServerGetPID
	(void)
{
  static const char	__procedure__[]	= "client:fnServerGetPID";
  static fnServerGetPID_rets	ZeroResult;
  fnServerGetPID_rets		* pResult = NULL;
  fnServerGetPID_rets		Result = ZeroResult;

  /* Client initialization: */
  if ( __bClientInitialize__ ) {
    __bClientInitialize__	= FALSE;
    RPC_CLIENT_INITIALIZE();
  }

#if	CLIENT_CREATE_BY_USER
  if ( __pClient__ == NULL ) {
    __pClient__	= RPC_CLIENT_CREATE ( __szHost__, __szTransport__ );
    if ( __pClient__ == NULL ) {
      /* Error handling for a not connected client: */
      char	szError [ 256 ];
      sprintf ( szError, szFormatNoServer, __procedure__ );
      RPC_CLIENT_ERROR ( szError );
      return Result.ReturnValue;
    }
  }
#else
  while ( __pClient__ == NULL ) {
    __pClient__	= RPC_CLIENT_CREATE ( __szHost__, __szTransport__ );
    if ( __pClient__ == NULL ) {
      /* Error handling for a not connected client: */
      char	szError [ 256 ];
      sprintf ( szError, szFormatNoServer, __procedure__ );
      RPC_CLIENT_CERROR ( szContNoServer, szError );
    }
  }
#endif	/* CLIENT_CREATE_BY_USER */

  pResult	=
#ifdef MULTITHREAD
    (
#else
    (fnServerGetPID_rets *)
#endif
    fnrpc_fnservergetpid_1 (
	NULL,
#ifdef MULTITHREAD
	&Result,
#endif
	__pClient__ )
#ifdef MULTITHREAD
	== RPC_SUCCESS ) ? &Result : NULL
#endif
	;

  if ( pResult == NULL ) {
    /* Error handling for a failed RPC call, */
    /* i.e. the server did not respond: */
    char	szError [ 256 ];
    sprintf ( szError, szFormatRpcFailed, __procedure__,
              clnt_sperror ( __pClient__, __szHost__ ) );
    __pClient__	= RPC_CLIENT_DESTROY ( __pClient__ );
    RPC_CLIENT_CERROR ( szContRpcFailed, szError );
    Result	= ZeroResult;
    return Result.ReturnValue;
  }
#ifndef MULTITHREAD
  Result	= * pResult;
#endif


  if ( pResult && pResult->nErrorLvl ) {
    /* Server returned a user error message: */
    char	szErrorMsg [ 1024 ];
    strncpy ( szErrorMsg,
              ( pResult->pszErrorMsg && pResult->pszErrorMsg [ 0 ] ) ?
              (LPCSTR) pResult->pszErrorMsg : (LPCSTR) szEmpty,
              sizeof ( szErrorMsg ) );
    szErrorMsg [ sizeof ( szErrorMsg ) - 1 ]	= (char) 0;
    xdr_free ( (xdrproc_t) xdr_fnServerGetPID_rets, (char *) pResult );
    RPC_CLIENT_SERROR ( pResult->nErrorLvl, __procedure__,
                        szErrorMsg );
  } else {
    xdr_free ( (xdrproc_t) xdr_fnServerGetPID_rets, (char *) pResult );
  }

  return Result.ReturnValue;

} /* fnServerGetPID */



int DLLEXPORT fnServerGetDirectory
	(int nDirectory ,
	  string_t /* string_t<nDirectory> */  szDirectory)
{
  static const char	__procedure__[]	= "client:fnServerGetDirectory";
  static fnServerGetDirectory_rets	ZeroResult;
  fnServerGetDirectory_rets		* pResult = NULL;
  fnServerGetDirectory_rets		Result = ZeroResult;
  fnServerGetDirectory_args	InArguments;

  /* Client initialization: */
  if ( __bClientInitialize__ ) {
    __bClientInitialize__	= FALSE;
    RPC_CLIENT_INITIALIZE();
  }

#if	CLIENT_CREATE_BY_USER
  if ( __pClient__ == NULL ) {
    __pClient__	= RPC_CLIENT_CREATE ( __szHost__, __szTransport__ );
    if ( __pClient__ == NULL ) {
      /* Error handling for a not connected client: */
      char	szError [ 256 ];
      sprintf ( szError, szFormatNoServer, __procedure__ );
      RPC_CLIENT_ERROR ( szError );
      return Result.ReturnValue;
    }
  }
#else
  while ( __pClient__ == NULL ) {
    __pClient__	= RPC_CLIENT_CREATE ( __szHost__, __szTransport__ );
    if ( __pClient__ == NULL ) {
      /* Error handling for a not connected client: */
      char	szError [ 256 ];
      sprintf ( szError, szFormatNoServer, __procedure__ );
      RPC_CLIENT_CERROR ( szContNoServer, szError );
    }
  }
#endif	/* CLIENT_CREATE_BY_USER */

  /* Copy in the nDirectory argument: */
  InArguments.nDirectory	= nDirectory;
  InArguments.szDirectorySize	= nDirectory;

  pResult	=
#ifdef MULTITHREAD
    (
#else
    (fnServerGetDirectory_rets *)
#endif
    fnrpc_fnservergetdirectory_1 (
	&InArguments,
#ifdef MULTITHREAD
	&Result,
#endif
	__pClient__ )
#ifdef MULTITHREAD
	== RPC_SUCCESS ) ? &Result : NULL
#endif
	;

  if ( pResult == NULL ) {
    /* Error handling for a failed RPC call, */
    /* i.e. the server did not respond: */
    char	szError [ 256 ];
    sprintf ( szError, szFormatRpcFailed, __procedure__,
              clnt_sperror ( __pClient__, __szHost__ ) );
    __pClient__	= RPC_CLIENT_DESTROY ( __pClient__ );
    RPC_CLIENT_CERROR ( szContRpcFailed, szError );
    Result	= ZeroResult;
    return Result.ReturnValue;
  }
#ifndef MULTITHREAD
  Result	= * pResult;
#endif

  /* Copy out the szDirectory argument: */
  if ( ! ( 
       pResult->szDirectory
       && *(pResult->szDirectory) &&
       szDirectory == NULL ) ) {
    if ( szDirectory != NULL ) {
      if ( pResult->szDirectory != NULL ) {
        strncpy ( szDirectory, pResult->szDirectory, nDirectory );
      } else {
        *szDirectory	= (char) 0;
      }
    }
  }

  if ( pResult && pResult->nErrorLvl ) {
    /* Server returned a user error message: */
    char	szErrorMsg [ 1024 ];
    strncpy ( szErrorMsg,
              ( pResult->pszErrorMsg && pResult->pszErrorMsg [ 0 ] ) ?
              (LPCSTR) pResult->pszErrorMsg : (LPCSTR) szEmpty,
              sizeof ( szErrorMsg ) );
    szErrorMsg [ sizeof ( szErrorMsg ) - 1 ]	= (char) 0;
    xdr_free ( (xdrproc_t) xdr_fnServerGetDirectory_rets, (char *) pResult );
    RPC_CLIENT_SERROR ( pResult->nErrorLvl, __procedure__,
                        szErrorMsg );
  } else {
    xdr_free ( (xdrproc_t) xdr_fnServerGetDirectory_rets, (char *) pResult );
  }
  if ( 
       Result.szDirectory
       && *(Result.szDirectory) &&
       szDirectory == NULL ) {
    /* Error handling for passing a NULL pointer on */
    /* out argument: */
    char	szError [ 256 ];
    sprintf ( szError, szFormatNullPassed,
              __procedure__, "szDirectory" );
    RPC_CLIENT_CERROR ( szContNullOutPassed, szError );
  }

  return Result.ReturnValue;

} /* fnServerGetDirectory */



bool_t DLLEXPORT fnServerExit
	(SHORTOBJID oShortObjIdHeap ,
	  bool_t bForceExit)
{
  static const char	__procedure__[]	= "client:fnServerExit";
  static fnServerExit_rets	ZeroResult;
  fnServerExit_rets		* pResult = NULL;
  fnServerExit_rets		Result = ZeroResult;
  fnServerExit_args	InArguments;

  /* Client initialization: */
  if ( __bClientInitialize__ ) {
    __bClientInitialize__	= FALSE;
    RPC_CLIENT_INITIALIZE();
  }

#if	CLIENT_CREATE_BY_USER
  if ( __pClient__ == NULL ) {
    __pClient__	= RPC_CLIENT_CREATE ( __szHost__, __szTransport__ );
    if ( __pClient__ == NULL ) {
      /* Error handling for a not connected client: */
      char	szError [ 256 ];
      sprintf ( szError, szFormatNoServer, __procedure__ );
      RPC_CLIENT_ERROR ( szError );
      return Result.ReturnValue;
    }
  }
#else
  while ( __pClient__ == NULL ) {
    __pClient__	= RPC_CLIENT_CREATE ( __szHost__, __szTransport__ );
    if ( __pClient__ == NULL ) {
      /* Error handling for a not connected client: */
      char	szError [ 256 ];
      sprintf ( szError, szFormatNoServer, __procedure__ );
      RPC_CLIENT_CERROR ( szContNoServer, szError );
    }
  }
#endif	/* CLIENT_CREATE_BY_USER */

  /* Copy in the oShortObjIdHeap argument: */
  InArguments.oShortObjIdHeap	= oShortObjIdHeap;
  /* Copy in the bForceExit argument: */
  InArguments.bForceExit	= bForceExit;

  pResult	=
#ifdef MULTITHREAD
    (
#else
    (fnServerExit_rets *)
#endif
    fnrpc_fnserverexit_1 (
	&InArguments,
#ifdef MULTITHREAD
	&Result,
#endif
	__pClient__ )
#ifdef MULTITHREAD
	== RPC_SUCCESS ) ? &Result : NULL
#endif
	;

  if ( pResult == NULL ) {
    /* Error handling for a failed RPC call, */
    /* i.e. the server did not respond: */
    char	szError [ 256 ];
    sprintf ( szError, szFormatRpcFailed, __procedure__,
              clnt_sperror ( __pClient__, __szHost__ ) );
    __pClient__	= RPC_CLIENT_DESTROY ( __pClient__ );
    RPC_CLIENT_CERROR ( szContRpcFailed, szError );
    Result	= ZeroResult;
    return Result.ReturnValue;
  }
#ifndef MULTITHREAD
  Result	= * pResult;
#endif


  if ( pResult && pResult->nErrorLvl ) {
    /* Server returned a user error message: */
    char	szErrorMsg [ 1024 ];
    strncpy ( szErrorMsg,
              ( pResult->pszErrorMsg && pResult->pszErrorMsg [ 0 ] ) ?
              (LPCSTR) pResult->pszErrorMsg : (LPCSTR) szEmpty,
              sizeof ( szErrorMsg ) );
    szErrorMsg [ sizeof ( szErrorMsg ) - 1 ]	= (char) 0;
    xdr_free ( (xdrproc_t) xdr_fnServerExit_rets, (char *) pResult );
    RPC_CLIENT_SERROR ( pResult->nErrorLvl, __procedure__,
                        szErrorMsg );
  } else {
    xdr_free ( (xdrproc_t) xdr_fnServerExit_rets, (char *) pResult );
  }

  return Result.ReturnValue;

} /* fnServerExit */



bool_t DLLEXPORT fnServerDbReset
	(SHORTOBJID oShortObjIdHeap ,
	  bool_t bForceReset)
{
  static const char	__procedure__[]	= "client:fnServerDbReset";
  static fnServerDbReset_rets	ZeroResult;
  fnServerDbReset_rets		* pResult = NULL;
  fnServerDbReset_rets		Result = ZeroResult;
  fnServerDbReset_args	InArguments;

  /* Client initialization: */
  if ( __bClientInitialize__ ) {
    __bClientInitialize__	= FALSE;
    RPC_CLIENT_INITIALIZE();
  }

#if	CLIENT_CREATE_BY_USER
  if ( __pClient__ == NULL ) {
    __pClient__	= RPC_CLIENT_CREATE ( __szHost__, __szTransport__ );
    if ( __pClient__ == NULL ) {
      /* Error handling for a not connected client: */
      char	szError [ 256 ];
      sprintf ( szError, szFormatNoServer, __procedure__ );
      RPC_CLIENT_ERROR ( szError );
      return Result.ReturnValue;
    }
  }
#else
  while ( __pClient__ == NULL ) {
    __pClient__	= RPC_CLIENT_CREATE ( __szHost__, __szTransport__ );
    if ( __pClient__ == NULL ) {
      /* Error handling for a not connected client: */
      char	szError [ 256 ];
      sprintf ( szError, szFormatNoServer, __procedure__ );
      RPC_CLIENT_CERROR ( szContNoServer, szError );
    }
  }
#endif	/* CLIENT_CREATE_BY_USER */

  /* Copy in the oShortObjIdHeap argument: */
  InArguments.oShortObjIdHeap	= oShortObjIdHeap;
  /* Copy in the bForceReset argument: */
  InArguments.bForceReset	= bForceReset;

  pResult	=
#ifdef MULTITHREAD
    (
#else
    (fnServerDbReset_rets *)
#endif
    fnrpc_fnserverdbreset_1 (
	&InArguments,
#ifdef MULTITHREAD
	&Result,
#endif
	__pClient__ )
#ifdef MULTITHREAD
	== RPC_SUCCESS ) ? &Result : NULL
#endif
	;

  if ( pResult == NULL ) {
    /* Error handling for a failed RPC call, */
    /* i.e. the server did not respond: */
    char	szError [ 256 ];
    sprintf ( szError, szFormatRpcFailed, __procedure__,
              clnt_sperror ( __pClient__, __szHost__ ) );
    __pClient__	= RPC_CLIENT_DESTROY ( __pClient__ );
    RPC_CLIENT_CERROR ( szContRpcFailed, szError );
    Result	= ZeroResult;
    return Result.ReturnValue;
  }
#ifndef MULTITHREAD
  Result	= * pResult;
#endif


  if ( pResult && pResult->nErrorLvl ) {
    /* Server returned a user error message: */
    char	szErrorMsg [ 1024 ];
    strncpy ( szErrorMsg,
              ( pResult->pszErrorMsg && pResult->pszErrorMsg [ 0 ] ) ?
              (LPCSTR) pResult->pszErrorMsg : (LPCSTR) szEmpty,
              sizeof ( szErrorMsg ) );
    szErrorMsg [ sizeof ( szErrorMsg ) - 1 ]	= (char) 0;
    xdr_free ( (xdrproc_t) xdr_fnServerDbReset_rets, (char *) pResult );
    RPC_CLIENT_SERROR ( pResult->nErrorLvl, __procedure__,
                        szErrorMsg );
  } else {
    xdr_free ( (xdrproc_t) xdr_fnServerDbReset_rets, (char *) pResult );
  }

  return Result.ReturnValue;

} /* fnServerDbReset */



bool_t DLLEXPORT fnServerRestart
	(SHORTOBJID oShortObjIdHeap ,
	  bool_t bForceRestart)
{
  static const char	__procedure__[]	= "client:fnServerRestart";
  static fnServerRestart_rets	ZeroResult;
  fnServerRestart_rets		* pResult = NULL;
  fnServerRestart_rets		Result = ZeroResult;
  fnServerRestart_args	InArguments;

  /* Client initialization: */
  if ( __bClientInitialize__ ) {
    __bClientInitialize__	= FALSE;
    RPC_CLIENT_INITIALIZE();
  }

#if	CLIENT_CREATE_BY_USER
  if ( __pClient__ == NULL ) {
    __pClient__	= RPC_CLIENT_CREATE ( __szHost__, __szTransport__ );
    if ( __pClient__ == NULL ) {
      /* Error handling for a not connected client: */
      char	szError [ 256 ];
      sprintf ( szError, szFormatNoServer, __procedure__ );
      RPC_CLIENT_ERROR ( szError );
      return Result.ReturnValue;
    }
  }
#else
  while ( __pClient__ == NULL ) {
    __pClient__	= RPC_CLIENT_CREATE ( __szHost__, __szTransport__ );
    if ( __pClient__ == NULL ) {
      /* Error handling for a not connected client: */
      char	szError [ 256 ];
      sprintf ( szError, szFormatNoServer, __procedure__ );
      RPC_CLIENT_CERROR ( szContNoServer, szError );
    }
  }
#endif	/* CLIENT_CREATE_BY_USER */

  /* Copy in the oShortObjIdHeap argument: */
  InArguments.oShortObjIdHeap	= oShortObjIdHeap;
  /* Copy in the bForceRestart argument: */
  InArguments.bForceRestart	= bForceRestart;

  pResult	=
#ifdef MULTITHREAD
    (
#else
    (fnServerRestart_rets *)
#endif
    fnrpc_fnserverrestart_1 (
	&InArguments,
#ifdef MULTITHREAD
	&Result,
#endif
	__pClient__ )
#ifdef MULTITHREAD
	== RPC_SUCCESS ) ? &Result : NULL
#endif
	;

  if ( pResult == NULL ) {
    /* Error handling for a failed RPC call, */
    /* i.e. the server did not respond: */
    char	szError [ 256 ];
    sprintf ( szError, szFormatRpcFailed, __procedure__,
              clnt_sperror ( __pClient__, __szHost__ ) );
    __pClient__	= RPC_CLIENT_DESTROY ( __pClient__ );
    RPC_CLIENT_CERROR ( szContRpcFailed, szError );
    Result	= ZeroResult;
    return Result.ReturnValue;
  }
#ifndef MULTITHREAD
  Result	= * pResult;
#endif


  if ( pResult && pResult->nErrorLvl ) {
    /* Server returned a user error message: */
    char	szErrorMsg [ 1024 ];
    strncpy ( szErrorMsg,
              ( pResult->pszErrorMsg && pResult->pszErrorMsg [ 0 ] ) ?
              (LPCSTR) pResult->pszErrorMsg : (LPCSTR) szEmpty,
              sizeof ( szErrorMsg ) );
    szErrorMsg [ sizeof ( szErrorMsg ) - 1 ]	= (char) 0;
    xdr_free ( (xdrproc_t) xdr_fnServerRestart_rets, (char *) pResult );
    RPC_CLIENT_SERROR ( pResult->nErrorLvl, __procedure__,
                        szErrorMsg );
  } else {
    xdr_free ( (xdrproc_t) xdr_fnServerRestart_rets, (char *) pResult );
  }

  return Result.ReturnValue;

} /* fnServerRestart */



bool_t DLLEXPORT fnClientObjectCanModify
	(SHORTOBJID oShortObjIdHeap ,
	  SHORTOBJID oShortObjId)
{
  static const char	__procedure__[]	= "client:fnClientObjectCanModify";
  static fnClientObjectCanModify_rets	ZeroResult;
  fnClientObjectCanModify_rets		* pResult = NULL;
  fnClientObjectCanModify_rets		Result = ZeroResult;
  fnClientObjectCanModify_args	InArguments;

  /* Client initialization: */
  if ( __bClientInitialize__ ) {
    __bClientInitialize__	= FALSE;
    RPC_CLIENT_INITIALIZE();
  }

#if	CLIENT_CREATE_BY_USER
  if ( __pClient__ == NULL ) {
    __pClient__	= RPC_CLIENT_CREATE ( __szHost__, __szTransport__ );
    if ( __pClient__ == NULL ) {
      /* Error handling for a not connected client: */
      char	szError [ 256 ];
      sprintf ( szError, szFormatNoServer, __procedure__ );
      RPC_CLIENT_ERROR ( szError );
      return Result.ReturnValue;
    }
  }
#else
  while ( __pClient__ == NULL ) {
    __pClient__	= RPC_CLIENT_CREATE ( __szHost__, __szTransport__ );
    if ( __pClient__ == NULL ) {
      /* Error handling for a not connected client: */
      char	szError [ 256 ];
      sprintf ( szError, szFormatNoServer, __procedure__ );
      RPC_CLIENT_CERROR ( szContNoServer, szError );
    }
  }
#endif	/* CLIENT_CREATE_BY_USER */

  /* Copy in the oShortObjIdHeap argument: */
  InArguments.oShortObjIdHeap	= oShortObjIdHeap;
  /* Copy in the oShortObjId argument: */
  InArguments.oShortObjId	= oShortObjId;

  pResult	=
#ifdef MULTITHREAD
    (
#else
    (fnClientObjectCanModify_rets *)
#endif
    fnrpc_fnclientobjectcanmodify_1 (
	&InArguments,
#ifdef MULTITHREAD
	&Result,
#endif
	__pClient__ )
#ifdef MULTITHREAD
	== RPC_SUCCESS ) ? &Result : NULL
#endif
	;

  if ( pResult == NULL ) {
    /* Error handling for a failed RPC call, */
    /* i.e. the server did not respond: */
    char	szError [ 256 ];
    sprintf ( szError, szFormatRpcFailed, __procedure__,
              clnt_sperror ( __pClient__, __szHost__ ) );
    __pClient__	= RPC_CLIENT_DESTROY ( __pClient__ );
    RPC_CLIENT_CERROR ( szContRpcFailed, szError );
    Result	= ZeroResult;
    return Result.ReturnValue;
  }
#ifndef MULTITHREAD
  Result	= * pResult;
#endif


  if ( pResult && pResult->nErrorLvl ) {
    /* Server returned a user error message: */
    char	szErrorMsg [ 1024 ];
    strncpy ( szErrorMsg,
              ( pResult->pszErrorMsg && pResult->pszErrorMsg [ 0 ] ) ?
              (LPCSTR) pResult->pszErrorMsg : (LPCSTR) szEmpty,
              sizeof ( szErrorMsg ) );
    szErrorMsg [ sizeof ( szErrorMsg ) - 1 ]	= (char) 0;
    xdr_free ( (xdrproc_t) xdr_fnClientObjectCanModify_rets, (char *) pResult );
    RPC_CLIENT_SERROR ( pResult->nErrorLvl, __procedure__,
                        szErrorMsg );
  } else {
    xdr_free ( (xdrproc_t) xdr_fnClientObjectCanModify_rets, (char *) pResult );
  }

  return Result.ReturnValue;

} /* fnClientObjectCanModify */



void DLLEXPORT fnServerDbClose
	(SHORTOBJID oShortObjIdHeap ,
	  bool_t bWithGarbageCollection)
{
  static const char	__procedure__[]	= "client:fnServerDbClose";
  static char	ZeroResult;
  void		* pResult = NULL;
#ifdef MULTITHREAD
  char		Result = ZeroResult;
#endif
  fnServerDbClose_args	InArguments;

  /* Client initialization: */
  if ( __bClientInitialize__ ) {
    __bClientInitialize__	= FALSE;
    RPC_CLIENT_INITIALIZE();
  }

#if	CLIENT_CREATE_BY_USER
  if ( __pClient__ == NULL ) {
    __pClient__	= RPC_CLIENT_CREATE ( __szHost__, __szTransport__ );
    if ( __pClient__ == NULL ) {
      /* Error handling for a not connected client: */
      char	szError [ 256 ];
      sprintf ( szError, szFormatNoServer, __procedure__ );
      RPC_CLIENT_ERROR ( szError );
      return;
    }
  }
#else
  while ( __pClient__ == NULL ) {
    __pClient__	= RPC_CLIENT_CREATE ( __szHost__, __szTransport__ );
    if ( __pClient__ == NULL ) {
      /* Error handling for a not connected client: */
      char	szError [ 256 ];
      sprintf ( szError, szFormatNoServer, __procedure__ );
      RPC_CLIENT_CERROR ( szContNoServer, szError );
    }
  }
#endif	/* CLIENT_CREATE_BY_USER */

  /* Copy in the oShortObjIdHeap argument: */
  InArguments.oShortObjIdHeap	= oShortObjIdHeap;
  /* Copy in the bWithGarbageCollection argument: */
  InArguments.bWithGarbageCollection	= bWithGarbageCollection;

  pResult	=
#ifdef MULTITHREAD
    (
#else
    (void *)
#endif
    fnrpc_fnserverdbclose_batch_1 (
	&InArguments,
#ifdef MULTITHREAD
	&Result,
#endif
	__pClient__ )
#ifdef MULTITHREAD
	== RPC_SUCCESS ) ? &Result : NULL
#endif
	;

  if ( pResult == NULL ) {
    /* Error handling for a failed RPC call, */
    /* i.e. the server did not respond: */
    char	szError [ 256 ];
    sprintf ( szError, szFormatRpcFailed, __procedure__,
              clnt_sperror ( __pClient__, __szHost__ ) );
    __pClient__	= RPC_CLIENT_DESTROY ( __pClient__ );
    RPC_CLIENT_CERROR ( szContRpcFailed, szError );
    return;
  }
} /* fnServerDbClose */

#ifdef MULTITHREAD
enum clnt_stat
#else
void *
#endif
fnrpc_fnserverdbclose_batch_1
	( fnServerDbClose_args * pArguments,
#ifdef MULTITHREAD
	  void * clnt_res,
#endif
	  PCLIENT pClient )
{
#ifdef MULTITHREAD
  return clnt_call ( pClient, fnRpc_fnServerDbClose_batch,
                     (xdrproc_t) xdr_fnServerDbClose_args,
                     (caddr_t) pArguments,
                     (xdrproc_t) NULL, (caddr_t) NULL,
                     NullTimeout );
#else
  if ( clnt_call ( pClient, fnRpc_fnServerDbClose_batch,
                   (xdrproc_t) xdr_fnServerDbClose_args,
                   (caddr_t) pArguments,
                   (xdrproc_t) NULL, (caddr_t) NULL,
                   NullTimeout ) != RPC_SUCCESS ) {
    return NULL;
  }
  return (void *) TRUE;
#endif
} /* fnrpc_fnserverdbclose_batch_1 */
#define	fnrpc_fnserverdbclose_batch_1	fnrpc_fnserverdbclose_1



bool_t DLLEXPORT fnClientDbConfiguration
	(SHORTOBJID oShortObjIdHeap ,
	  int * pnFlags ,
	  int * pnMinimumKey ,
	  int * pnMaximumKey ,
	  int * pnKeyAlignment)
{
  static const char	__procedure__[]	= "client:fnClientDbConfiguration";
  static fnClientDbConfiguration_rets	ZeroResult;
  fnClientDbConfiguration_rets		* pResult = NULL;
  fnClientDbConfiguration_rets		Result = ZeroResult;

  /* Client initialization: */
  if ( __bClientInitialize__ ) {
    __bClientInitialize__	= FALSE;
    RPC_CLIENT_INITIALIZE();
  }

#if	CLIENT_CREATE_BY_USER
  if ( __pClient__ == NULL ) {
    __pClient__	= RPC_CLIENT_CREATE ( __szHost__, __szTransport__ );
    if ( __pClient__ == NULL ) {
      /* Error handling for a not connected client: */
      char	szError [ 256 ];
      sprintf ( szError, szFormatNoServer, __procedure__ );
      RPC_CLIENT_ERROR ( szError );
      return Result.ReturnValue;
    }
  }
#else
  while ( __pClient__ == NULL ) {
    __pClient__	= RPC_CLIENT_CREATE ( __szHost__, __szTransport__ );
    if ( __pClient__ == NULL ) {
      /* Error handling for a not connected client: */
      char	szError [ 256 ];
      sprintf ( szError, szFormatNoServer, __procedure__ );
      RPC_CLIENT_CERROR ( szContNoServer, szError );
    }
  }
#endif	/* CLIENT_CREATE_BY_USER */

  pResult	=
#ifdef MULTITHREAD
    (
#else
    (fnClientDbConfiguration_rets *)
#endif
    fnrpc_fnclientdbconfiguration_1 (
	&oShortObjIdHeap,
#ifdef MULTITHREAD
	&Result,
#endif
	__pClient__ )
#ifdef MULTITHREAD
	== RPC_SUCCESS ) ? &Result : NULL
#endif
	;

  if ( pResult == NULL ) {
    /* Error handling for a failed RPC call, */
    /* i.e. the server did not respond: */
    char	szError [ 256 ];
    sprintf ( szError, szFormatRpcFailed, __procedure__,
              clnt_sperror ( __pClient__, __szHost__ ) );
    __pClient__	= RPC_CLIENT_DESTROY ( __pClient__ );
    RPC_CLIENT_CERROR ( szContRpcFailed, szError );
    Result	= ZeroResult;
    return Result.ReturnValue;
  }
#ifndef MULTITHREAD
  Result	= * pResult;
#endif

  /* Copy out the pnFlags argument: */
  if ( ! ( 
       pnFlags == NULL ) ) {
    *pnFlags	= pResult->pnFlags;
  }
  /* Copy out the pnMinimumKey argument: */
  if ( ! ( 
       pnMinimumKey == NULL ) ) {
    *pnMinimumKey	= pResult->pnMinimumKey;
  }
  /* Copy out the pnMaximumKey argument: */
  if ( ! ( 
       pnMaximumKey == NULL ) ) {
    *pnMaximumKey	= pResult->pnMaximumKey;
  }
  /* Copy out the pnKeyAlignment argument: */
  if ( ! ( 
       pnKeyAlignment == NULL ) ) {
    *pnKeyAlignment	= pResult->pnKeyAlignment;
  }

  if ( pResult && pResult->nErrorLvl ) {
    /* Server returned a user error message: */
    char	szErrorMsg [ 1024 ];
    strncpy ( szErrorMsg,
              ( pResult->pszErrorMsg && pResult->pszErrorMsg [ 0 ] ) ?
              (LPCSTR) pResult->pszErrorMsg : (LPCSTR) szEmpty,
              sizeof ( szErrorMsg ) );
    szErrorMsg [ sizeof ( szErrorMsg ) - 1 ]	= (char) 0;
    xdr_free ( (xdrproc_t) xdr_fnClientDbConfiguration_rets, (char *) pResult );
    RPC_CLIENT_SERROR ( pResult->nErrorLvl, __procedure__,
                        szErrorMsg );
  } else {
    xdr_free ( (xdrproc_t) xdr_fnClientDbConfiguration_rets, (char *) pResult );
  }
  if ( 
       pnFlags == NULL ) {
    /* Error handling for passing a NULL pointer on */
    /* out argument: */
    char	szError [ 256 ];
    sprintf ( szError, szFormatNullPassed,
              __procedure__, "pnFlags" );
    RPC_CLIENT_CERROR ( szContNullOutPassed, szError );
  }
  if ( 
       pnMinimumKey == NULL ) {
    /* Error handling for passing a NULL pointer on */
    /* out argument: */
    char	szError [ 256 ];
    sprintf ( szError, szFormatNullPassed,
              __procedure__, "pnMinimumKey" );
    RPC_CLIENT_CERROR ( szContNullOutPassed, szError );
  }
  if ( 
       pnMaximumKey == NULL ) {
    /* Error handling for passing a NULL pointer on */
    /* out argument: */
    char	szError [ 256 ];
    sprintf ( szError, szFormatNullPassed,
              __procedure__, "pnMaximumKey" );
    RPC_CLIENT_CERROR ( szContNullOutPassed, szError );
  }
  if ( 
       pnKeyAlignment == NULL ) {
    /* Error handling for passing a NULL pointer on */
    /* out argument: */
    char	szError [ 256 ];
    sprintf ( szError, szFormatNullPassed,
              __procedure__, "pnKeyAlignment" );
    RPC_CLIENT_CERROR ( szContNullOutPassed, szError );
  }

  return Result.ReturnValue;

} /* fnClientDbConfiguration */



SHORTOBJID DLLEXPORT fnServerDbCreateObject
	(SHORTOBJID oShortObjIdHeap ,
	  SHTYPETAG nTypeTag ,
	  int nExtraReferences ,
	  SHTYPETAG eTypeTagValues ,
	  int nExtraValues)
{
  static const char	__procedure__[]	= "client:fnServerDbCreateObject";
  static fnServerDbCreateObject_rets	ZeroResult;
  fnServerDbCreateObject_rets		* pResult = NULL;
  fnServerDbCreateObject_rets		Result = ZeroResult;
  fnServerDbCreateObject_args	InArguments;

  /* Client initialization: */
  if ( __bClientInitialize__ ) {
    __bClientInitialize__	= FALSE;
    RPC_CLIENT_INITIALIZE();
  }

#if	CLIENT_CREATE_BY_USER
  if ( __pClient__ == NULL ) {
    __pClient__	= RPC_CLIENT_CREATE ( __szHost__, __szTransport__ );
    if ( __pClient__ == NULL ) {
      /* Error handling for a not connected client: */
      char	szError [ 256 ];
      sprintf ( szError, szFormatNoServer, __procedure__ );
      RPC_CLIENT_ERROR ( szError );
      return Result.ReturnValue;
    }
  }
#else
  while ( __pClient__ == NULL ) {
    __pClient__	= RPC_CLIENT_CREATE ( __szHost__, __szTransport__ );
    if ( __pClient__ == NULL ) {
      /* Error handling for a not connected client: */
      char	szError [ 256 ];
      sprintf ( szError, szFormatNoServer, __procedure__ );
      RPC_CLIENT_CERROR ( szContNoServer, szError );
    }
  }
#endif	/* CLIENT_CREATE_BY_USER */

  /* Copy in the oShortObjIdHeap argument: */
  InArguments.oShortObjIdHeap	= oShortObjIdHeap;
  /* Copy in the nTypeTag argument: */
  InArguments.nTypeTag	= nTypeTag;
  /* Copy in the nExtraReferences argument: */
  InArguments.nExtraReferences	= nExtraReferences;
  /* Copy in the eTypeTagValues argument: */
  InArguments.eTypeTagValues	= eTypeTagValues;
  /* Copy in the nExtraValues argument: */
  InArguments.nExtraValues	= nExtraValues;

  pResult	=
#ifdef MULTITHREAD
    (
#else
    (fnServerDbCreateObject_rets *)
#endif
    fnrpc_fnserverdbcreateobject_1 (
	&InArguments,
#ifdef MULTITHREAD
	&Result,
#endif
	__pClient__ )
#ifdef MULTITHREAD
	== RPC_SUCCESS ) ? &Result : NULL
#endif
	;

  if ( pResult == NULL ) {
    /* Error handling for a failed RPC call, */
    /* i.e. the server did not respond: */
    char	szError [ 256 ];
    sprintf ( szError, szFormatRpcFailed, __procedure__,
              clnt_sperror ( __pClient__, __szHost__ ) );
    __pClient__	= RPC_CLIENT_DESTROY ( __pClient__ );
    RPC_CLIENT_CERROR ( szContRpcFailed, szError );
    Result	= ZeroResult;
    return Result.ReturnValue;
  }
#ifndef MULTITHREAD
  Result	= * pResult;
#endif


  if ( pResult && pResult->nErrorLvl ) {
    /* Server returned a user error message: */
    char	szErrorMsg [ 1024 ];
    strncpy ( szErrorMsg,
              ( pResult->pszErrorMsg && pResult->pszErrorMsg [ 0 ] ) ?
              (LPCSTR) pResult->pszErrorMsg : (LPCSTR) szEmpty,
              sizeof ( szErrorMsg ) );
    szErrorMsg [ sizeof ( szErrorMsg ) - 1 ]	= (char) 0;
    xdr_free ( (xdrproc_t) xdr_fnServerDbCreateObject_rets, (char *) pResult );
    RPC_CLIENT_SERROR ( pResult->nErrorLvl, __procedure__,
                        szErrorMsg );
  } else {
    xdr_free ( (xdrproc_t) xdr_fnServerDbCreateObject_rets, (char *) pResult );
  }

  return Result.ReturnValue;

} /* fnServerDbCreateObject */



int DLLEXPORT fnServerDbCreateObjects
	(SHORTOBJID oShortObjIdHeap ,
	  SHTYPETAG nTypeTag ,
	  int nExtraReferences ,
	  SHTYPETAG eTypeTagValues ,
	  int nExtraValues ,
	  int nObjIds ,
	  u_int * /* _vector_t<nObjIds> */  pObjIds)
{
  static const char	__procedure__[]	= "client:fnServerDbCreateObjects";
  static fnServerDbCreateObjects_rets	ZeroResult;
  fnServerDbCreateObjects_rets		* pResult = NULL;
  fnServerDbCreateObjects_rets		Result = ZeroResult;
  fnServerDbCreateObjects_args	InArguments;

  /* Client initialization: */
  if ( __bClientInitialize__ ) {
    __bClientInitialize__	= FALSE;
    RPC_CLIENT_INITIALIZE();
  }

#if	CLIENT_CREATE_BY_USER
  if ( __pClient__ == NULL ) {
    __pClient__	= RPC_CLIENT_CREATE ( __szHost__, __szTransport__ );
    if ( __pClient__ == NULL ) {
      /* Error handling for a not connected client: */
      char	szError [ 256 ];
      sprintf ( szError, szFormatNoServer, __procedure__ );
      RPC_CLIENT_ERROR ( szError );
      return Result.ReturnValue;
    }
  }
#else
  while ( __pClient__ == NULL ) {
    __pClient__	= RPC_CLIENT_CREATE ( __szHost__, __szTransport__ );
    if ( __pClient__ == NULL ) {
      /* Error handling for a not connected client: */
      char	szError [ 256 ];
      sprintf ( szError, szFormatNoServer, __procedure__ );
      RPC_CLIENT_CERROR ( szContNoServer, szError );
    }
  }
#endif	/* CLIENT_CREATE_BY_USER */

  /* Copy in the oShortObjIdHeap argument: */
  InArguments.oShortObjIdHeap	= oShortObjIdHeap;
  /* Copy in the nTypeTag argument: */
  InArguments.nTypeTag	= nTypeTag;
  /* Copy in the nExtraReferences argument: */
  InArguments.nExtraReferences	= nExtraReferences;
  /* Copy in the eTypeTagValues argument: */
  InArguments.eTypeTagValues	= eTypeTagValues;
  /* Copy in the nExtraValues argument: */
  InArguments.nExtraValues	= nExtraValues;
  /* Copy in the nObjIds argument: */
  InArguments.nObjIds	= nObjIds;
  InArguments.pObjIdsSize	= nObjIds;

  pResult	=
#ifdef MULTITHREAD
    (
#else
    (fnServerDbCreateObjects_rets *)
#endif
    fnrpc_fnserverdbcreateobjects_1 (
	&InArguments,
#ifdef MULTITHREAD
	&Result,
#endif
	__pClient__ )
#ifdef MULTITHREAD
	== RPC_SUCCESS ) ? &Result : NULL
#endif
	;

  if ( pResult == NULL ) {
    /* Error handling for a failed RPC call, */
    /* i.e. the server did not respond: */
    char	szError [ 256 ];
    sprintf ( szError, szFormatRpcFailed, __procedure__,
              clnt_sperror ( __pClient__, __szHost__ ) );
    __pClient__	= RPC_CLIENT_DESTROY ( __pClient__ );
    RPC_CLIENT_CERROR ( szContRpcFailed, szError );
    Result	= ZeroResult;
    return Result.ReturnValue;
  }
#ifndef MULTITHREAD
  Result	= * pResult;
#endif

  /* Copy out the pObjIds argument: */
  if ( ! ( 
       pResult->pObjIds.u_int_vector_t_len != 0 &&
       pObjIds == NULL ) ) {
    memcpy ( pObjIds,
             pResult->pObjIds.u_int_vector_t_val,
             MIN ( pResult->pObjIds.u_int_vector_t_len,
                   nObjIds ) *
             SIZEOF ( *(pResult->pObjIds.u_int_vector_t_val) ) );
  }

  if ( pResult && pResult->nErrorLvl ) {
    /* Server returned a user error message: */
    char	szErrorMsg [ 1024 ];
    strncpy ( szErrorMsg,
              ( pResult->pszErrorMsg && pResult->pszErrorMsg [ 0 ] ) ?
              (LPCSTR) pResult->pszErrorMsg : (LPCSTR) szEmpty,
              sizeof ( szErrorMsg ) );
    szErrorMsg [ sizeof ( szErrorMsg ) - 1 ]	= (char) 0;
    xdr_free ( (xdrproc_t) xdr_fnServerDbCreateObjects_rets, (char *) pResult );
    RPC_CLIENT_SERROR ( pResult->nErrorLvl, __procedure__,
                        szErrorMsg );
  } else {
    xdr_free ( (xdrproc_t) xdr_fnServerDbCreateObjects_rets, (char *) pResult );
  }
  if ( 
       pResult->pObjIds.u_int_vector_t_len != 0 &&
       pObjIds == NULL ) {
    /* Error handling for passing a NULL pointer on */
    /* out argument: */
    char	szError [ 256 ];
    sprintf ( szError, szFormatNullPassed,
              __procedure__, "pObjIds" );
    RPC_CLIENT_CERROR ( szContNullOutPassed, szError );
  } else if ( pResult->pObjIds.u_int_vector_t_len > nObjIds ) {
      /* Error handling for an output buffer overflow, */
      /* i.e. the buffer size passed is too small: */
      /* For example, signal a CERROR here ... */
      char	szError [ 256 ];
      sprintf ( szError, szFormatBufferOverflow,
                __procedure__, "pObjIds", 
                nObjIds, 
                pResult->pObjIds.u_int_vector_t_len );
      RPC_CLIENT_CERROR ( szContBufferOverflow, szError );
  }

  return Result.ReturnValue;

} /* fnServerDbCreateObjects */



void DLLEXPORT fnServerObjectDestroy
	(SHORTOBJID oShortObjIdHeap ,
	  SHORTOBJID oShortObjId)
{
  static const char	__procedure__[]	= "client:fnServerObjectDestroy";
  static char	ZeroResult;
  void		* pResult = NULL;
#ifdef MULTITHREAD
  char		Result = ZeroResult;
#endif
  fnServerObjectDestroy_args	InArguments;

  /* Client initialization: */
  if ( __bClientInitialize__ ) {
    __bClientInitialize__	= FALSE;
    RPC_CLIENT_INITIALIZE();
  }

#if	CLIENT_CREATE_BY_USER
  if ( __pClient__ == NULL ) {
    __pClient__	= RPC_CLIENT_CREATE ( __szHost__, __szTransport__ );
    if ( __pClient__ == NULL ) {
      /* Error handling for a not connected client: */
      char	szError [ 256 ];
      sprintf ( szError, szFormatNoServer, __procedure__ );
      RPC_CLIENT_ERROR ( szError );
      return;
    }
  }
#else
  while ( __pClient__ == NULL ) {
    __pClient__	= RPC_CLIENT_CREATE ( __szHost__, __szTransport__ );
    if ( __pClient__ == NULL ) {
      /* Error handling for a not connected client: */
      char	szError [ 256 ];
      sprintf ( szError, szFormatNoServer, __procedure__ );
      RPC_CLIENT_CERROR ( szContNoServer, szError );
    }
  }
#endif	/* CLIENT_CREATE_BY_USER */

  /* Copy in the oShortObjIdHeap argument: */
  InArguments.oShortObjIdHeap	= oShortObjIdHeap;
  /* Copy in the oShortObjId argument: */
  InArguments.oShortObjId	= oShortObjId;

  pResult	=
#ifdef MULTITHREAD
    (
#else
    (void *)
#endif
    fnrpc_fnserverobjectdestroy_batch_1 (
	&InArguments,
#ifdef MULTITHREAD
	&Result,
#endif
	__pClient__ )
#ifdef MULTITHREAD
	== RPC_SUCCESS ) ? &Result : NULL
#endif
	;

  if ( pResult == NULL ) {
    /* Error handling for a failed RPC call, */
    /* i.e. the server did not respond: */
    char	szError [ 256 ];
    sprintf ( szError, szFormatRpcFailed, __procedure__,
              clnt_sperror ( __pClient__, __szHost__ ) );
    __pClient__	= RPC_CLIENT_DESTROY ( __pClient__ );
    RPC_CLIENT_CERROR ( szContRpcFailed, szError );
    return;
  }
} /* fnServerObjectDestroy */

#ifdef MULTITHREAD
enum clnt_stat
#else
void *
#endif
fnrpc_fnserverobjectdestroy_batch_1
	( fnServerObjectDestroy_args * pArguments,
#ifdef MULTITHREAD
	  void * clnt_res,
#endif
	  PCLIENT pClient )
{
#ifdef MULTITHREAD
  return clnt_call ( pClient, fnRpc_fnServerObjectDestroy_batch,
                     (xdrproc_t) xdr_fnServerObjectDestroy_args,
                     (caddr_t) pArguments,
                     (xdrproc_t) NULL, (caddr_t) NULL,
                     NullTimeout );
#else
  if ( clnt_call ( pClient, fnRpc_fnServerObjectDestroy_batch,
                   (xdrproc_t) xdr_fnServerObjectDestroy_args,
                   (caddr_t) pArguments,
                   (xdrproc_t) NULL, (caddr_t) NULL,
                   NullTimeout ) != RPC_SUCCESS ) {
    return NULL;
  }
  return (void *) TRUE;
#endif
} /* fnrpc_fnserverobjectdestroy_batch_1 */
#define	fnrpc_fnserverobjectdestroy_batch_1	fnrpc_fnserverobjectdestroy_1



int DLLEXPORT fnServerObjectObjIdSize
	(SHORTOBJID oShortObjIdHeap ,
	  SHORTOBJID oShortObjId)
{
  static const char	__procedure__[]	= "client:fnServerObjectObjIdSize";
  static fnServerObjectObjIdSize_rets	ZeroResult;
  fnServerObjectObjIdSize_rets		* pResult = NULL;
  fnServerObjectObjIdSize_rets		Result = ZeroResult;
  fnServerObjectObjIdSize_args	InArguments;

  /* Client initialization: */
  if ( __bClientInitialize__ ) {
    __bClientInitialize__	= FALSE;
    RPC_CLIENT_INITIALIZE();
  }

#if	CLIENT_CREATE_BY_USER
  if ( __pClient__ == NULL ) {
    __pClient__	= RPC_CLIENT_CREATE ( __szHost__, __szTransport__ );
    if ( __pClient__ == NULL ) {
      /* Error handling for a not connected client: */
      char	szError [ 256 ];
      sprintf ( szError, szFormatNoServer, __procedure__ );
      RPC_CLIENT_ERROR ( szError );
      return Result.ReturnValue;
    }
  }
#else
  while ( __pClient__ == NULL ) {
    __pClient__	= RPC_CLIENT_CREATE ( __szHost__, __szTransport__ );
    if ( __pClient__ == NULL ) {
      /* Error handling for a not connected client: */
      char	szError [ 256 ];
      sprintf ( szError, szFormatNoServer, __procedure__ );
      RPC_CLIENT_CERROR ( szContNoServer, szError );
    }
  }
#endif	/* CLIENT_CREATE_BY_USER */

  /* Copy in the oShortObjIdHeap argument: */
  InArguments.oShortObjIdHeap	= oShortObjIdHeap;
  /* Copy in the oShortObjId argument: */
  InArguments.oShortObjId	= oShortObjId;

  pResult	=
#ifdef MULTITHREAD
    (
#else
    (fnServerObjectObjIdSize_rets *)
#endif
    fnrpc_fnserverobjectobjidsize_1 (
	&InArguments,
#ifdef MULTITHREAD
	&Result,
#endif
	__pClient__ )
#ifdef MULTITHREAD
	== RPC_SUCCESS ) ? &Result : NULL
#endif
	;

  if ( pResult == NULL ) {
    /* Error handling for a failed RPC call, */
    /* i.e. the server did not respond: */
    char	szError [ 256 ];
    sprintf ( szError, szFormatRpcFailed, __procedure__,
              clnt_sperror ( __pClient__, __szHost__ ) );
    __pClient__	= RPC_CLIENT_DESTROY ( __pClient__ );
    RPC_CLIENT_CERROR ( szContRpcFailed, szError );
    Result	= ZeroResult;
    return Result.ReturnValue;
  }
#ifndef MULTITHREAD
  Result	= * pResult;
#endif


  if ( pResult && pResult->nErrorLvl ) {
    /* Server returned a user error message: */
    char	szErrorMsg [ 1024 ];
    strncpy ( szErrorMsg,
              ( pResult->pszErrorMsg && pResult->pszErrorMsg [ 0 ] ) ?
              (LPCSTR) pResult->pszErrorMsg : (LPCSTR) szEmpty,
              sizeof ( szErrorMsg ) );
    szErrorMsg [ sizeof ( szErrorMsg ) - 1 ]	= (char) 0;
    xdr_free ( (xdrproc_t) xdr_fnServerObjectObjIdSize_rets, (char *) pResult );
    RPC_CLIENT_SERROR ( pResult->nErrorLvl, __procedure__,
                        szErrorMsg );
  } else {
    xdr_free ( (xdrproc_t) xdr_fnServerObjectObjIdSize_rets, (char *) pResult );
  }

  return Result.ReturnValue;

} /* fnServerObjectObjIdSize */



SHORTOBJID DLLEXPORT fnServerDbOpen
	(string_t /* string_t<@conststring@> */ szDirectory ,
	  string_t /* string_t<@conststring@> */ szUserName ,
	  string_t /* string_t<@conststring@> */ szDescription ,
	  int nMinAddrInK ,
	  OBJID * poObjIdMin ,
	  OBJID * poObjIdMax)
{
  static const char	__procedure__[]	= "client:fnServerDbOpen";
  static fnServerDbOpen_rets	ZeroResult;
  fnServerDbOpen_rets		* pResult = NULL;
  fnServerDbOpen_rets		Result = ZeroResult;
  fnServerDbOpen_args	InArguments;

  /* Client initialization: */
  if ( __bClientInitialize__ ) {
    __bClientInitialize__	= FALSE;
    RPC_CLIENT_INITIALIZE();
  }

#if	CLIENT_CREATE_BY_USER
  if ( __pClient__ == NULL ) {
    __pClient__	= RPC_CLIENT_CREATE ( __szHost__, __szTransport__ );
    if ( __pClient__ == NULL ) {
      /* Error handling for a not connected client: */
      char	szError [ 256 ];
      sprintf ( szError, szFormatNoServer, __procedure__ );
      RPC_CLIENT_ERROR ( szError );
      return Result.ReturnValue;
    }
  }
#else
  while ( __pClient__ == NULL ) {
    __pClient__	= RPC_CLIENT_CREATE ( __szHost__, __szTransport__ );
    if ( __pClient__ == NULL ) {
      /* Error handling for a not connected client: */
      char	szError [ 256 ];
      sprintf ( szError, szFormatNoServer, __procedure__ );
      RPC_CLIENT_CERROR ( szContNoServer, szError );
    }
  }
#endif	/* CLIENT_CREATE_BY_USER */

  /* Copy in the szDirectory argument: */
  InArguments.szDirectory	= szDirectory;
  if ( szDirectory == NULL ) {
    /* Error handling for passing a NULL string pointer: */
    char	szError [ 256 ];
    InArguments.szDirectory	= (LPSTR) szEmpty;
    sprintf ( szError, szFormatNullString,
              __procedure__, "szDirectory" );
    RPC_CLIENT_CERROR ( szContNullString, szError );
  }
  /* Copy in the szUserName argument: */
  InArguments.szUserName	= szUserName;
  if ( szUserName == NULL ) {
    /* Error handling for passing a NULL string pointer: */
    char	szError [ 256 ];
    InArguments.szUserName	= (LPSTR) szEmpty;
    sprintf ( szError, szFormatNullString,
              __procedure__, "szUserName" );
    RPC_CLIENT_CERROR ( szContNullString, szError );
  }
  /* Copy in the szDescription argument: */
  InArguments.szDescription	= szDescription;
  if ( szDescription == NULL ) {
    /* Error handling for passing a NULL string pointer: */
    char	szError [ 256 ];
    InArguments.szDescription	= (LPSTR) szEmpty;
    sprintf ( szError, szFormatNullString,
              __procedure__, "szDescription" );
    RPC_CLIENT_CERROR ( szContNullString, szError );
  }
  /* Copy in the nMinAddrInK argument: */
  InArguments.nMinAddrInK	= nMinAddrInK;

  pResult	=
#ifdef MULTITHREAD
    (
#else
    (fnServerDbOpen_rets *)
#endif
    fnrpc_fnserverdbopen_1 (
	&InArguments,
#ifdef MULTITHREAD
	&Result,
#endif
	__pClient__ )
#ifdef MULTITHREAD
	== RPC_SUCCESS ) ? &Result : NULL
#endif
	;

  if ( pResult == NULL ) {
    /* Error handling for a failed RPC call, */
    /* i.e. the server did not respond: */
    char	szError [ 256 ];
    sprintf ( szError, szFormatRpcFailed, __procedure__,
              clnt_sperror ( __pClient__, __szHost__ ) );
    __pClient__	= RPC_CLIENT_DESTROY ( __pClient__ );
    RPC_CLIENT_CERROR ( szContRpcFailed, szError );
    Result	= ZeroResult;
    return Result.ReturnValue;
  }
#ifndef MULTITHREAD
  Result	= * pResult;
#endif

  /* Copy out the poObjIdMin argument: */
  if ( ! ( 
       poObjIdMin == NULL ) ) {
    *poObjIdMin	= pResult->poObjIdMin;
  }
  /* Copy out the poObjIdMax argument: */
  if ( ! ( 
       poObjIdMax == NULL ) ) {
    *poObjIdMax	= pResult->poObjIdMax;
  }

  if ( pResult && pResult->nErrorLvl ) {
    /* Server returned a user error message: */
    char	szErrorMsg [ 1024 ];
    strncpy ( szErrorMsg,
              ( pResult->pszErrorMsg && pResult->pszErrorMsg [ 0 ] ) ?
              (LPCSTR) pResult->pszErrorMsg : (LPCSTR) szEmpty,
              sizeof ( szErrorMsg ) );
    szErrorMsg [ sizeof ( szErrorMsg ) - 1 ]	= (char) 0;
    xdr_free ( (xdrproc_t) xdr_fnServerDbOpen_rets, (char *) pResult );
    RPC_CLIENT_SERROR ( pResult->nErrorLvl, __procedure__,
                        szErrorMsg );
  } else {
    xdr_free ( (xdrproc_t) xdr_fnServerDbOpen_rets, (char *) pResult );
  }
  if ( 
       poObjIdMin == NULL ) {
    /* Error handling for passing a NULL pointer on */
    /* out argument: */
    char	szError [ 256 ];
    sprintf ( szError, szFormatNullPassed,
              __procedure__, "poObjIdMin" );
    RPC_CLIENT_CERROR ( szContNullOutPassed, szError );
  }
  if ( 
       poObjIdMax == NULL ) {
    /* Error handling for passing a NULL pointer on */
    /* out argument: */
    char	szError [ 256 ];
    sprintf ( szError, szFormatNullPassed,
              __procedure__, "poObjIdMax" );
    RPC_CLIENT_CERROR ( szContNullOutPassed, szError );
  }

  return Result.ReturnValue;

} /* fnServerDbOpen */



bool_t DLLEXPORT fnServerObjectFlush
	(SHORTOBJID oShortObjIdHeap ,
	  SHORTOBJID oShortObjId)
{
  static const char	__procedure__[]	= "client:fnServerObjectFlush";
  static fnServerObjectFlush_rets	ZeroResult;
  fnServerObjectFlush_rets		* pResult = NULL;
  fnServerObjectFlush_rets		Result = ZeroResult;
  fnServerObjectFlush_args	InArguments;

  /* Client initialization: */
  if ( __bClientInitialize__ ) {
    __bClientInitialize__	= FALSE;
    RPC_CLIENT_INITIALIZE();
  }

#if	CLIENT_CREATE_BY_USER
  if ( __pClient__ == NULL ) {
    __pClient__	= RPC_CLIENT_CREATE ( __szHost__, __szTransport__ );
    if ( __pClient__ == NULL ) {
      /* Error handling for a not connected client: */
      char	szError [ 256 ];
      sprintf ( szError, szFormatNoServer, __procedure__ );
      RPC_CLIENT_ERROR ( szError );
      return Result.ReturnValue;
    }
  }
#else
  while ( __pClient__ == NULL ) {
    __pClient__	= RPC_CLIENT_CREATE ( __szHost__, __szTransport__ );
    if ( __pClient__ == NULL ) {
      /* Error handling for a not connected client: */
      char	szError [ 256 ];
      sprintf ( szError, szFormatNoServer, __procedure__ );
      RPC_CLIENT_CERROR ( szContNoServer, szError );
    }
  }
#endif	/* CLIENT_CREATE_BY_USER */

  /* Copy in the oShortObjIdHeap argument: */
  InArguments.oShortObjIdHeap	= oShortObjIdHeap;
  /* Copy in the oShortObjId argument: */
  InArguments.oShortObjId	= oShortObjId;

  pResult	=
#ifdef MULTITHREAD
    (
#else
    (fnServerObjectFlush_rets *)
#endif
    fnrpc_fnserverobjectflush_1 (
	&InArguments,
#ifdef MULTITHREAD
	&Result,
#endif
	__pClient__ )
#ifdef MULTITHREAD
	== RPC_SUCCESS ) ? &Result : NULL
#endif
	;

  if ( pResult == NULL ) {
    /* Error handling for a failed RPC call, */
    /* i.e. the server did not respond: */
    char	szError [ 256 ];
    sprintf ( szError, szFormatRpcFailed, __procedure__,
              clnt_sperror ( __pClient__, __szHost__ ) );
    __pClient__	= RPC_CLIENT_DESTROY ( __pClient__ );
    RPC_CLIENT_CERROR ( szContRpcFailed, szError );
    Result	= ZeroResult;
    return Result.ReturnValue;
  }
#ifndef MULTITHREAD
  Result	= * pResult;
#endif


  if ( pResult && pResult->nErrorLvl ) {
    /* Server returned a user error message: */
    char	szErrorMsg [ 1024 ];
    strncpy ( szErrorMsg,
              ( pResult->pszErrorMsg && pResult->pszErrorMsg [ 0 ] ) ?
              (LPCSTR) pResult->pszErrorMsg : (LPCSTR) szEmpty,
              sizeof ( szErrorMsg ) );
    szErrorMsg [ sizeof ( szErrorMsg ) - 1 ]	= (char) 0;
    xdr_free ( (xdrproc_t) xdr_fnServerObjectFlush_rets, (char *) pResult );
    RPC_CLIENT_SERROR ( pResult->nErrorLvl, __procedure__,
                        szErrorMsg );
  } else {
    xdr_free ( (xdrproc_t) xdr_fnServerObjectFlush_rets, (char *) pResult );
  }

  return Result.ReturnValue;

} /* fnServerObjectFlush */



SHLOCK DLLEXPORT fnServerObjectReadAtIndex
	(SHORTOBJID oShortObjIdHeap ,
	  SHORTOBJID oShortObjId ,
	  SHORTOBJID oExpectingClass ,
	  SHTYPETAG nExpectingTypeTag ,
	  int nIndex ,
	  int * pnValue ,
	  SHTYPETAG * pnTypeTag)
{
  static const char	__procedure__[]	= "client:fnServerObjectReadAtIndex";
  static fnServerObjectReadAtIndex_rets	ZeroResult;
  fnServerObjectReadAtIndex_rets		* pResult = NULL;
  fnServerObjectReadAtIndex_rets		Result = ZeroResult;
  fnServerObjectReadAtIndex_args	InArguments;

  /* Client initialization: */
  if ( __bClientInitialize__ ) {
    __bClientInitialize__	= FALSE;
    RPC_CLIENT_INITIALIZE();
  }

#if	CLIENT_CREATE_BY_USER
  if ( __pClient__ == NULL ) {
    __pClient__	= RPC_CLIENT_CREATE ( __szHost__, __szTransport__ );
    if ( __pClient__ == NULL ) {
      /* Error handling for a not connected client: */
      char	szError [ 256 ];
      sprintf ( szError, szFormatNoServer, __procedure__ );
      RPC_CLIENT_ERROR ( szError );
      return Result.ReturnValue;
    }
  }
#else
  while ( __pClient__ == NULL ) {
    __pClient__	= RPC_CLIENT_CREATE ( __szHost__, __szTransport__ );
    if ( __pClient__ == NULL ) {
      /* Error handling for a not connected client: */
      char	szError [ 256 ];
      sprintf ( szError, szFormatNoServer, __procedure__ );
      RPC_CLIENT_CERROR ( szContNoServer, szError );
    }
  }
#endif	/* CLIENT_CREATE_BY_USER */

  /* Copy in the oShortObjIdHeap argument: */
  InArguments.oShortObjIdHeap	= oShortObjIdHeap;
  /* Copy in the oShortObjId argument: */
  InArguments.oShortObjId	= oShortObjId;
  /* Copy in the oExpectingClass argument: */
  InArguments.oExpectingClass	= oExpectingClass;
  /* Copy in the nExpectingTypeTag argument: */
  InArguments.nExpectingTypeTag	= nExpectingTypeTag;
  /* Copy in the nIndex argument: */
  InArguments.nIndex	= nIndex;

  pResult	=
#ifdef MULTITHREAD
    (
#else
    (fnServerObjectReadAtIndex_rets *)
#endif
    fnrpc_fnserverobjectreadatindex_1 (
	&InArguments,
#ifdef MULTITHREAD
	&Result,
#endif
	__pClient__ )
#ifdef MULTITHREAD
	== RPC_SUCCESS ) ? &Result : NULL
#endif
	;

  if ( pResult == NULL ) {
    /* Error handling for a failed RPC call, */
    /* i.e. the server did not respond: */
    char	szError [ 256 ];
    sprintf ( szError, szFormatRpcFailed, __procedure__,
              clnt_sperror ( __pClient__, __szHost__ ) );
    __pClient__	= RPC_CLIENT_DESTROY ( __pClient__ );
    RPC_CLIENT_CERROR ( szContRpcFailed, szError );
    Result	= ZeroResult;
    return Result.ReturnValue;
  }
#ifndef MULTITHREAD
  Result	= * pResult;
#endif

  /* Copy out the pnValue argument: */
  if ( ! ( 
       pnValue == NULL ) ) {
    *pnValue	= pResult->pnValue;
  }
  /* Copy out the pnTypeTag argument: */
  if ( ! ( 
       pnTypeTag == NULL ) ) {
    *pnTypeTag	= pResult->pnTypeTag;
  }

  if ( pResult && pResult->nErrorLvl ) {
    /* Server returned a user error message: */
    char	szErrorMsg [ 1024 ];
    strncpy ( szErrorMsg,
              ( pResult->pszErrorMsg && pResult->pszErrorMsg [ 0 ] ) ?
              (LPCSTR) pResult->pszErrorMsg : (LPCSTR) szEmpty,
              sizeof ( szErrorMsg ) );
    szErrorMsg [ sizeof ( szErrorMsg ) - 1 ]	= (char) 0;
    xdr_free ( (xdrproc_t) xdr_fnServerObjectReadAtIndex_rets, (char *) pResult );
    RPC_CLIENT_SERROR ( pResult->nErrorLvl, __procedure__,
                        szErrorMsg );
  } else {
    xdr_free ( (xdrproc_t) xdr_fnServerObjectReadAtIndex_rets, (char *) pResult );
  }
  if ( 
       pnValue == NULL ) {
    /* Error handling for passing a NULL pointer on */
    /* out argument: */
    char	szError [ 256 ];
    sprintf ( szError, szFormatNullPassed,
              __procedure__, "pnValue" );
    RPC_CLIENT_CERROR ( szContNullOutPassed, szError );
  }
  if ( 
       pnTypeTag == NULL ) {
    /* Error handling for passing a NULL pointer on */
    /* out argument: */
    char	szError [ 256 ];
    sprintf ( szError, szFormatNullPassed,
              __procedure__, "pnTypeTag" );
    RPC_CLIENT_CERROR ( szContNullOutPassed, szError );
  }

  return Result.ReturnValue;

} /* fnServerObjectReadAtIndex */



int DLLEXPORT fnServerObjectReadAtIndices
	(SHORTOBJID oShortObjIdHeap ,
	  SHORTOBJID oShortObjId ,
	  SHORTOBJID oExpectingClass ,
	  SHTYPETAG nExpectingTypeTag ,
	  int nIndex ,
	  int nObjIds ,
	  int * /* _vector_t<nObjIds> */  pObjIds ,
	  u_int * /* _vector_t<nObjIds> */  pnTypeTags)
{
  static const char	__procedure__[]	= "client:fnServerObjectReadAtIndices";
  static fnServerObjectReadAtIndices_rets	ZeroResult;
  fnServerObjectReadAtIndices_rets		* pResult = NULL;
  fnServerObjectReadAtIndices_rets		Result = ZeroResult;
  fnServerObjectReadAtIndices_args	InArguments;

  /* Client initialization: */
  if ( __bClientInitialize__ ) {
    __bClientInitialize__	= FALSE;
    RPC_CLIENT_INITIALIZE();
  }

#if	CLIENT_CREATE_BY_USER
  if ( __pClient__ == NULL ) {
    __pClient__	= RPC_CLIENT_CREATE ( __szHost__, __szTransport__ );
    if ( __pClient__ == NULL ) {
      /* Error handling for a not connected client: */
      char	szError [ 256 ];
      sprintf ( szError, szFormatNoServer, __procedure__ );
      RPC_CLIENT_ERROR ( szError );
      return Result.ReturnValue;
    }
  }
#else
  while ( __pClient__ == NULL ) {
    __pClient__	= RPC_CLIENT_CREATE ( __szHost__, __szTransport__ );
    if ( __pClient__ == NULL ) {
      /* Error handling for a not connected client: */
      char	szError [ 256 ];
      sprintf ( szError, szFormatNoServer, __procedure__ );
      RPC_CLIENT_CERROR ( szContNoServer, szError );
    }
  }
#endif	/* CLIENT_CREATE_BY_USER */

  /* Copy in the oShortObjIdHeap argument: */
  InArguments.oShortObjIdHeap	= oShortObjIdHeap;
  /* Copy in the oShortObjId argument: */
  InArguments.oShortObjId	= oShortObjId;
  /* Copy in the oExpectingClass argument: */
  InArguments.oExpectingClass	= oExpectingClass;
  /* Copy in the nExpectingTypeTag argument: */
  InArguments.nExpectingTypeTag	= nExpectingTypeTag;
  /* Copy in the nIndex argument: */
  InArguments.nIndex	= nIndex;
  /* Copy in the nObjIds argument: */
  InArguments.nObjIds	= nObjIds;
  InArguments.pObjIdsSize	= nObjIds;
  InArguments.pnTypeTagsSize	= nObjIds;

  pResult	=
#ifdef MULTITHREAD
    (
#else
    (fnServerObjectReadAtIndices_rets *)
#endif
    fnrpc_fnserverobjectreadatindices_1 (
	&InArguments,
#ifdef MULTITHREAD
	&Result,
#endif
	__pClient__ )
#ifdef MULTITHREAD
	== RPC_SUCCESS ) ? &Result : NULL
#endif
	;

  if ( pResult == NULL ) {
    /* Error handling for a failed RPC call, */
    /* i.e. the server did not respond: */
    char	szError [ 256 ];
    sprintf ( szError, szFormatRpcFailed, __procedure__,
              clnt_sperror ( __pClient__, __szHost__ ) );
    __pClient__	= RPC_CLIENT_DESTROY ( __pClient__ );
    RPC_CLIENT_CERROR ( szContRpcFailed, szError );
    Result	= ZeroResult;
    return Result.ReturnValue;
  }
#ifndef MULTITHREAD
  Result	= * pResult;
#endif

  /* Copy out the pObjIds argument: */
  if ( ! ( 
       pResult->pObjIds.int_vector_t_len != 0 &&
       pObjIds == NULL ) ) {
    memcpy ( pObjIds,
             pResult->pObjIds.int_vector_t_val,
             MIN ( pResult->pObjIds.int_vector_t_len,
                   nObjIds ) *
             SIZEOF ( *(pResult->pObjIds.int_vector_t_val) ) );
  }
  /* Copy out the pnTypeTags argument: */
  if ( ! ( 
       pResult->pnTypeTags.u_int_vector_t_len != 0 &&
       pnTypeTags == NULL ) ) {
    memcpy ( pnTypeTags,
             pResult->pnTypeTags.u_int_vector_t_val,
             MIN ( pResult->pnTypeTags.u_int_vector_t_len,
                   nObjIds ) *
             SIZEOF ( *(pResult->pnTypeTags.u_int_vector_t_val) ) );
  }

  if ( pResult && pResult->nErrorLvl ) {
    /* Server returned a user error message: */
    char	szErrorMsg [ 1024 ];
    strncpy ( szErrorMsg,
              ( pResult->pszErrorMsg && pResult->pszErrorMsg [ 0 ] ) ?
              (LPCSTR) pResult->pszErrorMsg : (LPCSTR) szEmpty,
              sizeof ( szErrorMsg ) );
    szErrorMsg [ sizeof ( szErrorMsg ) - 1 ]	= (char) 0;
    xdr_free ( (xdrproc_t) xdr_fnServerObjectReadAtIndices_rets, (char *) pResult );
    RPC_CLIENT_SERROR ( pResult->nErrorLvl, __procedure__,
                        szErrorMsg );
  } else {
    xdr_free ( (xdrproc_t) xdr_fnServerObjectReadAtIndices_rets, (char *) pResult );
  }
  if ( 
       pResult->pObjIds.int_vector_t_len != 0 &&
       pObjIds == NULL ) {
    /* Error handling for passing a NULL pointer on */
    /* out argument: */
    char	szError [ 256 ];
    sprintf ( szError, szFormatNullPassed,
              __procedure__, "pObjIds" );
    RPC_CLIENT_CERROR ( szContNullOutPassed, szError );
  } else if ( pResult->pObjIds.int_vector_t_len > nObjIds ) {
      /* Error handling for an output buffer overflow, */
      /* i.e. the buffer size passed is too small: */
      /* For example, signal a CERROR here ... */
      char	szError [ 256 ];
      sprintf ( szError, szFormatBufferOverflow,
                __procedure__, "pObjIds", 
                nObjIds, 
                pResult->pObjIds.int_vector_t_len );
      RPC_CLIENT_CERROR ( szContBufferOverflow, szError );
  }
  if ( 
       pResult->pnTypeTags.u_int_vector_t_len != 0 &&
       pnTypeTags == NULL ) {
    /* Error handling for passing a NULL pointer on */
    /* out argument: */
    char	szError [ 256 ];
    sprintf ( szError, szFormatNullPassed,
              __procedure__, "pnTypeTags" );
    RPC_CLIENT_CERROR ( szContNullOutPassed, szError );
  } else if ( pResult->pnTypeTags.u_int_vector_t_len > nObjIds ) {
      /* Error handling for an output buffer overflow, */
      /* i.e. the buffer size passed is too small: */
      /* For example, signal a CERROR here ... */
      char	szError [ 256 ];
      sprintf ( szError, szFormatBufferOverflow,
                __procedure__, "pnTypeTags", 
                nObjIds, 
                pResult->pnTypeTags.u_int_vector_t_len );
      RPC_CLIENT_CERROR ( szContBufferOverflow, szError );
  }

  return Result.ReturnValue;

} /* fnServerObjectReadAtIndices */



SHLOCK DLLEXPORT fnServerObjectReadObjId
	(SHORTOBJID oShortObjIdHeap ,
	  SHORTOBJID oShortObjId ,
	  SHORTOBJID oExpectingClass ,
	  SHTYPETAG nExpectingTypeTag ,
	  int nIndex ,
	  int * pnObjId)
{
  static const char	__procedure__[]	= "client:fnServerObjectReadObjId";
  static fnServerObjectReadObjId_rets	ZeroResult;
  fnServerObjectReadObjId_rets		* pResult = NULL;
  fnServerObjectReadObjId_rets		Result = ZeroResult;
  fnServerObjectReadObjId_args	InArguments;

  /* Client initialization: */
  if ( __bClientInitialize__ ) {
    __bClientInitialize__	= FALSE;
    RPC_CLIENT_INITIALIZE();
  }

#if	CLIENT_CREATE_BY_USER
  if ( __pClient__ == NULL ) {
    __pClient__	= RPC_CLIENT_CREATE ( __szHost__, __szTransport__ );
    if ( __pClient__ == NULL ) {
      /* Error handling for a not connected client: */
      char	szError [ 256 ];
      sprintf ( szError, szFormatNoServer, __procedure__ );
      RPC_CLIENT_ERROR ( szError );
      return Result.ReturnValue;
    }
  }
#else
  while ( __pClient__ == NULL ) {
    __pClient__	= RPC_CLIENT_CREATE ( __szHost__, __szTransport__ );
    if ( __pClient__ == NULL ) {
      /* Error handling for a not connected client: */
      char	szError [ 256 ];
      sprintf ( szError, szFormatNoServer, __procedure__ );
      RPC_CLIENT_CERROR ( szContNoServer, szError );
    }
  }
#endif	/* CLIENT_CREATE_BY_USER */

  /* Copy in the oShortObjIdHeap argument: */
  InArguments.oShortObjIdHeap	= oShortObjIdHeap;
  /* Copy in the oShortObjId argument: */
  InArguments.oShortObjId	= oShortObjId;
  /* Copy in the oExpectingClass argument: */
  InArguments.oExpectingClass	= oExpectingClass;
  /* Copy in the nExpectingTypeTag argument: */
  InArguments.nExpectingTypeTag	= nExpectingTypeTag;
  /* Copy in the nIndex argument: */
  InArguments.nIndex	= nIndex;

  pResult	=
#ifdef MULTITHREAD
    (
#else
    (fnServerObjectReadObjId_rets *)
#endif
    fnrpc_fnserverobjectreadobjid_1 (
	&InArguments,
#ifdef MULTITHREAD
	&Result,
#endif
	__pClient__ )
#ifdef MULTITHREAD
	== RPC_SUCCESS ) ? &Result : NULL
#endif
	;

  if ( pResult == NULL ) {
    /* Error handling for a failed RPC call, */
    /* i.e. the server did not respond: */
    char	szError [ 256 ];
    sprintf ( szError, szFormatRpcFailed, __procedure__,
              clnt_sperror ( __pClient__, __szHost__ ) );
    __pClient__	= RPC_CLIENT_DESTROY ( __pClient__ );
    RPC_CLIENT_CERROR ( szContRpcFailed, szError );
    Result	= ZeroResult;
    return Result.ReturnValue;
  }
#ifndef MULTITHREAD
  Result	= * pResult;
#endif

  /* Copy out the pnObjId argument: */
  if ( ! ( 
       pnObjId == NULL ) ) {
    *pnObjId	= pResult->pnObjId;
  }

  if ( pResult && pResult->nErrorLvl ) {
    /* Server returned a user error message: */
    char	szErrorMsg [ 1024 ];
    strncpy ( szErrorMsg,
              ( pResult->pszErrorMsg && pResult->pszErrorMsg [ 0 ] ) ?
              (LPCSTR) pResult->pszErrorMsg : (LPCSTR) szEmpty,
              sizeof ( szErrorMsg ) );
    szErrorMsg [ sizeof ( szErrorMsg ) - 1 ]	= (char) 0;
    xdr_free ( (xdrproc_t) xdr_fnServerObjectReadObjId_rets, (char *) pResult );
    RPC_CLIENT_SERROR ( pResult->nErrorLvl, __procedure__,
                        szErrorMsg );
  } else {
    xdr_free ( (xdrproc_t) xdr_fnServerObjectReadObjId_rets, (char *) pResult );
  }
  if ( 
       pnObjId == NULL ) {
    /* Error handling for passing a NULL pointer on */
    /* out argument: */
    char	szError [ 256 ];
    sprintf ( szError, szFormatNullPassed,
              __procedure__, "pnObjId" );
    RPC_CLIENT_CERROR ( szContNullOutPassed, szError );
  }

  return Result.ReturnValue;

} /* fnServerObjectReadObjId */



int DLLEXPORT fnServerObjectReadValues
	(SHORTOBJID oShortObjIdHeap ,
	  SHORTOBJID oShortObjId ,
	  SHORTOBJID oExpectingClass ,
	  SHTYPETAG nExpectingTypeTag ,
	  int nIndex ,
	  SHTYPETAG nElementTypeTagIn ,
	  int nSizeInElementsIn ,
	  SHTYPETAG * pnElementTypeTagOut ,
	  int * pnSizeInElementsOut ,
	  void * /* _vector_t<((( fnTypeTagSizeValue(1,&nElementTypeTagIn, &nSizeInElementsIn) )*( sizeof(int) )) )> */  pBuffer)
{
  static const char	__procedure__[]	= "client:fnServerObjectReadValues";
  static fnServerObjectReadValues_rets	ZeroResult;
  fnServerObjectReadValues_rets		* pResult = NULL;
  fnServerObjectReadValues_rets		Result = ZeroResult;
  fnServerObjectReadValues_args	InArguments;

  /* Client initialization: */
  if ( __bClientInitialize__ ) {
    __bClientInitialize__	= FALSE;
    RPC_CLIENT_INITIALIZE();
  }

#if	CLIENT_CREATE_BY_USER
  if ( __pClient__ == NULL ) {
    __pClient__	= RPC_CLIENT_CREATE ( __szHost__, __szTransport__ );
    if ( __pClient__ == NULL ) {
      /* Error handling for a not connected client: */
      char	szError [ 256 ];
      sprintf ( szError, szFormatNoServer, __procedure__ );
      RPC_CLIENT_ERROR ( szError );
      return Result.ReturnValue;
    }
  }
#else
  while ( __pClient__ == NULL ) {
    __pClient__	= RPC_CLIENT_CREATE ( __szHost__, __szTransport__ );
    if ( __pClient__ == NULL ) {
      /* Error handling for a not connected client: */
      char	szError [ 256 ];
      sprintf ( szError, szFormatNoServer, __procedure__ );
      RPC_CLIENT_CERROR ( szContNoServer, szError );
    }
  }
#endif	/* CLIENT_CREATE_BY_USER */

  /* Copy in the oShortObjIdHeap argument: */
  InArguments.oShortObjIdHeap	= oShortObjIdHeap;
  /* Copy in the oShortObjId argument: */
  InArguments.oShortObjId	= oShortObjId;
  /* Copy in the oExpectingClass argument: */
  InArguments.oExpectingClass	= oExpectingClass;
  /* Copy in the nExpectingTypeTag argument: */
  InArguments.nExpectingTypeTag	= nExpectingTypeTag;
  /* Copy in the nIndex argument: */
  InArguments.nIndex	= nIndex;
  /* Copy in the nElementTypeTagIn argument: */
  InArguments.nElementTypeTagIn	= nElementTypeTagIn;
  /* Copy in the nSizeInElementsIn argument: */
  InArguments.nSizeInElementsIn	= nSizeInElementsIn;
  InArguments.pBufferSize	= ((( fnTypeTagSizeValue(1,&nElementTypeTagIn, &nSizeInElementsIn) )*( sizeof(int) )) );

  pResult	=
#ifdef MULTITHREAD
    (
#else
    (fnServerObjectReadValues_rets *)
#endif
    fnrpc_fnserverobjectreadvalues_1 (
	&InArguments,
#ifdef MULTITHREAD
	&Result,
#endif
	__pClient__ )
#ifdef MULTITHREAD
	== RPC_SUCCESS ) ? &Result : NULL
#endif
	;

  if ( pResult == NULL ) {
    /* Error handling for a failed RPC call, */
    /* i.e. the server did not respond: */
    char	szError [ 256 ];
    sprintf ( szError, szFormatRpcFailed, __procedure__,
              clnt_sperror ( __pClient__, __szHost__ ) );
    __pClient__	= RPC_CLIENT_DESTROY ( __pClient__ );
    RPC_CLIENT_CERROR ( szContRpcFailed, szError );
    Result	= ZeroResult;
    return Result.ReturnValue;
  }
#ifndef MULTITHREAD
  Result	= * pResult;
#endif

  /* Copy out the pnElementTypeTagOut argument: */
  if ( ! ( 
       pnElementTypeTagOut == NULL ) ) {
    *pnElementTypeTagOut	= pResult->pnElementTypeTagOut;
  }
  /* Copy out the pnSizeInElementsOut argument: */
  if ( ! ( 
       pnSizeInElementsOut == NULL ) ) {
    *pnSizeInElementsOut	= pResult->pnSizeInElementsOut;
  }
  /* Copy out the pBuffer argument: */
  if ( ! ( 
       pResult->pBuffer.void_vector_t_len != 0 &&
       pBuffer == NULL ) ) {
    memcpy ( pBuffer,
             pResult->pBuffer.void_vector_t_val,
             MIN ( pResult->pBuffer.void_vector_t_len,
                   ((( fnTypeTagSizeValue(1,&nElementTypeTagIn, &nSizeInElementsIn) )*( sizeof(int) )) ) ) *
             SIZEOF ( *(pResult->pBuffer.void_vector_t_val) ) );
  }

  if ( pResult && pResult->nErrorLvl ) {
    /* Server returned a user error message: */
    char	szErrorMsg [ 1024 ];
    strncpy ( szErrorMsg,
              ( pResult->pszErrorMsg && pResult->pszErrorMsg [ 0 ] ) ?
              (LPCSTR) pResult->pszErrorMsg : (LPCSTR) szEmpty,
              sizeof ( szErrorMsg ) );
    szErrorMsg [ sizeof ( szErrorMsg ) - 1 ]	= (char) 0;
    xdr_free ( (xdrproc_t) xdr_fnServerObjectReadValues_rets, (char *) pResult );
    RPC_CLIENT_SERROR ( pResult->nErrorLvl, __procedure__,
                        szErrorMsg );
  } else {
    xdr_free ( (xdrproc_t) xdr_fnServerObjectReadValues_rets, (char *) pResult );
  }
  if ( 
       pnElementTypeTagOut == NULL ) {
    /* Error handling for passing a NULL pointer on */
    /* out argument: */
    char	szError [ 256 ];
    sprintf ( szError, szFormatNullPassed,
              __procedure__, "pnElementTypeTagOut" );
    RPC_CLIENT_CERROR ( szContNullOutPassed, szError );
  }
  if ( 
       pnSizeInElementsOut == NULL ) {
    /* Error handling for passing a NULL pointer on */
    /* out argument: */
    char	szError [ 256 ];
    sprintf ( szError, szFormatNullPassed,
              __procedure__, "pnSizeInElementsOut" );
    RPC_CLIENT_CERROR ( szContNullOutPassed, szError );
  }
  if ( 
       pResult->pBuffer.void_vector_t_len != 0 &&
       pBuffer == NULL ) {
    /* Error handling for passing a NULL pointer on */
    /* out argument: */
    char	szError [ 256 ];
    sprintf ( szError, szFormatNullPassed,
              __procedure__, "pBuffer" );
    RPC_CLIENT_CERROR ( szContNullOutPassed, szError );
  } else if ( pResult->pBuffer.void_vector_t_len > ((( fnTypeTagSizeValue(1,&nElementTypeTagIn, &nSizeInElementsIn) )*( sizeof(int) )) ) ) {
      /* Error handling for an output buffer overflow, */
      /* i.e. the buffer size passed is too small: */
      /* For example, signal a CERROR here ... */
      char	szError [ 256 ];
      sprintf ( szError, szFormatBufferOverflow,
                __procedure__, "pBuffer", 
                ((( fnTypeTagSizeValue(1,&nElementTypeTagIn, &nSizeInElementsIn) )*( sizeof(int) )) ), 
                pResult->pBuffer.void_vector_t_len );
      RPC_CLIENT_CERROR ( szContBufferOverflow, szError );
  }

  return Result.ReturnValue;

} /* fnServerObjectReadValues */



bool_t DLLEXPORT fnClientDbStatistics
	(SHORTOBJID oShortObjIdHeap ,
	  int * pnMaximumSpace ,
	  int * pnAllocatedSpace ,
	  int * pnUnallocatedSpace ,
	  int * pnUnusedAllocatedSpace ,
	  int * pnAllocatedManagementSpace ,
	  int * pnNumberOfObjects)
{
  static const char	__procedure__[]	= "client:fnClientDbStatistics";
  static fnClientDbStatistics_rets	ZeroResult;
  fnClientDbStatistics_rets		* pResult = NULL;
  fnClientDbStatistics_rets		Result = ZeroResult;

  /* Client initialization: */
  if ( __bClientInitialize__ ) {
    __bClientInitialize__	= FALSE;
    RPC_CLIENT_INITIALIZE();
  }

#if	CLIENT_CREATE_BY_USER
  if ( __pClient__ == NULL ) {
    __pClient__	= RPC_CLIENT_CREATE ( __szHost__, __szTransport__ );
    if ( __pClient__ == NULL ) {
      /* Error handling for a not connected client: */
      char	szError [ 256 ];
      sprintf ( szError, szFormatNoServer, __procedure__ );
      RPC_CLIENT_ERROR ( szError );
      return Result.ReturnValue;
    }
  }
#else
  while ( __pClient__ == NULL ) {
    __pClient__	= RPC_CLIENT_CREATE ( __szHost__, __szTransport__ );
    if ( __pClient__ == NULL ) {
      /* Error handling for a not connected client: */
      char	szError [ 256 ];
      sprintf ( szError, szFormatNoServer, __procedure__ );
      RPC_CLIENT_CERROR ( szContNoServer, szError );
    }
  }
#endif	/* CLIENT_CREATE_BY_USER */

  pResult	=
#ifdef MULTITHREAD
    (
#else
    (fnClientDbStatistics_rets *)
#endif
    fnrpc_fnclientdbstatistics_1 (
	&oShortObjIdHeap,
#ifdef MULTITHREAD
	&Result,
#endif
	__pClient__ )
#ifdef MULTITHREAD
	== RPC_SUCCESS ) ? &Result : NULL
#endif
	;

  if ( pResult == NULL ) {
    /* Error handling for a failed RPC call, */
    /* i.e. the server did not respond: */
    char	szError [ 256 ];
    sprintf ( szError, szFormatRpcFailed, __procedure__,
              clnt_sperror ( __pClient__, __szHost__ ) );
    __pClient__	= RPC_CLIENT_DESTROY ( __pClient__ );
    RPC_CLIENT_CERROR ( szContRpcFailed, szError );
    Result	= ZeroResult;
    return Result.ReturnValue;
  }
#ifndef MULTITHREAD
  Result	= * pResult;
#endif

  /* Copy out the pnMaximumSpace argument: */
  if ( ! ( 
       pnMaximumSpace == NULL ) ) {
    *pnMaximumSpace	= pResult->pnMaximumSpace;
  }
  /* Copy out the pnAllocatedSpace argument: */
  if ( ! ( 
       pnAllocatedSpace == NULL ) ) {
    *pnAllocatedSpace	= pResult->pnAllocatedSpace;
  }
  /* Copy out the pnUnallocatedSpace argument: */
  if ( ! ( 
       pnUnallocatedSpace == NULL ) ) {
    *pnUnallocatedSpace	= pResult->pnUnallocatedSpace;
  }
  /* Copy out the pnUnusedAllocatedSpace argument: */
  if ( ! ( 
       pnUnusedAllocatedSpace == NULL ) ) {
    *pnUnusedAllocatedSpace	= pResult->pnUnusedAllocatedSpace;
  }
  /* Copy out the pnAllocatedManagementSpace argument: */
  if ( ! ( 
       pnAllocatedManagementSpace == NULL ) ) {
    *pnAllocatedManagementSpace	= pResult->pnAllocatedManagementSpace;
  }
  /* Copy out the pnNumberOfObjects argument: */
  if ( ! ( 
       pnNumberOfObjects == NULL ) ) {
    *pnNumberOfObjects	= pResult->pnNumberOfObjects;
  }

  if ( pResult && pResult->nErrorLvl ) {
    /* Server returned a user error message: */
    char	szErrorMsg [ 1024 ];
    strncpy ( szErrorMsg,
              ( pResult->pszErrorMsg && pResult->pszErrorMsg [ 0 ] ) ?
              (LPCSTR) pResult->pszErrorMsg : (LPCSTR) szEmpty,
              sizeof ( szErrorMsg ) );
    szErrorMsg [ sizeof ( szErrorMsg ) - 1 ]	= (char) 0;
    xdr_free ( (xdrproc_t) xdr_fnClientDbStatistics_rets, (char *) pResult );
    RPC_CLIENT_SERROR ( pResult->nErrorLvl, __procedure__,
                        szErrorMsg );
  } else {
    xdr_free ( (xdrproc_t) xdr_fnClientDbStatistics_rets, (char *) pResult );
  }
  if ( 
       pnMaximumSpace == NULL ) {
    /* Error handling for passing a NULL pointer on */
    /* out argument: */
    char	szError [ 256 ];
    sprintf ( szError, szFormatNullPassed,
              __procedure__, "pnMaximumSpace" );
    RPC_CLIENT_CERROR ( szContNullOutPassed, szError );
  }
  if ( 
       pnAllocatedSpace == NULL ) {
    /* Error handling for passing a NULL pointer on */
    /* out argument: */
    char	szError [ 256 ];
    sprintf ( szError, szFormatNullPassed,
              __procedure__, "pnAllocatedSpace" );
    RPC_CLIENT_CERROR ( szContNullOutPassed, szError );
  }
  if ( 
       pnUnallocatedSpace == NULL ) {
    /* Error handling for passing a NULL pointer on */
    /* out argument: */
    char	szError [ 256 ];
    sprintf ( szError, szFormatNullPassed,
              __procedure__, "pnUnallocatedSpace" );
    RPC_CLIENT_CERROR ( szContNullOutPassed, szError );
  }
  if ( 
       pnUnusedAllocatedSpace == NULL ) {
    /* Error handling for passing a NULL pointer on */
    /* out argument: */
    char	szError [ 256 ];
    sprintf ( szError, szFormatNullPassed,
              __procedure__, "pnUnusedAllocatedSpace" );
    RPC_CLIENT_CERROR ( szContNullOutPassed, szError );
  }
  if ( 
       pnAllocatedManagementSpace == NULL ) {
    /* Error handling for passing a NULL pointer on */
    /* out argument: */
    char	szError [ 256 ];
    sprintf ( szError, szFormatNullPassed,
              __procedure__, "pnAllocatedManagementSpace" );
    RPC_CLIENT_CERROR ( szContNullOutPassed, szError );
  }
  if ( 
       pnNumberOfObjects == NULL ) {
    /* Error handling for passing a NULL pointer on */
    /* out argument: */
    char	szError [ 256 ];
    sprintf ( szError, szFormatNullPassed,
              __procedure__, "pnNumberOfObjects" );
    RPC_CLIENT_CERROR ( szContNullOutPassed, szError );
  }

  return Result.ReturnValue;

} /* fnClientDbStatistics */



void DLLEXPORT fnServerDbStabilise
	(SHORTOBJID oShortObjIdHeap)
{
  static const char	__procedure__[]	= "client:fnServerDbStabilise";
  static char	ZeroResult;
  void		* pResult = NULL;
#ifdef MULTITHREAD
  char		Result = ZeroResult;
#endif

  /* Client initialization: */
  if ( __bClientInitialize__ ) {
    __bClientInitialize__	= FALSE;
    RPC_CLIENT_INITIALIZE();
  }

#if	CLIENT_CREATE_BY_USER
  if ( __pClient__ == NULL ) {
    __pClient__	= RPC_CLIENT_CREATE ( __szHost__, __szTransport__ );
    if ( __pClient__ == NULL ) {
      /* Error handling for a not connected client: */
      char	szError [ 256 ];
      sprintf ( szError, szFormatNoServer, __procedure__ );
      RPC_CLIENT_ERROR ( szError );
      return;
    }
  }
#else
  while ( __pClient__ == NULL ) {
    __pClient__	= RPC_CLIENT_CREATE ( __szHost__, __szTransport__ );
    if ( __pClient__ == NULL ) {
      /* Error handling for a not connected client: */
      char	szError [ 256 ];
      sprintf ( szError, szFormatNoServer, __procedure__ );
      RPC_CLIENT_CERROR ( szContNoServer, szError );
    }
  }
#endif	/* CLIENT_CREATE_BY_USER */

  pResult	=
#ifdef MULTITHREAD
    (
#else
    (void *)
#endif
    fnrpc_fnserverdbstabilise_batch_1 (
	&oShortObjIdHeap,
#ifdef MULTITHREAD
	&Result,
#endif
	__pClient__ )
#ifdef MULTITHREAD
	== RPC_SUCCESS ) ? &Result : NULL
#endif
	;

  if ( pResult == NULL ) {
    /* Error handling for a failed RPC call, */
    /* i.e. the server did not respond: */
    char	szError [ 256 ];
    sprintf ( szError, szFormatRpcFailed, __procedure__,
              clnt_sperror ( __pClient__, __szHost__ ) );
    __pClient__	= RPC_CLIENT_DESTROY ( __pClient__ );
    RPC_CLIENT_CERROR ( szContRpcFailed, szError );
    return;
  }
} /* fnServerDbStabilise */

#ifdef MULTITHREAD
enum clnt_stat
#else
void *
#endif
fnrpc_fnserverdbstabilise_batch_1
	( SHORTOBJID * pArguments,
#ifdef MULTITHREAD
	  void * clnt_res,
#endif
	  PCLIENT pClient )
{
#ifdef MULTITHREAD
  return clnt_call ( pClient, fnRpc_fnServerDbStabilise_batch,
                     (xdrproc_t) xdr_SHORTOBJID,
                     (caddr_t) pArguments,
                     (xdrproc_t) NULL, (caddr_t) NULL,
                     NullTimeout );
#else
  if ( clnt_call ( pClient, fnRpc_fnServerDbStabilise_batch,
                   (xdrproc_t) xdr_SHORTOBJID,
                   (caddr_t) pArguments,
                   (xdrproc_t) NULL, (caddr_t) NULL,
                   NullTimeout ) != RPC_SUCCESS ) {
    return NULL;
  }
  return (void *) TRUE;
#endif
} /* fnrpc_fnserverdbstabilise_batch_1 */
#define	fnrpc_fnserverdbstabilise_batch_1	fnrpc_fnserverdbstabilise_1



SHTYPETAG DLLEXPORT fnServerObjectTypeTag
	(SHORTOBJID oShortObjIdHeap ,
	  SHORTOBJID oShortObjId)
{
  static const char	__procedure__[]	= "client:fnServerObjectTypeTag";
  static fnServerObjectTypeTag_rets	ZeroResult;
  fnServerObjectTypeTag_rets		* pResult = NULL;
  fnServerObjectTypeTag_rets		Result = ZeroResult;
  fnServerObjectTypeTag_args	InArguments;

  /* Client initialization: */
  if ( __bClientInitialize__ ) {
    __bClientInitialize__	= FALSE;
    RPC_CLIENT_INITIALIZE();
  }

#if	CLIENT_CREATE_BY_USER
  if ( __pClient__ == NULL ) {
    __pClient__	= RPC_CLIENT_CREATE ( __szHost__, __szTransport__ );
    if ( __pClient__ == NULL ) {
      /* Error handling for a not connected client: */
      char	szError [ 256 ];
      sprintf ( szError, szFormatNoServer, __procedure__ );
      RPC_CLIENT_ERROR ( szError );
      return Result.ReturnValue;
    }
  }
#else
  while ( __pClient__ == NULL ) {
    __pClient__	= RPC_CLIENT_CREATE ( __szHost__, __szTransport__ );
    if ( __pClient__ == NULL ) {
      /* Error handling for a not connected client: */
      char	szError [ 256 ];
      sprintf ( szError, szFormatNoServer, __procedure__ );
      RPC_CLIENT_CERROR ( szContNoServer, szError );
    }
  }
#endif	/* CLIENT_CREATE_BY_USER */

  /* Copy in the oShortObjIdHeap argument: */
  InArguments.oShortObjIdHeap	= oShortObjIdHeap;
  /* Copy in the oShortObjId argument: */
  InArguments.oShortObjId	= oShortObjId;

  pResult	=
#ifdef MULTITHREAD
    (
#else
    (fnServerObjectTypeTag_rets *)
#endif
    fnrpc_fnserverobjecttypetag_1 (
	&InArguments,
#ifdef MULTITHREAD
	&Result,
#endif
	__pClient__ )
#ifdef MULTITHREAD
	== RPC_SUCCESS ) ? &Result : NULL
#endif
	;

  if ( pResult == NULL ) {
    /* Error handling for a failed RPC call, */
    /* i.e. the server did not respond: */
    char	szError [ 256 ];
    sprintf ( szError, szFormatRpcFailed, __procedure__,
              clnt_sperror ( __pClient__, __szHost__ ) );
    __pClient__	= RPC_CLIENT_DESTROY ( __pClient__ );
    RPC_CLIENT_CERROR ( szContRpcFailed, szError );
    Result	= ZeroResult;
    return Result.ReturnValue;
  }
#ifndef MULTITHREAD
  Result	= * pResult;
#endif


  if ( pResult && pResult->nErrorLvl ) {
    /* Server returned a user error message: */
    char	szErrorMsg [ 1024 ];
    strncpy ( szErrorMsg,
              ( pResult->pszErrorMsg && pResult->pszErrorMsg [ 0 ] ) ?
              (LPCSTR) pResult->pszErrorMsg : (LPCSTR) szEmpty,
              sizeof ( szErrorMsg ) );
    szErrorMsg [ sizeof ( szErrorMsg ) - 1 ]	= (char) 0;
    xdr_free ( (xdrproc_t) xdr_fnServerObjectTypeTag_rets, (char *) pResult );
    RPC_CLIENT_SERROR ( pResult->nErrorLvl, __procedure__,
                        szErrorMsg );
  } else {
    xdr_free ( (xdrproc_t) xdr_fnServerObjectTypeTag_rets, (char *) pResult );
  }

  return Result.ReturnValue;

} /* fnServerObjectTypeTag */



int DLLEXPORT fnServerObjectValueSize
	(SHORTOBJID oShortObjIdHeap ,
	  SHORTOBJID oShortObjId)
{
  static const char	__procedure__[]	= "client:fnServerObjectValueSize";
  static fnServerObjectValueSize_rets	ZeroResult;
  fnServerObjectValueSize_rets		* pResult = NULL;
  fnServerObjectValueSize_rets		Result = ZeroResult;
  fnServerObjectValueSize_args	InArguments;

  /* Client initialization: */
  if ( __bClientInitialize__ ) {
    __bClientInitialize__	= FALSE;
    RPC_CLIENT_INITIALIZE();
  }

#if	CLIENT_CREATE_BY_USER
  if ( __pClient__ == NULL ) {
    __pClient__	= RPC_CLIENT_CREATE ( __szHost__, __szTransport__ );
    if ( __pClient__ == NULL ) {
      /* Error handling for a not connected client: */
      char	szError [ 256 ];
      sprintf ( szError, szFormatNoServer, __procedure__ );
      RPC_CLIENT_ERROR ( szError );
      return Result.ReturnValue;
    }
  }
#else
  while ( __pClient__ == NULL ) {
    __pClient__	= RPC_CLIENT_CREATE ( __szHost__, __szTransport__ );
    if ( __pClient__ == NULL ) {
      /* Error handling for a not connected client: */
      char	szError [ 256 ];
      sprintf ( szError, szFormatNoServer, __procedure__ );
      RPC_CLIENT_CERROR ( szContNoServer, szError );
    }
  }
#endif	/* CLIENT_CREATE_BY_USER */

  /* Copy in the oShortObjIdHeap argument: */
  InArguments.oShortObjIdHeap	= oShortObjIdHeap;
  /* Copy in the oShortObjId argument: */
  InArguments.oShortObjId	= oShortObjId;

  pResult	=
#ifdef MULTITHREAD
    (
#else
    (fnServerObjectValueSize_rets *)
#endif
    fnrpc_fnserverobjectvaluesize_1 (
	&InArguments,
#ifdef MULTITHREAD
	&Result,
#endif
	__pClient__ )
#ifdef MULTITHREAD
	== RPC_SUCCESS ) ? &Result : NULL
#endif
	;

  if ( pResult == NULL ) {
    /* Error handling for a failed RPC call, */
    /* i.e. the server did not respond: */
    char	szError [ 256 ];
    sprintf ( szError, szFormatRpcFailed, __procedure__,
              clnt_sperror ( __pClient__, __szHost__ ) );
    __pClient__	= RPC_CLIENT_DESTROY ( __pClient__ );
    RPC_CLIENT_CERROR ( szContRpcFailed, szError );
    Result	= ZeroResult;
    return Result.ReturnValue;
  }
#ifndef MULTITHREAD
  Result	= * pResult;
#endif


  if ( pResult && pResult->nErrorLvl ) {
    /* Server returned a user error message: */
    char	szErrorMsg [ 1024 ];
    strncpy ( szErrorMsg,
              ( pResult->pszErrorMsg && pResult->pszErrorMsg [ 0 ] ) ?
              (LPCSTR) pResult->pszErrorMsg : (LPCSTR) szEmpty,
              sizeof ( szErrorMsg ) );
    szErrorMsg [ sizeof ( szErrorMsg ) - 1 ]	= (char) 0;
    xdr_free ( (xdrproc_t) xdr_fnServerObjectValueSize_rets, (char *) pResult );
    RPC_CLIENT_SERROR ( pResult->nErrorLvl, __procedure__,
                        szErrorMsg );
  } else {
    xdr_free ( (xdrproc_t) xdr_fnServerObjectValueSize_rets, (char *) pResult );
  }

  return Result.ReturnValue;

} /* fnServerObjectValueSize */



SHLOCK DLLEXPORT fnServerObjectWriteAtIndex
	(SHORTOBJID oShortObjIdHeap ,
	  SHORTOBJID oShortObjId ,
	  SHORTOBJID oExpectingClass ,
	  SHTYPETAG nExpectingTypeTag ,
	  int nIndex ,
	  int nValue ,
	  SHTYPETAG nTypeTagValue)
{
  static const char	__procedure__[]	= "client:fnServerObjectWriteAtIndex";
  static fnServerObjectWriteAtIndex_rets	ZeroResult;
  fnServerObjectWriteAtIndex_rets		* pResult = NULL;
  fnServerObjectWriteAtIndex_rets		Result = ZeroResult;
  fnServerObjectWriteAtIndex_args	InArguments;

  /* Client initialization: */
  if ( __bClientInitialize__ ) {
    __bClientInitialize__	= FALSE;
    RPC_CLIENT_INITIALIZE();
  }

#if	CLIENT_CREATE_BY_USER
  if ( __pClient__ == NULL ) {
    __pClient__	= RPC_CLIENT_CREATE ( __szHost__, __szTransport__ );
    if ( __pClient__ == NULL ) {
      /* Error handling for a not connected client: */
      char	szError [ 256 ];
      sprintf ( szError, szFormatNoServer, __procedure__ );
      RPC_CLIENT_ERROR ( szError );
      return Result.ReturnValue;
    }
  }
#else
  while ( __pClient__ == NULL ) {
    __pClient__	= RPC_CLIENT_CREATE ( __szHost__, __szTransport__ );
    if ( __pClient__ == NULL ) {
      /* Error handling for a not connected client: */
      char	szError [ 256 ];
      sprintf ( szError, szFormatNoServer, __procedure__ );
      RPC_CLIENT_CERROR ( szContNoServer, szError );
    }
  }
#endif	/* CLIENT_CREATE_BY_USER */

  /* Copy in the oShortObjIdHeap argument: */
  InArguments.oShortObjIdHeap	= oShortObjIdHeap;
  /* Copy in the oShortObjId argument: */
  InArguments.oShortObjId	= oShortObjId;
  /* Copy in the oExpectingClass argument: */
  InArguments.oExpectingClass	= oExpectingClass;
  /* Copy in the nExpectingTypeTag argument: */
  InArguments.nExpectingTypeTag	= nExpectingTypeTag;
  /* Copy in the nIndex argument: */
  InArguments.nIndex	= nIndex;
  /* Copy in the nValue argument: */
  InArguments.nValue	= nValue;
  /* Copy in the nTypeTagValue argument: */
  InArguments.nTypeTagValue	= nTypeTagValue;

  pResult	=
#ifdef MULTITHREAD
    (
#else
    (fnServerObjectWriteAtIndex_rets *)
#endif
    fnrpc_fnserverobjectwriteatindex_1 (
	&InArguments,
#ifdef MULTITHREAD
	&Result,
#endif
	__pClient__ )
#ifdef MULTITHREAD
	== RPC_SUCCESS ) ? &Result : NULL
#endif
	;

  if ( pResult == NULL ) {
    /* Error handling for a failed RPC call, */
    /* i.e. the server did not respond: */
    char	szError [ 256 ];
    sprintf ( szError, szFormatRpcFailed, __procedure__,
              clnt_sperror ( __pClient__, __szHost__ ) );
    __pClient__	= RPC_CLIENT_DESTROY ( __pClient__ );
    RPC_CLIENT_CERROR ( szContRpcFailed, szError );
    Result	= ZeroResult;
    return Result.ReturnValue;
  }
#ifndef MULTITHREAD
  Result	= * pResult;
#endif


  if ( pResult && pResult->nErrorLvl ) {
    /* Server returned a user error message: */
    char	szErrorMsg [ 1024 ];
    strncpy ( szErrorMsg,
              ( pResult->pszErrorMsg && pResult->pszErrorMsg [ 0 ] ) ?
              (LPCSTR) pResult->pszErrorMsg : (LPCSTR) szEmpty,
              sizeof ( szErrorMsg ) );
    szErrorMsg [ sizeof ( szErrorMsg ) - 1 ]	= (char) 0;
    xdr_free ( (xdrproc_t) xdr_fnServerObjectWriteAtIndex_rets, (char *) pResult );
    RPC_CLIENT_SERROR ( pResult->nErrorLvl, __procedure__,
                        szErrorMsg );
  } else {
    xdr_free ( (xdrproc_t) xdr_fnServerObjectWriteAtIndex_rets, (char *) pResult );
  }

  return Result.ReturnValue;

} /* fnServerObjectWriteAtIndex */



int DLLEXPORT fnServerObjectWriteAtIndices
	(SHORTOBJID oShortObjIdHeap ,
	  SHORTOBJID oShortObjId ,
	  SHORTOBJID oExpectingClass ,
	  SHTYPETAG nExpectingTypeTag ,
	  int nIndex ,
	  int nObjIds ,
	  int * /* _vector_t<nObjIds> */ pObjIds ,
	  u_int * /* _vector_t<nObjIds> */ pnTypeTags)
{
  static const char	__procedure__[]	= "client:fnServerObjectWriteAtIndices";
  static fnServerObjectWriteAtIndices_rets	ZeroResult;
  fnServerObjectWriteAtIndices_rets		* pResult = NULL;
  fnServerObjectWriteAtIndices_rets		Result = ZeroResult;
  fnServerObjectWriteAtIndices_args	InArguments;

  /* Client initialization: */
  if ( __bClientInitialize__ ) {
    __bClientInitialize__	= FALSE;
    RPC_CLIENT_INITIALIZE();
  }

#if	CLIENT_CREATE_BY_USER
  if ( __pClient__ == NULL ) {
    __pClient__	= RPC_CLIENT_CREATE ( __szHost__, __szTransport__ );
    if ( __pClient__ == NULL ) {
      /* Error handling for a not connected client: */
      char	szError [ 256 ];
      sprintf ( szError, szFormatNoServer, __procedure__ );
      RPC_CLIENT_ERROR ( szError );
      return Result.ReturnValue;
    }
  }
#else
  while ( __pClient__ == NULL ) {
    __pClient__	= RPC_CLIENT_CREATE ( __szHost__, __szTransport__ );
    if ( __pClient__ == NULL ) {
      /* Error handling for a not connected client: */
      char	szError [ 256 ];
      sprintf ( szError, szFormatNoServer, __procedure__ );
      RPC_CLIENT_CERROR ( szContNoServer, szError );
    }
  }
#endif	/* CLIENT_CREATE_BY_USER */

  /* Copy in the oShortObjIdHeap argument: */
  InArguments.oShortObjIdHeap	= oShortObjIdHeap;
  /* Copy in the oShortObjId argument: */
  InArguments.oShortObjId	= oShortObjId;
  /* Copy in the oExpectingClass argument: */
  InArguments.oExpectingClass	= oExpectingClass;
  /* Copy in the nExpectingTypeTag argument: */
  InArguments.nExpectingTypeTag	= nExpectingTypeTag;
  /* Copy in the nIndex argument: */
  InArguments.nIndex	= nIndex;
  /* Copy in the nObjIds argument: */
  InArguments.nObjIds	= nObjIds;
  /* Copy in the pObjIds argument: */
  InArguments.pObjIds.int_vector_t_len	= nObjIds;
  InArguments.pObjIds.int_vector_t_val	= pObjIds;
  if ( InArguments.pObjIds.int_vector_t_len != 0 && pObjIds == NULL ) {
    /* Error handling for passing a NULL pointer on */
    /* VECTOR declared in argument: */
    char	szError [ 256 ];
    InArguments.pObjIds.int_vector_t_len	= 0;
    sprintf ( szError, szFormatNullPassed,
              __procedure__, "pObjIds" );
    RPC_CLIENT_CERROR ( szContNullPassed, szError );
  }
  /* Copy in the pnTypeTags argument: */
  InArguments.pnTypeTags.u_int_vector_t_len	= nObjIds;
  InArguments.pnTypeTags.u_int_vector_t_val	= pnTypeTags;
  if ( InArguments.pnTypeTags.u_int_vector_t_len != 0 && pnTypeTags == NULL ) {
    /* Error handling for passing a NULL pointer on */
    /* VECTOR declared in argument: */
    char	szError [ 256 ];
    InArguments.pnTypeTags.u_int_vector_t_len	= 0;
    sprintf ( szError, szFormatNullPassed,
              __procedure__, "pnTypeTags" );
    RPC_CLIENT_CERROR ( szContNullPassed, szError );
  }

  pResult	=
#ifdef MULTITHREAD
    (
#else
    (fnServerObjectWriteAtIndices_rets *)
#endif
    fnrpc_fnserverobjectwriteatindices_1 (
	&InArguments,
#ifdef MULTITHREAD
	&Result,
#endif
	__pClient__ )
#ifdef MULTITHREAD
	== RPC_SUCCESS ) ? &Result : NULL
#endif
	;

  if ( pResult == NULL ) {
    /* Error handling for a failed RPC call, */
    /* i.e. the server did not respond: */
    char	szError [ 256 ];
    sprintf ( szError, szFormatRpcFailed, __procedure__,
              clnt_sperror ( __pClient__, __szHost__ ) );
    __pClient__	= RPC_CLIENT_DESTROY ( __pClient__ );
    RPC_CLIENT_CERROR ( szContRpcFailed, szError );
    Result	= ZeroResult;
    return Result.ReturnValue;
  }
#ifndef MULTITHREAD
  Result	= * pResult;
#endif


  if ( pResult && pResult->nErrorLvl ) {
    /* Server returned a user error message: */
    char	szErrorMsg [ 1024 ];
    strncpy ( szErrorMsg,
              ( pResult->pszErrorMsg && pResult->pszErrorMsg [ 0 ] ) ?
              (LPCSTR) pResult->pszErrorMsg : (LPCSTR) szEmpty,
              sizeof ( szErrorMsg ) );
    szErrorMsg [ sizeof ( szErrorMsg ) - 1 ]	= (char) 0;
    xdr_free ( (xdrproc_t) xdr_fnServerObjectWriteAtIndices_rets, (char *) pResult );
    RPC_CLIENT_SERROR ( pResult->nErrorLvl, __procedure__,
                        szErrorMsg );
  } else {
    xdr_free ( (xdrproc_t) xdr_fnServerObjectWriteAtIndices_rets, (char *) pResult );
  }

  return Result.ReturnValue;

} /* fnServerObjectWriteAtIndices */



SHLOCK DLLEXPORT fnServerObjectWriteObjId
	(SHORTOBJID oShortObjIdHeap ,
	  SHORTOBJID oShortObjId ,
	  SHORTOBJID oExpectingClass ,
	  SHTYPETAG nExpectingTypeTag ,
	  int nIndex ,
	  SHORTOBJID oShortObjIdWrite)
{
  static const char	__procedure__[]	= "client:fnServerObjectWriteObjId";
  static fnServerObjectWriteObjId_rets	ZeroResult;
  fnServerObjectWriteObjId_rets		* pResult = NULL;
  fnServerObjectWriteObjId_rets		Result = ZeroResult;
  fnServerObjectWriteObjId_args	InArguments;

  /* Client initialization: */
  if ( __bClientInitialize__ ) {
    __bClientInitialize__	= FALSE;
    RPC_CLIENT_INITIALIZE();
  }

#if	CLIENT_CREATE_BY_USER
  if ( __pClient__ == NULL ) {
    __pClient__	= RPC_CLIENT_CREATE ( __szHost__, __szTransport__ );
    if ( __pClient__ == NULL ) {
      /* Error handling for a not connected client: */
      char	szError [ 256 ];
      sprintf ( szError, szFormatNoServer, __procedure__ );
      RPC_CLIENT_ERROR ( szError );
      return Result.ReturnValue;
    }
  }
#else
  while ( __pClient__ == NULL ) {
    __pClient__	= RPC_CLIENT_CREATE ( __szHost__, __szTransport__ );
    if ( __pClient__ == NULL ) {
      /* Error handling for a not connected client: */
      char	szError [ 256 ];
      sprintf ( szError, szFormatNoServer, __procedure__ );
      RPC_CLIENT_CERROR ( szContNoServer, szError );
    }
  }
#endif	/* CLIENT_CREATE_BY_USER */

  /* Copy in the oShortObjIdHeap argument: */
  InArguments.oShortObjIdHeap	= oShortObjIdHeap;
  /* Copy in the oShortObjId argument: */
  InArguments.oShortObjId	= oShortObjId;
  /* Copy in the oExpectingClass argument: */
  InArguments.oExpectingClass	= oExpectingClass;
  /* Copy in the nExpectingTypeTag argument: */
  InArguments.nExpectingTypeTag	= nExpectingTypeTag;
  /* Copy in the nIndex argument: */
  InArguments.nIndex	= nIndex;
  /* Copy in the oShortObjIdWrite argument: */
  InArguments.oShortObjIdWrite	= oShortObjIdWrite;

  pResult	=
#ifdef MULTITHREAD
    (
#else
    (fnServerObjectWriteObjId_rets *)
#endif
    fnrpc_fnserverobjectwriteobjid_1 (
	&InArguments,
#ifdef MULTITHREAD
	&Result,
#endif
	__pClient__ )
#ifdef MULTITHREAD
	== RPC_SUCCESS ) ? &Result : NULL
#endif
	;

  if ( pResult == NULL ) {
    /* Error handling for a failed RPC call, */
    /* i.e. the server did not respond: */
    char	szError [ 256 ];
    sprintf ( szError, szFormatRpcFailed, __procedure__,
              clnt_sperror ( __pClient__, __szHost__ ) );
    __pClient__	= RPC_CLIENT_DESTROY ( __pClient__ );
    RPC_CLIENT_CERROR ( szContRpcFailed, szError );
    Result	= ZeroResult;
    return Result.ReturnValue;
  }
#ifndef MULTITHREAD
  Result	= * pResult;
#endif


  if ( pResult && pResult->nErrorLvl ) {
    /* Server returned a user error message: */
    char	szErrorMsg [ 1024 ];
    strncpy ( szErrorMsg,
              ( pResult->pszErrorMsg && pResult->pszErrorMsg [ 0 ] ) ?
              (LPCSTR) pResult->pszErrorMsg : (LPCSTR) szEmpty,
              sizeof ( szErrorMsg ) );
    szErrorMsg [ sizeof ( szErrorMsg ) - 1 ]	= (char) 0;
    xdr_free ( (xdrproc_t) xdr_fnServerObjectWriteObjId_rets, (char *) pResult );
    RPC_CLIENT_SERROR ( pResult->nErrorLvl, __procedure__,
                        szErrorMsg );
  } else {
    xdr_free ( (xdrproc_t) xdr_fnServerObjectWriteObjId_rets, (char *) pResult );
  }

  return Result.ReturnValue;

} /* fnServerObjectWriteObjId */



int DLLEXPORT fnServerObjectWriteValues
	(SHORTOBJID oShortObjIdHeap ,
	  SHORTOBJID oShortObjId ,
	  SHORTOBJID oExpectingClass ,
	  SHTYPETAG nExpectingTypeTag ,
	  int nIndex ,
	  SHTYPETAG nElementTypeTag ,
	  int nSizeInElements ,
	  void * /* _vector_t<((( fnTypeTagSizeValue(1,&nElementTypeTag, &nSizeInElements ) )*( sizeof(int) )) )> */ pBuffer)
{
  static const char	__procedure__[]	= "client:fnServerObjectWriteValues";
  static fnServerObjectWriteValues_rets	ZeroResult;
  fnServerObjectWriteValues_rets		* pResult = NULL;
  fnServerObjectWriteValues_rets		Result = ZeroResult;
  fnServerObjectWriteValues_args	InArguments;

  /* Client initialization: */
  if ( __bClientInitialize__ ) {
    __bClientInitialize__	= FALSE;
    RPC_CLIENT_INITIALIZE();
  }

#if	CLIENT_CREATE_BY_USER
  if ( __pClient__ == NULL ) {
    __pClient__	= RPC_CLIENT_CREATE ( __szHost__, __szTransport__ );
    if ( __pClient__ == NULL ) {
      /* Error handling for a not connected client: */
      char	szError [ 256 ];
      sprintf ( szError, szFormatNoServer, __procedure__ );
      RPC_CLIENT_ERROR ( szError );
      return Result.ReturnValue;
    }
  }
#else
  while ( __pClient__ == NULL ) {
    __pClient__	= RPC_CLIENT_CREATE ( __szHost__, __szTransport__ );
    if ( __pClient__ == NULL ) {
      /* Error handling for a not connected client: */
      char	szError [ 256 ];
      sprintf ( szError, szFormatNoServer, __procedure__ );
      RPC_CLIENT_CERROR ( szContNoServer, szError );
    }
  }
#endif	/* CLIENT_CREATE_BY_USER */

  /* Copy in the oShortObjIdHeap argument: */
  InArguments.oShortObjIdHeap	= oShortObjIdHeap;
  /* Copy in the oShortObjId argument: */
  InArguments.oShortObjId	= oShortObjId;
  /* Copy in the oExpectingClass argument: */
  InArguments.oExpectingClass	= oExpectingClass;
  /* Copy in the nExpectingTypeTag argument: */
  InArguments.nExpectingTypeTag	= nExpectingTypeTag;
  /* Copy in the nIndex argument: */
  InArguments.nIndex	= nIndex;
  /* Copy in the nElementTypeTag argument: */
  InArguments.nElementTypeTag	= nElementTypeTag;
  /* Copy in the nSizeInElements argument: */
  InArguments.nSizeInElements	= nSizeInElements;
  /* Copy in the pBuffer argument: */
  InArguments.pBuffer.void_vector_t_len	= ((( fnTypeTagSizeValue(1,&nElementTypeTag, &nSizeInElements ) )*( sizeof(int) )) );
  InArguments.pBuffer.void_vector_t_val	= pBuffer;
  if ( InArguments.pBuffer.void_vector_t_len != 0 && pBuffer == NULL ) {
    /* Error handling for passing a NULL pointer on */
    /* VECTOR declared in argument: */
    char	szError [ 256 ];
    InArguments.pBuffer.void_vector_t_len	= 0;
    sprintf ( szError, szFormatNullPassed,
              __procedure__, "pBuffer" );
    RPC_CLIENT_CERROR ( szContNullPassed, szError );
  }

  pResult	=
#ifdef MULTITHREAD
    (
#else
    (fnServerObjectWriteValues_rets *)
#endif
    fnrpc_fnserverobjectwritevalues_1 (
	&InArguments,
#ifdef MULTITHREAD
	&Result,
#endif
	__pClient__ )
#ifdef MULTITHREAD
	== RPC_SUCCESS ) ? &Result : NULL
#endif
	;

  if ( pResult == NULL ) {
    /* Error handling for a failed RPC call, */
    /* i.e. the server did not respond: */
    char	szError [ 256 ];
    sprintf ( szError, szFormatRpcFailed, __procedure__,
              clnt_sperror ( __pClient__, __szHost__ ) );
    __pClient__	= RPC_CLIENT_DESTROY ( __pClient__ );
    RPC_CLIENT_CERROR ( szContRpcFailed, szError );
    Result	= ZeroResult;
    return Result.ReturnValue;
  }
#ifndef MULTITHREAD
  Result	= * pResult;
#endif


  if ( pResult && pResult->nErrorLvl ) {
    /* Server returned a user error message: */
    char	szErrorMsg [ 1024 ];
    strncpy ( szErrorMsg,
              ( pResult->pszErrorMsg && pResult->pszErrorMsg [ 0 ] ) ?
              (LPCSTR) pResult->pszErrorMsg : (LPCSTR) szEmpty,
              sizeof ( szErrorMsg ) );
    szErrorMsg [ sizeof ( szErrorMsg ) - 1 ]	= (char) 0;
    xdr_free ( (xdrproc_t) xdr_fnServerObjectWriteValues_rets, (char *) pResult );
    RPC_CLIENT_SERROR ( pResult->nErrorLvl, __procedure__,
                        szErrorMsg );
  } else {
    xdr_free ( (xdrproc_t) xdr_fnServerObjectWriteValues_rets, (char *) pResult );
  }

  return Result.ReturnValue;

} /* fnServerObjectWriteValues */



DEPENDENTMODE DLLEXPORT fnShortMakeDependent
	(SHORTOBJID oShortObjIdHeap ,
	  SHORTOBJID oShortSelf ,
	  DEPENDENTMODE nDependentMode)
{
  static const char	__procedure__[]	= "client:fnShortMakeDependent";
  static fnShortMakeDependent_rets	ZeroResult;
  fnShortMakeDependent_rets		* pResult = NULL;
  fnShortMakeDependent_rets		Result = ZeroResult;
  fnShortMakeDependent_args	InArguments;

  /* Client initialization: */
  if ( __bClientInitialize__ ) {
    __bClientInitialize__	= FALSE;
    RPC_CLIENT_INITIALIZE();
  }

#if	CLIENT_CREATE_BY_USER
  if ( __pClient__ == NULL ) {
    __pClient__	= RPC_CLIENT_CREATE ( __szHost__, __szTransport__ );
    if ( __pClient__ == NULL ) {
      /* Error handling for a not connected client: */
      char	szError [ 256 ];
      sprintf ( szError, szFormatNoServer, __procedure__ );
      RPC_CLIENT_ERROR ( szError );
      return Result.ReturnValue;
    }
  }
#else
  while ( __pClient__ == NULL ) {
    __pClient__	= RPC_CLIENT_CREATE ( __szHost__, __szTransport__ );
    if ( __pClient__ == NULL ) {
      /* Error handling for a not connected client: */
      char	szError [ 256 ];
      sprintf ( szError, szFormatNoServer, __procedure__ );
      RPC_CLIENT_CERROR ( szContNoServer, szError );
    }
  }
#endif	/* CLIENT_CREATE_BY_USER */

  /* Copy in the oShortObjIdHeap argument: */
  InArguments.oShortObjIdHeap	= oShortObjIdHeap;
  /* Copy in the oShortSelf argument: */
  InArguments.oShortSelf	= oShortSelf;
  /* Copy in the nDependentMode argument: */
  InArguments.nDependentMode	= nDependentMode;

  pResult	=
#ifdef MULTITHREAD
    (
#else
    (fnShortMakeDependent_rets *)
#endif
    fnrpc_fnshortmakedependent_1 (
	&InArguments,
#ifdef MULTITHREAD
	&Result,
#endif
	__pClient__ )
#ifdef MULTITHREAD
	== RPC_SUCCESS ) ? &Result : NULL
#endif
	;

  if ( pResult == NULL ) {
    /* Error handling for a failed RPC call, */
    /* i.e. the server did not respond: */
    char	szError [ 256 ];
    sprintf ( szError, szFormatRpcFailed, __procedure__,
              clnt_sperror ( __pClient__, __szHost__ ) );
    __pClient__	= RPC_CLIENT_DESTROY ( __pClient__ );
    RPC_CLIENT_CERROR ( szContRpcFailed, szError );
    Result	= ZeroResult;
    return Result.ReturnValue;
  }
#ifndef MULTITHREAD
  Result	= * pResult;
#endif


  if ( pResult && pResult->nErrorLvl ) {
    /* Server returned a user error message: */
    char	szErrorMsg [ 1024 ];
    strncpy ( szErrorMsg,
              ( pResult->pszErrorMsg && pResult->pszErrorMsg [ 0 ] ) ?
              (LPCSTR) pResult->pszErrorMsg : (LPCSTR) szEmpty,
              sizeof ( szErrorMsg ) );
    szErrorMsg [ sizeof ( szErrorMsg ) - 1 ]	= (char) 0;
    xdr_free ( (xdrproc_t) xdr_fnShortMakeDependent_rets, (char *) pResult );
    RPC_CLIENT_SERROR ( pResult->nErrorLvl, __procedure__,
                        szErrorMsg );
  } else {
    xdr_free ( (xdrproc_t) xdr_fnShortMakeDependent_rets, (char *) pResult );
  }

  return Result.ReturnValue;

} /* fnShortMakeDependent */



SHLOCK DLLEXPORT fnServerObjectPeekSlots
	(SHORTOBJID oShortObjIdHeap ,
	  int hPeek ,
	  int nWords ,
	  u_int * /* _vector_t<nWords> */  pBuffer)
{
  static const char	__procedure__[]	= "client:fnServerObjectPeekSlots";
  static fnServerObjectPeekSlots_rets	ZeroResult;
  fnServerObjectPeekSlots_rets		* pResult = NULL;
  fnServerObjectPeekSlots_rets		Result = ZeroResult;
  fnServerObjectPeekSlots_args	InArguments;

  /* Client initialization: */
  if ( __bClientInitialize__ ) {
    __bClientInitialize__	= FALSE;
    RPC_CLIENT_INITIALIZE();
  }

#if	CLIENT_CREATE_BY_USER
  if ( __pClient__ == NULL ) {
    __pClient__	= RPC_CLIENT_CREATE ( __szHost__, __szTransport__ );
    if ( __pClient__ == NULL ) {
      /* Error handling for a not connected client: */
      char	szError [ 256 ];
      sprintf ( szError, szFormatNoServer, __procedure__ );
      RPC_CLIENT_ERROR ( szError );
      return Result.ReturnValue;
    }
  }
#else
  while ( __pClient__ == NULL ) {
    __pClient__	= RPC_CLIENT_CREATE ( __szHost__, __szTransport__ );
    if ( __pClient__ == NULL ) {
      /* Error handling for a not connected client: */
      char	szError [ 256 ];
      sprintf ( szError, szFormatNoServer, __procedure__ );
      RPC_CLIENT_CERROR ( szContNoServer, szError );
    }
  }
#endif	/* CLIENT_CREATE_BY_USER */

  /* Copy in the oShortObjIdHeap argument: */
  InArguments.oShortObjIdHeap	= oShortObjIdHeap;
  /* Copy in the hPeek argument: */
  InArguments.hPeek	= hPeek;
  /* Copy in the nWords argument: */
  InArguments.nWords	= nWords;
  InArguments.pBufferSize	= nWords;

  pResult	=
#ifdef MULTITHREAD
    (
#else
    (fnServerObjectPeekSlots_rets *)
#endif
    fnrpc_fnserverobjectpeekslots_1 (
	&InArguments,
#ifdef MULTITHREAD
	&Result,
#endif
	__pClient__ )
#ifdef MULTITHREAD
	== RPC_SUCCESS ) ? &Result : NULL
#endif
	;

  if ( pResult == NULL ) {
    /* Error handling for a failed RPC call, */
    /* i.e. the server did not respond: */
    char	szError [ 256 ];
    sprintf ( szError, szFormatRpcFailed, __procedure__,
              clnt_sperror ( __pClient__, __szHost__ ) );
    __pClient__	= RPC_CLIENT_DESTROY ( __pClient__ );
    RPC_CLIENT_CERROR ( szContRpcFailed, szError );
    Result	= ZeroResult;
    return Result.ReturnValue;
  }
#ifndef MULTITHREAD
  Result	= * pResult;
#endif

  /* Copy out the pBuffer argument: */
  if ( ! ( 
       pResult->pBuffer.u_int_vector_t_len != 0 &&
       pBuffer == NULL ) ) {
    memcpy ( pBuffer,
             pResult->pBuffer.u_int_vector_t_val,
             MIN ( pResult->pBuffer.u_int_vector_t_len,
                   nWords ) *
             SIZEOF ( *(pResult->pBuffer.u_int_vector_t_val) ) );
  }

  if ( pResult && pResult->nErrorLvl ) {
    /* Server returned a user error message: */
    char	szErrorMsg [ 1024 ];
    strncpy ( szErrorMsg,
              ( pResult->pszErrorMsg && pResult->pszErrorMsg [ 0 ] ) ?
              (LPCSTR) pResult->pszErrorMsg : (LPCSTR) szEmpty,
              sizeof ( szErrorMsg ) );
    szErrorMsg [ sizeof ( szErrorMsg ) - 1 ]	= (char) 0;
    xdr_free ( (xdrproc_t) xdr_fnServerObjectPeekSlots_rets, (char *) pResult );
    RPC_CLIENT_SERROR ( pResult->nErrorLvl, __procedure__,
                        szErrorMsg );
  } else {
    xdr_free ( (xdrproc_t) xdr_fnServerObjectPeekSlots_rets, (char *) pResult );
  }
  if ( 
       pResult->pBuffer.u_int_vector_t_len != 0 &&
       pBuffer == NULL ) {
    /* Error handling for passing a NULL pointer on */
    /* out argument: */
    char	szError [ 256 ];
    sprintf ( szError, szFormatNullPassed,
              __procedure__, "pBuffer" );
    RPC_CLIENT_CERROR ( szContNullOutPassed, szError );
  } else if ( pResult->pBuffer.u_int_vector_t_len > nWords ) {
      /* Error handling for an output buffer overflow, */
      /* i.e. the buffer size passed is too small: */
      /* For example, signal a CERROR here ... */
      char	szError [ 256 ];
      sprintf ( szError, szFormatBufferOverflow,
                __procedure__, "pBuffer", 
                nWords, 
                pResult->pBuffer.u_int_vector_t_len );
      RPC_CLIENT_CERROR ( szContBufferOverflow, szError );
  }

  return Result.ReturnValue;

} /* fnServerObjectPeekSlots */



SHLOCK DLLEXPORT fnServerObjectPeekValues
	(SHORTOBJID oShortObjIdHeap ,
	  int hPeek ,
	  int nObjects ,
	  u_int * /* _vector_t<nObjects> */ pnElementTypeTagsIn ,
	  u_int * /* _vector_t<nObjects> */ pnSizesInElementsIn ,
	  u_int * /* _vector_t<nObjects> */  pnElementTypeTagsOut ,
	  u_int * /* _vector_t<nObjects> */  pnSizesInElementsOut ,
	  void * /* _vector_t<((( fnTypeTagSizeValue ( nObjects,pnElementTypeTagsIn, pnSizesInElementsIn ) )*( sizeof(int) )) )> */  pBuffer)
{
  static const char	__procedure__[]	= "client:fnServerObjectPeekValues";
  static fnServerObjectPeekValues_rets	ZeroResult;
  fnServerObjectPeekValues_rets		* pResult = NULL;
  fnServerObjectPeekValues_rets		Result = ZeroResult;
  fnServerObjectPeekValues_args	InArguments;

  /* Client initialization: */
  if ( __bClientInitialize__ ) {
    __bClientInitialize__	= FALSE;
    RPC_CLIENT_INITIALIZE();
  }

#if	CLIENT_CREATE_BY_USER
  if ( __pClient__ == NULL ) {
    __pClient__	= RPC_CLIENT_CREATE ( __szHost__, __szTransport__ );
    if ( __pClient__ == NULL ) {
      /* Error handling for a not connected client: */
      char	szError [ 256 ];
      sprintf ( szError, szFormatNoServer, __procedure__ );
      RPC_CLIENT_ERROR ( szError );
      return Result.ReturnValue;
    }
  }
#else
  while ( __pClient__ == NULL ) {
    __pClient__	= RPC_CLIENT_CREATE ( __szHost__, __szTransport__ );
    if ( __pClient__ == NULL ) {
      /* Error handling for a not connected client: */
      char	szError [ 256 ];
      sprintf ( szError, szFormatNoServer, __procedure__ );
      RPC_CLIENT_CERROR ( szContNoServer, szError );
    }
  }
#endif	/* CLIENT_CREATE_BY_USER */

  /* Copy in the oShortObjIdHeap argument: */
  InArguments.oShortObjIdHeap	= oShortObjIdHeap;
  /* Copy in the hPeek argument: */
  InArguments.hPeek	= hPeek;
  /* Copy in the nObjects argument: */
  InArguments.nObjects	= nObjects;
  /* Copy in the pnElementTypeTagsIn argument: */
  InArguments.pnElementTypeTagsIn.u_int_vector_t_len	= nObjects;
  InArguments.pnElementTypeTagsIn.u_int_vector_t_val	= pnElementTypeTagsIn;
  if ( InArguments.pnElementTypeTagsIn.u_int_vector_t_len != 0 && pnElementTypeTagsIn == NULL ) {
    /* Error handling for passing a NULL pointer on */
    /* VECTOR declared in argument: */
    char	szError [ 256 ];
    InArguments.pnElementTypeTagsIn.u_int_vector_t_len	= 0;
    sprintf ( szError, szFormatNullPassed,
              __procedure__, "pnElementTypeTagsIn" );
    RPC_CLIENT_CERROR ( szContNullPassed, szError );
  }
  /* Copy in the pnSizesInElementsIn argument: */
  InArguments.pnSizesInElementsIn.u_int_vector_t_len	= nObjects;
  InArguments.pnSizesInElementsIn.u_int_vector_t_val	= pnSizesInElementsIn;
  if ( InArguments.pnSizesInElementsIn.u_int_vector_t_len != 0 && pnSizesInElementsIn == NULL ) {
    /* Error handling for passing a NULL pointer on */
    /* VECTOR declared in argument: */
    char	szError [ 256 ];
    InArguments.pnSizesInElementsIn.u_int_vector_t_len	= 0;
    sprintf ( szError, szFormatNullPassed,
              __procedure__, "pnSizesInElementsIn" );
    RPC_CLIENT_CERROR ( szContNullPassed, szError );
  }
  InArguments.pnElementTypeTagsOutSize	= nObjects;
  InArguments.pnSizesInElementsOutSize	= nObjects;
  InArguments.pBufferSize	= ((( fnTypeTagSizeValue ( nObjects,pnElementTypeTagsIn, pnSizesInElementsIn ) )*( sizeof(int) )) );

  pResult	=
#ifdef MULTITHREAD
    (
#else
    (fnServerObjectPeekValues_rets *)
#endif
    fnrpc_fnserverobjectpeekvalues_1 (
	&InArguments,
#ifdef MULTITHREAD
	&Result,
#endif
	__pClient__ )
#ifdef MULTITHREAD
	== RPC_SUCCESS ) ? &Result : NULL
#endif
	;

  if ( pResult == NULL ) {
    /* Error handling for a failed RPC call, */
    /* i.e. the server did not respond: */
    char	szError [ 256 ];
    sprintf ( szError, szFormatRpcFailed, __procedure__,
              clnt_sperror ( __pClient__, __szHost__ ) );
    __pClient__	= RPC_CLIENT_DESTROY ( __pClient__ );
    RPC_CLIENT_CERROR ( szContRpcFailed, szError );
    Result	= ZeroResult;
    return Result.ReturnValue;
  }
#ifndef MULTITHREAD
  Result	= * pResult;
#endif

  /* Copy out the pnElementTypeTagsOut argument: */
  if ( ! ( 
       pResult->pnElementTypeTagsOut.u_int_vector_t_len != 0 &&
       pnElementTypeTagsOut == NULL ) ) {
    memcpy ( pnElementTypeTagsOut,
             pResult->pnElementTypeTagsOut.u_int_vector_t_val,
             MIN ( pResult->pnElementTypeTagsOut.u_int_vector_t_len,
                   nObjects ) *
             SIZEOF ( *(pResult->pnElementTypeTagsOut.u_int_vector_t_val) ) );
  }
  /* Copy out the pnSizesInElementsOut argument: */
  if ( ! ( 
       pResult->pnSizesInElementsOut.u_int_vector_t_len != 0 &&
       pnSizesInElementsOut == NULL ) ) {
    memcpy ( pnSizesInElementsOut,
             pResult->pnSizesInElementsOut.u_int_vector_t_val,
             MIN ( pResult->pnSizesInElementsOut.u_int_vector_t_len,
                   nObjects ) *
             SIZEOF ( *(pResult->pnSizesInElementsOut.u_int_vector_t_val) ) );
  }
  /* Copy out the pBuffer argument: */
  if ( ! ( 
       pResult->pBuffer.void_vector_t_len != 0 &&
       pBuffer == NULL ) ) {
    memcpy ( pBuffer,
             pResult->pBuffer.void_vector_t_val,
             MIN ( pResult->pBuffer.void_vector_t_len,
                   ((( fnTypeTagSizeValue ( nObjects,pnElementTypeTagsIn, pnSizesInElementsIn ) )*( sizeof(int) )) ) ) *
             SIZEOF ( *(pResult->pBuffer.void_vector_t_val) ) );
  }

  if ( pResult && pResult->nErrorLvl ) {
    /* Server returned a user error message: */
    char	szErrorMsg [ 1024 ];
    strncpy ( szErrorMsg,
              ( pResult->pszErrorMsg && pResult->pszErrorMsg [ 0 ] ) ?
              (LPCSTR) pResult->pszErrorMsg : (LPCSTR) szEmpty,
              sizeof ( szErrorMsg ) );
    szErrorMsg [ sizeof ( szErrorMsg ) - 1 ]	= (char) 0;
    xdr_free ( (xdrproc_t) xdr_fnServerObjectPeekValues_rets, (char *) pResult );
    RPC_CLIENT_SERROR ( pResult->nErrorLvl, __procedure__,
                        szErrorMsg );
  } else {
    xdr_free ( (xdrproc_t) xdr_fnServerObjectPeekValues_rets, (char *) pResult );
  }
  if ( 
       pResult->pnElementTypeTagsOut.u_int_vector_t_len != 0 &&
       pnElementTypeTagsOut == NULL ) {
    /* Error handling for passing a NULL pointer on */
    /* out argument: */
    char	szError [ 256 ];
    sprintf ( szError, szFormatNullPassed,
              __procedure__, "pnElementTypeTagsOut" );
    RPC_CLIENT_CERROR ( szContNullOutPassed, szError );
  } else if ( pResult->pnElementTypeTagsOut.u_int_vector_t_len > nObjects ) {
      /* Error handling for an output buffer overflow, */
      /* i.e. the buffer size passed is too small: */
      /* For example, signal a CERROR here ... */
      char	szError [ 256 ];
      sprintf ( szError, szFormatBufferOverflow,
                __procedure__, "pnElementTypeTagsOut", 
                nObjects, 
                pResult->pnElementTypeTagsOut.u_int_vector_t_len );
      RPC_CLIENT_CERROR ( szContBufferOverflow, szError );
  }
  if ( 
       pResult->pnSizesInElementsOut.u_int_vector_t_len != 0 &&
       pnSizesInElementsOut == NULL ) {
    /* Error handling for passing a NULL pointer on */
    /* out argument: */
    char	szError [ 256 ];
    sprintf ( szError, szFormatNullPassed,
              __procedure__, "pnSizesInElementsOut" );
    RPC_CLIENT_CERROR ( szContNullOutPassed, szError );
  } else if ( pResult->pnSizesInElementsOut.u_int_vector_t_len > nObjects ) {
      /* Error handling for an output buffer overflow, */
      /* i.e. the buffer size passed is too small: */
      /* For example, signal a CERROR here ... */
      char	szError [ 256 ];
      sprintf ( szError, szFormatBufferOverflow,
                __procedure__, "pnSizesInElementsOut", 
                nObjects, 
                pResult->pnSizesInElementsOut.u_int_vector_t_len );
      RPC_CLIENT_CERROR ( szContBufferOverflow, szError );
  }
  if ( 
       pResult->pBuffer.void_vector_t_len != 0 &&
       pBuffer == NULL ) {
    /* Error handling for passing a NULL pointer on */
    /* out argument: */
    char	szError [ 256 ];
    sprintf ( szError, szFormatNullPassed,
              __procedure__, "pBuffer" );
    RPC_CLIENT_CERROR ( szContNullOutPassed, szError );
  } else if ( pResult->pBuffer.void_vector_t_len > ((( fnTypeTagSizeValue ( nObjects,pnElementTypeTagsIn, pnSizesInElementsIn ) )*( sizeof(int) )) ) ) {
      /* Error handling for an output buffer overflow, */
      /* i.e. the buffer size passed is too small: */
      /* For example, signal a CERROR here ... */
      char	szError [ 256 ];
      sprintf ( szError, szFormatBufferOverflow,
                __procedure__, "pBuffer", 
                ((( fnTypeTagSizeValue ( nObjects,pnElementTypeTagsIn, pnSizesInElementsIn ) )*( sizeof(int) )) ), 
                pResult->pBuffer.void_vector_t_len );
      RPC_CLIENT_CERROR ( szContBufferOverflow, szError );
  }

  return Result.ReturnValue;

} /* fnServerObjectPeekValues */



void DLLEXPORT fnServerObjectPoke
	(SHORTOBJID oShortObjIdHeap ,
	  SHORTOBJID oShortObjId ,
	  int nSlots ,
	  u_int * /* _vector_t<nSlots> */ pSlots ,
	  SHTYPETAG nElementTypeTag ,
	  int nSizeInElements ,
	  void * /* _vector_t<((( fnTypeTagSizeValue(1,&nElementTypeTag, &nSizeInElements ) )*( sizeof(int) )) )> */ pValues)
{
  static const char	__procedure__[]	= "client:fnServerObjectPoke";
  static char	ZeroResult;
  void		* pResult = NULL;
#ifdef MULTITHREAD
  char		Result = ZeroResult;
#endif
  fnServerObjectPoke_args	InArguments;

  /* Client initialization: */
  if ( __bClientInitialize__ ) {
    __bClientInitialize__	= FALSE;
    RPC_CLIENT_INITIALIZE();
  }

#if	CLIENT_CREATE_BY_USER
  if ( __pClient__ == NULL ) {
    __pClient__	= RPC_CLIENT_CREATE ( __szHost__, __szTransport__ );
    if ( __pClient__ == NULL ) {
      /* Error handling for a not connected client: */
      char	szError [ 256 ];
      sprintf ( szError, szFormatNoServer, __procedure__ );
      RPC_CLIENT_ERROR ( szError );
      return;
    }
  }
#else
  while ( __pClient__ == NULL ) {
    __pClient__	= RPC_CLIENT_CREATE ( __szHost__, __szTransport__ );
    if ( __pClient__ == NULL ) {
      /* Error handling for a not connected client: */
      char	szError [ 256 ];
      sprintf ( szError, szFormatNoServer, __procedure__ );
      RPC_CLIENT_CERROR ( szContNoServer, szError );
    }
  }
#endif	/* CLIENT_CREATE_BY_USER */

  /* Copy in the oShortObjIdHeap argument: */
  InArguments.oShortObjIdHeap	= oShortObjIdHeap;
  /* Copy in the oShortObjId argument: */
  InArguments.oShortObjId	= oShortObjId;
  /* Copy in the nSlots argument: */
  InArguments.nSlots	= nSlots;
  /* Copy in the pSlots argument: */
  InArguments.pSlots.u_int_vector_t_len	= nSlots;
  InArguments.pSlots.u_int_vector_t_val	= pSlots;
  if ( InArguments.pSlots.u_int_vector_t_len != 0 && pSlots == NULL ) {
    /* Error handling for passing a NULL pointer on */
    /* VECTOR declared in argument: */
    char	szError [ 256 ];
    InArguments.pSlots.u_int_vector_t_len	= 0;
    sprintf ( szError, szFormatNullPassed,
              __procedure__, "pSlots" );
    RPC_CLIENT_CERROR ( szContNullPassed, szError );
  }
  /* Copy in the nElementTypeTag argument: */
  InArguments.nElementTypeTag	= nElementTypeTag;
  /* Copy in the nSizeInElements argument: */
  InArguments.nSizeInElements	= nSizeInElements;
  /* Copy in the pValues argument: */
  InArguments.pValues.void_vector_t_len	= ((( fnTypeTagSizeValue(1,&nElementTypeTag, &nSizeInElements ) )*( sizeof(int) )) );
  InArguments.pValues.void_vector_t_val	= pValues;
  if ( InArguments.pValues.void_vector_t_len != 0 && pValues == NULL ) {
    /* Error handling for passing a NULL pointer on */
    /* VECTOR declared in argument: */
    char	szError [ 256 ];
    InArguments.pValues.void_vector_t_len	= 0;
    sprintf ( szError, szFormatNullPassed,
              __procedure__, "pValues" );
    RPC_CLIENT_CERROR ( szContNullPassed, szError );
  }

  pResult	=
#ifdef MULTITHREAD
    (
#else
    (void *)
#endif
    fnrpc_fnserverobjectpoke_batch_1 (
	&InArguments,
#ifdef MULTITHREAD
	&Result,
#endif
	__pClient__ )
#ifdef MULTITHREAD
	== RPC_SUCCESS ) ? &Result : NULL
#endif
	;

  if ( pResult == NULL ) {
    /* Error handling for a failed RPC call, */
    /* i.e. the server did not respond: */
    char	szError [ 256 ];
    sprintf ( szError, szFormatRpcFailed, __procedure__,
              clnt_sperror ( __pClient__, __szHost__ ) );
    __pClient__	= RPC_CLIENT_DESTROY ( __pClient__ );
    RPC_CLIENT_CERROR ( szContRpcFailed, szError );
    return;
  }
} /* fnServerObjectPoke */

#ifdef MULTITHREAD
enum clnt_stat
#else
void *
#endif
fnrpc_fnserverobjectpoke_batch_1
	( fnServerObjectPoke_args * pArguments,
#ifdef MULTITHREAD
	  void * clnt_res,
#endif
	  PCLIENT pClient )
{
#ifdef MULTITHREAD
  return clnt_call ( pClient, fnRpc_fnServerObjectPoke_batch,
                     (xdrproc_t) xdr_fnServerObjectPoke_args,
                     (caddr_t) pArguments,
                     (xdrproc_t) NULL, (caddr_t) NULL,
                     NullTimeout );
#else
  if ( clnt_call ( pClient, fnRpc_fnServerObjectPoke_batch,
                   (xdrproc_t) xdr_fnServerObjectPoke_args,
                   (caddr_t) pArguments,
                   (xdrproc_t) NULL, (caddr_t) NULL,
                   NullTimeout ) != RPC_SUCCESS ) {
    return NULL;
  }
  return (void *) TRUE;
#endif
} /* fnrpc_fnserverobjectpoke_batch_1 */
#define	fnrpc_fnserverobjectpoke_batch_1	fnrpc_fnserverobjectpoke_1



FLUSHMODE DLLEXPORT fnFlushMode
	(SHORTOBJID oShortObjIdHeap ,
	  FLUSHMODE nMode)
{
  static const char	__procedure__[]	= "client:fnFlushMode";
  static fnFlushMode_rets	ZeroResult;
  fnFlushMode_rets		* pResult = NULL;
  fnFlushMode_rets		Result = ZeroResult;
  fnFlushMode_args	InArguments;

  /* Client initialization: */
  if ( __bClientInitialize__ ) {
    __bClientInitialize__	= FALSE;
    RPC_CLIENT_INITIALIZE();
  }

#if	CLIENT_CREATE_BY_USER
  if ( __pClient__ == NULL ) {
    __pClient__	= RPC_CLIENT_CREATE ( __szHost__, __szTransport__ );
    if ( __pClient__ == NULL ) {
      /* Error handling for a not connected client: */
      char	szError [ 256 ];
      sprintf ( szError, szFormatNoServer, __procedure__ );
      RPC_CLIENT_ERROR ( szError );
      return Result.ReturnValue;
    }
  }
#else
  while ( __pClient__ == NULL ) {
    __pClient__	= RPC_CLIENT_CREATE ( __szHost__, __szTransport__ );
    if ( __pClient__ == NULL ) {
      /* Error handling for a not connected client: */
      char	szError [ 256 ];
      sprintf ( szError, szFormatNoServer, __procedure__ );
      RPC_CLIENT_CERROR ( szContNoServer, szError );
    }
  }
#endif	/* CLIENT_CREATE_BY_USER */

  /* Copy in the oShortObjIdHeap argument: */
  InArguments.oShortObjIdHeap	= oShortObjIdHeap;
  /* Copy in the nMode argument: */
  InArguments.nMode	= nMode;

  pResult	=
#ifdef MULTITHREAD
    (
#else
    (fnFlushMode_rets *)
#endif
    fnrpc_fnflushmode_1 (
	&InArguments,
#ifdef MULTITHREAD
	&Result,
#endif
	__pClient__ )
#ifdef MULTITHREAD
	== RPC_SUCCESS ) ? &Result : NULL
#endif
	;

  if ( pResult == NULL ) {
    /* Error handling for a failed RPC call, */
    /* i.e. the server did not respond: */
    char	szError [ 256 ];
    sprintf ( szError, szFormatRpcFailed, __procedure__,
              clnt_sperror ( __pClient__, __szHost__ ) );
    __pClient__	= RPC_CLIENT_DESTROY ( __pClient__ );
    RPC_CLIENT_CERROR ( szContRpcFailed, szError );
    Result	= ZeroResult;
    return Result.ReturnValue;
  }
#ifndef MULTITHREAD
  Result	= * pResult;
#endif


  if ( pResult && pResult->nErrorLvl ) {
    /* Server returned a user error message: */
    char	szErrorMsg [ 1024 ];
    strncpy ( szErrorMsg,
              ( pResult->pszErrorMsg && pResult->pszErrorMsg [ 0 ] ) ?
              (LPCSTR) pResult->pszErrorMsg : (LPCSTR) szEmpty,
              sizeof ( szErrorMsg ) );
    szErrorMsg [ sizeof ( szErrorMsg ) - 1 ]	= (char) 0;
    xdr_free ( (xdrproc_t) xdr_fnFlushMode_rets, (char *) pResult );
    RPC_CLIENT_SERROR ( pResult->nErrorLvl, __procedure__,
                        szErrorMsg );
  } else {
    xdr_free ( (xdrproc_t) xdr_fnFlushMode_rets, (char *) pResult );
  }

  return Result.ReturnValue;

} /* fnFlushMode */



int DLLEXPORT fnFlagWord
	(FLAGMODE nGetOrSet ,
	  int nFlagWord)
{
  static const char	__procedure__[]	= "client:fnFlagWord";
  static fnFlagWord_rets	ZeroResult;
  fnFlagWord_rets		* pResult = NULL;
  fnFlagWord_rets		Result = ZeroResult;
  fnFlagWord_args	InArguments;

  /* Client initialization: */
  if ( __bClientInitialize__ ) {
    __bClientInitialize__	= FALSE;
    RPC_CLIENT_INITIALIZE();
  }

#if	CLIENT_CREATE_BY_USER
  if ( __pClient__ == NULL ) {
    __pClient__	= RPC_CLIENT_CREATE ( __szHost__, __szTransport__ );
    if ( __pClient__ == NULL ) {
      /* Error handling for a not connected client: */
      char	szError [ 256 ];
      sprintf ( szError, szFormatNoServer, __procedure__ );
      RPC_CLIENT_ERROR ( szError );
      return Result.ReturnValue;
    }
  }
#else
  while ( __pClient__ == NULL ) {
    __pClient__	= RPC_CLIENT_CREATE ( __szHost__, __szTransport__ );
    if ( __pClient__ == NULL ) {
      /* Error handling for a not connected client: */
      char	szError [ 256 ];
      sprintf ( szError, szFormatNoServer, __procedure__ );
      RPC_CLIENT_CERROR ( szContNoServer, szError );
    }
  }
#endif	/* CLIENT_CREATE_BY_USER */

  /* Copy in the nGetOrSet argument: */
  InArguments.nGetOrSet	= nGetOrSet;
  /* Copy in the nFlagWord argument: */
  InArguments.nFlagWord	= nFlagWord;

  pResult	=
#ifdef MULTITHREAD
    (
#else
    (fnFlagWord_rets *)
#endif
    fnrpc_fnflagword_1 (
	&InArguments,
#ifdef MULTITHREAD
	&Result,
#endif
	__pClient__ )
#ifdef MULTITHREAD
	== RPC_SUCCESS ) ? &Result : NULL
#endif
	;

  if ( pResult == NULL ) {
    /* Error handling for a failed RPC call, */
    /* i.e. the server did not respond: */
    char	szError [ 256 ];
    sprintf ( szError, szFormatRpcFailed, __procedure__,
              clnt_sperror ( __pClient__, __szHost__ ) );
    __pClient__	= RPC_CLIENT_DESTROY ( __pClient__ );
    RPC_CLIENT_CERROR ( szContRpcFailed, szError );
    Result	= ZeroResult;
    return Result.ReturnValue;
  }
#ifndef MULTITHREAD
  Result	= * pResult;
#endif


  if ( pResult && pResult->nErrorLvl ) {
    /* Server returned a user error message: */
    char	szErrorMsg [ 1024 ];
    strncpy ( szErrorMsg,
              ( pResult->pszErrorMsg && pResult->pszErrorMsg [ 0 ] ) ?
              (LPCSTR) pResult->pszErrorMsg : (LPCSTR) szEmpty,
              sizeof ( szErrorMsg ) );
    szErrorMsg [ sizeof ( szErrorMsg ) - 1 ]	= (char) 0;
    xdr_free ( (xdrproc_t) xdr_fnFlagWord_rets, (char *) pResult );
    RPC_CLIENT_SERROR ( pResult->nErrorLvl, __procedure__,
                        szErrorMsg );
  } else {
    xdr_free ( (xdrproc_t) xdr_fnFlagWord_rets, (char *) pResult );
  }

  return Result.ReturnValue;

} /* fnFlagWord */



SHORTOBJID DLLEXPORT fnShortMakeIVector
	(SHORTOBJID oShortObjIdHeap ,
	  SHTYPETAG nTypeTag ,
	  int nElements)
{
  static const char	__procedure__[]	= "client:fnShortMakeIVector";
  static fnShortMakeIVector_rets	ZeroResult;
  fnShortMakeIVector_rets		* pResult = NULL;
  fnShortMakeIVector_rets		Result = ZeroResult;
  fnShortMakeIVector_args	InArguments;

  /* Client initialization: */
  if ( __bClientInitialize__ ) {
    __bClientInitialize__	= FALSE;
    RPC_CLIENT_INITIALIZE();
  }

#if	CLIENT_CREATE_BY_USER
  if ( __pClient__ == NULL ) {
    __pClient__	= RPC_CLIENT_CREATE ( __szHost__, __szTransport__ );
    if ( __pClient__ == NULL ) {
      /* Error handling for a not connected client: */
      char	szError [ 256 ];
      sprintf ( szError, szFormatNoServer, __procedure__ );
      RPC_CLIENT_ERROR ( szError );
      return Result.ReturnValue;
    }
  }
#else
  while ( __pClient__ == NULL ) {
    __pClient__	= RPC_CLIENT_CREATE ( __szHost__, __szTransport__ );
    if ( __pClient__ == NULL ) {
      /* Error handling for a not connected client: */
      char	szError [ 256 ];
      sprintf ( szError, szFormatNoServer, __procedure__ );
      RPC_CLIENT_CERROR ( szContNoServer, szError );
    }
  }
#endif	/* CLIENT_CREATE_BY_USER */

  /* Copy in the oShortObjIdHeap argument: */
  InArguments.oShortObjIdHeap	= oShortObjIdHeap;
  /* Copy in the nTypeTag argument: */
  InArguments.nTypeTag	= nTypeTag;
  /* Copy in the nElements argument: */
  InArguments.nElements	= nElements;

  pResult	=
#ifdef MULTITHREAD
    (
#else
    (fnShortMakeIVector_rets *)
#endif
    fnrpc_fnshortmakeivector_1 (
	&InArguments,
#ifdef MULTITHREAD
	&Result,
#endif
	__pClient__ )
#ifdef MULTITHREAD
	== RPC_SUCCESS ) ? &Result : NULL
#endif
	;

  if ( pResult == NULL ) {
    /* Error handling for a failed RPC call, */
    /* i.e. the server did not respond: */
    char	szError [ 256 ];
    sprintf ( szError, szFormatRpcFailed, __procedure__,
              clnt_sperror ( __pClient__, __szHost__ ) );
    __pClient__	= RPC_CLIENT_DESTROY ( __pClient__ );
    RPC_CLIENT_CERROR ( szContRpcFailed, szError );
    Result	= ZeroResult;
    return Result.ReturnValue;
  }
#ifndef MULTITHREAD
  Result	= * pResult;
#endif


  if ( pResult && pResult->nErrorLvl ) {
    /* Server returned a user error message: */
    char	szErrorMsg [ 1024 ];
    strncpy ( szErrorMsg,
              ( pResult->pszErrorMsg && pResult->pszErrorMsg [ 0 ] ) ?
              (LPCSTR) pResult->pszErrorMsg : (LPCSTR) szEmpty,
              sizeof ( szErrorMsg ) );
    szErrorMsg [ sizeof ( szErrorMsg ) - 1 ]	= (char) 0;
    xdr_free ( (xdrproc_t) xdr_fnShortMakeIVector_rets, (char *) pResult );
    RPC_CLIENT_SERROR ( pResult->nErrorLvl, __procedure__,
                        szErrorMsg );
  } else {
    xdr_free ( (xdrproc_t) xdr_fnShortMakeIVector_rets, (char *) pResult );
  }

  return Result.ReturnValue;

} /* fnShortMakeIVector */



SHORTOBJID DLLEXPORT fnShortMakeString
	(SHORTOBJID oShortObjIdHeap ,
	  string_t /* string_t<@conststring@> */ lpszFrom)
{
  static const char	__procedure__[]	= "client:fnShortMakeString";
  static fnShortMakeString_rets	ZeroResult;
  fnShortMakeString_rets		* pResult = NULL;
  fnShortMakeString_rets		Result = ZeroResult;
  fnShortMakeString_args	InArguments;

  /* Client initialization: */
  if ( __bClientInitialize__ ) {
    __bClientInitialize__	= FALSE;
    RPC_CLIENT_INITIALIZE();
  }

#if	CLIENT_CREATE_BY_USER
  if ( __pClient__ == NULL ) {
    __pClient__	= RPC_CLIENT_CREATE ( __szHost__, __szTransport__ );
    if ( __pClient__ == NULL ) {
      /* Error handling for a not connected client: */
      char	szError [ 256 ];
      sprintf ( szError, szFormatNoServer, __procedure__ );
      RPC_CLIENT_ERROR ( szError );
      return Result.ReturnValue;
    }
  }
#else
  while ( __pClient__ == NULL ) {
    __pClient__	= RPC_CLIENT_CREATE ( __szHost__, __szTransport__ );
    if ( __pClient__ == NULL ) {
      /* Error handling for a not connected client: */
      char	szError [ 256 ];
      sprintf ( szError, szFormatNoServer, __procedure__ );
      RPC_CLIENT_CERROR ( szContNoServer, szError );
    }
  }
#endif	/* CLIENT_CREATE_BY_USER */

  /* Copy in the oShortObjIdHeap argument: */
  InArguments.oShortObjIdHeap	= oShortObjIdHeap;
  /* Copy in the lpszFrom argument: */
  InArguments.lpszFrom	= lpszFrom;
  if ( lpszFrom == NULL ) {
    /* Error handling for passing a NULL string pointer: */
    char	szError [ 256 ];
    InArguments.lpszFrom	= (LPSTR) szEmpty;
    sprintf ( szError, szFormatNullString,
              __procedure__, "lpszFrom" );
    RPC_CLIENT_CERROR ( szContNullString, szError );
  }

  pResult	=
#ifdef MULTITHREAD
    (
#else
    (fnShortMakeString_rets *)
#endif
    fnrpc_fnshortmakestring_1 (
	&InArguments,
#ifdef MULTITHREAD
	&Result,
#endif
	__pClient__ )
#ifdef MULTITHREAD
	== RPC_SUCCESS ) ? &Result : NULL
#endif
	;

  if ( pResult == NULL ) {
    /* Error handling for a failed RPC call, */
    /* i.e. the server did not respond: */
    char	szError [ 256 ];
    sprintf ( szError, szFormatRpcFailed, __procedure__,
              clnt_sperror ( __pClient__, __szHost__ ) );
    __pClient__	= RPC_CLIENT_DESTROY ( __pClient__ );
    RPC_CLIENT_CERROR ( szContRpcFailed, szError );
    Result	= ZeroResult;
    return Result.ReturnValue;
  }
#ifndef MULTITHREAD
  Result	= * pResult;
#endif


  if ( pResult && pResult->nErrorLvl ) {
    /* Server returned a user error message: */
    char	szErrorMsg [ 1024 ];
    strncpy ( szErrorMsg,
              ( pResult->pszErrorMsg && pResult->pszErrorMsg [ 0 ] ) ?
              (LPCSTR) pResult->pszErrorMsg : (LPCSTR) szEmpty,
              sizeof ( szErrorMsg ) );
    szErrorMsg [ sizeof ( szErrorMsg ) - 1 ]	= (char) 0;
    xdr_free ( (xdrproc_t) xdr_fnShortMakeString_rets, (char *) pResult );
    RPC_CLIENT_SERROR ( pResult->nErrorLvl, __procedure__,
                        szErrorMsg );
  } else {
    xdr_free ( (xdrproc_t) xdr_fnShortMakeString_rets, (char *) pResult );
  }

  return Result.ReturnValue;

} /* fnShortMakeString */



int DLLEXPORT fnServerDbCreateStructures
	(SHORTOBJID oShortObjIdHeap ,
	  SHORTOBJID oShortObjIdStructDescr ,
	  int nObjIds ,
	  u_int * /* _vector_t<nObjIds> */  pObjIds ,
	  u_int * pnSlots)
{
  static const char	__procedure__[]	= "client:fnServerDbCreateStructures";
  static fnServerDbCreateStructures_rets	ZeroResult;
  fnServerDbCreateStructures_rets		* pResult = NULL;
  fnServerDbCreateStructures_rets		Result = ZeroResult;
  fnServerDbCreateStructures_args	InArguments;

  /* Client initialization: */
  if ( __bClientInitialize__ ) {
    __bClientInitialize__	= FALSE;
    RPC_CLIENT_INITIALIZE();
  }

#if	CLIENT_CREATE_BY_USER
  if ( __pClient__ == NULL ) {
    __pClient__	= RPC_CLIENT_CREATE ( __szHost__, __szTransport__ );
    if ( __pClient__ == NULL ) {
      /* Error handling for a not connected client: */
      char	szError [ 256 ];
      sprintf ( szError, szFormatNoServer, __procedure__ );
      RPC_CLIENT_ERROR ( szError );
      return Result.ReturnValue;
    }
  }
#else
  while ( __pClient__ == NULL ) {
    __pClient__	= RPC_CLIENT_CREATE ( __szHost__, __szTransport__ );
    if ( __pClient__ == NULL ) {
      /* Error handling for a not connected client: */
      char	szError [ 256 ];
      sprintf ( szError, szFormatNoServer, __procedure__ );
      RPC_CLIENT_CERROR ( szContNoServer, szError );
    }
  }
#endif	/* CLIENT_CREATE_BY_USER */

  /* Copy in the oShortObjIdHeap argument: */
  InArguments.oShortObjIdHeap	= oShortObjIdHeap;
  /* Copy in the oShortObjIdStructDescr argument: */
  InArguments.oShortObjIdStructDescr	= oShortObjIdStructDescr;
  /* Copy in the nObjIds argument: */
  InArguments.nObjIds	= nObjIds;
  InArguments.pObjIdsSize	= nObjIds;

  pResult	=
#ifdef MULTITHREAD
    (
#else
    (fnServerDbCreateStructures_rets *)
#endif
    fnrpc_fnserverdbcreatestructures_1 (
	&InArguments,
#ifdef MULTITHREAD
	&Result,
#endif
	__pClient__ )
#ifdef MULTITHREAD
	== RPC_SUCCESS ) ? &Result : NULL
#endif
	;

  if ( pResult == NULL ) {
    /* Error handling for a failed RPC call, */
    /* i.e. the server did not respond: */
    char	szError [ 256 ];
    sprintf ( szError, szFormatRpcFailed, __procedure__,
              clnt_sperror ( __pClient__, __szHost__ ) );
    __pClient__	= RPC_CLIENT_DESTROY ( __pClient__ );
    RPC_CLIENT_CERROR ( szContRpcFailed, szError );
    Result	= ZeroResult;
    return Result.ReturnValue;
  }
#ifndef MULTITHREAD
  Result	= * pResult;
#endif

  /* Copy out the pObjIds argument: */
  if ( ! ( 
       pResult->pObjIds.u_int_vector_t_len != 0 &&
       pObjIds == NULL ) ) {
    memcpy ( pObjIds,
             pResult->pObjIds.u_int_vector_t_val,
             MIN ( pResult->pObjIds.u_int_vector_t_len,
                   nObjIds ) *
             SIZEOF ( *(pResult->pObjIds.u_int_vector_t_val) ) );
  }
  /* Copy out the pnSlots argument: */
  if ( ! ( 
       pnSlots == NULL ) ) {
    *pnSlots	= pResult->pnSlots;
  }

  if ( pResult && pResult->nErrorLvl ) {
    /* Server returned a user error message: */
    char	szErrorMsg [ 1024 ];
    strncpy ( szErrorMsg,
              ( pResult->pszErrorMsg && pResult->pszErrorMsg [ 0 ] ) ?
              (LPCSTR) pResult->pszErrorMsg : (LPCSTR) szEmpty,
              sizeof ( szErrorMsg ) );
    szErrorMsg [ sizeof ( szErrorMsg ) - 1 ]	= (char) 0;
    xdr_free ( (xdrproc_t) xdr_fnServerDbCreateStructures_rets, (char *) pResult );
    RPC_CLIENT_SERROR ( pResult->nErrorLvl, __procedure__,
                        szErrorMsg );
  } else {
    xdr_free ( (xdrproc_t) xdr_fnServerDbCreateStructures_rets, (char *) pResult );
  }
  if ( 
       pResult->pObjIds.u_int_vector_t_len != 0 &&
       pObjIds == NULL ) {
    /* Error handling for passing a NULL pointer on */
    /* out argument: */
    char	szError [ 256 ];
    sprintf ( szError, szFormatNullPassed,
              __procedure__, "pObjIds" );
    RPC_CLIENT_CERROR ( szContNullOutPassed, szError );
  } else if ( pResult->pObjIds.u_int_vector_t_len > nObjIds ) {
      /* Error handling for an output buffer overflow, */
      /* i.e. the buffer size passed is too small: */
      /* For example, signal a CERROR here ... */
      char	szError [ 256 ];
      sprintf ( szError, szFormatBufferOverflow,
                __procedure__, "pObjIds", 
                nObjIds, 
                pResult->pObjIds.u_int_vector_t_len );
      RPC_CLIENT_CERROR ( szContBufferOverflow, szError );
  }
  if ( 
       pnSlots == NULL ) {
    /* Error handling for passing a NULL pointer on */
    /* out argument: */
    char	szError [ 256 ];
    sprintf ( szError, szFormatNullPassed,
              __procedure__, "pnSlots" );
    RPC_CLIENT_CERROR ( szContNullOutPassed, szError );
  }

  return Result.ReturnValue;

} /* fnServerDbCreateStructures */



int DLLEXPORT fnServerDbCreateInstances
	(SHORTOBJID oShortObjIdHeap ,
	  SHORTOBJID oShortObjIdClassDescr ,
	  int nObjIds ,
	  u_int * /* _vector_t<nObjIds> */  pObjIds ,
	  u_int * pnSlots ,
	  u_int * /* _vector_t<nObjIds> */  pDatas)
{
  static const char	__procedure__[]	= "client:fnServerDbCreateInstances";
  static fnServerDbCreateInstances_rets	ZeroResult;
  fnServerDbCreateInstances_rets		* pResult = NULL;
  fnServerDbCreateInstances_rets		Result = ZeroResult;
  fnServerDbCreateInstances_args	InArguments;

  /* Client initialization: */
  if ( __bClientInitialize__ ) {
    __bClientInitialize__	= FALSE;
    RPC_CLIENT_INITIALIZE();
  }

#if	CLIENT_CREATE_BY_USER
  if ( __pClient__ == NULL ) {
    __pClient__	= RPC_CLIENT_CREATE ( __szHost__, __szTransport__ );
    if ( __pClient__ == NULL ) {
      /* Error handling for a not connected client: */
      char	szError [ 256 ];
      sprintf ( szError, szFormatNoServer, __procedure__ );
      RPC_CLIENT_ERROR ( szError );
      return Result.ReturnValue;
    }
  }
#else
  while ( __pClient__ == NULL ) {
    __pClient__	= RPC_CLIENT_CREATE ( __szHost__, __szTransport__ );
    if ( __pClient__ == NULL ) {
      /* Error handling for a not connected client: */
      char	szError [ 256 ];
      sprintf ( szError, szFormatNoServer, __procedure__ );
      RPC_CLIENT_CERROR ( szContNoServer, szError );
    }
  }
#endif	/* CLIENT_CREATE_BY_USER */

  /* Copy in the oShortObjIdHeap argument: */
  InArguments.oShortObjIdHeap	= oShortObjIdHeap;
  /* Copy in the oShortObjIdClassDescr argument: */
  InArguments.oShortObjIdClassDescr	= oShortObjIdClassDescr;
  /* Copy in the nObjIds argument: */
  InArguments.nObjIds	= nObjIds;
  InArguments.pObjIdsSize	= nObjIds;
  InArguments.pDatasSize	= nObjIds;

  pResult	=
#ifdef MULTITHREAD
    (
#else
    (fnServerDbCreateInstances_rets *)
#endif
    fnrpc_fnserverdbcreateinstances_1 (
	&InArguments,
#ifdef MULTITHREAD
	&Result,
#endif
	__pClient__ )
#ifdef MULTITHREAD
	== RPC_SUCCESS ) ? &Result : NULL
#endif
	;

  if ( pResult == NULL ) {
    /* Error handling for a failed RPC call, */
    /* i.e. the server did not respond: */
    char	szError [ 256 ];
    sprintf ( szError, szFormatRpcFailed, __procedure__,
              clnt_sperror ( __pClient__, __szHost__ ) );
    __pClient__	= RPC_CLIENT_DESTROY ( __pClient__ );
    RPC_CLIENT_CERROR ( szContRpcFailed, szError );
    Result	= ZeroResult;
    return Result.ReturnValue;
  }
#ifndef MULTITHREAD
  Result	= * pResult;
#endif

  /* Copy out the pObjIds argument: */
  if ( ! ( 
       pResult->pObjIds.u_int_vector_t_len != 0 &&
       pObjIds == NULL ) ) {
    memcpy ( pObjIds,
             pResult->pObjIds.u_int_vector_t_val,
             MIN ( pResult->pObjIds.u_int_vector_t_len,
                   nObjIds ) *
             SIZEOF ( *(pResult->pObjIds.u_int_vector_t_val) ) );
  }
  /* Copy out the pnSlots argument: */
  if ( ! ( 
       pnSlots == NULL ) ) {
    *pnSlots	= pResult->pnSlots;
  }
  /* Copy out the pDatas argument: */
  if ( ! ( 
       pResult->pDatas.u_int_vector_t_len != 0 &&
       pDatas == NULL ) ) {
    memcpy ( pDatas,
             pResult->pDatas.u_int_vector_t_val,
             MIN ( pResult->pDatas.u_int_vector_t_len,
                   nObjIds ) *
             SIZEOF ( *(pResult->pDatas.u_int_vector_t_val) ) );
  }

  if ( pResult && pResult->nErrorLvl ) {
    /* Server returned a user error message: */
    char	szErrorMsg [ 1024 ];
    strncpy ( szErrorMsg,
              ( pResult->pszErrorMsg && pResult->pszErrorMsg [ 0 ] ) ?
              (LPCSTR) pResult->pszErrorMsg : (LPCSTR) szEmpty,
              sizeof ( szErrorMsg ) );
    szErrorMsg [ sizeof ( szErrorMsg ) - 1 ]	= (char) 0;
    xdr_free ( (xdrproc_t) xdr_fnServerDbCreateInstances_rets, (char *) pResult );
    RPC_CLIENT_SERROR ( pResult->nErrorLvl, __procedure__,
                        szErrorMsg );
  } else {
    xdr_free ( (xdrproc_t) xdr_fnServerDbCreateInstances_rets, (char *) pResult );
  }
  if ( 
       pResult->pObjIds.u_int_vector_t_len != 0 &&
       pObjIds == NULL ) {
    /* Error handling for passing a NULL pointer on */
    /* out argument: */
    char	szError [ 256 ];
    sprintf ( szError, szFormatNullPassed,
              __procedure__, "pObjIds" );
    RPC_CLIENT_CERROR ( szContNullOutPassed, szError );
  } else if ( pResult->pObjIds.u_int_vector_t_len > nObjIds ) {
      /* Error handling for an output buffer overflow, */
      /* i.e. the buffer size passed is too small: */
      /* For example, signal a CERROR here ... */
      char	szError [ 256 ];
      sprintf ( szError, szFormatBufferOverflow,
                __procedure__, "pObjIds", 
                nObjIds, 
                pResult->pObjIds.u_int_vector_t_len );
      RPC_CLIENT_CERROR ( szContBufferOverflow, szError );
  }
  if ( 
       pnSlots == NULL ) {
    /* Error handling for passing a NULL pointer on */
    /* out argument: */
    char	szError [ 256 ];
    sprintf ( szError, szFormatNullPassed,
              __procedure__, "pnSlots" );
    RPC_CLIENT_CERROR ( szContNullOutPassed, szError );
  }
  if ( 
       pResult->pDatas.u_int_vector_t_len != 0 &&
       pDatas == NULL ) {
    /* Error handling for passing a NULL pointer on */
    /* out argument: */
    char	szError [ 256 ];
    sprintf ( szError, szFormatNullPassed,
              __procedure__, "pDatas" );
    RPC_CLIENT_CERROR ( szContNullOutPassed, szError );
  } else if ( pResult->pDatas.u_int_vector_t_len > nObjIds ) {
      /* Error handling for an output buffer overflow, */
      /* i.e. the buffer size passed is too small: */
      /* For example, signal a CERROR here ... */
      char	szError [ 256 ];
      sprintf ( szError, szFormatBufferOverflow,
                __procedure__, "pDatas", 
                nObjIds, 
                pResult->pDatas.u_int_vector_t_len );
      RPC_CLIENT_CERROR ( szContBufferOverflow, szError );
  }

  return Result.ReturnValue;

} /* fnServerDbCreateInstances */



SHLOCK DLLEXPORT fnServerInstanceWriteWrapper
	(SHORTOBJID oShortObjIdHeap ,
	  SHORTOBJID oShortObjIdInstance ,
	  SHORTOBJID oShortObjIdClassDescr)
{
  static const char	__procedure__[]	= "client:fnServerInstanceWriteWrapper";
  static fnServerInstanceWriteWrapper_rets	ZeroResult;
  fnServerInstanceWriteWrapper_rets		* pResult = NULL;
  fnServerInstanceWriteWrapper_rets		Result = ZeroResult;
  fnServerInstanceWriteWrapper_args	InArguments;

  /* Client initialization: */
  if ( __bClientInitialize__ ) {
    __bClientInitialize__	= FALSE;
    RPC_CLIENT_INITIALIZE();
  }

#if	CLIENT_CREATE_BY_USER
  if ( __pClient__ == NULL ) {
    __pClient__	= RPC_CLIENT_CREATE ( __szHost__, __szTransport__ );
    if ( __pClient__ == NULL ) {
      /* Error handling for a not connected client: */
      char	szError [ 256 ];
      sprintf ( szError, szFormatNoServer, __procedure__ );
      RPC_CLIENT_ERROR ( szError );
      return Result.ReturnValue;
    }
  }
#else
  while ( __pClient__ == NULL ) {
    __pClient__	= RPC_CLIENT_CREATE ( __szHost__, __szTransport__ );
    if ( __pClient__ == NULL ) {
      /* Error handling for a not connected client: */
      char	szError [ 256 ];
      sprintf ( szError, szFormatNoServer, __procedure__ );
      RPC_CLIENT_CERROR ( szContNoServer, szError );
    }
  }
#endif	/* CLIENT_CREATE_BY_USER */

  /* Copy in the oShortObjIdHeap argument: */
  InArguments.oShortObjIdHeap	= oShortObjIdHeap;
  /* Copy in the oShortObjIdInstance argument: */
  InArguments.oShortObjIdInstance	= oShortObjIdInstance;
  /* Copy in the oShortObjIdClassDescr argument: */
  InArguments.oShortObjIdClassDescr	= oShortObjIdClassDescr;

  pResult	=
#ifdef MULTITHREAD
    (
#else
    (fnServerInstanceWriteWrapper_rets *)
#endif
    fnrpc_fnserverinstancewritewrapper_1 (
	&InArguments,
#ifdef MULTITHREAD
	&Result,
#endif
	__pClient__ )
#ifdef MULTITHREAD
	== RPC_SUCCESS ) ? &Result : NULL
#endif
	;

  if ( pResult == NULL ) {
    /* Error handling for a failed RPC call, */
    /* i.e. the server did not respond: */
    char	szError [ 256 ];
    sprintf ( szError, szFormatRpcFailed, __procedure__,
              clnt_sperror ( __pClient__, __szHost__ ) );
    __pClient__	= RPC_CLIENT_DESTROY ( __pClient__ );
    RPC_CLIENT_CERROR ( szContRpcFailed, szError );
    Result	= ZeroResult;
    return Result.ReturnValue;
  }
#ifndef MULTITHREAD
  Result	= * pResult;
#endif


  if ( pResult && pResult->nErrorLvl ) {
    /* Server returned a user error message: */
    char	szErrorMsg [ 1024 ];
    strncpy ( szErrorMsg,
              ( pResult->pszErrorMsg && pResult->pszErrorMsg [ 0 ] ) ?
              (LPCSTR) pResult->pszErrorMsg : (LPCSTR) szEmpty,
              sizeof ( szErrorMsg ) );
    szErrorMsg [ sizeof ( szErrorMsg ) - 1 ]	= (char) 0;
    xdr_free ( (xdrproc_t) xdr_fnServerInstanceWriteWrapper_rets, (char *) pResult );
    RPC_CLIENT_SERROR ( pResult->nErrorLvl, __procedure__,
                        szErrorMsg );
  } else {
    xdr_free ( (xdrproc_t) xdr_fnServerInstanceWriteWrapper_rets, (char *) pResult );
  }

  return Result.ReturnValue;

} /* fnServerInstanceWriteWrapper */



SHLOCK DLLEXPORT fnServerInstanceWriteData
	(SHORTOBJID oShortObjIdHeap ,
	  SHORTOBJID oShortObjIdInstance ,
	  SHORTOBJID oShortObjIdData)
{
  static const char	__procedure__[]	= "client:fnServerInstanceWriteData";
  static fnServerInstanceWriteData_rets	ZeroResult;
  fnServerInstanceWriteData_rets		* pResult = NULL;
  fnServerInstanceWriteData_rets		Result = ZeroResult;
  fnServerInstanceWriteData_args	InArguments;

  /* Client initialization: */
  if ( __bClientInitialize__ ) {
    __bClientInitialize__	= FALSE;
    RPC_CLIENT_INITIALIZE();
  }

#if	CLIENT_CREATE_BY_USER
  if ( __pClient__ == NULL ) {
    __pClient__	= RPC_CLIENT_CREATE ( __szHost__, __szTransport__ );
    if ( __pClient__ == NULL ) {
      /* Error handling for a not connected client: */
      char	szError [ 256 ];
      sprintf ( szError, szFormatNoServer, __procedure__ );
      RPC_CLIENT_ERROR ( szError );
      return Result.ReturnValue;
    }
  }
#else
  while ( __pClient__ == NULL ) {
    __pClient__	= RPC_CLIENT_CREATE ( __szHost__, __szTransport__ );
    if ( __pClient__ == NULL ) {
      /* Error handling for a not connected client: */
      char	szError [ 256 ];
      sprintf ( szError, szFormatNoServer, __procedure__ );
      RPC_CLIENT_CERROR ( szContNoServer, szError );
    }
  }
#endif	/* CLIENT_CREATE_BY_USER */

  /* Copy in the oShortObjIdHeap argument: */
  InArguments.oShortObjIdHeap	= oShortObjIdHeap;
  /* Copy in the oShortObjIdInstance argument: */
  InArguments.oShortObjIdInstance	= oShortObjIdInstance;
  /* Copy in the oShortObjIdData argument: */
  InArguments.oShortObjIdData	= oShortObjIdData;

  pResult	=
#ifdef MULTITHREAD
    (
#else
    (fnServerInstanceWriteData_rets *)
#endif
    fnrpc_fnserverinstancewritedata_1 (
	&InArguments,
#ifdef MULTITHREAD
	&Result,
#endif
	__pClient__ )
#ifdef MULTITHREAD
	== RPC_SUCCESS ) ? &Result : NULL
#endif
	;

  if ( pResult == NULL ) {
    /* Error handling for a failed RPC call, */
    /* i.e. the server did not respond: */
    char	szError [ 256 ];
    sprintf ( szError, szFormatRpcFailed, __procedure__,
              clnt_sperror ( __pClient__, __szHost__ ) );
    __pClient__	= RPC_CLIENT_DESTROY ( __pClient__ );
    RPC_CLIENT_CERROR ( szContRpcFailed, szError );
    Result	= ZeroResult;
    return Result.ReturnValue;
  }
#ifndef MULTITHREAD
  Result	= * pResult;
#endif


  if ( pResult && pResult->nErrorLvl ) {
    /* Server returned a user error message: */
    char	szErrorMsg [ 1024 ];
    strncpy ( szErrorMsg,
              ( pResult->pszErrorMsg && pResult->pszErrorMsg [ 0 ] ) ?
              (LPCSTR) pResult->pszErrorMsg : (LPCSTR) szEmpty,
              sizeof ( szErrorMsg ) );
    szErrorMsg [ sizeof ( szErrorMsg ) - 1 ]	= (char) 0;
    xdr_free ( (xdrproc_t) xdr_fnServerInstanceWriteData_rets, (char *) pResult );
    RPC_CLIENT_SERROR ( pResult->nErrorLvl, __procedure__,
                        szErrorMsg );
  } else {
    xdr_free ( (xdrproc_t) xdr_fnServerInstanceWriteData_rets, (char *) pResult );
  }

  return Result.ReturnValue;

} /* fnServerInstanceWriteData */



string_t DLLEXPORT fnServerDbTypeTagName
	(SHTYPETAG nTypeTag)
{
  static const char	__procedure__[]	= "client:fnServerDbTypeTagName";
  static fnServerDbTypeTagName_rets	ZeroResult;
  fnServerDbTypeTagName_rets		* pResult = NULL;
  fnServerDbTypeTagName_rets		Result = ZeroResult;

  /* Client initialization: */
  if ( __bClientInitialize__ ) {
    __bClientInitialize__	= FALSE;
    RPC_CLIENT_INITIALIZE();
  }

#if	CLIENT_CREATE_BY_USER
  if ( __pClient__ == NULL ) {
    __pClient__	= RPC_CLIENT_CREATE ( __szHost__, __szTransport__ );
    if ( __pClient__ == NULL ) {
      /* Error handling for a not connected client: */
      char	szError [ 256 ];
      sprintf ( szError, szFormatNoServer, __procedure__ );
      RPC_CLIENT_ERROR ( szError );
      return Result.ReturnValue;
    }
  }
#else
  while ( __pClient__ == NULL ) {
    __pClient__	= RPC_CLIENT_CREATE ( __szHost__, __szTransport__ );
    if ( __pClient__ == NULL ) {
      /* Error handling for a not connected client: */
      char	szError [ 256 ];
      sprintf ( szError, szFormatNoServer, __procedure__ );
      RPC_CLIENT_CERROR ( szContNoServer, szError );
    }
  }
#endif	/* CLIENT_CREATE_BY_USER */

  pResult	=
#ifdef MULTITHREAD
    (
#else
    (fnServerDbTypeTagName_rets *)
#endif
    fnrpc_fnserverdbtypetagname_1 (
	&nTypeTag,
#ifdef MULTITHREAD
	&Result,
#endif
	__pClient__ )
#ifdef MULTITHREAD
	== RPC_SUCCESS ) ? &Result : NULL
#endif
	;

  if ( pResult == NULL ) {
    /* Error handling for a failed RPC call, */
    /* i.e. the server did not respond: */
    char	szError [ 256 ];
    sprintf ( szError, szFormatRpcFailed, __procedure__,
              clnt_sperror ( __pClient__, __szHost__ ) );
    __pClient__	= RPC_CLIENT_DESTROY ( __pClient__ );
    RPC_CLIENT_CERROR ( szContRpcFailed, szError );
    Result	= ZeroResult;
    return Result.ReturnValue;
  }
#ifndef MULTITHREAD
  Result	= * pResult;
#endif


  if ( pResult && pResult->nErrorLvl ) {
    /* Server returned a user error message: */
    char	szErrorMsg [ 1024 ];
    strncpy ( szErrorMsg,
              ( pResult->pszErrorMsg && pResult->pszErrorMsg [ 0 ] ) ?
              (LPCSTR) pResult->pszErrorMsg : (LPCSTR) szEmpty,
              sizeof ( szErrorMsg ) );
    szErrorMsg [ sizeof ( szErrorMsg ) - 1 ]	= (char) 0;
    xdr_free ( (xdrproc_t) xdr_fnServerDbTypeTagName_rets, (char *) pResult );
    RPC_CLIENT_SERROR ( pResult->nErrorLvl, __procedure__,
                        szErrorMsg );
  } else {
    xdr_free ( (xdrproc_t) xdr_fnServerDbTypeTagName_rets, (char *) pResult );
  }

  return Result.ReturnValue;

} /* fnServerDbTypeTagName */



int DLLEXPORT fnServerObjectPrettyPrint
	(SHORTOBJID oShortObjIdHeap ,
	  SHORTOBJID oShortObjId ,
	  SHTYPETAG nTypeTag ,
	  string_t /* string_t<nBuffer> */  lpszBuffer ,
	  int nBuffer)
{
  static const char	__procedure__[]	= "client:fnServerObjectPrettyPrint";
  static fnServerObjectPrettyPrint_rets	ZeroResult;
  fnServerObjectPrettyPrint_rets		* pResult = NULL;
  fnServerObjectPrettyPrint_rets		Result = ZeroResult;
  fnServerObjectPrettyPrint_args	InArguments;

  /* Client initialization: */
  if ( __bClientInitialize__ ) {
    __bClientInitialize__	= FALSE;
    RPC_CLIENT_INITIALIZE();
  }

#if	CLIENT_CREATE_BY_USER
  if ( __pClient__ == NULL ) {
    __pClient__	= RPC_CLIENT_CREATE ( __szHost__, __szTransport__ );
    if ( __pClient__ == NULL ) {
      /* Error handling for a not connected client: */
      char	szError [ 256 ];
      sprintf ( szError, szFormatNoServer, __procedure__ );
      RPC_CLIENT_ERROR ( szError );
      return Result.ReturnValue;
    }
  }
#else
  while ( __pClient__ == NULL ) {
    __pClient__	= RPC_CLIENT_CREATE ( __szHost__, __szTransport__ );
    if ( __pClient__ == NULL ) {
      /* Error handling for a not connected client: */
      char	szError [ 256 ];
      sprintf ( szError, szFormatNoServer, __procedure__ );
      RPC_CLIENT_CERROR ( szContNoServer, szError );
    }
  }
#endif	/* CLIENT_CREATE_BY_USER */

  /* Copy in the oShortObjIdHeap argument: */
  InArguments.oShortObjIdHeap	= oShortObjIdHeap;
  /* Copy in the oShortObjId argument: */
  InArguments.oShortObjId	= oShortObjId;
  /* Copy in the nTypeTag argument: */
  InArguments.nTypeTag	= nTypeTag;
  /* Copy in the nBuffer argument: */
  InArguments.nBuffer	= nBuffer;
  InArguments.lpszBufferSize	= nBuffer;

  pResult	=
#ifdef MULTITHREAD
    (
#else
    (fnServerObjectPrettyPrint_rets *)
#endif
    fnrpc_fnserverobjectprettyprint_1 (
	&InArguments,
#ifdef MULTITHREAD
	&Result,
#endif
	__pClient__ )
#ifdef MULTITHREAD
	== RPC_SUCCESS ) ? &Result : NULL
#endif
	;

  if ( pResult == NULL ) {
    /* Error handling for a failed RPC call, */
    /* i.e. the server did not respond: */
    char	szError [ 256 ];
    sprintf ( szError, szFormatRpcFailed, __procedure__,
              clnt_sperror ( __pClient__, __szHost__ ) );
    __pClient__	= RPC_CLIENT_DESTROY ( __pClient__ );
    RPC_CLIENT_CERROR ( szContRpcFailed, szError );
    Result	= ZeroResult;
    return Result.ReturnValue;
  }
#ifndef MULTITHREAD
  Result	= * pResult;
#endif

  /* Copy out the lpszBuffer argument: */
  if ( ! ( 
       pResult->lpszBuffer
       && *(pResult->lpszBuffer) &&
       lpszBuffer == NULL ) ) {
    if ( lpszBuffer != NULL ) {
      if ( pResult->lpszBuffer != NULL ) {
        strncpy ( lpszBuffer, pResult->lpszBuffer, nBuffer );
      } else {
        *lpszBuffer	= (char) 0;
      }
    }
  }

  if ( pResult && pResult->nErrorLvl ) {
    /* Server returned a user error message: */
    char	szErrorMsg [ 1024 ];
    strncpy ( szErrorMsg,
              ( pResult->pszErrorMsg && pResult->pszErrorMsg [ 0 ] ) ?
              (LPCSTR) pResult->pszErrorMsg : (LPCSTR) szEmpty,
              sizeof ( szErrorMsg ) );
    szErrorMsg [ sizeof ( szErrorMsg ) - 1 ]	= (char) 0;
    xdr_free ( (xdrproc_t) xdr_fnServerObjectPrettyPrint_rets, (char *) pResult );
    RPC_CLIENT_SERROR ( pResult->nErrorLvl, __procedure__,
                        szErrorMsg );
  } else {
    xdr_free ( (xdrproc_t) xdr_fnServerObjectPrettyPrint_rets, (char *) pResult );
  }
  if ( 
       Result.lpszBuffer
       && *(Result.lpszBuffer) &&
       lpszBuffer == NULL ) {
    /* Error handling for passing a NULL pointer on */
    /* out argument: */
    char	szError [ 256 ];
    sprintf ( szError, szFormatNullPassed,
              __procedure__, "lpszBuffer" );
    RPC_CLIENT_CERROR ( szContNullOutPassed, szError );
  }

  return Result.ReturnValue;

} /* fnServerObjectPrettyPrint */



int DLLEXPORT fnShortPrintSymbol
	(SHORTOBJID oShortObjIdHeap ,
	  SHORTOBJID oShortSymbol ,
	  string_t /* string_t<nBuffer> */  lpszBuffer ,
	  int nBuffer)
{
  static const char	__procedure__[]	= "client:fnShortPrintSymbol";
  static fnShortPrintSymbol_rets	ZeroResult;
  fnShortPrintSymbol_rets		* pResult = NULL;
  fnShortPrintSymbol_rets		Result = ZeroResult;
  fnShortPrintSymbol_args	InArguments;

  /* Client initialization: */
  if ( __bClientInitialize__ ) {
    __bClientInitialize__	= FALSE;
    RPC_CLIENT_INITIALIZE();
  }

#if	CLIENT_CREATE_BY_USER
  if ( __pClient__ == NULL ) {
    __pClient__	= RPC_CLIENT_CREATE ( __szHost__, __szTransport__ );
    if ( __pClient__ == NULL ) {
      /* Error handling for a not connected client: */
      char	szError [ 256 ];
      sprintf ( szError, szFormatNoServer, __procedure__ );
      RPC_CLIENT_ERROR ( szError );
      return Result.ReturnValue;
    }
  }
#else
  while ( __pClient__ == NULL ) {
    __pClient__	= RPC_CLIENT_CREATE ( __szHost__, __szTransport__ );
    if ( __pClient__ == NULL ) {
      /* Error handling for a not connected client: */
      char	szError [ 256 ];
      sprintf ( szError, szFormatNoServer, __procedure__ );
      RPC_CLIENT_CERROR ( szContNoServer, szError );
    }
  }
#endif	/* CLIENT_CREATE_BY_USER */

  /* Copy in the oShortObjIdHeap argument: */
  InArguments.oShortObjIdHeap	= oShortObjIdHeap;
  /* Copy in the oShortSymbol argument: */
  InArguments.oShortSymbol	= oShortSymbol;
  /* Copy in the nBuffer argument: */
  InArguments.nBuffer	= nBuffer;
  InArguments.lpszBufferSize	= nBuffer;

  pResult	=
#ifdef MULTITHREAD
    (
#else
    (fnShortPrintSymbol_rets *)
#endif
    fnrpc_fnshortprintsymbol_1 (
	&InArguments,
#ifdef MULTITHREAD
	&Result,
#endif
	__pClient__ )
#ifdef MULTITHREAD
	== RPC_SUCCESS ) ? &Result : NULL
#endif
	;

  if ( pResult == NULL ) {
    /* Error handling for a failed RPC call, */
    /* i.e. the server did not respond: */
    char	szError [ 256 ];
    sprintf ( szError, szFormatRpcFailed, __procedure__,
              clnt_sperror ( __pClient__, __szHost__ ) );
    __pClient__	= RPC_CLIENT_DESTROY ( __pClient__ );
    RPC_CLIENT_CERROR ( szContRpcFailed, szError );
    Result	= ZeroResult;
    return Result.ReturnValue;
  }
#ifndef MULTITHREAD
  Result	= * pResult;
#endif

  /* Copy out the lpszBuffer argument: */
  if ( ! ( 
       pResult->lpszBuffer
       && *(pResult->lpszBuffer) &&
       lpszBuffer == NULL ) ) {
    if ( lpszBuffer != NULL ) {
      if ( pResult->lpszBuffer != NULL ) {
        strncpy ( lpszBuffer, pResult->lpszBuffer, nBuffer );
      } else {
        *lpszBuffer	= (char) 0;
      }
    }
  }

  if ( pResult && pResult->nErrorLvl ) {
    /* Server returned a user error message: */
    char	szErrorMsg [ 1024 ];
    strncpy ( szErrorMsg,
              ( pResult->pszErrorMsg && pResult->pszErrorMsg [ 0 ] ) ?
              (LPCSTR) pResult->pszErrorMsg : (LPCSTR) szEmpty,
              sizeof ( szErrorMsg ) );
    szErrorMsg [ sizeof ( szErrorMsg ) - 1 ]	= (char) 0;
    xdr_free ( (xdrproc_t) xdr_fnShortPrintSymbol_rets, (char *) pResult );
    RPC_CLIENT_SERROR ( pResult->nErrorLvl, __procedure__,
                        szErrorMsg );
  } else {
    xdr_free ( (xdrproc_t) xdr_fnShortPrintSymbol_rets, (char *) pResult );
  }
  if ( 
       Result.lpszBuffer
       && *(Result.lpszBuffer) &&
       lpszBuffer == NULL ) {
    /* Error handling for passing a NULL pointer on */
    /* out argument: */
    char	szError [ 256 ];
    sprintf ( szError, szFormatNullPassed,
              __procedure__, "lpszBuffer" );
    RPC_CLIENT_CERROR ( szContNullOutPassed, szError );
  }

  return Result.ReturnValue;

} /* fnShortPrintSymbol */



SHORTOBJID DLLEXPORT fnShortMakeSingleFloat
	(SHORTOBJID oShortObjIdHeap ,
	  float fFrom)
{
  static const char	__procedure__[]	= "client:fnShortMakeSingleFloat";
  static fnShortMakeSingleFloat_rets	ZeroResult;
  fnShortMakeSingleFloat_rets		* pResult = NULL;
  fnShortMakeSingleFloat_rets		Result = ZeroResult;
  fnShortMakeSingleFloat_args	InArguments;

  /* Client initialization: */
  if ( __bClientInitialize__ ) {
    __bClientInitialize__	= FALSE;
    RPC_CLIENT_INITIALIZE();
  }

#if	CLIENT_CREATE_BY_USER
  if ( __pClient__ == NULL ) {
    __pClient__	= RPC_CLIENT_CREATE ( __szHost__, __szTransport__ );
    if ( __pClient__ == NULL ) {
      /* Error handling for a not connected client: */
      char	szError [ 256 ];
      sprintf ( szError, szFormatNoServer, __procedure__ );
      RPC_CLIENT_ERROR ( szError );
      return Result.ReturnValue;
    }
  }
#else
  while ( __pClient__ == NULL ) {
    __pClient__	= RPC_CLIENT_CREATE ( __szHost__, __szTransport__ );
    if ( __pClient__ == NULL ) {
      /* Error handling for a not connected client: */
      char	szError [ 256 ];
      sprintf ( szError, szFormatNoServer, __procedure__ );
      RPC_CLIENT_CERROR ( szContNoServer, szError );
    }
  }
#endif	/* CLIENT_CREATE_BY_USER */

  /* Copy in the oShortObjIdHeap argument: */
  InArguments.oShortObjIdHeap	= oShortObjIdHeap;
  /* Copy in the fFrom argument: */
  InArguments.fFrom	= fFrom;

  pResult	=
#ifdef MULTITHREAD
    (
#else
    (fnShortMakeSingleFloat_rets *)
#endif
    fnrpc_fnshortmakesinglefloat_1 (
	&InArguments,
#ifdef MULTITHREAD
	&Result,
#endif
	__pClient__ )
#ifdef MULTITHREAD
	== RPC_SUCCESS ) ? &Result : NULL
#endif
	;

  if ( pResult == NULL ) {
    /* Error handling for a failed RPC call, */
    /* i.e. the server did not respond: */
    char	szError [ 256 ];
    sprintf ( szError, szFormatRpcFailed, __procedure__,
              clnt_sperror ( __pClient__, __szHost__ ) );
    __pClient__	= RPC_CLIENT_DESTROY ( __pClient__ );
    RPC_CLIENT_CERROR ( szContRpcFailed, szError );
    Result	= ZeroResult;
    return Result.ReturnValue;
  }
#ifndef MULTITHREAD
  Result	= * pResult;
#endif


  if ( pResult && pResult->nErrorLvl ) {
    /* Server returned a user error message: */
    char	szErrorMsg [ 1024 ];
    strncpy ( szErrorMsg,
              ( pResult->pszErrorMsg && pResult->pszErrorMsg [ 0 ] ) ?
              (LPCSTR) pResult->pszErrorMsg : (LPCSTR) szEmpty,
              sizeof ( szErrorMsg ) );
    szErrorMsg [ sizeof ( szErrorMsg ) - 1 ]	= (char) 0;
    xdr_free ( (xdrproc_t) xdr_fnShortMakeSingleFloat_rets, (char *) pResult );
    RPC_CLIENT_SERROR ( pResult->nErrorLvl, __procedure__,
                        szErrorMsg );
  } else {
    xdr_free ( (xdrproc_t) xdr_fnShortMakeSingleFloat_rets, (char *) pResult );
  }

  return Result.ReturnValue;

} /* fnShortMakeSingleFloat */



SHORTOBJID DLLEXPORT fnShortMakeDoubleFloat
	(SHORTOBJID oShortObjIdHeap ,
	  double fFrom)
{
  static const char	__procedure__[]	= "client:fnShortMakeDoubleFloat";
  static fnShortMakeDoubleFloat_rets	ZeroResult;
  fnShortMakeDoubleFloat_rets		* pResult = NULL;
  fnShortMakeDoubleFloat_rets		Result = ZeroResult;
  fnShortMakeDoubleFloat_args	InArguments;

  /* Client initialization: */
  if ( __bClientInitialize__ ) {
    __bClientInitialize__	= FALSE;
    RPC_CLIENT_INITIALIZE();
  }

#if	CLIENT_CREATE_BY_USER
  if ( __pClient__ == NULL ) {
    __pClient__	= RPC_CLIENT_CREATE ( __szHost__, __szTransport__ );
    if ( __pClient__ == NULL ) {
      /* Error handling for a not connected client: */
      char	szError [ 256 ];
      sprintf ( szError, szFormatNoServer, __procedure__ );
      RPC_CLIENT_ERROR ( szError );
      return Result.ReturnValue;
    }
  }
#else
  while ( __pClient__ == NULL ) {
    __pClient__	= RPC_CLIENT_CREATE ( __szHost__, __szTransport__ );
    if ( __pClient__ == NULL ) {
      /* Error handling for a not connected client: */
      char	szError [ 256 ];
      sprintf ( szError, szFormatNoServer, __procedure__ );
      RPC_CLIENT_CERROR ( szContNoServer, szError );
    }
  }
#endif	/* CLIENT_CREATE_BY_USER */

  /* Copy in the oShortObjIdHeap argument: */
  InArguments.oShortObjIdHeap	= oShortObjIdHeap;
  /* Copy in the fFrom argument: */
  InArguments.fFrom	= fFrom;

  pResult	=
#ifdef MULTITHREAD
    (
#else
    (fnShortMakeDoubleFloat_rets *)
#endif
    fnrpc_fnshortmakedoublefloat_1 (
	&InArguments,
#ifdef MULTITHREAD
	&Result,
#endif
	__pClient__ )
#ifdef MULTITHREAD
	== RPC_SUCCESS ) ? &Result : NULL
#endif
	;

  if ( pResult == NULL ) {
    /* Error handling for a failed RPC call, */
    /* i.e. the server did not respond: */
    char	szError [ 256 ];
    sprintf ( szError, szFormatRpcFailed, __procedure__,
              clnt_sperror ( __pClient__, __szHost__ ) );
    __pClient__	= RPC_CLIENT_DESTROY ( __pClient__ );
    RPC_CLIENT_CERROR ( szContRpcFailed, szError );
    Result	= ZeroResult;
    return Result.ReturnValue;
  }
#ifndef MULTITHREAD
  Result	= * pResult;
#endif


  if ( pResult && pResult->nErrorLvl ) {
    /* Server returned a user error message: */
    char	szErrorMsg [ 1024 ];
    strncpy ( szErrorMsg,
              ( pResult->pszErrorMsg && pResult->pszErrorMsg [ 0 ] ) ?
              (LPCSTR) pResult->pszErrorMsg : (LPCSTR) szEmpty,
              sizeof ( szErrorMsg ) );
    szErrorMsg [ sizeof ( szErrorMsg ) - 1 ]	= (char) 0;
    xdr_free ( (xdrproc_t) xdr_fnShortMakeDoubleFloat_rets, (char *) pResult );
    RPC_CLIENT_SERROR ( pResult->nErrorLvl, __procedure__,
                        szErrorMsg );
  } else {
    xdr_free ( (xdrproc_t) xdr_fnShortMakeDoubleFloat_rets, (char *) pResult );
  }

  return Result.ReturnValue;

} /* fnShortMakeDoubleFloat */



SHORTOBJID DLLEXPORT fnServerDbMakeBignum
	(SHORTOBJID oShortObjIdHeap ,
	  SHORTOBJID oShortObjIdFormat ,
	  int nSizeInBits ,
	  as_is * /* _vector_t<((( AlignBitsToWords ( ABS ( nSizeInBits ) ) )*( sizeof(int) )) )> */ pnBignum)
{
  static const char	__procedure__[]	= "client:fnServerDbMakeBignum";
  static fnServerDbMakeBignum_rets	ZeroResult;
  fnServerDbMakeBignum_rets		* pResult = NULL;
  fnServerDbMakeBignum_rets		Result = ZeroResult;
  fnServerDbMakeBignum_args	InArguments;

  /* Client initialization: */
  if ( __bClientInitialize__ ) {
    __bClientInitialize__	= FALSE;
    RPC_CLIENT_INITIALIZE();
  }

#if	CLIENT_CREATE_BY_USER
  if ( __pClient__ == NULL ) {
    __pClient__	= RPC_CLIENT_CREATE ( __szHost__, __szTransport__ );
    if ( __pClient__ == NULL ) {
      /* Error handling for a not connected client: */
      char	szError [ 256 ];
      sprintf ( szError, szFormatNoServer, __procedure__ );
      RPC_CLIENT_ERROR ( szError );
      return Result.ReturnValue;
    }
  }
#else
  while ( __pClient__ == NULL ) {
    __pClient__	= RPC_CLIENT_CREATE ( __szHost__, __szTransport__ );
    if ( __pClient__ == NULL ) {
      /* Error handling for a not connected client: */
      char	szError [ 256 ];
      sprintf ( szError, szFormatNoServer, __procedure__ );
      RPC_CLIENT_CERROR ( szContNoServer, szError );
    }
  }
#endif	/* CLIENT_CREATE_BY_USER */

  /* Copy in the oShortObjIdHeap argument: */
  InArguments.oShortObjIdHeap	= oShortObjIdHeap;
  /* Copy in the oShortObjIdFormat argument: */
  InArguments.oShortObjIdFormat	= oShortObjIdFormat;
  /* Copy in the nSizeInBits argument: */
  InArguments.nSizeInBits	= nSizeInBits;
  /* Copy in the pnBignum argument: */
  InArguments.pnBignum.as_is_vector_t_len	= ((( AlignBitsToWords ( ABS ( nSizeInBits ) ) )*( sizeof(int) )) );
  InArguments.pnBignum.as_is_vector_t_val	= pnBignum;
  if ( InArguments.pnBignum.as_is_vector_t_len != 0 && pnBignum == NULL ) {
    /* Error handling for passing a NULL pointer on */
    /* VECTOR declared in argument: */
    char	szError [ 256 ];
    InArguments.pnBignum.as_is_vector_t_len	= 0;
    sprintf ( szError, szFormatNullPassed,
              __procedure__, "pnBignum" );
    RPC_CLIENT_CERROR ( szContNullPassed, szError );
  }

  pResult	=
#ifdef MULTITHREAD
    (
#else
    (fnServerDbMakeBignum_rets *)
#endif
    fnrpc_fnserverdbmakebignum_1 (
	&InArguments,
#ifdef MULTITHREAD
	&Result,
#endif
	__pClient__ )
#ifdef MULTITHREAD
	== RPC_SUCCESS ) ? &Result : NULL
#endif
	;

  if ( pResult == NULL ) {
    /* Error handling for a failed RPC call, */
    /* i.e. the server did not respond: */
    char	szError [ 256 ];
    sprintf ( szError, szFormatRpcFailed, __procedure__,
              clnt_sperror ( __pClient__, __szHost__ ) );
    __pClient__	= RPC_CLIENT_DESTROY ( __pClient__ );
    RPC_CLIENT_CERROR ( szContRpcFailed, szError );
    Result	= ZeroResult;
    return Result.ReturnValue;
  }
#ifndef MULTITHREAD
  Result	= * pResult;
#endif


  if ( pResult && pResult->nErrorLvl ) {
    /* Server returned a user error message: */
    char	szErrorMsg [ 1024 ];
    strncpy ( szErrorMsg,
              ( pResult->pszErrorMsg && pResult->pszErrorMsg [ 0 ] ) ?
              (LPCSTR) pResult->pszErrorMsg : (LPCSTR) szEmpty,
              sizeof ( szErrorMsg ) );
    szErrorMsg [ sizeof ( szErrorMsg ) - 1 ]	= (char) 0;
    xdr_free ( (xdrproc_t) xdr_fnServerDbMakeBignum_rets, (char *) pResult );
    RPC_CLIENT_SERROR ( pResult->nErrorLvl, __procedure__,
                        szErrorMsg );
  } else {
    xdr_free ( (xdrproc_t) xdr_fnServerDbMakeBignum_rets, (char *) pResult );
  }

  return Result.ReturnValue;

} /* fnServerDbMakeBignum */



SHLOCK DLLEXPORT fnServerObjectReadBignum
	(SHORTOBJID oShortObjIdHeap ,
	  SHORTOBJID oShortObjIdFormat ,
	  SHORTOBJID oShortObjId ,
	  int nSizeInBits ,
	  as_is * /* _vector_t<((( AlignBitsToWords ( ABS ( nSizeInBits ) ) )*( sizeof(int) )) )> */  pnBignum)
{
  static const char	__procedure__[]	= "client:fnServerObjectReadBignum";
  static fnServerObjectReadBignum_rets	ZeroResult;
  fnServerObjectReadBignum_rets		* pResult = NULL;
  fnServerObjectReadBignum_rets		Result = ZeroResult;
  fnServerObjectReadBignum_args	InArguments;

  /* Client initialization: */
  if ( __bClientInitialize__ ) {
    __bClientInitialize__	= FALSE;
    RPC_CLIENT_INITIALIZE();
  }

#if	CLIENT_CREATE_BY_USER
  if ( __pClient__ == NULL ) {
    __pClient__	= RPC_CLIENT_CREATE ( __szHost__, __szTransport__ );
    if ( __pClient__ == NULL ) {
      /* Error handling for a not connected client: */
      char	szError [ 256 ];
      sprintf ( szError, szFormatNoServer, __procedure__ );
      RPC_CLIENT_ERROR ( szError );
      return Result.ReturnValue;
    }
  }
#else
  while ( __pClient__ == NULL ) {
    __pClient__	= RPC_CLIENT_CREATE ( __szHost__, __szTransport__ );
    if ( __pClient__ == NULL ) {
      /* Error handling for a not connected client: */
      char	szError [ 256 ];
      sprintf ( szError, szFormatNoServer, __procedure__ );
      RPC_CLIENT_CERROR ( szContNoServer, szError );
    }
  }
#endif	/* CLIENT_CREATE_BY_USER */

  /* Copy in the oShortObjIdHeap argument: */
  InArguments.oShortObjIdHeap	= oShortObjIdHeap;
  /* Copy in the oShortObjIdFormat argument: */
  InArguments.oShortObjIdFormat	= oShortObjIdFormat;
  /* Copy in the oShortObjId argument: */
  InArguments.oShortObjId	= oShortObjId;
  /* Copy in the nSizeInBits argument: */
  InArguments.nSizeInBits	= nSizeInBits;
  InArguments.pnBignumSize	= ((( AlignBitsToWords ( ABS ( nSizeInBits ) ) )*( sizeof(int) )) );

  pResult	=
#ifdef MULTITHREAD
    (
#else
    (fnServerObjectReadBignum_rets *)
#endif
    fnrpc_fnserverobjectreadbignum_1 (
	&InArguments,
#ifdef MULTITHREAD
	&Result,
#endif
	__pClient__ )
#ifdef MULTITHREAD
	== RPC_SUCCESS ) ? &Result : NULL
#endif
	;

  if ( pResult == NULL ) {
    /* Error handling for a failed RPC call, */
    /* i.e. the server did not respond: */
    char	szError [ 256 ];
    sprintf ( szError, szFormatRpcFailed, __procedure__,
              clnt_sperror ( __pClient__, __szHost__ ) );
    __pClient__	= RPC_CLIENT_DESTROY ( __pClient__ );
    RPC_CLIENT_CERROR ( szContRpcFailed, szError );
    Result	= ZeroResult;
    return Result.ReturnValue;
  }
#ifndef MULTITHREAD
  Result	= * pResult;
#endif

  /* Copy out the pnBignum argument: */
  if ( ! ( 
       pResult->pnBignum.as_is_vector_t_len != 0 &&
       pnBignum == NULL ) ) {
    memcpy ( pnBignum,
             pResult->pnBignum.as_is_vector_t_val,
             MIN ( pResult->pnBignum.as_is_vector_t_len,
                   ((( AlignBitsToWords ( ABS ( nSizeInBits ) ) )*( sizeof(int) )) ) ) *
             SIZEOF ( *(pResult->pnBignum.as_is_vector_t_val) ) );
  }

  if ( pResult && pResult->nErrorLvl ) {
    /* Server returned a user error message: */
    char	szErrorMsg [ 1024 ];
    strncpy ( szErrorMsg,
              ( pResult->pszErrorMsg && pResult->pszErrorMsg [ 0 ] ) ?
              (LPCSTR) pResult->pszErrorMsg : (LPCSTR) szEmpty,
              sizeof ( szErrorMsg ) );
    szErrorMsg [ sizeof ( szErrorMsg ) - 1 ]	= (char) 0;
    xdr_free ( (xdrproc_t) xdr_fnServerObjectReadBignum_rets, (char *) pResult );
    RPC_CLIENT_SERROR ( pResult->nErrorLvl, __procedure__,
                        szErrorMsg );
  } else {
    xdr_free ( (xdrproc_t) xdr_fnServerObjectReadBignum_rets, (char *) pResult );
  }
  if ( 
       pResult->pnBignum.as_is_vector_t_len != 0 &&
       pnBignum == NULL ) {
    /* Error handling for passing a NULL pointer on */
    /* out argument: */
    char	szError [ 256 ];
    sprintf ( szError, szFormatNullPassed,
              __procedure__, "pnBignum" );
    RPC_CLIENT_CERROR ( szContNullOutPassed, szError );
  } else if ( pResult->pnBignum.as_is_vector_t_len > ((( AlignBitsToWords ( ABS ( nSizeInBits ) ) )*( sizeof(int) )) ) ) {
      /* Error handling for an output buffer overflow, */
      /* i.e. the buffer size passed is too small: */
      /* For example, signal a CERROR here ... */
      char	szError [ 256 ];
      sprintf ( szError, szFormatBufferOverflow,
                __procedure__, "pnBignum", 
                ((( AlignBitsToWords ( ABS ( nSizeInBits ) ) )*( sizeof(int) )) ), 
                pResult->pnBignum.as_is_vector_t_len );
      RPC_CLIENT_CERROR ( szContBufferOverflow, szError );
  }

  return Result.ReturnValue;

} /* fnServerObjectReadBignum */



SHLOCK DLLEXPORT fnServerObjectReadDoubleFloat
	(SHORTOBJID oShortObjIdHeap ,
	  SHORTOBJID oShortObjId ,
	  double * pfDoubleFloat)
{
  static const char	__procedure__[]	= "client:fnServerObjectReadDoubleFloat";
  static fnServerObjectReadDoubleFloat_rets	ZeroResult;
  fnServerObjectReadDoubleFloat_rets		* pResult = NULL;
  fnServerObjectReadDoubleFloat_rets		Result = ZeroResult;
  fnServerObjectReadDoubleFloat_args	InArguments;

  /* Client initialization: */
  if ( __bClientInitialize__ ) {
    __bClientInitialize__	= FALSE;
    RPC_CLIENT_INITIALIZE();
  }

#if	CLIENT_CREATE_BY_USER
  if ( __pClient__ == NULL ) {
    __pClient__	= RPC_CLIENT_CREATE ( __szHost__, __szTransport__ );
    if ( __pClient__ == NULL ) {
      /* Error handling for a not connected client: */
      char	szError [ 256 ];
      sprintf ( szError, szFormatNoServer, __procedure__ );
      RPC_CLIENT_ERROR ( szError );
      return Result.ReturnValue;
    }
  }
#else
  while ( __pClient__ == NULL ) {
    __pClient__	= RPC_CLIENT_CREATE ( __szHost__, __szTransport__ );
    if ( __pClient__ == NULL ) {
      /* Error handling for a not connected client: */
      char	szError [ 256 ];
      sprintf ( szError, szFormatNoServer, __procedure__ );
      RPC_CLIENT_CERROR ( szContNoServer, szError );
    }
  }
#endif	/* CLIENT_CREATE_BY_USER */

  /* Copy in the oShortObjIdHeap argument: */
  InArguments.oShortObjIdHeap	= oShortObjIdHeap;
  /* Copy in the oShortObjId argument: */
  InArguments.oShortObjId	= oShortObjId;

  pResult	=
#ifdef MULTITHREAD
    (
#else
    (fnServerObjectReadDoubleFloat_rets *)
#endif
    fnrpc_fnserverobjectreaddoublefloat_1 (
	&InArguments,
#ifdef MULTITHREAD
	&Result,
#endif
	__pClient__ )
#ifdef MULTITHREAD
	== RPC_SUCCESS ) ? &Result : NULL
#endif
	;

  if ( pResult == NULL ) {
    /* Error handling for a failed RPC call, */
    /* i.e. the server did not respond: */
    char	szError [ 256 ];
    sprintf ( szError, szFormatRpcFailed, __procedure__,
              clnt_sperror ( __pClient__, __szHost__ ) );
    __pClient__	= RPC_CLIENT_DESTROY ( __pClient__ );
    RPC_CLIENT_CERROR ( szContRpcFailed, szError );
    Result	= ZeroResult;
    return Result.ReturnValue;
  }
#ifndef MULTITHREAD
  Result	= * pResult;
#endif

  /* Copy out the pfDoubleFloat argument: */
  if ( ! ( 
       pfDoubleFloat == NULL ) ) {
    *pfDoubleFloat	= pResult->pfDoubleFloat;
  }

  if ( pResult && pResult->nErrorLvl ) {
    /* Server returned a user error message: */
    char	szErrorMsg [ 1024 ];
    strncpy ( szErrorMsg,
              ( pResult->pszErrorMsg && pResult->pszErrorMsg [ 0 ] ) ?
              (LPCSTR) pResult->pszErrorMsg : (LPCSTR) szEmpty,
              sizeof ( szErrorMsg ) );
    szErrorMsg [ sizeof ( szErrorMsg ) - 1 ]	= (char) 0;
    xdr_free ( (xdrproc_t) xdr_fnServerObjectReadDoubleFloat_rets, (char *) pResult );
    RPC_CLIENT_SERROR ( pResult->nErrorLvl, __procedure__,
                        szErrorMsg );
  } else {
    xdr_free ( (xdrproc_t) xdr_fnServerObjectReadDoubleFloat_rets, (char *) pResult );
  }
  if ( 
       pfDoubleFloat == NULL ) {
    /* Error handling for passing a NULL pointer on */
    /* out argument: */
    char	szError [ 256 ];
    sprintf ( szError, szFormatNullPassed,
              __procedure__, "pfDoubleFloat" );
    RPC_CLIENT_CERROR ( szContNullOutPassed, szError );
  }

  return Result.ReturnValue;

} /* fnServerObjectReadDoubleFloat */



SHLOCK DLLEXPORT fnServerObjectReadFixnum
	(SHORTOBJID oShortObjIdHeap ,
	  SHORTOBJID oShortObjId ,
	  SHORTOBJID oExpectingClass ,
	  SHTYPETAG nExpectingTypeTag ,
	  int nIndex ,
	  int * pnFixnum)
{
  static const char	__procedure__[]	= "client:fnServerObjectReadFixnum";
  static fnServerObjectReadFixnum_rets	ZeroResult;
  fnServerObjectReadFixnum_rets		* pResult = NULL;
  fnServerObjectReadFixnum_rets		Result = ZeroResult;
  fnServerObjectReadFixnum_args	InArguments;

  /* Client initialization: */
  if ( __bClientInitialize__ ) {
    __bClientInitialize__	= FALSE;
    RPC_CLIENT_INITIALIZE();
  }

#if	CLIENT_CREATE_BY_USER
  if ( __pClient__ == NULL ) {
    __pClient__	= RPC_CLIENT_CREATE ( __szHost__, __szTransport__ );
    if ( __pClient__ == NULL ) {
      /* Error handling for a not connected client: */
      char	szError [ 256 ];
      sprintf ( szError, szFormatNoServer, __procedure__ );
      RPC_CLIENT_ERROR ( szError );
      return Result.ReturnValue;
    }
  }
#else
  while ( __pClient__ == NULL ) {
    __pClient__	= RPC_CLIENT_CREATE ( __szHost__, __szTransport__ );
    if ( __pClient__ == NULL ) {
      /* Error handling for a not connected client: */
      char	szError [ 256 ];
      sprintf ( szError, szFormatNoServer, __procedure__ );
      RPC_CLIENT_CERROR ( szContNoServer, szError );
    }
  }
#endif	/* CLIENT_CREATE_BY_USER */

  /* Copy in the oShortObjIdHeap argument: */
  InArguments.oShortObjIdHeap	= oShortObjIdHeap;
  /* Copy in the oShortObjId argument: */
  InArguments.oShortObjId	= oShortObjId;
  /* Copy in the oExpectingClass argument: */
  InArguments.oExpectingClass	= oExpectingClass;
  /* Copy in the nExpectingTypeTag argument: */
  InArguments.nExpectingTypeTag	= nExpectingTypeTag;
  /* Copy in the nIndex argument: */
  InArguments.nIndex	= nIndex;

  pResult	=
#ifdef MULTITHREAD
    (
#else
    (fnServerObjectReadFixnum_rets *)
#endif
    fnrpc_fnserverobjectreadfixnum_1 (
	&InArguments,
#ifdef MULTITHREAD
	&Result,
#endif
	__pClient__ )
#ifdef MULTITHREAD
	== RPC_SUCCESS ) ? &Result : NULL
#endif
	;

  if ( pResult == NULL ) {
    /* Error handling for a failed RPC call, */
    /* i.e. the server did not respond: */
    char	szError [ 256 ];
    sprintf ( szError, szFormatRpcFailed, __procedure__,
              clnt_sperror ( __pClient__, __szHost__ ) );
    __pClient__	= RPC_CLIENT_DESTROY ( __pClient__ );
    RPC_CLIENT_CERROR ( szContRpcFailed, szError );
    Result	= ZeroResult;
    return Result.ReturnValue;
  }
#ifndef MULTITHREAD
  Result	= * pResult;
#endif

  /* Copy out the pnFixnum argument: */
  if ( ! ( 
       pnFixnum == NULL ) ) {
    *pnFixnum	= pResult->pnFixnum;
  }

  if ( pResult && pResult->nErrorLvl ) {
    /* Server returned a user error message: */
    char	szErrorMsg [ 1024 ];
    strncpy ( szErrorMsg,
              ( pResult->pszErrorMsg && pResult->pszErrorMsg [ 0 ] ) ?
              (LPCSTR) pResult->pszErrorMsg : (LPCSTR) szEmpty,
              sizeof ( szErrorMsg ) );
    szErrorMsg [ sizeof ( szErrorMsg ) - 1 ]	= (char) 0;
    xdr_free ( (xdrproc_t) xdr_fnServerObjectReadFixnum_rets, (char *) pResult );
    RPC_CLIENT_SERROR ( pResult->nErrorLvl, __procedure__,
                        szErrorMsg );
  } else {
    xdr_free ( (xdrproc_t) xdr_fnServerObjectReadFixnum_rets, (char *) pResult );
  }
  if ( 
       pnFixnum == NULL ) {
    /* Error handling for passing a NULL pointer on */
    /* out argument: */
    char	szError [ 256 ];
    sprintf ( szError, szFormatNullPassed,
              __procedure__, "pnFixnum" );
    RPC_CLIENT_CERROR ( szContNullOutPassed, szError );
  }

  return Result.ReturnValue;

} /* fnServerObjectReadFixnum */



SHLOCK DLLEXPORT fnServerObjectReadSingleFloat
	(SHORTOBJID oShortObjIdHeap ,
	  SHORTOBJID oShortObjId ,
	  float * pfSingleFloat)
{
  static const char	__procedure__[]	= "client:fnServerObjectReadSingleFloat";
  static fnServerObjectReadSingleFloat_rets	ZeroResult;
  fnServerObjectReadSingleFloat_rets		* pResult = NULL;
  fnServerObjectReadSingleFloat_rets		Result = ZeroResult;
  fnServerObjectReadSingleFloat_args	InArguments;

  /* Client initialization: */
  if ( __bClientInitialize__ ) {
    __bClientInitialize__	= FALSE;
    RPC_CLIENT_INITIALIZE();
  }

#if	CLIENT_CREATE_BY_USER
  if ( __pClient__ == NULL ) {
    __pClient__	= RPC_CLIENT_CREATE ( __szHost__, __szTransport__ );
    if ( __pClient__ == NULL ) {
      /* Error handling for a not connected client: */
      char	szError [ 256 ];
      sprintf ( szError, szFormatNoServer, __procedure__ );
      RPC_CLIENT_ERROR ( szError );
      return Result.ReturnValue;
    }
  }
#else
  while ( __pClient__ == NULL ) {
    __pClient__	= RPC_CLIENT_CREATE ( __szHost__, __szTransport__ );
    if ( __pClient__ == NULL ) {
      /* Error handling for a not connected client: */
      char	szError [ 256 ];
      sprintf ( szError, szFormatNoServer, __procedure__ );
      RPC_CLIENT_CERROR ( szContNoServer, szError );
    }
  }
#endif	/* CLIENT_CREATE_BY_USER */

  /* Copy in the oShortObjIdHeap argument: */
  InArguments.oShortObjIdHeap	= oShortObjIdHeap;
  /* Copy in the oShortObjId argument: */
  InArguments.oShortObjId	= oShortObjId;

  pResult	=
#ifdef MULTITHREAD
    (
#else
    (fnServerObjectReadSingleFloat_rets *)
#endif
    fnrpc_fnserverobjectreadsinglefloat_1 (
	&InArguments,
#ifdef MULTITHREAD
	&Result,
#endif
	__pClient__ )
#ifdef MULTITHREAD
	== RPC_SUCCESS ) ? &Result : NULL
#endif
	;

  if ( pResult == NULL ) {
    /* Error handling for a failed RPC call, */
    /* i.e. the server did not respond: */
    char	szError [ 256 ];
    sprintf ( szError, szFormatRpcFailed, __procedure__,
              clnt_sperror ( __pClient__, __szHost__ ) );
    __pClient__	= RPC_CLIENT_DESTROY ( __pClient__ );
    RPC_CLIENT_CERROR ( szContRpcFailed, szError );
    Result	= ZeroResult;
    return Result.ReturnValue;
  }
#ifndef MULTITHREAD
  Result	= * pResult;
#endif

  /* Copy out the pfSingleFloat argument: */
  if ( ! ( 
       pfSingleFloat == NULL ) ) {
    *pfSingleFloat	= pResult->pfSingleFloat;
  }

  if ( pResult && pResult->nErrorLvl ) {
    /* Server returned a user error message: */
    char	szErrorMsg [ 1024 ];
    strncpy ( szErrorMsg,
              ( pResult->pszErrorMsg && pResult->pszErrorMsg [ 0 ] ) ?
              (LPCSTR) pResult->pszErrorMsg : (LPCSTR) szEmpty,
              sizeof ( szErrorMsg ) );
    szErrorMsg [ sizeof ( szErrorMsg ) - 1 ]	= (char) 0;
    xdr_free ( (xdrproc_t) xdr_fnServerObjectReadSingleFloat_rets, (char *) pResult );
    RPC_CLIENT_SERROR ( pResult->nErrorLvl, __procedure__,
                        szErrorMsg );
  } else {
    xdr_free ( (xdrproc_t) xdr_fnServerObjectReadSingleFloat_rets, (char *) pResult );
  }
  if ( 
       pfSingleFloat == NULL ) {
    /* Error handling for passing a NULL pointer on */
    /* out argument: */
    char	szError [ 256 ];
    sprintf ( szError, szFormatNullPassed,
              __procedure__, "pfSingleFloat" );
    RPC_CLIENT_CERROR ( szContNullOutPassed, szError );
  }

  return Result.ReturnValue;

} /* fnServerObjectReadSingleFloat */



SHLOCK DLLEXPORT fnServerObjectWriteBignum
	(SHORTOBJID oShortObjIdHeap ,
	  SHORTOBJID oShortObjIdFormat ,
	  SHORTOBJID oShortObjId ,
	  int nSizeInBits ,
	  as_is * /* _vector_t<((( AlignBitsToWords ( ABS ( nSizeInBits ) ) )*( sizeof(int) )) )> */ pnBignum)
{
  static const char	__procedure__[]	= "client:fnServerObjectWriteBignum";
  static fnServerObjectWriteBignum_rets	ZeroResult;
  fnServerObjectWriteBignum_rets		* pResult = NULL;
  fnServerObjectWriteBignum_rets		Result = ZeroResult;
  fnServerObjectWriteBignum_args	InArguments;

  /* Client initialization: */
  if ( __bClientInitialize__ ) {
    __bClientInitialize__	= FALSE;
    RPC_CLIENT_INITIALIZE();
  }

#if	CLIENT_CREATE_BY_USER
  if ( __pClient__ == NULL ) {
    __pClient__	= RPC_CLIENT_CREATE ( __szHost__, __szTransport__ );
    if ( __pClient__ == NULL ) {
      /* Error handling for a not connected client: */
      char	szError [ 256 ];
      sprintf ( szError, szFormatNoServer, __procedure__ );
      RPC_CLIENT_ERROR ( szError );
      return Result.ReturnValue;
    }
  }
#else
  while ( __pClient__ == NULL ) {
    __pClient__	= RPC_CLIENT_CREATE ( __szHost__, __szTransport__ );
    if ( __pClient__ == NULL ) {
      /* Error handling for a not connected client: */
      char	szError [ 256 ];
      sprintf ( szError, szFormatNoServer, __procedure__ );
      RPC_CLIENT_CERROR ( szContNoServer, szError );
    }
  }
#endif	/* CLIENT_CREATE_BY_USER */

  /* Copy in the oShortObjIdHeap argument: */
  InArguments.oShortObjIdHeap	= oShortObjIdHeap;
  /* Copy in the oShortObjIdFormat argument: */
  InArguments.oShortObjIdFormat	= oShortObjIdFormat;
  /* Copy in the oShortObjId argument: */
  InArguments.oShortObjId	= oShortObjId;
  /* Copy in the nSizeInBits argument: */
  InArguments.nSizeInBits	= nSizeInBits;
  /* Copy in the pnBignum argument: */
  InArguments.pnBignum.as_is_vector_t_len	= ((( AlignBitsToWords ( ABS ( nSizeInBits ) ) )*( sizeof(int) )) );
  InArguments.pnBignum.as_is_vector_t_val	= pnBignum;
  if ( InArguments.pnBignum.as_is_vector_t_len != 0 && pnBignum == NULL ) {
    /* Error handling for passing a NULL pointer on */
    /* VECTOR declared in argument: */
    char	szError [ 256 ];
    InArguments.pnBignum.as_is_vector_t_len	= 0;
    sprintf ( szError, szFormatNullPassed,
              __procedure__, "pnBignum" );
    RPC_CLIENT_CERROR ( szContNullPassed, szError );
  }

  pResult	=
#ifdef MULTITHREAD
    (
#else
    (fnServerObjectWriteBignum_rets *)
#endif
    fnrpc_fnserverobjectwritebignum_1 (
	&InArguments,
#ifdef MULTITHREAD
	&Result,
#endif
	__pClient__ )
#ifdef MULTITHREAD
	== RPC_SUCCESS ) ? &Result : NULL
#endif
	;

  if ( pResult == NULL ) {
    /* Error handling for a failed RPC call, */
    /* i.e. the server did not respond: */
    char	szError [ 256 ];
    sprintf ( szError, szFormatRpcFailed, __procedure__,
              clnt_sperror ( __pClient__, __szHost__ ) );
    __pClient__	= RPC_CLIENT_DESTROY ( __pClient__ );
    RPC_CLIENT_CERROR ( szContRpcFailed, szError );
    Result	= ZeroResult;
    return Result.ReturnValue;
  }
#ifndef MULTITHREAD
  Result	= * pResult;
#endif


  if ( pResult && pResult->nErrorLvl ) {
    /* Server returned a user error message: */
    char	szErrorMsg [ 1024 ];
    strncpy ( szErrorMsg,
              ( pResult->pszErrorMsg && pResult->pszErrorMsg [ 0 ] ) ?
              (LPCSTR) pResult->pszErrorMsg : (LPCSTR) szEmpty,
              sizeof ( szErrorMsg ) );
    szErrorMsg [ sizeof ( szErrorMsg ) - 1 ]	= (char) 0;
    xdr_free ( (xdrproc_t) xdr_fnServerObjectWriteBignum_rets, (char *) pResult );
    RPC_CLIENT_SERROR ( pResult->nErrorLvl, __procedure__,
                        szErrorMsg );
  } else {
    xdr_free ( (xdrproc_t) xdr_fnServerObjectWriteBignum_rets, (char *) pResult );
  }

  return Result.ReturnValue;

} /* fnServerObjectWriteBignum */



SHLOCK DLLEXPORT fnServerObjectWriteDoubleFloat
	(SHORTOBJID oShortObjIdHeap ,
	  SHORTOBJID oShortObjId ,
	  double fDoubleFloat)
{
  static const char	__procedure__[]	= "client:fnServerObjectWriteDoubleFloat";
  static fnServerObjectWriteDoubleFloat_rets	ZeroResult;
  fnServerObjectWriteDoubleFloat_rets		* pResult = NULL;
  fnServerObjectWriteDoubleFloat_rets		Result = ZeroResult;
  fnServerObjectWriteDoubleFloat_args	InArguments;

  /* Client initialization: */
  if ( __bClientInitialize__ ) {
    __bClientInitialize__	= FALSE;
    RPC_CLIENT_INITIALIZE();
  }

#if	CLIENT_CREATE_BY_USER
  if ( __pClient__ == NULL ) {
    __pClient__	= RPC_CLIENT_CREATE ( __szHost__, __szTransport__ );
    if ( __pClient__ == NULL ) {
      /* Error handling for a not connected client: */
      char	szError [ 256 ];
      sprintf ( szError, szFormatNoServer, __procedure__ );
      RPC_CLIENT_ERROR ( szError );
      return Result.ReturnValue;
    }
  }
#else
  while ( __pClient__ == NULL ) {
    __pClient__	= RPC_CLIENT_CREATE ( __szHost__, __szTransport__ );
    if ( __pClient__ == NULL ) {
      /* Error handling for a not connected client: */
      char	szError [ 256 ];
      sprintf ( szError, szFormatNoServer, __procedure__ );
      RPC_CLIENT_CERROR ( szContNoServer, szError );
    }
  }
#endif	/* CLIENT_CREATE_BY_USER */

  /* Copy in the oShortObjIdHeap argument: */
  InArguments.oShortObjIdHeap	= oShortObjIdHeap;
  /* Copy in the oShortObjId argument: */
  InArguments.oShortObjId	= oShortObjId;
  /* Copy in the fDoubleFloat argument: */
  InArguments.fDoubleFloat	= fDoubleFloat;

  pResult	=
#ifdef MULTITHREAD
    (
#else
    (fnServerObjectWriteDoubleFloat_rets *)
#endif
    fnrpc_fnserverobjectwritedoublefloat_1 (
	&InArguments,
#ifdef MULTITHREAD
	&Result,
#endif
	__pClient__ )
#ifdef MULTITHREAD
	== RPC_SUCCESS ) ? &Result : NULL
#endif
	;

  if ( pResult == NULL ) {
    /* Error handling for a failed RPC call, */
    /* i.e. the server did not respond: */
    char	szError [ 256 ];
    sprintf ( szError, szFormatRpcFailed, __procedure__,
              clnt_sperror ( __pClient__, __szHost__ ) );
    __pClient__	= RPC_CLIENT_DESTROY ( __pClient__ );
    RPC_CLIENT_CERROR ( szContRpcFailed, szError );
    Result	= ZeroResult;
    return Result.ReturnValue;
  }
#ifndef MULTITHREAD
  Result	= * pResult;
#endif


  if ( pResult && pResult->nErrorLvl ) {
    /* Server returned a user error message: */
    char	szErrorMsg [ 1024 ];
    strncpy ( szErrorMsg,
              ( pResult->pszErrorMsg && pResult->pszErrorMsg [ 0 ] ) ?
              (LPCSTR) pResult->pszErrorMsg : (LPCSTR) szEmpty,
              sizeof ( szErrorMsg ) );
    szErrorMsg [ sizeof ( szErrorMsg ) - 1 ]	= (char) 0;
    xdr_free ( (xdrproc_t) xdr_fnServerObjectWriteDoubleFloat_rets, (char *) pResult );
    RPC_CLIENT_SERROR ( pResult->nErrorLvl, __procedure__,
                        szErrorMsg );
  } else {
    xdr_free ( (xdrproc_t) xdr_fnServerObjectWriteDoubleFloat_rets, (char *) pResult );
  }

  return Result.ReturnValue;

} /* fnServerObjectWriteDoubleFloat */



SHLOCK DLLEXPORT fnServerObjectWriteFixnum
	(SHORTOBJID oShortObjIdHeap ,
	  SHORTOBJID oShortObjId ,
	  SHORTOBJID oExpectingClass ,
	  SHTYPETAG nExpectingTypeTag ,
	  int nIndex ,
	  int nFixnumWrite)
{
  static const char	__procedure__[]	= "client:fnServerObjectWriteFixnum";
  static fnServerObjectWriteFixnum_rets	ZeroResult;
  fnServerObjectWriteFixnum_rets		* pResult = NULL;
  fnServerObjectWriteFixnum_rets		Result = ZeroResult;
  fnServerObjectWriteFixnum_args	InArguments;

  /* Client initialization: */
  if ( __bClientInitialize__ ) {
    __bClientInitialize__	= FALSE;
    RPC_CLIENT_INITIALIZE();
  }

#if	CLIENT_CREATE_BY_USER
  if ( __pClient__ == NULL ) {
    __pClient__	= RPC_CLIENT_CREATE ( __szHost__, __szTransport__ );
    if ( __pClient__ == NULL ) {
      /* Error handling for a not connected client: */
      char	szError [ 256 ];
      sprintf ( szError, szFormatNoServer, __procedure__ );
      RPC_CLIENT_ERROR ( szError );
      return Result.ReturnValue;
    }
  }
#else
  while ( __pClient__ == NULL ) {
    __pClient__	= RPC_CLIENT_CREATE ( __szHost__, __szTransport__ );
    if ( __pClient__ == NULL ) {
      /* Error handling for a not connected client: */
      char	szError [ 256 ];
      sprintf ( szError, szFormatNoServer, __procedure__ );
      RPC_CLIENT_CERROR ( szContNoServer, szError );
    }
  }
#endif	/* CLIENT_CREATE_BY_USER */

  /* Copy in the oShortObjIdHeap argument: */
  InArguments.oShortObjIdHeap	= oShortObjIdHeap;
  /* Copy in the oShortObjId argument: */
  InArguments.oShortObjId	= oShortObjId;
  /* Copy in the oExpectingClass argument: */
  InArguments.oExpectingClass	= oExpectingClass;
  /* Copy in the nExpectingTypeTag argument: */
  InArguments.nExpectingTypeTag	= nExpectingTypeTag;
  /* Copy in the nIndex argument: */
  InArguments.nIndex	= nIndex;
  /* Copy in the nFixnumWrite argument: */
  InArguments.nFixnumWrite	= nFixnumWrite;

  pResult	=
#ifdef MULTITHREAD
    (
#else
    (fnServerObjectWriteFixnum_rets *)
#endif
    fnrpc_fnserverobjectwritefixnum_1 (
	&InArguments,
#ifdef MULTITHREAD
	&Result,
#endif
	__pClient__ )
#ifdef MULTITHREAD
	== RPC_SUCCESS ) ? &Result : NULL
#endif
	;

  if ( pResult == NULL ) {
    /* Error handling for a failed RPC call, */
    /* i.e. the server did not respond: */
    char	szError [ 256 ];
    sprintf ( szError, szFormatRpcFailed, __procedure__,
              clnt_sperror ( __pClient__, __szHost__ ) );
    __pClient__	= RPC_CLIENT_DESTROY ( __pClient__ );
    RPC_CLIENT_CERROR ( szContRpcFailed, szError );
    Result	= ZeroResult;
    return Result.ReturnValue;
  }
#ifndef MULTITHREAD
  Result	= * pResult;
#endif


  if ( pResult && pResult->nErrorLvl ) {
    /* Server returned a user error message: */
    char	szErrorMsg [ 1024 ];
    strncpy ( szErrorMsg,
              ( pResult->pszErrorMsg && pResult->pszErrorMsg [ 0 ] ) ?
              (LPCSTR) pResult->pszErrorMsg : (LPCSTR) szEmpty,
              sizeof ( szErrorMsg ) );
    szErrorMsg [ sizeof ( szErrorMsg ) - 1 ]	= (char) 0;
    xdr_free ( (xdrproc_t) xdr_fnServerObjectWriteFixnum_rets, (char *) pResult );
    RPC_CLIENT_SERROR ( pResult->nErrorLvl, __procedure__,
                        szErrorMsg );
  } else {
    xdr_free ( (xdrproc_t) xdr_fnServerObjectWriteFixnum_rets, (char *) pResult );
  }

  return Result.ReturnValue;

} /* fnServerObjectWriteFixnum */



SHLOCK DLLEXPORT fnServerObjectWriteSingleFloat
	(SHORTOBJID oShortObjIdHeap ,
	  SHORTOBJID oShortObjId ,
	  float fSingleFloat)
{
  static const char	__procedure__[]	= "client:fnServerObjectWriteSingleFloat";
  static fnServerObjectWriteSingleFloat_rets	ZeroResult;
  fnServerObjectWriteSingleFloat_rets		* pResult = NULL;
  fnServerObjectWriteSingleFloat_rets		Result = ZeroResult;
  fnServerObjectWriteSingleFloat_args	InArguments;

  /* Client initialization: */
  if ( __bClientInitialize__ ) {
    __bClientInitialize__	= FALSE;
    RPC_CLIENT_INITIALIZE();
  }

#if	CLIENT_CREATE_BY_USER
  if ( __pClient__ == NULL ) {
    __pClient__	= RPC_CLIENT_CREATE ( __szHost__, __szTransport__ );
    if ( __pClient__ == NULL ) {
      /* Error handling for a not connected client: */
      char	szError [ 256 ];
      sprintf ( szError, szFormatNoServer, __procedure__ );
      RPC_CLIENT_ERROR ( szError );
      return Result.ReturnValue;
    }
  }
#else
  while ( __pClient__ == NULL ) {
    __pClient__	= RPC_CLIENT_CREATE ( __szHost__, __szTransport__ );
    if ( __pClient__ == NULL ) {
      /* Error handling for a not connected client: */
      char	szError [ 256 ];
      sprintf ( szError, szFormatNoServer, __procedure__ );
      RPC_CLIENT_CERROR ( szContNoServer, szError );
    }
  }
#endif	/* CLIENT_CREATE_BY_USER */

  /* Copy in the oShortObjIdHeap argument: */
  InArguments.oShortObjIdHeap	= oShortObjIdHeap;
  /* Copy in the oShortObjId argument: */
  InArguments.oShortObjId	= oShortObjId;
  /* Copy in the fSingleFloat argument: */
  InArguments.fSingleFloat	= fSingleFloat;

  pResult	=
#ifdef MULTITHREAD
    (
#else
    (fnServerObjectWriteSingleFloat_rets *)
#endif
    fnrpc_fnserverobjectwritesinglefloat_1 (
	&InArguments,
#ifdef MULTITHREAD
	&Result,
#endif
	__pClient__ )
#ifdef MULTITHREAD
	== RPC_SUCCESS ) ? &Result : NULL
#endif
	;

  if ( pResult == NULL ) {
    /* Error handling for a failed RPC call, */
    /* i.e. the server did not respond: */
    char	szError [ 256 ];
    sprintf ( szError, szFormatRpcFailed, __procedure__,
              clnt_sperror ( __pClient__, __szHost__ ) );
    __pClient__	= RPC_CLIENT_DESTROY ( __pClient__ );
    RPC_CLIENT_CERROR ( szContRpcFailed, szError );
    Result	= ZeroResult;
    return Result.ReturnValue;
  }
#ifndef MULTITHREAD
  Result	= * pResult;
#endif


  if ( pResult && pResult->nErrorLvl ) {
    /* Server returned a user error message: */
    char	szErrorMsg [ 1024 ];
    strncpy ( szErrorMsg,
              ( pResult->pszErrorMsg && pResult->pszErrorMsg [ 0 ] ) ?
              (LPCSTR) pResult->pszErrorMsg : (LPCSTR) szEmpty,
              sizeof ( szErrorMsg ) );
    szErrorMsg [ sizeof ( szErrorMsg ) - 1 ]	= (char) 0;
    xdr_free ( (xdrproc_t) xdr_fnServerObjectWriteSingleFloat_rets, (char *) pResult );
    RPC_CLIENT_SERROR ( pResult->nErrorLvl, __procedure__,
                        szErrorMsg );
  } else {
    xdr_free ( (xdrproc_t) xdr_fnServerObjectWriteSingleFloat_rets, (char *) pResult );
  }

  return Result.ReturnValue;

} /* fnServerObjectWriteSingleFloat */



int DLLEXPORT fnClientLockPrint
	(SHORTOBJID oShortObjIdHeap ,
	  SHORTOBJID oShortSelf ,
	  SHLOCK nLevel ,
	  NUMERICSTDSTREAM nStdStream)
{
  static const char	__procedure__[]	= "client:fnClientLockPrint";
  static fnClientLockPrint_rets	ZeroResult;
  fnClientLockPrint_rets		* pResult = NULL;
  fnClientLockPrint_rets		Result = ZeroResult;
  fnClientLockPrint_args	InArguments;

  /* Client initialization: */
  if ( __bClientInitialize__ ) {
    __bClientInitialize__	= FALSE;
    RPC_CLIENT_INITIALIZE();
  }

#if	CLIENT_CREATE_BY_USER
  if ( __pClient__ == NULL ) {
    __pClient__	= RPC_CLIENT_CREATE ( __szHost__, __szTransport__ );
    if ( __pClient__ == NULL ) {
      /* Error handling for a not connected client: */
      char	szError [ 256 ];
      sprintf ( szError, szFormatNoServer, __procedure__ );
      RPC_CLIENT_ERROR ( szError );
      return Result.ReturnValue;
    }
  }
#else
  while ( __pClient__ == NULL ) {
    __pClient__	= RPC_CLIENT_CREATE ( __szHost__, __szTransport__ );
    if ( __pClient__ == NULL ) {
      /* Error handling for a not connected client: */
      char	szError [ 256 ];
      sprintf ( szError, szFormatNoServer, __procedure__ );
      RPC_CLIENT_CERROR ( szContNoServer, szError );
    }
  }
#endif	/* CLIENT_CREATE_BY_USER */

  /* Copy in the oShortObjIdHeap argument: */
  InArguments.oShortObjIdHeap	= oShortObjIdHeap;
  /* Copy in the oShortSelf argument: */
  InArguments.oShortSelf	= oShortSelf;
  /* Copy in the nLevel argument: */
  InArguments.nLevel	= nLevel;
  /* Copy in the nStdStream argument: */
  InArguments.nStdStream	= nStdStream;

  pResult	=
#ifdef MULTITHREAD
    (
#else
    (fnClientLockPrint_rets *)
#endif
    fnrpc_fnclientlockprint_1 (
	&InArguments,
#ifdef MULTITHREAD
	&Result,
#endif
	__pClient__ )
#ifdef MULTITHREAD
	== RPC_SUCCESS ) ? &Result : NULL
#endif
	;

  if ( pResult == NULL ) {
    /* Error handling for a failed RPC call, */
    /* i.e. the server did not respond: */
    char	szError [ 256 ];
    sprintf ( szError, szFormatRpcFailed, __procedure__,
              clnt_sperror ( __pClient__, __szHost__ ) );
    __pClient__	= RPC_CLIENT_DESTROY ( __pClient__ );
    RPC_CLIENT_CERROR ( szContRpcFailed, szError );
    Result	= ZeroResult;
    return Result.ReturnValue;
  }
#ifndef MULTITHREAD
  Result	= * pResult;
#endif


  if ( pResult && pResult->nErrorLvl ) {
    /* Server returned a user error message: */
    char	szErrorMsg [ 1024 ];
    strncpy ( szErrorMsg,
              ( pResult->pszErrorMsg && pResult->pszErrorMsg [ 0 ] ) ?
              (LPCSTR) pResult->pszErrorMsg : (LPCSTR) szEmpty,
              sizeof ( szErrorMsg ) );
    szErrorMsg [ sizeof ( szErrorMsg ) - 1 ]	= (char) 0;
    xdr_free ( (xdrproc_t) xdr_fnClientLockPrint_rets, (char *) pResult );
    RPC_CLIENT_SERROR ( pResult->nErrorLvl, __procedure__,
                        szErrorMsg );
  } else {
    xdr_free ( (xdrproc_t) xdr_fnClientLockPrint_rets, (char *) pResult );
  }

  return Result.ReturnValue;

} /* fnClientLockPrint */



SHLOCK DLLEXPORT fnClientTransactionLockGet
	(SHORTOBJID oShortObjIdHeap ,
	  SHORTOBJID oShortObjIdLockedByP ,
	  SHLOCK nLevelP ,
	  SHORTOBJID oShortLockedP ,
	  SHTYPETAG nTypeTagLockedP ,
	  int nIndexP)
{
  static const char	__procedure__[]	= "client:fnClientTransactionLockGet";
  static fnClientTransactionLockGet_rets	ZeroResult;
  fnClientTransactionLockGet_rets		* pResult = NULL;
  fnClientTransactionLockGet_rets		Result = ZeroResult;
  fnClientTransactionLockGet_args	InArguments;

  /* Client initialization: */
  if ( __bClientInitialize__ ) {
    __bClientInitialize__	= FALSE;
    RPC_CLIENT_INITIALIZE();
  }

#if	CLIENT_CREATE_BY_USER
  if ( __pClient__ == NULL ) {
    __pClient__	= RPC_CLIENT_CREATE ( __szHost__, __szTransport__ );
    if ( __pClient__ == NULL ) {
      /* Error handling for a not connected client: */
      char	szError [ 256 ];
      sprintf ( szError, szFormatNoServer, __procedure__ );
      RPC_CLIENT_ERROR ( szError );
      return Result.ReturnValue;
    }
  }
#else
  while ( __pClient__ == NULL ) {
    __pClient__	= RPC_CLIENT_CREATE ( __szHost__, __szTransport__ );
    if ( __pClient__ == NULL ) {
      /* Error handling for a not connected client: */
      char	szError [ 256 ];
      sprintf ( szError, szFormatNoServer, __procedure__ );
      RPC_CLIENT_CERROR ( szContNoServer, szError );
    }
  }
#endif	/* CLIENT_CREATE_BY_USER */

  /* Copy in the oShortObjIdHeap argument: */
  InArguments.oShortObjIdHeap	= oShortObjIdHeap;
  /* Copy in the oShortObjIdLockedByP argument: */
  InArguments.oShortObjIdLockedByP	= oShortObjIdLockedByP;
  /* Copy in the nLevelP argument: */
  InArguments.nLevelP	= nLevelP;
  /* Copy in the oShortLockedP argument: */
  InArguments.oShortLockedP	= oShortLockedP;
  /* Copy in the nTypeTagLockedP argument: */
  InArguments.nTypeTagLockedP	= nTypeTagLockedP;
  /* Copy in the nIndexP argument: */
  InArguments.nIndexP	= nIndexP;

  pResult	=
#ifdef MULTITHREAD
    (
#else
    (fnClientTransactionLockGet_rets *)
#endif
    fnrpc_fnclienttransactionlockget_1 (
	&InArguments,
#ifdef MULTITHREAD
	&Result,
#endif
	__pClient__ )
#ifdef MULTITHREAD
	== RPC_SUCCESS ) ? &Result : NULL
#endif
	;

  if ( pResult == NULL ) {
    /* Error handling for a failed RPC call, */
    /* i.e. the server did not respond: */
    char	szError [ 256 ];
    sprintf ( szError, szFormatRpcFailed, __procedure__,
              clnt_sperror ( __pClient__, __szHost__ ) );
    __pClient__	= RPC_CLIENT_DESTROY ( __pClient__ );
    RPC_CLIENT_CERROR ( szContRpcFailed, szError );
    Result	= ZeroResult;
    return Result.ReturnValue;
  }
#ifndef MULTITHREAD
  Result	= * pResult;
#endif


  if ( pResult && pResult->nErrorLvl ) {
    /* Server returned a user error message: */
    char	szErrorMsg [ 1024 ];
    strncpy ( szErrorMsg,
              ( pResult->pszErrorMsg && pResult->pszErrorMsg [ 0 ] ) ?
              (LPCSTR) pResult->pszErrorMsg : (LPCSTR) szEmpty,
              sizeof ( szErrorMsg ) );
    szErrorMsg [ sizeof ( szErrorMsg ) - 1 ]	= (char) 0;
    xdr_free ( (xdrproc_t) xdr_fnClientTransactionLockGet_rets, (char *) pResult );
    RPC_CLIENT_SERROR ( pResult->nErrorLvl, __procedure__,
                        szErrorMsg );
  } else {
    xdr_free ( (xdrproc_t) xdr_fnClientTransactionLockGet_rets, (char *) pResult );
  }

  return Result.ReturnValue;

} /* fnClientTransactionLockGet */



SHLOCK DLLEXPORT fnServerTransactionLockInsert
	(SHORTOBJID oShortObjIdHeap ,
	  SHORTOBJID oShortObjIdLockBy ,
	  SHLOCK nLock ,
	  SHORTOBJID oShortToLock ,
	  SHTYPETAG nTypeTagToLock ,
	  int nIndex ,
	  int * phPeek ,
	  int * pnObjIdWords)
{
  static const char	__procedure__[]	= "client:fnServerTransactionLockInsert";
  static fnServerTransactionLockInsert_rets	ZeroResult;
  fnServerTransactionLockInsert_rets		* pResult = NULL;
  fnServerTransactionLockInsert_rets		Result = ZeroResult;
  fnServerTransactionLockInsert_args	InArguments;

  /* Client initialization: */
  if ( __bClientInitialize__ ) {
    __bClientInitialize__	= FALSE;
    RPC_CLIENT_INITIALIZE();
  }

#if	CLIENT_CREATE_BY_USER
  if ( __pClient__ == NULL ) {
    __pClient__	= RPC_CLIENT_CREATE ( __szHost__, __szTransport__ );
    if ( __pClient__ == NULL ) {
      /* Error handling for a not connected client: */
      char	szError [ 256 ];
      sprintf ( szError, szFormatNoServer, __procedure__ );
      RPC_CLIENT_ERROR ( szError );
      return Result.ReturnValue;
    }
  }
#else
  while ( __pClient__ == NULL ) {
    __pClient__	= RPC_CLIENT_CREATE ( __szHost__, __szTransport__ );
    if ( __pClient__ == NULL ) {
      /* Error handling for a not connected client: */
      char	szError [ 256 ];
      sprintf ( szError, szFormatNoServer, __procedure__ );
      RPC_CLIENT_CERROR ( szContNoServer, szError );
    }
  }
#endif	/* CLIENT_CREATE_BY_USER */

  /* Copy in the oShortObjIdHeap argument: */
  InArguments.oShortObjIdHeap	= oShortObjIdHeap;
  /* Copy in the oShortObjIdLockBy argument: */
  InArguments.oShortObjIdLockBy	= oShortObjIdLockBy;
  /* Copy in the nLock argument: */
  InArguments.nLock	= nLock;
  /* Copy in the oShortToLock argument: */
  InArguments.oShortToLock	= oShortToLock;
  /* Copy in the nTypeTagToLock argument: */
  InArguments.nTypeTagToLock	= nTypeTagToLock;
  /* Copy in the nIndex argument: */
  InArguments.nIndex	= nIndex;

  pResult	=
#ifdef MULTITHREAD
    (
#else
    (fnServerTransactionLockInsert_rets *)
#endif
    fnrpc_fnservertransactionlockinsert_1 (
	&InArguments,
#ifdef MULTITHREAD
	&Result,
#endif
	__pClient__ )
#ifdef MULTITHREAD
	== RPC_SUCCESS ) ? &Result : NULL
#endif
	;

  if ( pResult == NULL ) {
    /* Error handling for a failed RPC call, */
    /* i.e. the server did not respond: */
    char	szError [ 256 ];
    sprintf ( szError, szFormatRpcFailed, __procedure__,
              clnt_sperror ( __pClient__, __szHost__ ) );
    __pClient__	= RPC_CLIENT_DESTROY ( __pClient__ );
    RPC_CLIENT_CERROR ( szContRpcFailed, szError );
    Result	= ZeroResult;
    return Result.ReturnValue;
  }
#ifndef MULTITHREAD
  Result	= * pResult;
#endif

  /* Copy out the phPeek argument: */
  if ( ! ( 
       phPeek == NULL ) ) {
    *phPeek	= pResult->phPeek;
  }
  /* Copy out the pnObjIdWords argument: */
  if ( ! ( 
       pnObjIdWords == NULL ) ) {
    *pnObjIdWords	= pResult->pnObjIdWords;
  }

  if ( pResult && pResult->nErrorLvl ) {
    /* Server returned a user error message: */
    char	szErrorMsg [ 1024 ];
    strncpy ( szErrorMsg,
              ( pResult->pszErrorMsg && pResult->pszErrorMsg [ 0 ] ) ?
              (LPCSTR) pResult->pszErrorMsg : (LPCSTR) szEmpty,
              sizeof ( szErrorMsg ) );
    szErrorMsg [ sizeof ( szErrorMsg ) - 1 ]	= (char) 0;
    xdr_free ( (xdrproc_t) xdr_fnServerTransactionLockInsert_rets, (char *) pResult );
    RPC_CLIENT_SERROR ( pResult->nErrorLvl, __procedure__,
                        szErrorMsg );
  } else {
    xdr_free ( (xdrproc_t) xdr_fnServerTransactionLockInsert_rets, (char *) pResult );
  }
  if ( 
       phPeek == NULL ) {
    /* Error handling for passing a NULL pointer on */
    /* out argument: */
    char	szError [ 256 ];
    sprintf ( szError, szFormatNullPassed,
              __procedure__, "phPeek" );
    RPC_CLIENT_CERROR ( szContNullOutPassed, szError );
  }
  if ( 
       pnObjIdWords == NULL ) {
    /* Error handling for passing a NULL pointer on */
    /* out argument: */
    char	szError [ 256 ];
    sprintf ( szError, szFormatNullPassed,
              __procedure__, "pnObjIdWords" );
    RPC_CLIENT_CERROR ( szContNullOutPassed, szError );
  }

  return Result.ReturnValue;

} /* fnServerTransactionLockInsert */



SHLOCK DLLEXPORT fnServerTransactionLockSet
	(SHORTOBJID oShortObjIdHeap ,
	  SHORTOBJID oShortObjIdLockBy ,
	  SHLOCK nLock ,
	  SHORTOBJID oShortToLock ,
	  SHTYPETAG nTypeTagToLock ,
	  int nIndex ,
	  int * phPeek ,
	  int * pnObjIdWords)
{
  static const char	__procedure__[]	= "client:fnServerTransactionLockSet";
  static fnServerTransactionLockSet_rets	ZeroResult;
  fnServerTransactionLockSet_rets		* pResult = NULL;
  fnServerTransactionLockSet_rets		Result = ZeroResult;
  fnServerTransactionLockSet_args	InArguments;

  /* Client initialization: */
  if ( __bClientInitialize__ ) {
    __bClientInitialize__	= FALSE;
    RPC_CLIENT_INITIALIZE();
  }

#if	CLIENT_CREATE_BY_USER
  if ( __pClient__ == NULL ) {
    __pClient__	= RPC_CLIENT_CREATE ( __szHost__, __szTransport__ );
    if ( __pClient__ == NULL ) {
      /* Error handling for a not connected client: */
      char	szError [ 256 ];
      sprintf ( szError, szFormatNoServer, __procedure__ );
      RPC_CLIENT_ERROR ( szError );
      return Result.ReturnValue;
    }
  }
#else
  while ( __pClient__ == NULL ) {
    __pClient__	= RPC_CLIENT_CREATE ( __szHost__, __szTransport__ );
    if ( __pClient__ == NULL ) {
      /* Error handling for a not connected client: */
      char	szError [ 256 ];
      sprintf ( szError, szFormatNoServer, __procedure__ );
      RPC_CLIENT_CERROR ( szContNoServer, szError );
    }
  }
#endif	/* CLIENT_CREATE_BY_USER */

  /* Copy in the oShortObjIdHeap argument: */
  InArguments.oShortObjIdHeap	= oShortObjIdHeap;
  /* Copy in the oShortObjIdLockBy argument: */
  InArguments.oShortObjIdLockBy	= oShortObjIdLockBy;
  /* Copy in the nLock argument: */
  InArguments.nLock	= nLock;
  /* Copy in the oShortToLock argument: */
  InArguments.oShortToLock	= oShortToLock;
  /* Copy in the nTypeTagToLock argument: */
  InArguments.nTypeTagToLock	= nTypeTagToLock;
  /* Copy in the nIndex argument: */
  InArguments.nIndex	= nIndex;

  pResult	=
#ifdef MULTITHREAD
    (
#else
    (fnServerTransactionLockSet_rets *)
#endif
    fnrpc_fnservertransactionlockset_1 (
	&InArguments,
#ifdef MULTITHREAD
	&Result,
#endif
	__pClient__ )
#ifdef MULTITHREAD
	== RPC_SUCCESS ) ? &Result : NULL
#endif
	;

  if ( pResult == NULL ) {
    /* Error handling for a failed RPC call, */
    /* i.e. the server did not respond: */
    char	szError [ 256 ];
    sprintf ( szError, szFormatRpcFailed, __procedure__,
              clnt_sperror ( __pClient__, __szHost__ ) );
    __pClient__	= RPC_CLIENT_DESTROY ( __pClient__ );
    RPC_CLIENT_CERROR ( szContRpcFailed, szError );
    Result	= ZeroResult;
    return Result.ReturnValue;
  }
#ifndef MULTITHREAD
  Result	= * pResult;
#endif

  /* Copy out the phPeek argument: */
  if ( ! ( 
       phPeek == NULL ) ) {
    *phPeek	= pResult->phPeek;
  }
  /* Copy out the pnObjIdWords argument: */
  if ( ! ( 
       pnObjIdWords == NULL ) ) {
    *pnObjIdWords	= pResult->pnObjIdWords;
  }

  if ( pResult && pResult->nErrorLvl ) {
    /* Server returned a user error message: */
    char	szErrorMsg [ 1024 ];
    strncpy ( szErrorMsg,
              ( pResult->pszErrorMsg && pResult->pszErrorMsg [ 0 ] ) ?
              (LPCSTR) pResult->pszErrorMsg : (LPCSTR) szEmpty,
              sizeof ( szErrorMsg ) );
    szErrorMsg [ sizeof ( szErrorMsg ) - 1 ]	= (char) 0;
    xdr_free ( (xdrproc_t) xdr_fnServerTransactionLockSet_rets, (char *) pResult );
    RPC_CLIENT_SERROR ( pResult->nErrorLvl, __procedure__,
                        szErrorMsg );
  } else {
    xdr_free ( (xdrproc_t) xdr_fnServerTransactionLockSet_rets, (char *) pResult );
  }
  if ( 
       phPeek == NULL ) {
    /* Error handling for passing a NULL pointer on */
    /* out argument: */
    char	szError [ 256 ];
    sprintf ( szError, szFormatNullPassed,
              __procedure__, "phPeek" );
    RPC_CLIENT_CERROR ( szContNullOutPassed, szError );
  }
  if ( 
       pnObjIdWords == NULL ) {
    /* Error handling for passing a NULL pointer on */
    /* out argument: */
    char	szError [ 256 ];
    sprintf ( szError, szFormatNullPassed,
              __procedure__, "pnObjIdWords" );
    RPC_CLIENT_CERROR ( szContNullOutPassed, szError );
  }

  return Result.ReturnValue;

} /* fnServerTransactionLockSet */



SHLOCK DLLEXPORT fnServerTransactionUnlock
	(SHORTOBJID oShortObjIdHeap ,
	  SHORTOBJID oShortObjIdLockedBy ,
	  SHLOCK nLock ,
	  SHORTOBJID oShortToUnlock ,
	  int nIndex ,
	  SHLOCK * pnVectorLockNow)
{
  static const char	__procedure__[]	= "client:fnServerTransactionUnlock";
  static fnServerTransactionUnlock_rets	ZeroResult;
  fnServerTransactionUnlock_rets		* pResult = NULL;
  fnServerTransactionUnlock_rets		Result = ZeroResult;
  fnServerTransactionUnlock_args	InArguments;

  /* Client initialization: */
  if ( __bClientInitialize__ ) {
    __bClientInitialize__	= FALSE;
    RPC_CLIENT_INITIALIZE();
  }

#if	CLIENT_CREATE_BY_USER
  if ( __pClient__ == NULL ) {
    __pClient__	= RPC_CLIENT_CREATE ( __szHost__, __szTransport__ );
    if ( __pClient__ == NULL ) {
      /* Error handling for a not connected client: */
      char	szError [ 256 ];
      sprintf ( szError, szFormatNoServer, __procedure__ );
      RPC_CLIENT_ERROR ( szError );
      return Result.ReturnValue;
    }
  }
#else
  while ( __pClient__ == NULL ) {
    __pClient__	= RPC_CLIENT_CREATE ( __szHost__, __szTransport__ );
    if ( __pClient__ == NULL ) {
      /* Error handling for a not connected client: */
      char	szError [ 256 ];
      sprintf ( szError, szFormatNoServer, __procedure__ );
      RPC_CLIENT_CERROR ( szContNoServer, szError );
    }
  }
#endif	/* CLIENT_CREATE_BY_USER */

  /* Copy in the oShortObjIdHeap argument: */
  InArguments.oShortObjIdHeap	= oShortObjIdHeap;
  /* Copy in the oShortObjIdLockedBy argument: */
  InArguments.oShortObjIdLockedBy	= oShortObjIdLockedBy;
  /* Copy in the nLock argument: */
  InArguments.nLock	= nLock;
  /* Copy in the oShortToUnlock argument: */
  InArguments.oShortToUnlock	= oShortToUnlock;
  /* Copy in the nIndex argument: */
  InArguments.nIndex	= nIndex;

  pResult	=
#ifdef MULTITHREAD
    (
#else
    (fnServerTransactionUnlock_rets *)
#endif
    fnrpc_fnservertransactionunlock_1 (
	&InArguments,
#ifdef MULTITHREAD
	&Result,
#endif
	__pClient__ )
#ifdef MULTITHREAD
	== RPC_SUCCESS ) ? &Result : NULL
#endif
	;

  if ( pResult == NULL ) {
    /* Error handling for a failed RPC call, */
    /* i.e. the server did not respond: */
    char	szError [ 256 ];
    sprintf ( szError, szFormatRpcFailed, __procedure__,
              clnt_sperror ( __pClient__, __szHost__ ) );
    __pClient__	= RPC_CLIENT_DESTROY ( __pClient__ );
    RPC_CLIENT_CERROR ( szContRpcFailed, szError );
    Result	= ZeroResult;
    return Result.ReturnValue;
  }
#ifndef MULTITHREAD
  Result	= * pResult;
#endif

  /* Copy out the pnVectorLockNow argument: */
  if ( ! ( 
       pnVectorLockNow == NULL ) ) {
    *pnVectorLockNow	= pResult->pnVectorLockNow;
  }

  if ( pResult && pResult->nErrorLvl ) {
    /* Server returned a user error message: */
    char	szErrorMsg [ 1024 ];
    strncpy ( szErrorMsg,
              ( pResult->pszErrorMsg && pResult->pszErrorMsg [ 0 ] ) ?
              (LPCSTR) pResult->pszErrorMsg : (LPCSTR) szEmpty,
              sizeof ( szErrorMsg ) );
    szErrorMsg [ sizeof ( szErrorMsg ) - 1 ]	= (char) 0;
    xdr_free ( (xdrproc_t) xdr_fnServerTransactionUnlock_rets, (char *) pResult );
    RPC_CLIENT_SERROR ( pResult->nErrorLvl, __procedure__,
                        szErrorMsg );
  } else {
    xdr_free ( (xdrproc_t) xdr_fnServerTransactionUnlock_rets, (char *) pResult );
  }
  if ( 
       pnVectorLockNow == NULL ) {
    /* Error handling for passing a NULL pointer on */
    /* out argument: */
    char	szError [ 256 ];
    sprintf ( szError, szFormatNullPassed,
              __procedure__, "pnVectorLockNow" );
    RPC_CLIENT_CERROR ( szContNullOutPassed, szError );
  }

  return Result.ReturnValue;

} /* fnServerTransactionUnlock */



int DLLEXPORT fnServerTransactionUnlockAll
	(SHORTOBJID oShortObjIdHeap ,
	  SHORTOBJID oShortObjIdLockedBy ,
	  SHORTOBJID oShortToUnlock)
{
  static const char	__procedure__[]	= "client:fnServerTransactionUnlockAll";
  static fnServerTransactionUnlockAll_rets	ZeroResult;
  fnServerTransactionUnlockAll_rets		* pResult = NULL;
  fnServerTransactionUnlockAll_rets		Result = ZeroResult;
  fnServerTransactionUnlockAll_args	InArguments;

  /* Client initialization: */
  if ( __bClientInitialize__ ) {
    __bClientInitialize__	= FALSE;
    RPC_CLIENT_INITIALIZE();
  }

#if	CLIENT_CREATE_BY_USER
  if ( __pClient__ == NULL ) {
    __pClient__	= RPC_CLIENT_CREATE ( __szHost__, __szTransport__ );
    if ( __pClient__ == NULL ) {
      /* Error handling for a not connected client: */
      char	szError [ 256 ];
      sprintf ( szError, szFormatNoServer, __procedure__ );
      RPC_CLIENT_ERROR ( szError );
      return Result.ReturnValue;
    }
  }
#else
  while ( __pClient__ == NULL ) {
    __pClient__	= RPC_CLIENT_CREATE ( __szHost__, __szTransport__ );
    if ( __pClient__ == NULL ) {
      /* Error handling for a not connected client: */
      char	szError [ 256 ];
      sprintf ( szError, szFormatNoServer, __procedure__ );
      RPC_CLIENT_CERROR ( szContNoServer, szError );
    }
  }
#endif	/* CLIENT_CREATE_BY_USER */

  /* Copy in the oShortObjIdHeap argument: */
  InArguments.oShortObjIdHeap	= oShortObjIdHeap;
  /* Copy in the oShortObjIdLockedBy argument: */
  InArguments.oShortObjIdLockedBy	= oShortObjIdLockedBy;
  /* Copy in the oShortToUnlock argument: */
  InArguments.oShortToUnlock	= oShortToUnlock;

  pResult	=
#ifdef MULTITHREAD
    (
#else
    (fnServerTransactionUnlockAll_rets *)
#endif
    fnrpc_fnservertransactionunlockall_1 (
	&InArguments,
#ifdef MULTITHREAD
	&Result,
#endif
	__pClient__ )
#ifdef MULTITHREAD
	== RPC_SUCCESS ) ? &Result : NULL
#endif
	;

  if ( pResult == NULL ) {
    /* Error handling for a failed RPC call, */
    /* i.e. the server did not respond: */
    char	szError [ 256 ];
    sprintf ( szError, szFormatRpcFailed, __procedure__,
              clnt_sperror ( __pClient__, __szHost__ ) );
    __pClient__	= RPC_CLIENT_DESTROY ( __pClient__ );
    RPC_CLIENT_CERROR ( szContRpcFailed, szError );
    Result	= ZeroResult;
    return Result.ReturnValue;
  }
#ifndef MULTITHREAD
  Result	= * pResult;
#endif


  if ( pResult && pResult->nErrorLvl ) {
    /* Server returned a user error message: */
    char	szErrorMsg [ 1024 ];
    strncpy ( szErrorMsg,
              ( pResult->pszErrorMsg && pResult->pszErrorMsg [ 0 ] ) ?
              (LPCSTR) pResult->pszErrorMsg : (LPCSTR) szEmpty,
              sizeof ( szErrorMsg ) );
    szErrorMsg [ sizeof ( szErrorMsg ) - 1 ]	= (char) 0;
    xdr_free ( (xdrproc_t) xdr_fnServerTransactionUnlockAll_rets, (char *) pResult );
    RPC_CLIENT_SERROR ( pResult->nErrorLvl, __procedure__,
                        szErrorMsg );
  } else {
    xdr_free ( (xdrproc_t) xdr_fnServerTransactionUnlockAll_rets, (char *) pResult );
  }

  return Result.ReturnValue;

} /* fnServerTransactionUnlockAll */



int DLLEXPORT fnServerTransactionUnlockAllAll
	(SHORTOBJID oShortObjIdHeap ,
	  SHORTOBJID oShortObjIdLockedBy)
{
  static const char	__procedure__[]	= "client:fnServerTransactionUnlockAllAll";
  static fnServerTransactionUnlockAllAll_rets	ZeroResult;
  fnServerTransactionUnlockAllAll_rets		* pResult = NULL;
  fnServerTransactionUnlockAllAll_rets		Result = ZeroResult;
  fnServerTransactionUnlockAllAll_args	InArguments;

  /* Client initialization: */
  if ( __bClientInitialize__ ) {
    __bClientInitialize__	= FALSE;
    RPC_CLIENT_INITIALIZE();
  }

#if	CLIENT_CREATE_BY_USER
  if ( __pClient__ == NULL ) {
    __pClient__	= RPC_CLIENT_CREATE ( __szHost__, __szTransport__ );
    if ( __pClient__ == NULL ) {
      /* Error handling for a not connected client: */
      char	szError [ 256 ];
      sprintf ( szError, szFormatNoServer, __procedure__ );
      RPC_CLIENT_ERROR ( szError );
      return Result.ReturnValue;
    }
  }
#else
  while ( __pClient__ == NULL ) {
    __pClient__	= RPC_CLIENT_CREATE ( __szHost__, __szTransport__ );
    if ( __pClient__ == NULL ) {
      /* Error handling for a not connected client: */
      char	szError [ 256 ];
      sprintf ( szError, szFormatNoServer, __procedure__ );
      RPC_CLIENT_CERROR ( szContNoServer, szError );
    }
  }
#endif	/* CLIENT_CREATE_BY_USER */

  /* Copy in the oShortObjIdHeap argument: */
  InArguments.oShortObjIdHeap	= oShortObjIdHeap;
  /* Copy in the oShortObjIdLockedBy argument: */
  InArguments.oShortObjIdLockedBy	= oShortObjIdLockedBy;

  pResult	=
#ifdef MULTITHREAD
    (
#else
    (fnServerTransactionUnlockAllAll_rets *)
#endif
    fnrpc_fnservertransactionunlockallall_1 (
	&InArguments,
#ifdef MULTITHREAD
	&Result,
#endif
	__pClient__ )
#ifdef MULTITHREAD
	== RPC_SUCCESS ) ? &Result : NULL
#endif
	;

  if ( pResult == NULL ) {
    /* Error handling for a failed RPC call, */
    /* i.e. the server did not respond: */
    char	szError [ 256 ];
    sprintf ( szError, szFormatRpcFailed, __procedure__,
              clnt_sperror ( __pClient__, __szHost__ ) );
    __pClient__	= RPC_CLIENT_DESTROY ( __pClient__ );
    RPC_CLIENT_CERROR ( szContRpcFailed, szError );
    Result	= ZeroResult;
    return Result.ReturnValue;
  }
#ifndef MULTITHREAD
  Result	= * pResult;
#endif


  if ( pResult && pResult->nErrorLvl ) {
    /* Server returned a user error message: */
    char	szErrorMsg [ 1024 ];
    strncpy ( szErrorMsg,
              ( pResult->pszErrorMsg && pResult->pszErrorMsg [ 0 ] ) ?
              (LPCSTR) pResult->pszErrorMsg : (LPCSTR) szEmpty,
              sizeof ( szErrorMsg ) );
    szErrorMsg [ sizeof ( szErrorMsg ) - 1 ]	= (char) 0;
    xdr_free ( (xdrproc_t) xdr_fnServerTransactionUnlockAllAll_rets, (char *) pResult );
    RPC_CLIENT_SERROR ( pResult->nErrorLvl, __procedure__,
                        szErrorMsg );
  } else {
    xdr_free ( (xdrproc_t) xdr_fnServerTransactionUnlockAllAll_rets, (char *) pResult );
  }

  return Result.ReturnValue;

} /* fnServerTransactionUnlockAllAll */



bool_t DLLEXPORT fnShortMakeReadOnly
	(SHORTOBJID oShortObjIdHeap ,
	  SHORTOBJID oShortSelf ,
	  READONLYMODE nReadOnlyP)
{
  static const char	__procedure__[]	= "client:fnShortMakeReadOnly";
  static fnShortMakeReadOnly_rets	ZeroResult;
  fnShortMakeReadOnly_rets		* pResult = NULL;
  fnShortMakeReadOnly_rets		Result = ZeroResult;
  fnShortMakeReadOnly_args	InArguments;

  /* Client initialization: */
  if ( __bClientInitialize__ ) {
    __bClientInitialize__	= FALSE;
    RPC_CLIENT_INITIALIZE();
  }

#if	CLIENT_CREATE_BY_USER
  if ( __pClient__ == NULL ) {
    __pClient__	= RPC_CLIENT_CREATE ( __szHost__, __szTransport__ );
    if ( __pClient__ == NULL ) {
      /* Error handling for a not connected client: */
      char	szError [ 256 ];
      sprintf ( szError, szFormatNoServer, __procedure__ );
      RPC_CLIENT_ERROR ( szError );
      return Result.ReturnValue;
    }
  }
#else
  while ( __pClient__ == NULL ) {
    __pClient__	= RPC_CLIENT_CREATE ( __szHost__, __szTransport__ );
    if ( __pClient__ == NULL ) {
      /* Error handling for a not connected client: */
      char	szError [ 256 ];
      sprintf ( szError, szFormatNoServer, __procedure__ );
      RPC_CLIENT_CERROR ( szContNoServer, szError );
    }
  }
#endif	/* CLIENT_CREATE_BY_USER */

  /* Copy in the oShortObjIdHeap argument: */
  InArguments.oShortObjIdHeap	= oShortObjIdHeap;
  /* Copy in the oShortSelf argument: */
  InArguments.oShortSelf	= oShortSelf;
  /* Copy in the nReadOnlyP argument: */
  InArguments.nReadOnlyP	= nReadOnlyP;

  pResult	=
#ifdef MULTITHREAD
    (
#else
    (fnShortMakeReadOnly_rets *)
#endif
    fnrpc_fnshortmakereadonly_1 (
	&InArguments,
#ifdef MULTITHREAD
	&Result,
#endif
	__pClient__ )
#ifdef MULTITHREAD
	== RPC_SUCCESS ) ? &Result : NULL
#endif
	;

  if ( pResult == NULL ) {
    /* Error handling for a failed RPC call, */
    /* i.e. the server did not respond: */
    char	szError [ 256 ];
    sprintf ( szError, szFormatRpcFailed, __procedure__,
              clnt_sperror ( __pClient__, __szHost__ ) );
    __pClient__	= RPC_CLIENT_DESTROY ( __pClient__ );
    RPC_CLIENT_CERROR ( szContRpcFailed, szError );
    Result	= ZeroResult;
    return Result.ReturnValue;
  }
#ifndef MULTITHREAD
  Result	= * pResult;
#endif


  if ( pResult && pResult->nErrorLvl ) {
    /* Server returned a user error message: */
    char	szErrorMsg [ 1024 ];
    strncpy ( szErrorMsg,
              ( pResult->pszErrorMsg && pResult->pszErrorMsg [ 0 ] ) ?
              (LPCSTR) pResult->pszErrorMsg : (LPCSTR) szEmpty,
              sizeof ( szErrorMsg ) );
    szErrorMsg [ sizeof ( szErrorMsg ) - 1 ]	= (char) 0;
    xdr_free ( (xdrproc_t) xdr_fnShortMakeReadOnly_rets, (char *) pResult );
    RPC_CLIENT_SERROR ( pResult->nErrorLvl, __procedure__,
                        szErrorMsg );
  } else {
    xdr_free ( (xdrproc_t) xdr_fnShortMakeReadOnly_rets, (char *) pResult );
  }

  return Result.ReturnValue;

} /* fnShortMakeReadOnly */



TRACTID DLLEXPORT fnServerTransactionBegin
	(SHORTOBJID oShortObjIdHeap ,
	  bool_t bIgnoreError)
{
  static const char	__procedure__[]	= "client:fnServerTransactionBegin";
  static fnServerTransactionBegin_rets	ZeroResult;
  fnServerTransactionBegin_rets		* pResult = NULL;
  fnServerTransactionBegin_rets		Result = ZeroResult;
  fnServerTransactionBegin_args	InArguments;

  /* Client initialization: */
  if ( __bClientInitialize__ ) {
    __bClientInitialize__	= FALSE;
    RPC_CLIENT_INITIALIZE();
  }

#if	CLIENT_CREATE_BY_USER
  if ( __pClient__ == NULL ) {
    __pClient__	= RPC_CLIENT_CREATE ( __szHost__, __szTransport__ );
    if ( __pClient__ == NULL ) {
      /* Error handling for a not connected client: */
      char	szError [ 256 ];
      sprintf ( szError, szFormatNoServer, __procedure__ );
      RPC_CLIENT_ERROR ( szError );
      return Result.ReturnValue;
    }
  }
#else
  while ( __pClient__ == NULL ) {
    __pClient__	= RPC_CLIENT_CREATE ( __szHost__, __szTransport__ );
    if ( __pClient__ == NULL ) {
      /* Error handling for a not connected client: */
      char	szError [ 256 ];
      sprintf ( szError, szFormatNoServer, __procedure__ );
      RPC_CLIENT_CERROR ( szContNoServer, szError );
    }
  }
#endif	/* CLIENT_CREATE_BY_USER */

  /* Copy in the oShortObjIdHeap argument: */
  InArguments.oShortObjIdHeap	= oShortObjIdHeap;
  /* Copy in the bIgnoreError argument: */
  InArguments.bIgnoreError	= bIgnoreError;

  pResult	=
#ifdef MULTITHREAD
    (
#else
    (fnServerTransactionBegin_rets *)
#endif
    fnrpc_fnservertransactionbegin_1 (
	&InArguments,
#ifdef MULTITHREAD
	&Result,
#endif
	__pClient__ )
#ifdef MULTITHREAD
	== RPC_SUCCESS ) ? &Result : NULL
#endif
	;

  if ( pResult == NULL ) {
    /* Error handling for a failed RPC call, */
    /* i.e. the server did not respond: */
    char	szError [ 256 ];
    sprintf ( szError, szFormatRpcFailed, __procedure__,
              clnt_sperror ( __pClient__, __szHost__ ) );
    __pClient__	= RPC_CLIENT_DESTROY ( __pClient__ );
    RPC_CLIENT_CERROR ( szContRpcFailed, szError );
    Result	= ZeroResult;
    return Result.ReturnValue;
  }
#ifndef MULTITHREAD
  Result	= * pResult;
#endif


  if ( pResult && pResult->nErrorLvl ) {
    /* Server returned a user error message: */
    char	szErrorMsg [ 1024 ];
    strncpy ( szErrorMsg,
              ( pResult->pszErrorMsg && pResult->pszErrorMsg [ 0 ] ) ?
              (LPCSTR) pResult->pszErrorMsg : (LPCSTR) szEmpty,
              sizeof ( szErrorMsg ) );
    szErrorMsg [ sizeof ( szErrorMsg ) - 1 ]	= (char) 0;
    xdr_free ( (xdrproc_t) xdr_fnServerTransactionBegin_rets, (char *) pResult );
    RPC_CLIENT_SERROR ( pResult->nErrorLvl, __procedure__,
                        szErrorMsg );
  } else {
    xdr_free ( (xdrproc_t) xdr_fnServerTransactionBegin_rets, (char *) pResult );
  }

  return Result.ReturnValue;

} /* fnServerTransactionBegin */



TRACTID DLLEXPORT fnServerTransactionCancel
	(SHORTOBJID oShortObjIdHeap ,
	  bool_t bIgnoreError)
{
  static const char	__procedure__[]	= "client:fnServerTransactionCancel";
  static fnServerTransactionCancel_rets	ZeroResult;
  fnServerTransactionCancel_rets		* pResult = NULL;
  fnServerTransactionCancel_rets		Result = ZeroResult;
  fnServerTransactionCancel_args	InArguments;

  /* Client initialization: */
  if ( __bClientInitialize__ ) {
    __bClientInitialize__	= FALSE;
    RPC_CLIENT_INITIALIZE();
  }

#if	CLIENT_CREATE_BY_USER
  if ( __pClient__ == NULL ) {
    __pClient__	= RPC_CLIENT_CREATE ( __szHost__, __szTransport__ );
    if ( __pClient__ == NULL ) {
      /* Error handling for a not connected client: */
      char	szError [ 256 ];
      sprintf ( szError, szFormatNoServer, __procedure__ );
      RPC_CLIENT_ERROR ( szError );
      return Result.ReturnValue;
    }
  }
#else
  while ( __pClient__ == NULL ) {
    __pClient__	= RPC_CLIENT_CREATE ( __szHost__, __szTransport__ );
    if ( __pClient__ == NULL ) {
      /* Error handling for a not connected client: */
      char	szError [ 256 ];
      sprintf ( szError, szFormatNoServer, __procedure__ );
      RPC_CLIENT_CERROR ( szContNoServer, szError );
    }
  }
#endif	/* CLIENT_CREATE_BY_USER */

  /* Copy in the oShortObjIdHeap argument: */
  InArguments.oShortObjIdHeap	= oShortObjIdHeap;
  /* Copy in the bIgnoreError argument: */
  InArguments.bIgnoreError	= bIgnoreError;

  pResult	=
#ifdef MULTITHREAD
    (
#else
    (fnServerTransactionCancel_rets *)
#endif
    fnrpc_fnservertransactioncancel_1 (
	&InArguments,
#ifdef MULTITHREAD
	&Result,
#endif
	__pClient__ )
#ifdef MULTITHREAD
	== RPC_SUCCESS ) ? &Result : NULL
#endif
	;

  if ( pResult == NULL ) {
    /* Error handling for a failed RPC call, */
    /* i.e. the server did not respond: */
    char	szError [ 256 ];
    sprintf ( szError, szFormatRpcFailed, __procedure__,
              clnt_sperror ( __pClient__, __szHost__ ) );
    __pClient__	= RPC_CLIENT_DESTROY ( __pClient__ );
    RPC_CLIENT_CERROR ( szContRpcFailed, szError );
    Result	= ZeroResult;
    return Result.ReturnValue;
  }
#ifndef MULTITHREAD
  Result	= * pResult;
#endif


  if ( pResult && pResult->nErrorLvl ) {
    /* Server returned a user error message: */
    char	szErrorMsg [ 1024 ];
    strncpy ( szErrorMsg,
              ( pResult->pszErrorMsg && pResult->pszErrorMsg [ 0 ] ) ?
              (LPCSTR) pResult->pszErrorMsg : (LPCSTR) szEmpty,
              sizeof ( szErrorMsg ) );
    szErrorMsg [ sizeof ( szErrorMsg ) - 1 ]	= (char) 0;
    xdr_free ( (xdrproc_t) xdr_fnServerTransactionCancel_rets, (char *) pResult );
    RPC_CLIENT_SERROR ( pResult->nErrorLvl, __procedure__,
                        szErrorMsg );
  } else {
    xdr_free ( (xdrproc_t) xdr_fnServerTransactionCancel_rets, (char *) pResult );
  }

  return Result.ReturnValue;

} /* fnServerTransactionCancel */



TRACTID DLLEXPORT fnServerTransactionEnd
	(SHORTOBJID oShortObjIdHeap ,
	  bool_t bIgnoreError)
{
  static const char	__procedure__[]	= "client:fnServerTransactionEnd";
  static fnServerTransactionEnd_rets	ZeroResult;
  fnServerTransactionEnd_rets		* pResult = NULL;
  fnServerTransactionEnd_rets		Result = ZeroResult;
  fnServerTransactionEnd_args	InArguments;

  /* Client initialization: */
  if ( __bClientInitialize__ ) {
    __bClientInitialize__	= FALSE;
    RPC_CLIENT_INITIALIZE();
  }

#if	CLIENT_CREATE_BY_USER
  if ( __pClient__ == NULL ) {
    __pClient__	= RPC_CLIENT_CREATE ( __szHost__, __szTransport__ );
    if ( __pClient__ == NULL ) {
      /* Error handling for a not connected client: */
      char	szError [ 256 ];
      sprintf ( szError, szFormatNoServer, __procedure__ );
      RPC_CLIENT_ERROR ( szError );
      return Result.ReturnValue;
    }
  }
#else
  while ( __pClient__ == NULL ) {
    __pClient__	= RPC_CLIENT_CREATE ( __szHost__, __szTransport__ );
    if ( __pClient__ == NULL ) {
      /* Error handling for a not connected client: */
      char	szError [ 256 ];
      sprintf ( szError, szFormatNoServer, __procedure__ );
      RPC_CLIENT_CERROR ( szContNoServer, szError );
    }
  }
#endif	/* CLIENT_CREATE_BY_USER */

  /* Copy in the oShortObjIdHeap argument: */
  InArguments.oShortObjIdHeap	= oShortObjIdHeap;
  /* Copy in the bIgnoreError argument: */
  InArguments.bIgnoreError	= bIgnoreError;

  pResult	=
#ifdef MULTITHREAD
    (
#else
    (fnServerTransactionEnd_rets *)
#endif
    fnrpc_fnservertransactionend_1 (
	&InArguments,
#ifdef MULTITHREAD
	&Result,
#endif
	__pClient__ )
#ifdef MULTITHREAD
	== RPC_SUCCESS ) ? &Result : NULL
#endif
	;

  if ( pResult == NULL ) {
    /* Error handling for a failed RPC call, */
    /* i.e. the server did not respond: */
    char	szError [ 256 ];
    sprintf ( szError, szFormatRpcFailed, __procedure__,
              clnt_sperror ( __pClient__, __szHost__ ) );
    __pClient__	= RPC_CLIENT_DESTROY ( __pClient__ );
    RPC_CLIENT_CERROR ( szContRpcFailed, szError );
    Result	= ZeroResult;
    return Result.ReturnValue;
  }
#ifndef MULTITHREAD
  Result	= * pResult;
#endif


  if ( pResult && pResult->nErrorLvl ) {
    /* Server returned a user error message: */
    char	szErrorMsg [ 1024 ];
    strncpy ( szErrorMsg,
              ( pResult->pszErrorMsg && pResult->pszErrorMsg [ 0 ] ) ?
              (LPCSTR) pResult->pszErrorMsg : (LPCSTR) szEmpty,
              sizeof ( szErrorMsg ) );
    szErrorMsg [ sizeof ( szErrorMsg ) - 1 ]	= (char) 0;
    xdr_free ( (xdrproc_t) xdr_fnServerTransactionEnd_rets, (char *) pResult );
    RPC_CLIENT_SERROR ( pResult->nErrorLvl, __procedure__,
                        szErrorMsg );
  } else {
    xdr_free ( (xdrproc_t) xdr_fnServerTransactionEnd_rets, (char *) pResult );
  }

  return Result.ReturnValue;

} /* fnServerTransactionEnd */



void DLLEXPORT fnServerTransactionFlush
	(SHORTOBJID oShortObjIdHeap)
{
  static const char	__procedure__[]	= "client:fnServerTransactionFlush";
  static char	ZeroResult;
  void		* pResult = NULL;
#ifdef MULTITHREAD
  char		Result = ZeroResult;
#endif

  /* Client initialization: */
  if ( __bClientInitialize__ ) {
    __bClientInitialize__	= FALSE;
    RPC_CLIENT_INITIALIZE();
  }

#if	CLIENT_CREATE_BY_USER
  if ( __pClient__ == NULL ) {
    __pClient__	= RPC_CLIENT_CREATE ( __szHost__, __szTransport__ );
    if ( __pClient__ == NULL ) {
      /* Error handling for a not connected client: */
      char	szError [ 256 ];
      sprintf ( szError, szFormatNoServer, __procedure__ );
      RPC_CLIENT_ERROR ( szError );
      return;
    }
  }
#else
  while ( __pClient__ == NULL ) {
    __pClient__	= RPC_CLIENT_CREATE ( __szHost__, __szTransport__ );
    if ( __pClient__ == NULL ) {
      /* Error handling for a not connected client: */
      char	szError [ 256 ];
      sprintf ( szError, szFormatNoServer, __procedure__ );
      RPC_CLIENT_CERROR ( szContNoServer, szError );
    }
  }
#endif	/* CLIENT_CREATE_BY_USER */

  pResult	=
#ifdef MULTITHREAD
    (
#else
    (void *)
#endif
    fnrpc_fnservertransactionflush_batch_1 (
	&oShortObjIdHeap,
#ifdef MULTITHREAD
	&Result,
#endif
	__pClient__ )
#ifdef MULTITHREAD
	== RPC_SUCCESS ) ? &Result : NULL
#endif
	;

  if ( pResult == NULL ) {
    /* Error handling for a failed RPC call, */
    /* i.e. the server did not respond: */
    char	szError [ 256 ];
    sprintf ( szError, szFormatRpcFailed, __procedure__,
              clnt_sperror ( __pClient__, __szHost__ ) );
    __pClient__	= RPC_CLIENT_DESTROY ( __pClient__ );
    RPC_CLIENT_CERROR ( szContRpcFailed, szError );
    return;
  }
} /* fnServerTransactionFlush */

#ifdef MULTITHREAD
enum clnt_stat
#else
void *
#endif
fnrpc_fnservertransactionflush_batch_1
	( SHORTOBJID * pArguments,
#ifdef MULTITHREAD
	  void * clnt_res,
#endif
	  PCLIENT pClient )
{
#ifdef MULTITHREAD
  return clnt_call ( pClient, fnRpc_fnServerTransactionFlush_batch,
                     (xdrproc_t) xdr_SHORTOBJID,
                     (caddr_t) pArguments,
                     (xdrproc_t) NULL, (caddr_t) NULL,
                     NullTimeout );
#else
  if ( clnt_call ( pClient, fnRpc_fnServerTransactionFlush_batch,
                   (xdrproc_t) xdr_SHORTOBJID,
                   (caddr_t) pArguments,
                   (xdrproc_t) NULL, (caddr_t) NULL,
                   NullTimeout ) != RPC_SUCCESS ) {
    return NULL;
  }
  return (void *) TRUE;
#endif
} /* fnrpc_fnservertransactionflush_batch_1 */
#define	fnrpc_fnservertransactionflush_batch_1	fnrpc_fnservertransactionflush_1



TRACTID DLLEXPORT fnServerDbTransactionP
	(SHORTOBJID oShortObjIdHeap ,
	  TRACTID nTractId)
{
  static const char	__procedure__[]	= "client:fnServerDbTransactionP";
  static fnServerDbTransactionP_rets	ZeroResult;
  fnServerDbTransactionP_rets		* pResult = NULL;
  fnServerDbTransactionP_rets		Result = ZeroResult;
  fnServerDbTransactionP_args	InArguments;

  /* Client initialization: */
  if ( __bClientInitialize__ ) {
    __bClientInitialize__	= FALSE;
    RPC_CLIENT_INITIALIZE();
  }

#if	CLIENT_CREATE_BY_USER
  if ( __pClient__ == NULL ) {
    __pClient__	= RPC_CLIENT_CREATE ( __szHost__, __szTransport__ );
    if ( __pClient__ == NULL ) {
      /* Error handling for a not connected client: */
      char	szError [ 256 ];
      sprintf ( szError, szFormatNoServer, __procedure__ );
      RPC_CLIENT_ERROR ( szError );
      return Result.ReturnValue;
    }
  }
#else
  while ( __pClient__ == NULL ) {
    __pClient__	= RPC_CLIENT_CREATE ( __szHost__, __szTransport__ );
    if ( __pClient__ == NULL ) {
      /* Error handling for a not connected client: */
      char	szError [ 256 ];
      sprintf ( szError, szFormatNoServer, __procedure__ );
      RPC_CLIENT_CERROR ( szContNoServer, szError );
    }
  }
#endif	/* CLIENT_CREATE_BY_USER */

  /* Copy in the oShortObjIdHeap argument: */
  InArguments.oShortObjIdHeap	= oShortObjIdHeap;
  /* Copy in the nTractId argument: */
  InArguments.nTractId	= nTractId;

  pResult	=
#ifdef MULTITHREAD
    (
#else
    (fnServerDbTransactionP_rets *)
#endif
    fnrpc_fnserverdbtransactionp_1 (
	&InArguments,
#ifdef MULTITHREAD
	&Result,
#endif
	__pClient__ )
#ifdef MULTITHREAD
	== RPC_SUCCESS ) ? &Result : NULL
#endif
	;

  if ( pResult == NULL ) {
    /* Error handling for a failed RPC call, */
    /* i.e. the server did not respond: */
    char	szError [ 256 ];
    sprintf ( szError, szFormatRpcFailed, __procedure__,
              clnt_sperror ( __pClient__, __szHost__ ) );
    __pClient__	= RPC_CLIENT_DESTROY ( __pClient__ );
    RPC_CLIENT_CERROR ( szContRpcFailed, szError );
    Result	= ZeroResult;
    return Result.ReturnValue;
  }
#ifndef MULTITHREAD
  Result	= * pResult;
#endif


  if ( pResult && pResult->nErrorLvl ) {
    /* Server returned a user error message: */
    char	szErrorMsg [ 1024 ];
    strncpy ( szErrorMsg,
              ( pResult->pszErrorMsg && pResult->pszErrorMsg [ 0 ] ) ?
              (LPCSTR) pResult->pszErrorMsg : (LPCSTR) szEmpty,
              sizeof ( szErrorMsg ) );
    szErrorMsg [ sizeof ( szErrorMsg ) - 1 ]	= (char) 0;
    xdr_free ( (xdrproc_t) xdr_fnServerDbTransactionP_rets, (char *) pResult );
    RPC_CLIENT_SERROR ( pResult->nErrorLvl, __procedure__,
                        szErrorMsg );
  } else {
    xdr_free ( (xdrproc_t) xdr_fnServerDbTransactionP_rets, (char *) pResult );
  }

  return Result.ReturnValue;

} /* fnServerDbTransactionP */



BTREERESULT DLLEXPORT fnClientBtreeClear
	(SHORTOBJID oShortObjIdHeap ,
	  SHORTOBJID oShortObjIdBTree)
{
  static const char	__procedure__[]	= "client:fnClientBtreeClear";
  static fnClientBtreeClear_rets	ZeroResult;
  fnClientBtreeClear_rets		* pResult = NULL;
  fnClientBtreeClear_rets		Result = ZeroResult;
  fnClientBtreeClear_args	InArguments;

  /* Client initialization: */
  if ( __bClientInitialize__ ) {
    __bClientInitialize__	= FALSE;
    RPC_CLIENT_INITIALIZE();
  }

#if	CLIENT_CREATE_BY_USER
  if ( __pClient__ == NULL ) {
    __pClient__	= RPC_CLIENT_CREATE ( __szHost__, __szTransport__ );
    if ( __pClient__ == NULL ) {
      /* Error handling for a not connected client: */
      char	szError [ 256 ];
      sprintf ( szError, szFormatNoServer, __procedure__ );
      RPC_CLIENT_ERROR ( szError );
      return Result.ReturnValue;
    }
  }
#else
  while ( __pClient__ == NULL ) {
    __pClient__	= RPC_CLIENT_CREATE ( __szHost__, __szTransport__ );
    if ( __pClient__ == NULL ) {
      /* Error handling for a not connected client: */
      char	szError [ 256 ];
      sprintf ( szError, szFormatNoServer, __procedure__ );
      RPC_CLIENT_CERROR ( szContNoServer, szError );
    }
  }
#endif	/* CLIENT_CREATE_BY_USER */

  /* Copy in the oShortObjIdHeap argument: */
  InArguments.oShortObjIdHeap	= oShortObjIdHeap;
  /* Copy in the oShortObjIdBTree argument: */
  InArguments.oShortObjIdBTree	= oShortObjIdBTree;

  pResult	=
#ifdef MULTITHREAD
    (
#else
    (fnClientBtreeClear_rets *)
#endif
    fnrpc_fnclientbtreeclear_1 (
	&InArguments,
#ifdef MULTITHREAD
	&Result,
#endif
	__pClient__ )
#ifdef MULTITHREAD
	== RPC_SUCCESS ) ? &Result : NULL
#endif
	;

  if ( pResult == NULL ) {
    /* Error handling for a failed RPC call, */
    /* i.e. the server did not respond: */
    char	szError [ 256 ];
    sprintf ( szError, szFormatRpcFailed, __procedure__,
              clnt_sperror ( __pClient__, __szHost__ ) );
    __pClient__	= RPC_CLIENT_DESTROY ( __pClient__ );
    RPC_CLIENT_CERROR ( szContRpcFailed, szError );
    Result	= ZeroResult;
    return Result.ReturnValue;
  }
#ifndef MULTITHREAD
  Result	= * pResult;
#endif


  if ( pResult && pResult->nErrorLvl ) {
    /* Server returned a user error message: */
    char	szErrorMsg [ 1024 ];
    strncpy ( szErrorMsg,
              ( pResult->pszErrorMsg && pResult->pszErrorMsg [ 0 ] ) ?
              (LPCSTR) pResult->pszErrorMsg : (LPCSTR) szEmpty,
              sizeof ( szErrorMsg ) );
    szErrorMsg [ sizeof ( szErrorMsg ) - 1 ]	= (char) 0;
    xdr_free ( (xdrproc_t) xdr_fnClientBtreeClear_rets, (char *) pResult );
    RPC_CLIENT_SERROR ( pResult->nErrorLvl, __procedure__,
                        szErrorMsg );
  } else {
    xdr_free ( (xdrproc_t) xdr_fnClientBtreeClear_rets, (char *) pResult );
  }

  return Result.ReturnValue;

} /* fnClientBtreeClear */



int DLLEXPORT fnClientBtreeCount
	(SHORTOBJID oShortObjIdHeap ,
	  SHORTOBJID oShortObjIdBTree)
{
  static const char	__procedure__[]	= "client:fnClientBtreeCount";
  static fnClientBtreeCount_rets	ZeroResult;
  fnClientBtreeCount_rets		* pResult = NULL;
  fnClientBtreeCount_rets		Result = ZeroResult;
  fnClientBtreeCount_args	InArguments;

  /* Client initialization: */
  if ( __bClientInitialize__ ) {
    __bClientInitialize__	= FALSE;
    RPC_CLIENT_INITIALIZE();
  }

#if	CLIENT_CREATE_BY_USER
  if ( __pClient__ == NULL ) {
    __pClient__	= RPC_CLIENT_CREATE ( __szHost__, __szTransport__ );
    if ( __pClient__ == NULL ) {
      /* Error handling for a not connected client: */
      char	szError [ 256 ];
      sprintf ( szError, szFormatNoServer, __procedure__ );
      RPC_CLIENT_ERROR ( szError );
      return Result.ReturnValue;
    }
  }
#else
  while ( __pClient__ == NULL ) {
    __pClient__	= RPC_CLIENT_CREATE ( __szHost__, __szTransport__ );
    if ( __pClient__ == NULL ) {
      /* Error handling for a not connected client: */
      char	szError [ 256 ];
      sprintf ( szError, szFormatNoServer, __procedure__ );
      RPC_CLIENT_CERROR ( szContNoServer, szError );
    }
  }
#endif	/* CLIENT_CREATE_BY_USER */

  /* Copy in the oShortObjIdHeap argument: */
  InArguments.oShortObjIdHeap	= oShortObjIdHeap;
  /* Copy in the oShortObjIdBTree argument: */
  InArguments.oShortObjIdBTree	= oShortObjIdBTree;

  pResult	=
#ifdef MULTITHREAD
    (
#else
    (fnClientBtreeCount_rets *)
#endif
    fnrpc_fnclientbtreecount_1 (
	&InArguments,
#ifdef MULTITHREAD
	&Result,
#endif
	__pClient__ )
#ifdef MULTITHREAD
	== RPC_SUCCESS ) ? &Result : NULL
#endif
	;

  if ( pResult == NULL ) {
    /* Error handling for a failed RPC call, */
    /* i.e. the server did not respond: */
    char	szError [ 256 ];
    sprintf ( szError, szFormatRpcFailed, __procedure__,
              clnt_sperror ( __pClient__, __szHost__ ) );
    __pClient__	= RPC_CLIENT_DESTROY ( __pClient__ );
    RPC_CLIENT_CERROR ( szContRpcFailed, szError );
    Result	= ZeroResult;
    return Result.ReturnValue;
  }
#ifndef MULTITHREAD
  Result	= * pResult;
#endif


  if ( pResult && pResult->nErrorLvl ) {
    /* Server returned a user error message: */
    char	szErrorMsg [ 1024 ];
    strncpy ( szErrorMsg,
              ( pResult->pszErrorMsg && pResult->pszErrorMsg [ 0 ] ) ?
              (LPCSTR) pResult->pszErrorMsg : (LPCSTR) szEmpty,
              sizeof ( szErrorMsg ) );
    szErrorMsg [ sizeof ( szErrorMsg ) - 1 ]	= (char) 0;
    xdr_free ( (xdrproc_t) xdr_fnClientBtreeCount_rets, (char *) pResult );
    RPC_CLIENT_SERROR ( pResult->nErrorLvl, __procedure__,
                        szErrorMsg );
  } else {
    xdr_free ( (xdrproc_t) xdr_fnClientBtreeCount_rets, (char *) pResult );
  }

  return Result.ReturnValue;

} /* fnClientBtreeCount */



BTREERESULT DLLEXPORT fnServerBtreeDelete
	(SHORTOBJID oShortObjIdHeap ,
	  SHORTOBJID oShortObjIdBTree ,
	  int nValueKey ,
	  SHTYPETAG nTypeTagKey)
{
  static const char	__procedure__[]	= "client:fnServerBtreeDelete";
  static fnServerBtreeDelete_rets	ZeroResult;
  fnServerBtreeDelete_rets		* pResult = NULL;
  fnServerBtreeDelete_rets		Result = ZeroResult;
  fnServerBtreeDelete_args	InArguments;

  /* Client initialization: */
  if ( __bClientInitialize__ ) {
    __bClientInitialize__	= FALSE;
    RPC_CLIENT_INITIALIZE();
  }

#if	CLIENT_CREATE_BY_USER
  if ( __pClient__ == NULL ) {
    __pClient__	= RPC_CLIENT_CREATE ( __szHost__, __szTransport__ );
    if ( __pClient__ == NULL ) {
      /* Error handling for a not connected client: */
      char	szError [ 256 ];
      sprintf ( szError, szFormatNoServer, __procedure__ );
      RPC_CLIENT_ERROR ( szError );
      return Result.ReturnValue;
    }
  }
#else
  while ( __pClient__ == NULL ) {
    __pClient__	= RPC_CLIENT_CREATE ( __szHost__, __szTransport__ );
    if ( __pClient__ == NULL ) {
      /* Error handling for a not connected client: */
      char	szError [ 256 ];
      sprintf ( szError, szFormatNoServer, __procedure__ );
      RPC_CLIENT_CERROR ( szContNoServer, szError );
    }
  }
#endif	/* CLIENT_CREATE_BY_USER */

  /* Copy in the oShortObjIdHeap argument: */
  InArguments.oShortObjIdHeap	= oShortObjIdHeap;
  /* Copy in the oShortObjIdBTree argument: */
  InArguments.oShortObjIdBTree	= oShortObjIdBTree;
  /* Copy in the nValueKey argument: */
  InArguments.nValueKey	= nValueKey;
  /* Copy in the nTypeTagKey argument: */
  InArguments.nTypeTagKey	= nTypeTagKey;

  pResult	=
#ifdef MULTITHREAD
    (
#else
    (fnServerBtreeDelete_rets *)
#endif
    fnrpc_fnserverbtreedelete_1 (
	&InArguments,
#ifdef MULTITHREAD
	&Result,
#endif
	__pClient__ )
#ifdef MULTITHREAD
	== RPC_SUCCESS ) ? &Result : NULL
#endif
	;

  if ( pResult == NULL ) {
    /* Error handling for a failed RPC call, */
    /* i.e. the server did not respond: */
    char	szError [ 256 ];
    sprintf ( szError, szFormatRpcFailed, __procedure__,
              clnt_sperror ( __pClient__, __szHost__ ) );
    __pClient__	= RPC_CLIENT_DESTROY ( __pClient__ );
    RPC_CLIENT_CERROR ( szContRpcFailed, szError );
    Result	= ZeroResult;
    return Result.ReturnValue;
  }
#ifndef MULTITHREAD
  Result	= * pResult;
#endif


  if ( pResult && pResult->nErrorLvl ) {
    /* Server returned a user error message: */
    char	szErrorMsg [ 1024 ];
    strncpy ( szErrorMsg,
              ( pResult->pszErrorMsg && pResult->pszErrorMsg [ 0 ] ) ?
              (LPCSTR) pResult->pszErrorMsg : (LPCSTR) szEmpty,
              sizeof ( szErrorMsg ) );
    szErrorMsg [ sizeof ( szErrorMsg ) - 1 ]	= (char) 0;
    xdr_free ( (xdrproc_t) xdr_fnServerBtreeDelete_rets, (char *) pResult );
    RPC_CLIENT_SERROR ( pResult->nErrorLvl, __procedure__,
                        szErrorMsg );
  } else {
    xdr_free ( (xdrproc_t) xdr_fnServerBtreeDelete_rets, (char *) pResult );
  }

  return Result.ReturnValue;

} /* fnServerBtreeDelete */



BTREERESULT DLLEXPORT fnServerBtreeDeleteByFloat
	(SHORTOBJID oShortObjIdHeap ,
	  SHORTOBJID oShortObjIdBTree ,
	  float fKey)
{
  static const char	__procedure__[]	= "client:fnServerBtreeDeleteByFloat";
  static fnServerBtreeDeleteByFloat_rets	ZeroResult;
  fnServerBtreeDeleteByFloat_rets		* pResult = NULL;
  fnServerBtreeDeleteByFloat_rets		Result = ZeroResult;
  fnServerBtreeDeleteByFloat_args	InArguments;

  /* Client initialization: */
  if ( __bClientInitialize__ ) {
    __bClientInitialize__	= FALSE;
    RPC_CLIENT_INITIALIZE();
  }

#if	CLIENT_CREATE_BY_USER
  if ( __pClient__ == NULL ) {
    __pClient__	= RPC_CLIENT_CREATE ( __szHost__, __szTransport__ );
    if ( __pClient__ == NULL ) {
      /* Error handling for a not connected client: */
      char	szError [ 256 ];
      sprintf ( szError, szFormatNoServer, __procedure__ );
      RPC_CLIENT_ERROR ( szError );
      return Result.ReturnValue;
    }
  }
#else
  while ( __pClient__ == NULL ) {
    __pClient__	= RPC_CLIENT_CREATE ( __szHost__, __szTransport__ );
    if ( __pClient__ == NULL ) {
      /* Error handling for a not connected client: */
      char	szError [ 256 ];
      sprintf ( szError, szFormatNoServer, __procedure__ );
      RPC_CLIENT_CERROR ( szContNoServer, szError );
    }
  }
#endif	/* CLIENT_CREATE_BY_USER */

  /* Copy in the oShortObjIdHeap argument: */
  InArguments.oShortObjIdHeap	= oShortObjIdHeap;
  /* Copy in the oShortObjIdBTree argument: */
  InArguments.oShortObjIdBTree	= oShortObjIdBTree;
  /* Copy in the fKey argument: */
  InArguments.fKey	= fKey;

  pResult	=
#ifdef MULTITHREAD
    (
#else
    (fnServerBtreeDeleteByFloat_rets *)
#endif
    fnrpc_fnserverbtreedeletebyfloat_1 (
	&InArguments,
#ifdef MULTITHREAD
	&Result,
#endif
	__pClient__ )
#ifdef MULTITHREAD
	== RPC_SUCCESS ) ? &Result : NULL
#endif
	;

  if ( pResult == NULL ) {
    /* Error handling for a failed RPC call, */
    /* i.e. the server did not respond: */
    char	szError [ 256 ];
    sprintf ( szError, szFormatRpcFailed, __procedure__,
              clnt_sperror ( __pClient__, __szHost__ ) );
    __pClient__	= RPC_CLIENT_DESTROY ( __pClient__ );
    RPC_CLIENT_CERROR ( szContRpcFailed, szError );
    Result	= ZeroResult;
    return Result.ReturnValue;
  }
#ifndef MULTITHREAD
  Result	= * pResult;
#endif


  if ( pResult && pResult->nErrorLvl ) {
    /* Server returned a user error message: */
    char	szErrorMsg [ 1024 ];
    strncpy ( szErrorMsg,
              ( pResult->pszErrorMsg && pResult->pszErrorMsg [ 0 ] ) ?
              (LPCSTR) pResult->pszErrorMsg : (LPCSTR) szEmpty,
              sizeof ( szErrorMsg ) );
    szErrorMsg [ sizeof ( szErrorMsg ) - 1 ]	= (char) 0;
    xdr_free ( (xdrproc_t) xdr_fnServerBtreeDeleteByFloat_rets, (char *) pResult );
    RPC_CLIENT_SERROR ( pResult->nErrorLvl, __procedure__,
                        szErrorMsg );
  } else {
    xdr_free ( (xdrproc_t) xdr_fnServerBtreeDeleteByFloat_rets, (char *) pResult );
  }

  return Result.ReturnValue;

} /* fnServerBtreeDeleteByFloat */



BTREERESULT DLLEXPORT fnServerBtreeDeleteByDouble
	(SHORTOBJID oShortObjIdHeap ,
	  SHORTOBJID oShortObjIdBTree ,
	  double fKey)
{
  static const char	__procedure__[]	= "client:fnServerBtreeDeleteByDouble";
  static fnServerBtreeDeleteByDouble_rets	ZeroResult;
  fnServerBtreeDeleteByDouble_rets		* pResult = NULL;
  fnServerBtreeDeleteByDouble_rets		Result = ZeroResult;
  fnServerBtreeDeleteByDouble_args	InArguments;

  /* Client initialization: */
  if ( __bClientInitialize__ ) {
    __bClientInitialize__	= FALSE;
    RPC_CLIENT_INITIALIZE();
  }

#if	CLIENT_CREATE_BY_USER
  if ( __pClient__ == NULL ) {
    __pClient__	= RPC_CLIENT_CREATE ( __szHost__, __szTransport__ );
    if ( __pClient__ == NULL ) {
      /* Error handling for a not connected client: */
      char	szError [ 256 ];
      sprintf ( szError, szFormatNoServer, __procedure__ );
      RPC_CLIENT_ERROR ( szError );
      return Result.ReturnValue;
    }
  }
#else
  while ( __pClient__ == NULL ) {
    __pClient__	= RPC_CLIENT_CREATE ( __szHost__, __szTransport__ );
    if ( __pClient__ == NULL ) {
      /* Error handling for a not connected client: */
      char	szError [ 256 ];
      sprintf ( szError, szFormatNoServer, __procedure__ );
      RPC_CLIENT_CERROR ( szContNoServer, szError );
    }
  }
#endif	/* CLIENT_CREATE_BY_USER */

  /* Copy in the oShortObjIdHeap argument: */
  InArguments.oShortObjIdHeap	= oShortObjIdHeap;
  /* Copy in the oShortObjIdBTree argument: */
  InArguments.oShortObjIdBTree	= oShortObjIdBTree;
  /* Copy in the fKey argument: */
  InArguments.fKey	= fKey;

  pResult	=
#ifdef MULTITHREAD
    (
#else
    (fnServerBtreeDeleteByDouble_rets *)
#endif
    fnrpc_fnserverbtreedeletebydouble_1 (
	&InArguments,
#ifdef MULTITHREAD
	&Result,
#endif
	__pClient__ )
#ifdef MULTITHREAD
	== RPC_SUCCESS ) ? &Result : NULL
#endif
	;

  if ( pResult == NULL ) {
    /* Error handling for a failed RPC call, */
    /* i.e. the server did not respond: */
    char	szError [ 256 ];
    sprintf ( szError, szFormatRpcFailed, __procedure__,
              clnt_sperror ( __pClient__, __szHost__ ) );
    __pClient__	= RPC_CLIENT_DESTROY ( __pClient__ );
    RPC_CLIENT_CERROR ( szContRpcFailed, szError );
    Result	= ZeroResult;
    return Result.ReturnValue;
  }
#ifndef MULTITHREAD
  Result	= * pResult;
#endif


  if ( pResult && pResult->nErrorLvl ) {
    /* Server returned a user error message: */
    char	szErrorMsg [ 1024 ];
    strncpy ( szErrorMsg,
              ( pResult->pszErrorMsg && pResult->pszErrorMsg [ 0 ] ) ?
              (LPCSTR) pResult->pszErrorMsg : (LPCSTR) szEmpty,
              sizeof ( szErrorMsg ) );
    szErrorMsg [ sizeof ( szErrorMsg ) - 1 ]	= (char) 0;
    xdr_free ( (xdrproc_t) xdr_fnServerBtreeDeleteByDouble_rets, (char *) pResult );
    RPC_CLIENT_SERROR ( pResult->nErrorLvl, __procedure__,
                        szErrorMsg );
  } else {
    xdr_free ( (xdrproc_t) xdr_fnServerBtreeDeleteByDouble_rets, (char *) pResult );
  }

  return Result.ReturnValue;

} /* fnServerBtreeDeleteByDouble */



BTREERESULT DLLEXPORT fnServerBtreeDeleteByString
	(SHORTOBJID oShortObjIdHeap ,
	  SHORTOBJID oShortObjIdBTree ,
	  string_t /* string_t<@conststring@> */ szKey)
{
  static const char	__procedure__[]	= "client:fnServerBtreeDeleteByString";
  static fnServerBtreeDeleteByString_rets	ZeroResult;
  fnServerBtreeDeleteByString_rets		* pResult = NULL;
  fnServerBtreeDeleteByString_rets		Result = ZeroResult;
  fnServerBtreeDeleteByString_args	InArguments;

  /* Client initialization: */
  if ( __bClientInitialize__ ) {
    __bClientInitialize__	= FALSE;
    RPC_CLIENT_INITIALIZE();
  }

#if	CLIENT_CREATE_BY_USER
  if ( __pClient__ == NULL ) {
    __pClient__	= RPC_CLIENT_CREATE ( __szHost__, __szTransport__ );
    if ( __pClient__ == NULL ) {
      /* Error handling for a not connected client: */
      char	szError [ 256 ];
      sprintf ( szError, szFormatNoServer, __procedure__ );
      RPC_CLIENT_ERROR ( szError );
      return Result.ReturnValue;
    }
  }
#else
  while ( __pClient__ == NULL ) {
    __pClient__	= RPC_CLIENT_CREATE ( __szHost__, __szTransport__ );
    if ( __pClient__ == NULL ) {
      /* Error handling for a not connected client: */
      char	szError [ 256 ];
      sprintf ( szError, szFormatNoServer, __procedure__ );
      RPC_CLIENT_CERROR ( szContNoServer, szError );
    }
  }
#endif	/* CLIENT_CREATE_BY_USER */

  /* Copy in the oShortObjIdHeap argument: */
  InArguments.oShortObjIdHeap	= oShortObjIdHeap;
  /* Copy in the oShortObjIdBTree argument: */
  InArguments.oShortObjIdBTree	= oShortObjIdBTree;
  /* Copy in the szKey argument: */
  InArguments.szKey	= szKey;
  if ( szKey == NULL ) {
    /* Error handling for passing a NULL string pointer: */
    char	szError [ 256 ];
    InArguments.szKey	= (LPSTR) szEmpty;
    sprintf ( szError, szFormatNullString,
              __procedure__, "szKey" );
    RPC_CLIENT_CERROR ( szContNullString, szError );
  }

  pResult	=
#ifdef MULTITHREAD
    (
#else
    (fnServerBtreeDeleteByString_rets *)
#endif
    fnrpc_fnserverbtreedeletebystring_1 (
	&InArguments,
#ifdef MULTITHREAD
	&Result,
#endif
	__pClient__ )
#ifdef MULTITHREAD
	== RPC_SUCCESS ) ? &Result : NULL
#endif
	;

  if ( pResult == NULL ) {
    /* Error handling for a failed RPC call, */
    /* i.e. the server did not respond: */
    char	szError [ 256 ];
    sprintf ( szError, szFormatRpcFailed, __procedure__,
              clnt_sperror ( __pClient__, __szHost__ ) );
    __pClient__	= RPC_CLIENT_DESTROY ( __pClient__ );
    RPC_CLIENT_CERROR ( szContRpcFailed, szError );
    Result	= ZeroResult;
    return Result.ReturnValue;
  }
#ifndef MULTITHREAD
  Result	= * pResult;
#endif


  if ( pResult && pResult->nErrorLvl ) {
    /* Server returned a user error message: */
    char	szErrorMsg [ 1024 ];
    strncpy ( szErrorMsg,
              ( pResult->pszErrorMsg && pResult->pszErrorMsg [ 0 ] ) ?
              (LPCSTR) pResult->pszErrorMsg : (LPCSTR) szEmpty,
              sizeof ( szErrorMsg ) );
    szErrorMsg [ sizeof ( szErrorMsg ) - 1 ]	= (char) 0;
    xdr_free ( (xdrproc_t) xdr_fnServerBtreeDeleteByString_rets, (char *) pResult );
    RPC_CLIENT_SERROR ( pResult->nErrorLvl, __procedure__,
                        szErrorMsg );
  } else {
    xdr_free ( (xdrproc_t) xdr_fnServerBtreeDeleteByString_rets, (char *) pResult );
  }

  return Result.ReturnValue;

} /* fnServerBtreeDeleteByString */



BTREERESULT DLLEXPORT fnServerBtreeInsert
	(SHORTOBJID oShortObjIdHeap ,
	  SHORTOBJID oShortObjIdBTree ,
	  int nValueKey ,
	  SHTYPETAG nTypeTagKey ,
	  int nValueData ,
	  SHTYPETAG nTypeTagData)
{
  static const char	__procedure__[]	= "client:fnServerBtreeInsert";
  static fnServerBtreeInsert_rets	ZeroResult;
  fnServerBtreeInsert_rets		* pResult = NULL;
  fnServerBtreeInsert_rets		Result = ZeroResult;
  fnServerBtreeInsert_args	InArguments;

  /* Client initialization: */
  if ( __bClientInitialize__ ) {
    __bClientInitialize__	= FALSE;
    RPC_CLIENT_INITIALIZE();
  }

#if	CLIENT_CREATE_BY_USER
  if ( __pClient__ == NULL ) {
    __pClient__	= RPC_CLIENT_CREATE ( __szHost__, __szTransport__ );
    if ( __pClient__ == NULL ) {
      /* Error handling for a not connected client: */
      char	szError [ 256 ];
      sprintf ( szError, szFormatNoServer, __procedure__ );
      RPC_CLIENT_ERROR ( szError );
      return Result.ReturnValue;
    }
  }
#else
  while ( __pClient__ == NULL ) {
    __pClient__	= RPC_CLIENT_CREATE ( __szHost__, __szTransport__ );
    if ( __pClient__ == NULL ) {
      /* Error handling for a not connected client: */
      char	szError [ 256 ];
      sprintf ( szError, szFormatNoServer, __procedure__ );
      RPC_CLIENT_CERROR ( szContNoServer, szError );
    }
  }
#endif	/* CLIENT_CREATE_BY_USER */

  /* Copy in the oShortObjIdHeap argument: */
  InArguments.oShortObjIdHeap	= oShortObjIdHeap;
  /* Copy in the oShortObjIdBTree argument: */
  InArguments.oShortObjIdBTree	= oShortObjIdBTree;
  /* Copy in the nValueKey argument: */
  InArguments.nValueKey	= nValueKey;
  /* Copy in the nTypeTagKey argument: */
  InArguments.nTypeTagKey	= nTypeTagKey;
  /* Copy in the nValueData argument: */
  InArguments.nValueData	= nValueData;
  /* Copy in the nTypeTagData argument: */
  InArguments.nTypeTagData	= nTypeTagData;

  pResult	=
#ifdef MULTITHREAD
    (
#else
    (fnServerBtreeInsert_rets *)
#endif
    fnrpc_fnserverbtreeinsert_1 (
	&InArguments,
#ifdef MULTITHREAD
	&Result,
#endif
	__pClient__ )
#ifdef MULTITHREAD
	== RPC_SUCCESS ) ? &Result : NULL
#endif
	;

  if ( pResult == NULL ) {
    /* Error handling for a failed RPC call, */
    /* i.e. the server did not respond: */
    char	szError [ 256 ];
    sprintf ( szError, szFormatRpcFailed, __procedure__,
              clnt_sperror ( __pClient__, __szHost__ ) );
    __pClient__	= RPC_CLIENT_DESTROY ( __pClient__ );
    RPC_CLIENT_CERROR ( szContRpcFailed, szError );
    Result	= ZeroResult;
    return Result.ReturnValue;
  }
#ifndef MULTITHREAD
  Result	= * pResult;
#endif


  if ( pResult && pResult->nErrorLvl ) {
    /* Server returned a user error message: */
    char	szErrorMsg [ 1024 ];
    strncpy ( szErrorMsg,
              ( pResult->pszErrorMsg && pResult->pszErrorMsg [ 0 ] ) ?
              (LPCSTR) pResult->pszErrorMsg : (LPCSTR) szEmpty,
              sizeof ( szErrorMsg ) );
    szErrorMsg [ sizeof ( szErrorMsg ) - 1 ]	= (char) 0;
    xdr_free ( (xdrproc_t) xdr_fnServerBtreeInsert_rets, (char *) pResult );
    RPC_CLIENT_SERROR ( pResult->nErrorLvl, __procedure__,
                        szErrorMsg );
  } else {
    xdr_free ( (xdrproc_t) xdr_fnServerBtreeInsert_rets, (char *) pResult );
  }

  return Result.ReturnValue;

} /* fnServerBtreeInsert */



BTREERESULT DLLEXPORT fnServerBtreeInsertByFloat
	(SHORTOBJID oShortObjIdHeap ,
	  SHORTOBJID oShortObjIdBTree ,
	  float fKey ,
	  int nValueData ,
	  SHTYPETAG nTypeTagData)
{
  static const char	__procedure__[]	= "client:fnServerBtreeInsertByFloat";
  static fnServerBtreeInsertByFloat_rets	ZeroResult;
  fnServerBtreeInsertByFloat_rets		* pResult = NULL;
  fnServerBtreeInsertByFloat_rets		Result = ZeroResult;
  fnServerBtreeInsertByFloat_args	InArguments;

  /* Client initialization: */
  if ( __bClientInitialize__ ) {
    __bClientInitialize__	= FALSE;
    RPC_CLIENT_INITIALIZE();
  }

#if	CLIENT_CREATE_BY_USER
  if ( __pClient__ == NULL ) {
    __pClient__	= RPC_CLIENT_CREATE ( __szHost__, __szTransport__ );
    if ( __pClient__ == NULL ) {
      /* Error handling for a not connected client: */
      char	szError [ 256 ];
      sprintf ( szError, szFormatNoServer, __procedure__ );
      RPC_CLIENT_ERROR ( szError );
      return Result.ReturnValue;
    }
  }
#else
  while ( __pClient__ == NULL ) {
    __pClient__	= RPC_CLIENT_CREATE ( __szHost__, __szTransport__ );
    if ( __pClient__ == NULL ) {
      /* Error handling for a not connected client: */
      char	szError [ 256 ];
      sprintf ( szError, szFormatNoServer, __procedure__ );
      RPC_CLIENT_CERROR ( szContNoServer, szError );
    }
  }
#endif	/* CLIENT_CREATE_BY_USER */

  /* Copy in the oShortObjIdHeap argument: */
  InArguments.oShortObjIdHeap	= oShortObjIdHeap;
  /* Copy in the oShortObjIdBTree argument: */
  InArguments.oShortObjIdBTree	= oShortObjIdBTree;
  /* Copy in the fKey argument: */
  InArguments.fKey	= fKey;
  /* Copy in the nValueData argument: */
  InArguments.nValueData	= nValueData;
  /* Copy in the nTypeTagData argument: */
  InArguments.nTypeTagData	= nTypeTagData;

  pResult	=
#ifdef MULTITHREAD
    (
#else
    (fnServerBtreeInsertByFloat_rets *)
#endif
    fnrpc_fnserverbtreeinsertbyfloat_1 (
	&InArguments,
#ifdef MULTITHREAD
	&Result,
#endif
	__pClient__ )
#ifdef MULTITHREAD
	== RPC_SUCCESS ) ? &Result : NULL
#endif
	;

  if ( pResult == NULL ) {
    /* Error handling for a failed RPC call, */
    /* i.e. the server did not respond: */
    char	szError [ 256 ];
    sprintf ( szError, szFormatRpcFailed, __procedure__,
              clnt_sperror ( __pClient__, __szHost__ ) );
    __pClient__	= RPC_CLIENT_DESTROY ( __pClient__ );
    RPC_CLIENT_CERROR ( szContRpcFailed, szError );
    Result	= ZeroResult;
    return Result.ReturnValue;
  }
#ifndef MULTITHREAD
  Result	= * pResult;
#endif


  if ( pResult && pResult->nErrorLvl ) {
    /* Server returned a user error message: */
    char	szErrorMsg [ 1024 ];
    strncpy ( szErrorMsg,
              ( pResult->pszErrorMsg && pResult->pszErrorMsg [ 0 ] ) ?
              (LPCSTR) pResult->pszErrorMsg : (LPCSTR) szEmpty,
              sizeof ( szErrorMsg ) );
    szErrorMsg [ sizeof ( szErrorMsg ) - 1 ]	= (char) 0;
    xdr_free ( (xdrproc_t) xdr_fnServerBtreeInsertByFloat_rets, (char *) pResult );
    RPC_CLIENT_SERROR ( pResult->nErrorLvl, __procedure__,
                        szErrorMsg );
  } else {
    xdr_free ( (xdrproc_t) xdr_fnServerBtreeInsertByFloat_rets, (char *) pResult );
  }

  return Result.ReturnValue;

} /* fnServerBtreeInsertByFloat */



BTREERESULT DLLEXPORT fnServerBtreeInsertByDouble
	(SHORTOBJID oShortObjIdHeap ,
	  SHORTOBJID oShortObjIdBTree ,
	  double fKey ,
	  int nValueData ,
	  SHTYPETAG nTypeTagData)
{
  static const char	__procedure__[]	= "client:fnServerBtreeInsertByDouble";
  static fnServerBtreeInsertByDouble_rets	ZeroResult;
  fnServerBtreeInsertByDouble_rets		* pResult = NULL;
  fnServerBtreeInsertByDouble_rets		Result = ZeroResult;
  fnServerBtreeInsertByDouble_args	InArguments;

  /* Client initialization: */
  if ( __bClientInitialize__ ) {
    __bClientInitialize__	= FALSE;
    RPC_CLIENT_INITIALIZE();
  }

#if	CLIENT_CREATE_BY_USER
  if ( __pClient__ == NULL ) {
    __pClient__	= RPC_CLIENT_CREATE ( __szHost__, __szTransport__ );
    if ( __pClient__ == NULL ) {
      /* Error handling for a not connected client: */
      char	szError [ 256 ];
      sprintf ( szError, szFormatNoServer, __procedure__ );
      RPC_CLIENT_ERROR ( szError );
      return Result.ReturnValue;
    }
  }
#else
  while ( __pClient__ == NULL ) {
    __pClient__	= RPC_CLIENT_CREATE ( __szHost__, __szTransport__ );
    if ( __pClient__ == NULL ) {
      /* Error handling for a not connected client: */
      char	szError [ 256 ];
      sprintf ( szError, szFormatNoServer, __procedure__ );
      RPC_CLIENT_CERROR ( szContNoServer, szError );
    }
  }
#endif	/* CLIENT_CREATE_BY_USER */

  /* Copy in the oShortObjIdHeap argument: */
  InArguments.oShortObjIdHeap	= oShortObjIdHeap;
  /* Copy in the oShortObjIdBTree argument: */
  InArguments.oShortObjIdBTree	= oShortObjIdBTree;
  /* Copy in the fKey argument: */
  InArguments.fKey	= fKey;
  /* Copy in the nValueData argument: */
  InArguments.nValueData	= nValueData;
  /* Copy in the nTypeTagData argument: */
  InArguments.nTypeTagData	= nTypeTagData;

  pResult	=
#ifdef MULTITHREAD
    (
#else
    (fnServerBtreeInsertByDouble_rets *)
#endif
    fnrpc_fnserverbtreeinsertbydouble_1 (
	&InArguments,
#ifdef MULTITHREAD
	&Result,
#endif
	__pClient__ )
#ifdef MULTITHREAD
	== RPC_SUCCESS ) ? &Result : NULL
#endif
	;

  if ( pResult == NULL ) {
    /* Error handling for a failed RPC call, */
    /* i.e. the server did not respond: */
    char	szError [ 256 ];
    sprintf ( szError, szFormatRpcFailed, __procedure__,
              clnt_sperror ( __pClient__, __szHost__ ) );
    __pClient__	= RPC_CLIENT_DESTROY ( __pClient__ );
    RPC_CLIENT_CERROR ( szContRpcFailed, szError );
    Result	= ZeroResult;
    return Result.ReturnValue;
  }
#ifndef MULTITHREAD
  Result	= * pResult;
#endif


  if ( pResult && pResult->nErrorLvl ) {
    /* Server returned a user error message: */
    char	szErrorMsg [ 1024 ];
    strncpy ( szErrorMsg,
              ( pResult->pszErrorMsg && pResult->pszErrorMsg [ 0 ] ) ?
              (LPCSTR) pResult->pszErrorMsg : (LPCSTR) szEmpty,
              sizeof ( szErrorMsg ) );
    szErrorMsg [ sizeof ( szErrorMsg ) - 1 ]	= (char) 0;
    xdr_free ( (xdrproc_t) xdr_fnServerBtreeInsertByDouble_rets, (char *) pResult );
    RPC_CLIENT_SERROR ( pResult->nErrorLvl, __procedure__,
                        szErrorMsg );
  } else {
    xdr_free ( (xdrproc_t) xdr_fnServerBtreeInsertByDouble_rets, (char *) pResult );
  }

  return Result.ReturnValue;

} /* fnServerBtreeInsertByDouble */



BTREERESULT DLLEXPORT fnServerBtreeInsertByString
	(SHORTOBJID oShortObjIdHeap ,
	  SHORTOBJID oShortObjIdBTree ,
	  string_t /* string_t<@conststring@> */ szKey ,
	  int nValueData ,
	  SHTYPETAG nTypeTagData)
{
  static const char	__procedure__[]	= "client:fnServerBtreeInsertByString";
  static fnServerBtreeInsertByString_rets	ZeroResult;
  fnServerBtreeInsertByString_rets		* pResult = NULL;
  fnServerBtreeInsertByString_rets		Result = ZeroResult;
  fnServerBtreeInsertByString_args	InArguments;

  /* Client initialization: */
  if ( __bClientInitialize__ ) {
    __bClientInitialize__	= FALSE;
    RPC_CLIENT_INITIALIZE();
  }

#if	CLIENT_CREATE_BY_USER
  if ( __pClient__ == NULL ) {
    __pClient__	= RPC_CLIENT_CREATE ( __szHost__, __szTransport__ );
    if ( __pClient__ == NULL ) {
      /* Error handling for a not connected client: */
      char	szError [ 256 ];
      sprintf ( szError, szFormatNoServer, __procedure__ );
      RPC_CLIENT_ERROR ( szError );
      return Result.ReturnValue;
    }
  }
#else
  while ( __pClient__ == NULL ) {
    __pClient__	= RPC_CLIENT_CREATE ( __szHost__, __szTransport__ );
    if ( __pClient__ == NULL ) {
      /* Error handling for a not connected client: */
      char	szError [ 256 ];
      sprintf ( szError, szFormatNoServer, __procedure__ );
      RPC_CLIENT_CERROR ( szContNoServer, szError );
    }
  }
#endif	/* CLIENT_CREATE_BY_USER */

  /* Copy in the oShortObjIdHeap argument: */
  InArguments.oShortObjIdHeap	= oShortObjIdHeap;
  /* Copy in the oShortObjIdBTree argument: */
  InArguments.oShortObjIdBTree	= oShortObjIdBTree;
  /* Copy in the szKey argument: */
  InArguments.szKey	= szKey;
  if ( szKey == NULL ) {
    /* Error handling for passing a NULL string pointer: */
    char	szError [ 256 ];
    InArguments.szKey	= (LPSTR) szEmpty;
    sprintf ( szError, szFormatNullString,
              __procedure__, "szKey" );
    RPC_CLIENT_CERROR ( szContNullString, szError );
  }
  /* Copy in the nValueData argument: */
  InArguments.nValueData	= nValueData;
  /* Copy in the nTypeTagData argument: */
  InArguments.nTypeTagData	= nTypeTagData;

  pResult	=
#ifdef MULTITHREAD
    (
#else
    (fnServerBtreeInsertByString_rets *)
#endif
    fnrpc_fnserverbtreeinsertbystring_1 (
	&InArguments,
#ifdef MULTITHREAD
	&Result,
#endif
	__pClient__ )
#ifdef MULTITHREAD
	== RPC_SUCCESS ) ? &Result : NULL
#endif
	;

  if ( pResult == NULL ) {
    /* Error handling for a failed RPC call, */
    /* i.e. the server did not respond: */
    char	szError [ 256 ];
    sprintf ( szError, szFormatRpcFailed, __procedure__,
              clnt_sperror ( __pClient__, __szHost__ ) );
    __pClient__	= RPC_CLIENT_DESTROY ( __pClient__ );
    RPC_CLIENT_CERROR ( szContRpcFailed, szError );
    Result	= ZeroResult;
    return Result.ReturnValue;
  }
#ifndef MULTITHREAD
  Result	= * pResult;
#endif


  if ( pResult && pResult->nErrorLvl ) {
    /* Server returned a user error message: */
    char	szErrorMsg [ 1024 ];
    strncpy ( szErrorMsg,
              ( pResult->pszErrorMsg && pResult->pszErrorMsg [ 0 ] ) ?
              (LPCSTR) pResult->pszErrorMsg : (LPCSTR) szEmpty,
              sizeof ( szErrorMsg ) );
    szErrorMsg [ sizeof ( szErrorMsg ) - 1 ]	= (char) 0;
    xdr_free ( (xdrproc_t) xdr_fnServerBtreeInsertByString_rets, (char *) pResult );
    RPC_CLIENT_SERROR ( pResult->nErrorLvl, __procedure__,
                        szErrorMsg );
  } else {
    xdr_free ( (xdrproc_t) xdr_fnServerBtreeInsertByString_rets, (char *) pResult );
  }

  return Result.ReturnValue;

} /* fnServerBtreeInsertByString */



int DLLEXPORT fnServerBtreemapSearch
	(SHORTOBJID oShortObjIdMapper ,
	  SHORTOBJID oShortObjIdHeap ,
	  SHORTOBJID oShortObjIdBTree ,
	  int nValueKeyLower ,
	  SHTYPETAG nTypeTagKeyLower ,
	  COMPARETAG eCompareLower ,
	  int nValueKeyUpper ,
	  SHTYPETAG nTypeTagKeyUpper ,
	  COMPARETAG eCompareUpper ,
	  bool_t bDescending)
{
  static const char	__procedure__[]	= "client:fnServerBtreemapSearch";
  static fnServerBtreemapSearch_rets	ZeroResult;
  fnServerBtreemapSearch_rets		* pResult = NULL;
  fnServerBtreemapSearch_rets		Result = ZeroResult;
  fnServerBtreemapSearch_args	InArguments;

  /* Client initialization: */
  if ( __bClientInitialize__ ) {
    __bClientInitialize__	= FALSE;
    RPC_CLIENT_INITIALIZE();
  }

#if	CLIENT_CREATE_BY_USER
  if ( __pClient__ == NULL ) {
    __pClient__	= RPC_CLIENT_CREATE ( __szHost__, __szTransport__ );
    if ( __pClient__ == NULL ) {
      /* Error handling for a not connected client: */
      char	szError [ 256 ];
      sprintf ( szError, szFormatNoServer, __procedure__ );
      RPC_CLIENT_ERROR ( szError );
      return Result.ReturnValue;
    }
  }
#else
  while ( __pClient__ == NULL ) {
    __pClient__	= RPC_CLIENT_CREATE ( __szHost__, __szTransport__ );
    if ( __pClient__ == NULL ) {
      /* Error handling for a not connected client: */
      char	szError [ 256 ];
      sprintf ( szError, szFormatNoServer, __procedure__ );
      RPC_CLIENT_CERROR ( szContNoServer, szError );
    }
  }
#endif	/* CLIENT_CREATE_BY_USER */

  /* Copy in the oShortObjIdMapper argument: */
  InArguments.oShortObjIdMapper	= oShortObjIdMapper;
  /* Copy in the oShortObjIdHeap argument: */
  InArguments.oShortObjIdHeap	= oShortObjIdHeap;
  /* Copy in the oShortObjIdBTree argument: */
  InArguments.oShortObjIdBTree	= oShortObjIdBTree;
  /* Copy in the nValueKeyLower argument: */
  InArguments.nValueKeyLower	= nValueKeyLower;
  /* Copy in the nTypeTagKeyLower argument: */
  InArguments.nTypeTagKeyLower	= nTypeTagKeyLower;
  /* Copy in the eCompareLower argument: */
  InArguments.eCompareLower	= eCompareLower;
  /* Copy in the nValueKeyUpper argument: */
  InArguments.nValueKeyUpper	= nValueKeyUpper;
  /* Copy in the nTypeTagKeyUpper argument: */
  InArguments.nTypeTagKeyUpper	= nTypeTagKeyUpper;
  /* Copy in the eCompareUpper argument: */
  InArguments.eCompareUpper	= eCompareUpper;
  /* Copy in the bDescending argument: */
  InArguments.bDescending	= bDescending;

  pResult	=
#ifdef MULTITHREAD
    (
#else
    (fnServerBtreemapSearch_rets *)
#endif
    fnrpc_fnserverbtreemapsearch_1 (
	&InArguments,
#ifdef MULTITHREAD
	&Result,
#endif
	__pClient__ )
#ifdef MULTITHREAD
	== RPC_SUCCESS ) ? &Result : NULL
#endif
	;

  if ( pResult == NULL ) {
    /* Error handling for a failed RPC call, */
    /* i.e. the server did not respond: */
    char	szError [ 256 ];
    sprintf ( szError, szFormatRpcFailed, __procedure__,
              clnt_sperror ( __pClient__, __szHost__ ) );
    __pClient__	= RPC_CLIENT_DESTROY ( __pClient__ );
    RPC_CLIENT_CERROR ( szContRpcFailed, szError );
    Result	= ZeroResult;
    return Result.ReturnValue;
  }
#ifndef MULTITHREAD
  Result	= * pResult;
#endif


  if ( pResult && pResult->nErrorLvl ) {
    /* Server returned a user error message: */
    char	szErrorMsg [ 1024 ];
    strncpy ( szErrorMsg,
              ( pResult->pszErrorMsg && pResult->pszErrorMsg [ 0 ] ) ?
              (LPCSTR) pResult->pszErrorMsg : (LPCSTR) szEmpty,
              sizeof ( szErrorMsg ) );
    szErrorMsg [ sizeof ( szErrorMsg ) - 1 ]	= (char) 0;
    xdr_free ( (xdrproc_t) xdr_fnServerBtreemapSearch_rets, (char *) pResult );
    RPC_CLIENT_SERROR ( pResult->nErrorLvl, __procedure__,
                        szErrorMsg );
  } else {
    xdr_free ( (xdrproc_t) xdr_fnServerBtreemapSearch_rets, (char *) pResult );
  }

  return Result.ReturnValue;

} /* fnServerBtreemapSearch */



int DLLEXPORT fnServerBtreemapSearchByFloat
	(SHORTOBJID oShortObjIdMapper ,
	  SHORTOBJID oShortObjIdHeap ,
	  SHORTOBJID oShortObjIdBTree ,
	  float fKeyLower ,
	  SHTYPETAG nTypeTagKeyLower ,
	  COMPARETAG eCompareLower ,
	  float fKeyUpper ,
	  SHTYPETAG nTypeTagKeyUpper ,
	  COMPARETAG eCompareUpper ,
	  bool_t bDescending)
{
  static const char	__procedure__[]	= "client:fnServerBtreemapSearchByFloat";
  static fnServerBtreemapSearchByFloat_rets	ZeroResult;
  fnServerBtreemapSearchByFloat_rets		* pResult = NULL;
  fnServerBtreemapSearchByFloat_rets		Result = ZeroResult;
  fnServerBtreemapSearchByFloat_args	InArguments;

  /* Client initialization: */
  if ( __bClientInitialize__ ) {
    __bClientInitialize__	= FALSE;
    RPC_CLIENT_INITIALIZE();
  }

#if	CLIENT_CREATE_BY_USER
  if ( __pClient__ == NULL ) {
    __pClient__	= RPC_CLIENT_CREATE ( __szHost__, __szTransport__ );
    if ( __pClient__ == NULL ) {
      /* Error handling for a not connected client: */
      char	szError [ 256 ];
      sprintf ( szError, szFormatNoServer, __procedure__ );
      RPC_CLIENT_ERROR ( szError );
      return Result.ReturnValue;
    }
  }
#else
  while ( __pClient__ == NULL ) {
    __pClient__	= RPC_CLIENT_CREATE ( __szHost__, __szTransport__ );
    if ( __pClient__ == NULL ) {
      /* Error handling for a not connected client: */
      char	szError [ 256 ];
      sprintf ( szError, szFormatNoServer, __procedure__ );
      RPC_CLIENT_CERROR ( szContNoServer, szError );
    }
  }
#endif	/* CLIENT_CREATE_BY_USER */

  /* Copy in the oShortObjIdMapper argument: */
  InArguments.oShortObjIdMapper	= oShortObjIdMapper;
  /* Copy in the oShortObjIdHeap argument: */
  InArguments.oShortObjIdHeap	= oShortObjIdHeap;
  /* Copy in the oShortObjIdBTree argument: */
  InArguments.oShortObjIdBTree	= oShortObjIdBTree;
  /* Copy in the fKeyLower argument: */
  InArguments.fKeyLower	= fKeyLower;
  /* Copy in the nTypeTagKeyLower argument: */
  InArguments.nTypeTagKeyLower	= nTypeTagKeyLower;
  /* Copy in the eCompareLower argument: */
  InArguments.eCompareLower	= eCompareLower;
  /* Copy in the fKeyUpper argument: */
  InArguments.fKeyUpper	= fKeyUpper;
  /* Copy in the nTypeTagKeyUpper argument: */
  InArguments.nTypeTagKeyUpper	= nTypeTagKeyUpper;
  /* Copy in the eCompareUpper argument: */
  InArguments.eCompareUpper	= eCompareUpper;
  /* Copy in the bDescending argument: */
  InArguments.bDescending	= bDescending;

  pResult	=
#ifdef MULTITHREAD
    (
#else
    (fnServerBtreemapSearchByFloat_rets *)
#endif
    fnrpc_fnserverbtreemapsearchbyfloat_1 (
	&InArguments,
#ifdef MULTITHREAD
	&Result,
#endif
	__pClient__ )
#ifdef MULTITHREAD
	== RPC_SUCCESS ) ? &Result : NULL
#endif
	;

  if ( pResult == NULL ) {
    /* Error handling for a failed RPC call, */
    /* i.e. the server did not respond: */
    char	szError [ 256 ];
    sprintf ( szError, szFormatRpcFailed, __procedure__,
              clnt_sperror ( __pClient__, __szHost__ ) );
    __pClient__	= RPC_CLIENT_DESTROY ( __pClient__ );
    RPC_CLIENT_CERROR ( szContRpcFailed, szError );
    Result	= ZeroResult;
    return Result.ReturnValue;
  }
#ifndef MULTITHREAD
  Result	= * pResult;
#endif


  if ( pResult && pResult->nErrorLvl ) {
    /* Server returned a user error message: */
    char	szErrorMsg [ 1024 ];
    strncpy ( szErrorMsg,
              ( pResult->pszErrorMsg && pResult->pszErrorMsg [ 0 ] ) ?
              (LPCSTR) pResult->pszErrorMsg : (LPCSTR) szEmpty,
              sizeof ( szErrorMsg ) );
    szErrorMsg [ sizeof ( szErrorMsg ) - 1 ]	= (char) 0;
    xdr_free ( (xdrproc_t) xdr_fnServerBtreemapSearchByFloat_rets, (char *) pResult );
    RPC_CLIENT_SERROR ( pResult->nErrorLvl, __procedure__,
                        szErrorMsg );
  } else {
    xdr_free ( (xdrproc_t) xdr_fnServerBtreemapSearchByFloat_rets, (char *) pResult );
  }

  return Result.ReturnValue;

} /* fnServerBtreemapSearchByFloat */



int DLLEXPORT fnServerBtreemapSearchByDouble
	(SHORTOBJID oShortObjIdMapper ,
	  SHORTOBJID oShortObjIdHeap ,
	  SHORTOBJID oShortObjIdBTree ,
	  double fKeyLower ,
	  COMPARETAG eCompareLower ,
	  SHTYPETAG nTypeTagKeyLower ,
	  double fKeyUpper ,
	  SHTYPETAG nTypeTagKeyUpper ,
	  COMPARETAG eCompareUpper ,
	  bool_t bDescending)
{
  static const char	__procedure__[]	= "client:fnServerBtreemapSearchByDouble";
  static fnServerBtreemapSearchByDouble_rets	ZeroResult;
  fnServerBtreemapSearchByDouble_rets		* pResult = NULL;
  fnServerBtreemapSearchByDouble_rets		Result = ZeroResult;
  fnServerBtreemapSearchByDouble_args	InArguments;

  /* Client initialization: */
  if ( __bClientInitialize__ ) {
    __bClientInitialize__	= FALSE;
    RPC_CLIENT_INITIALIZE();
  }

#if	CLIENT_CREATE_BY_USER
  if ( __pClient__ == NULL ) {
    __pClient__	= RPC_CLIENT_CREATE ( __szHost__, __szTransport__ );
    if ( __pClient__ == NULL ) {
      /* Error handling for a not connected client: */
      char	szError [ 256 ];
      sprintf ( szError, szFormatNoServer, __procedure__ );
      RPC_CLIENT_ERROR ( szError );
      return Result.ReturnValue;
    }
  }
#else
  while ( __pClient__ == NULL ) {
    __pClient__	= RPC_CLIENT_CREATE ( __szHost__, __szTransport__ );
    if ( __pClient__ == NULL ) {
      /* Error handling for a not connected client: */
      char	szError [ 256 ];
      sprintf ( szError, szFormatNoServer, __procedure__ );
      RPC_CLIENT_CERROR ( szContNoServer, szError );
    }
  }
#endif	/* CLIENT_CREATE_BY_USER */

  /* Copy in the oShortObjIdMapper argument: */
  InArguments.oShortObjIdMapper	= oShortObjIdMapper;
  /* Copy in the oShortObjIdHeap argument: */
  InArguments.oShortObjIdHeap	= oShortObjIdHeap;
  /* Copy in the oShortObjIdBTree argument: */
  InArguments.oShortObjIdBTree	= oShortObjIdBTree;
  /* Copy in the fKeyLower argument: */
  InArguments.fKeyLower	= fKeyLower;
  /* Copy in the eCompareLower argument: */
  InArguments.eCompareLower	= eCompareLower;
  /* Copy in the nTypeTagKeyLower argument: */
  InArguments.nTypeTagKeyLower	= nTypeTagKeyLower;
  /* Copy in the fKeyUpper argument: */
  InArguments.fKeyUpper	= fKeyUpper;
  /* Copy in the nTypeTagKeyUpper argument: */
  InArguments.nTypeTagKeyUpper	= nTypeTagKeyUpper;
  /* Copy in the eCompareUpper argument: */
  InArguments.eCompareUpper	= eCompareUpper;
  /* Copy in the bDescending argument: */
  InArguments.bDescending	= bDescending;

  pResult	=
#ifdef MULTITHREAD
    (
#else
    (fnServerBtreemapSearchByDouble_rets *)
#endif
    fnrpc_fnserverbtreemapsearchbydouble_1 (
	&InArguments,
#ifdef MULTITHREAD
	&Result,
#endif
	__pClient__ )
#ifdef MULTITHREAD
	== RPC_SUCCESS ) ? &Result : NULL
#endif
	;

  if ( pResult == NULL ) {
    /* Error handling for a failed RPC call, */
    /* i.e. the server did not respond: */
    char	szError [ 256 ];
    sprintf ( szError, szFormatRpcFailed, __procedure__,
              clnt_sperror ( __pClient__, __szHost__ ) );
    __pClient__	= RPC_CLIENT_DESTROY ( __pClient__ );
    RPC_CLIENT_CERROR ( szContRpcFailed, szError );
    Result	= ZeroResult;
    return Result.ReturnValue;
  }
#ifndef MULTITHREAD
  Result	= * pResult;
#endif


  if ( pResult && pResult->nErrorLvl ) {
    /* Server returned a user error message: */
    char	szErrorMsg [ 1024 ];
    strncpy ( szErrorMsg,
              ( pResult->pszErrorMsg && pResult->pszErrorMsg [ 0 ] ) ?
              (LPCSTR) pResult->pszErrorMsg : (LPCSTR) szEmpty,
              sizeof ( szErrorMsg ) );
    szErrorMsg [ sizeof ( szErrorMsg ) - 1 ]	= (char) 0;
    xdr_free ( (xdrproc_t) xdr_fnServerBtreemapSearchByDouble_rets, (char *) pResult );
    RPC_CLIENT_SERROR ( pResult->nErrorLvl, __procedure__,
                        szErrorMsg );
  } else {
    xdr_free ( (xdrproc_t) xdr_fnServerBtreemapSearchByDouble_rets, (char *) pResult );
  }

  return Result.ReturnValue;

} /* fnServerBtreemapSearchByDouble */



int DLLEXPORT fnServerBtreemapSearchByString
	(SHORTOBJID oShortObjIdMapper ,
	  SHORTOBJID oShortObjIdHeap ,
	  SHORTOBJID oShortObjIdBTree ,
	  string_t /* string_t<@conststring@> */ szKeyLower ,
	  SHTYPETAG nTypeTagKeyLower ,
	  COMPARETAG eCompareLower ,
	  string_t /* string_t<@conststring@> */ szKeyUpper ,
	  SHTYPETAG nTypeTagKeyUpper ,
	  COMPARETAG eCompareUpper ,
	  bool_t bDescending)
{
  static const char	__procedure__[]	= "client:fnServerBtreemapSearchByString";
  static fnServerBtreemapSearchByString_rets	ZeroResult;
  fnServerBtreemapSearchByString_rets		* pResult = NULL;
  fnServerBtreemapSearchByString_rets		Result = ZeroResult;
  fnServerBtreemapSearchByString_args	InArguments;

  /* Client initialization: */
  if ( __bClientInitialize__ ) {
    __bClientInitialize__	= FALSE;
    RPC_CLIENT_INITIALIZE();
  }

#if	CLIENT_CREATE_BY_USER
  if ( __pClient__ == NULL ) {
    __pClient__	= RPC_CLIENT_CREATE ( __szHost__, __szTransport__ );
    if ( __pClient__ == NULL ) {
      /* Error handling for a not connected client: */
      char	szError [ 256 ];
      sprintf ( szError, szFormatNoServer, __procedure__ );
      RPC_CLIENT_ERROR ( szError );
      return Result.ReturnValue;
    }
  }
#else
  while ( __pClient__ == NULL ) {
    __pClient__	= RPC_CLIENT_CREATE ( __szHost__, __szTransport__ );
    if ( __pClient__ == NULL ) {
      /* Error handling for a not connected client: */
      char	szError [ 256 ];
      sprintf ( szError, szFormatNoServer, __procedure__ );
      RPC_CLIENT_CERROR ( szContNoServer, szError );
    }
  }
#endif	/* CLIENT_CREATE_BY_USER */

  /* Copy in the oShortObjIdMapper argument: */
  InArguments.oShortObjIdMapper	= oShortObjIdMapper;
  /* Copy in the oShortObjIdHeap argument: */
  InArguments.oShortObjIdHeap	= oShortObjIdHeap;
  /* Copy in the oShortObjIdBTree argument: */
  InArguments.oShortObjIdBTree	= oShortObjIdBTree;
  /* Copy in the szKeyLower argument: */
  InArguments.szKeyLower	= szKeyLower;
  if ( szKeyLower == NULL ) {
    /* Error handling for passing a NULL string pointer: */
    char	szError [ 256 ];
    InArguments.szKeyLower	= (LPSTR) szEmpty;
    sprintf ( szError, szFormatNullString,
              __procedure__, "szKeyLower" );
    RPC_CLIENT_CERROR ( szContNullString, szError );
  }
  /* Copy in the nTypeTagKeyLower argument: */
  InArguments.nTypeTagKeyLower	= nTypeTagKeyLower;
  /* Copy in the eCompareLower argument: */
  InArguments.eCompareLower	= eCompareLower;
  /* Copy in the szKeyUpper argument: */
  InArguments.szKeyUpper	= szKeyUpper;
  if ( szKeyUpper == NULL ) {
    /* Error handling for passing a NULL string pointer: */
    char	szError [ 256 ];
    InArguments.szKeyUpper	= (LPSTR) szEmpty;
    sprintf ( szError, szFormatNullString,
              __procedure__, "szKeyUpper" );
    RPC_CLIENT_CERROR ( szContNullString, szError );
  }
  /* Copy in the nTypeTagKeyUpper argument: */
  InArguments.nTypeTagKeyUpper	= nTypeTagKeyUpper;
  /* Copy in the eCompareUpper argument: */
  InArguments.eCompareUpper	= eCompareUpper;
  /* Copy in the bDescending argument: */
  InArguments.bDescending	= bDescending;

  pResult	=
#ifdef MULTITHREAD
    (
#else
    (fnServerBtreemapSearchByString_rets *)
#endif
    fnrpc_fnserverbtreemapsearchbystring_1 (
	&InArguments,
#ifdef MULTITHREAD
	&Result,
#endif
	__pClient__ )
#ifdef MULTITHREAD
	== RPC_SUCCESS ) ? &Result : NULL
#endif
	;

  if ( pResult == NULL ) {
    /* Error handling for a failed RPC call, */
    /* i.e. the server did not respond: */
    char	szError [ 256 ];
    sprintf ( szError, szFormatRpcFailed, __procedure__,
              clnt_sperror ( __pClient__, __szHost__ ) );
    __pClient__	= RPC_CLIENT_DESTROY ( __pClient__ );
    RPC_CLIENT_CERROR ( szContRpcFailed, szError );
    Result	= ZeroResult;
    return Result.ReturnValue;
  }
#ifndef MULTITHREAD
  Result	= * pResult;
#endif


  if ( pResult && pResult->nErrorLvl ) {
    /* Server returned a user error message: */
    char	szErrorMsg [ 1024 ];
    strncpy ( szErrorMsg,
              ( pResult->pszErrorMsg && pResult->pszErrorMsg [ 0 ] ) ?
              (LPCSTR) pResult->pszErrorMsg : (LPCSTR) szEmpty,
              sizeof ( szErrorMsg ) );
    szErrorMsg [ sizeof ( szErrorMsg ) - 1 ]	= (char) 0;
    xdr_free ( (xdrproc_t) xdr_fnServerBtreemapSearchByString_rets, (char *) pResult );
    RPC_CLIENT_SERROR ( pResult->nErrorLvl, __procedure__,
                        szErrorMsg );
  } else {
    xdr_free ( (xdrproc_t) xdr_fnServerBtreemapSearchByString_rets, (char *) pResult );
  }

  return Result.ReturnValue;

} /* fnServerBtreemapSearchByString */



int DLLEXPORT fnServerBtreemapSeek
	(SHORTOBJID oShortObjIdHeap ,
	  SHORTOBJID oShortObjIdMapper ,
	  int nIncrement ,
	  SEEK eOrigin ,
	  int * pnValueKey ,
	  SHTYPETAG * pnTypeTagKey ,
	  int * pnValueData ,
	  SHTYPETAG * pnTypeTagData)
{
  static const char	__procedure__[]	= "client:fnServerBtreemapSeek";
  static fnServerBtreemapSeek_rets	ZeroResult;
  fnServerBtreemapSeek_rets		* pResult = NULL;
  fnServerBtreemapSeek_rets		Result = ZeroResult;
  fnServerBtreemapSeek_args	InArguments;

  /* Client initialization: */
  if ( __bClientInitialize__ ) {
    __bClientInitialize__	= FALSE;
    RPC_CLIENT_INITIALIZE();
  }

#if	CLIENT_CREATE_BY_USER
  if ( __pClient__ == NULL ) {
    __pClient__	= RPC_CLIENT_CREATE ( __szHost__, __szTransport__ );
    if ( __pClient__ == NULL ) {
      /* Error handling for a not connected client: */
      char	szError [ 256 ];
      sprintf ( szError, szFormatNoServer, __procedure__ );
      RPC_CLIENT_ERROR ( szError );
      return Result.ReturnValue;
    }
  }
#else
  while ( __pClient__ == NULL ) {
    __pClient__	= RPC_CLIENT_CREATE ( __szHost__, __szTransport__ );
    if ( __pClient__ == NULL ) {
      /* Error handling for a not connected client: */
      char	szError [ 256 ];
      sprintf ( szError, szFormatNoServer, __procedure__ );
      RPC_CLIENT_CERROR ( szContNoServer, szError );
    }
  }
#endif	/* CLIENT_CREATE_BY_USER */

  /* Copy in the oShortObjIdHeap argument: */
  InArguments.oShortObjIdHeap	= oShortObjIdHeap;
  /* Copy in the oShortObjIdMapper argument: */
  InArguments.oShortObjIdMapper	= oShortObjIdMapper;
  /* Copy in the nIncrement argument: */
  InArguments.nIncrement	= nIncrement;
  /* Copy in the eOrigin argument: */
  InArguments.eOrigin	= eOrigin;

  pResult	=
#ifdef MULTITHREAD
    (
#else
    (fnServerBtreemapSeek_rets *)
#endif
    fnrpc_fnserverbtreemapseek_1 (
	&InArguments,
#ifdef MULTITHREAD
	&Result,
#endif
	__pClient__ )
#ifdef MULTITHREAD
	== RPC_SUCCESS ) ? &Result : NULL
#endif
	;

  if ( pResult == NULL ) {
    /* Error handling for a failed RPC call, */
    /* i.e. the server did not respond: */
    char	szError [ 256 ];
    sprintf ( szError, szFormatRpcFailed, __procedure__,
              clnt_sperror ( __pClient__, __szHost__ ) );
    __pClient__	= RPC_CLIENT_DESTROY ( __pClient__ );
    RPC_CLIENT_CERROR ( szContRpcFailed, szError );
    Result	= ZeroResult;
    return Result.ReturnValue;
  }
#ifndef MULTITHREAD
  Result	= * pResult;
#endif

  /* Copy out the pnValueKey argument: */
  if ( ! ( 
       pnValueKey == NULL ) ) {
    *pnValueKey	= pResult->pnValueKey;
  }
  /* Copy out the pnTypeTagKey argument: */
  if ( ! ( 
       pnTypeTagKey == NULL ) ) {
    *pnTypeTagKey	= pResult->pnTypeTagKey;
  }
  /* Copy out the pnValueData argument: */
  if ( ! ( 
       pnValueData == NULL ) ) {
    *pnValueData	= pResult->pnValueData;
  }
  /* Copy out the pnTypeTagData argument: */
  if ( ! ( 
       pnTypeTagData == NULL ) ) {
    *pnTypeTagData	= pResult->pnTypeTagData;
  }

  if ( pResult && pResult->nErrorLvl ) {
    /* Server returned a user error message: */
    char	szErrorMsg [ 1024 ];
    strncpy ( szErrorMsg,
              ( pResult->pszErrorMsg && pResult->pszErrorMsg [ 0 ] ) ?
              (LPCSTR) pResult->pszErrorMsg : (LPCSTR) szEmpty,
              sizeof ( szErrorMsg ) );
    szErrorMsg [ sizeof ( szErrorMsg ) - 1 ]	= (char) 0;
    xdr_free ( (xdrproc_t) xdr_fnServerBtreemapSeek_rets, (char *) pResult );
    RPC_CLIENT_SERROR ( pResult->nErrorLvl, __procedure__,
                        szErrorMsg );
  } else {
    xdr_free ( (xdrproc_t) xdr_fnServerBtreemapSeek_rets, (char *) pResult );
  }
  if ( 
       pnValueKey == NULL ) {
    /* Error handling for passing a NULL pointer on */
    /* out argument: */
    char	szError [ 256 ];
    sprintf ( szError, szFormatNullPassed,
              __procedure__, "pnValueKey" );
    RPC_CLIENT_CERROR ( szContNullOutPassed, szError );
  }
  if ( 
       pnTypeTagKey == NULL ) {
    /* Error handling for passing a NULL pointer on */
    /* out argument: */
    char	szError [ 256 ];
    sprintf ( szError, szFormatNullPassed,
              __procedure__, "pnTypeTagKey" );
    RPC_CLIENT_CERROR ( szContNullOutPassed, szError );
  }
  if ( 
       pnValueData == NULL ) {
    /* Error handling for passing a NULL pointer on */
    /* out argument: */
    char	szError [ 256 ];
    sprintf ( szError, szFormatNullPassed,
              __procedure__, "pnValueData" );
    RPC_CLIENT_CERROR ( szContNullOutPassed, szError );
  }
  if ( 
       pnTypeTagData == NULL ) {
    /* Error handling for passing a NULL pointer on */
    /* out argument: */
    char	szError [ 256 ];
    sprintf ( szError, szFormatNullPassed,
              __procedure__, "pnTypeTagData" );
    RPC_CLIENT_CERROR ( szContNullOutPassed, szError );
  }

  return Result.ReturnValue;

} /* fnServerBtreemapSeek */



int DLLEXPORT fnServerBtreemapSeekSet
	(SHORTOBJID oShortObjIdHeap ,
	  SHORTOBJID oShortObjIdMapper ,
	  int nIncrement ,
	  SEEK eOrigin ,
	  int nValueData ,
	  SHTYPETAG nTypeTagData)
{
  static const char	__procedure__[]	= "client:fnServerBtreemapSeekSet";
  static fnServerBtreemapSeekSet_rets	ZeroResult;
  fnServerBtreemapSeekSet_rets		* pResult = NULL;
  fnServerBtreemapSeekSet_rets		Result = ZeroResult;
  fnServerBtreemapSeekSet_args	InArguments;

  /* Client initialization: */
  if ( __bClientInitialize__ ) {
    __bClientInitialize__	= FALSE;
    RPC_CLIENT_INITIALIZE();
  }

#if	CLIENT_CREATE_BY_USER
  if ( __pClient__ == NULL ) {
    __pClient__	= RPC_CLIENT_CREATE ( __szHost__, __szTransport__ );
    if ( __pClient__ == NULL ) {
      /* Error handling for a not connected client: */
      char	szError [ 256 ];
      sprintf ( szError, szFormatNoServer, __procedure__ );
      RPC_CLIENT_ERROR ( szError );
      return Result.ReturnValue;
    }
  }
#else
  while ( __pClient__ == NULL ) {
    __pClient__	= RPC_CLIENT_CREATE ( __szHost__, __szTransport__ );
    if ( __pClient__ == NULL ) {
      /* Error handling for a not connected client: */
      char	szError [ 256 ];
      sprintf ( szError, szFormatNoServer, __procedure__ );
      RPC_CLIENT_CERROR ( szContNoServer, szError );
    }
  }
#endif	/* CLIENT_CREATE_BY_USER */

  /* Copy in the oShortObjIdHeap argument: */
  InArguments.oShortObjIdHeap	= oShortObjIdHeap;
  /* Copy in the oShortObjIdMapper argument: */
  InArguments.oShortObjIdMapper	= oShortObjIdMapper;
  /* Copy in the nIncrement argument: */
  InArguments.nIncrement	= nIncrement;
  /* Copy in the eOrigin argument: */
  InArguments.eOrigin	= eOrigin;
  /* Copy in the nValueData argument: */
  InArguments.nValueData	= nValueData;
  /* Copy in the nTypeTagData argument: */
  InArguments.nTypeTagData	= nTypeTagData;

  pResult	=
#ifdef MULTITHREAD
    (
#else
    (fnServerBtreemapSeekSet_rets *)
#endif
    fnrpc_fnserverbtreemapseekset_1 (
	&InArguments,
#ifdef MULTITHREAD
	&Result,
#endif
	__pClient__ )
#ifdef MULTITHREAD
	== RPC_SUCCESS ) ? &Result : NULL
#endif
	;

  if ( pResult == NULL ) {
    /* Error handling for a failed RPC call, */
    /* i.e. the server did not respond: */
    char	szError [ 256 ];
    sprintf ( szError, szFormatRpcFailed, __procedure__,
              clnt_sperror ( __pClient__, __szHost__ ) );
    __pClient__	= RPC_CLIENT_DESTROY ( __pClient__ );
    RPC_CLIENT_CERROR ( szContRpcFailed, szError );
    Result	= ZeroResult;
    return Result.ReturnValue;
  }
#ifndef MULTITHREAD
  Result	= * pResult;
#endif


  if ( pResult && pResult->nErrorLvl ) {
    /* Server returned a user error message: */
    char	szErrorMsg [ 1024 ];
    strncpy ( szErrorMsg,
              ( pResult->pszErrorMsg && pResult->pszErrorMsg [ 0 ] ) ?
              (LPCSTR) pResult->pszErrorMsg : (LPCSTR) szEmpty,
              sizeof ( szErrorMsg ) );
    szErrorMsg [ sizeof ( szErrorMsg ) - 1 ]	= (char) 0;
    xdr_free ( (xdrproc_t) xdr_fnServerBtreemapSeekSet_rets, (char *) pResult );
    RPC_CLIENT_SERROR ( pResult->nErrorLvl, __procedure__,
                        szErrorMsg );
  } else {
    xdr_free ( (xdrproc_t) xdr_fnServerBtreemapSeekSet_rets, (char *) pResult );
  }

  return Result.ReturnValue;

} /* fnServerBtreemapSeekSet */



int DLLEXPORT fnServerBtreemapFirst
	(SHORTOBJID * lpoShortObjIdMapper ,
	  SHORTOBJID oShortObjIdHeap ,
	  SHORTOBJID oShortObjIdBTree ,
	  int nValueKeyLower ,
	  SHTYPETAG nTypeTagKeyLower ,
	  COMPARETAG eCompareLower ,
	  int nValueKeyUpper ,
	  SHTYPETAG nTypeTagKeyUpper ,
	  COMPARETAG eCompareUpper ,
	  bool_t bDescending ,
	  int nMap ,
	  int * /* _vector_t<nMap> */  pnValueKey ,
	  u_int * /* _vector_t<nMap> */  pnTypeTagKey ,
	  int * /* _vector_t<nMap> */  pnValueData ,
	  u_int * /* _vector_t<nMap> */  pnTypeTagData)
{
  static const char	__procedure__[]	= "client:fnServerBtreemapFirst";
  static fnServerBtreemapFirst_rets	ZeroResult;
  fnServerBtreemapFirst_rets		* pResult = NULL;
  fnServerBtreemapFirst_rets		Result = ZeroResult;
  fnServerBtreemapFirst_args	InArguments;

  /* Client initialization: */
  if ( __bClientInitialize__ ) {
    __bClientInitialize__	= FALSE;
    RPC_CLIENT_INITIALIZE();
  }

#if	CLIENT_CREATE_BY_USER
  if ( __pClient__ == NULL ) {
    __pClient__	= RPC_CLIENT_CREATE ( __szHost__, __szTransport__ );
    if ( __pClient__ == NULL ) {
      /* Error handling for a not connected client: */
      char	szError [ 256 ];
      sprintf ( szError, szFormatNoServer, __procedure__ );
      RPC_CLIENT_ERROR ( szError );
      return Result.ReturnValue;
    }
  }
#else
  while ( __pClient__ == NULL ) {
    __pClient__	= RPC_CLIENT_CREATE ( __szHost__, __szTransport__ );
    if ( __pClient__ == NULL ) {
      /* Error handling for a not connected client: */
      char	szError [ 256 ];
      sprintf ( szError, szFormatNoServer, __procedure__ );
      RPC_CLIENT_CERROR ( szContNoServer, szError );
    }
  }
#endif	/* CLIENT_CREATE_BY_USER */

  /* Copy in the oShortObjIdHeap argument: */
  InArguments.oShortObjIdHeap	= oShortObjIdHeap;
  /* Copy in the oShortObjIdBTree argument: */
  InArguments.oShortObjIdBTree	= oShortObjIdBTree;
  /* Copy in the nValueKeyLower argument: */
  InArguments.nValueKeyLower	= nValueKeyLower;
  /* Copy in the nTypeTagKeyLower argument: */
  InArguments.nTypeTagKeyLower	= nTypeTagKeyLower;
  /* Copy in the eCompareLower argument: */
  InArguments.eCompareLower	= eCompareLower;
  /* Copy in the nValueKeyUpper argument: */
  InArguments.nValueKeyUpper	= nValueKeyUpper;
  /* Copy in the nTypeTagKeyUpper argument: */
  InArguments.nTypeTagKeyUpper	= nTypeTagKeyUpper;
  /* Copy in the eCompareUpper argument: */
  InArguments.eCompareUpper	= eCompareUpper;
  /* Copy in the bDescending argument: */
  InArguments.bDescending	= bDescending;
  /* Copy in the nMap argument: */
  InArguments.nMap	= nMap;
  InArguments.pnValueKeySize	= nMap;
  InArguments.pnTypeTagKeySize	= nMap;
  InArguments.pnValueDataSize	= nMap;
  InArguments.pnTypeTagDataSize	= nMap;

  pResult	=
#ifdef MULTITHREAD
    (
#else
    (fnServerBtreemapFirst_rets *)
#endif
    fnrpc_fnserverbtreemapfirst_1 (
	&InArguments,
#ifdef MULTITHREAD
	&Result,
#endif
	__pClient__ )
#ifdef MULTITHREAD
	== RPC_SUCCESS ) ? &Result : NULL
#endif
	;

  if ( pResult == NULL ) {
    /* Error handling for a failed RPC call, */
    /* i.e. the server did not respond: */
    char	szError [ 256 ];
    sprintf ( szError, szFormatRpcFailed, __procedure__,
              clnt_sperror ( __pClient__, __szHost__ ) );
    __pClient__	= RPC_CLIENT_DESTROY ( __pClient__ );
    RPC_CLIENT_CERROR ( szContRpcFailed, szError );
    Result	= ZeroResult;
    return Result.ReturnValue;
  }
#ifndef MULTITHREAD
  Result	= * pResult;
#endif

  /* Copy out the lpoShortObjIdMapper argument: */
  if ( ! ( 
       lpoShortObjIdMapper == NULL ) ) {
    *lpoShortObjIdMapper	= pResult->lpoShortObjIdMapper;
  }
  /* Copy out the pnValueKey argument: */
  if ( ! ( 
       pResult->pnValueKey.int_vector_t_len != 0 &&
       pnValueKey == NULL ) ) {
    memcpy ( pnValueKey,
             pResult->pnValueKey.int_vector_t_val,
             MIN ( pResult->pnValueKey.int_vector_t_len,
                   nMap ) *
             SIZEOF ( *(pResult->pnValueKey.int_vector_t_val) ) );
  }
  /* Copy out the pnTypeTagKey argument: */
  if ( ! ( 
       pResult->pnTypeTagKey.u_int_vector_t_len != 0 &&
       pnTypeTagKey == NULL ) ) {
    memcpy ( pnTypeTagKey,
             pResult->pnTypeTagKey.u_int_vector_t_val,
             MIN ( pResult->pnTypeTagKey.u_int_vector_t_len,
                   nMap ) *
             SIZEOF ( *(pResult->pnTypeTagKey.u_int_vector_t_val) ) );
  }
  /* Copy out the pnValueData argument: */
  if ( ! ( 
       pResult->pnValueData.int_vector_t_len != 0 &&
       pnValueData == NULL ) ) {
    memcpy ( pnValueData,
             pResult->pnValueData.int_vector_t_val,
             MIN ( pResult->pnValueData.int_vector_t_len,
                   nMap ) *
             SIZEOF ( *(pResult->pnValueData.int_vector_t_val) ) );
  }
  /* Copy out the pnTypeTagData argument: */
  if ( ! ( 
       pResult->pnTypeTagData.u_int_vector_t_len != 0 &&
       pnTypeTagData == NULL ) ) {
    memcpy ( pnTypeTagData,
             pResult->pnTypeTagData.u_int_vector_t_val,
             MIN ( pResult->pnTypeTagData.u_int_vector_t_len,
                   nMap ) *
             SIZEOF ( *(pResult->pnTypeTagData.u_int_vector_t_val) ) );
  }

  if ( pResult && pResult->nErrorLvl ) {
    /* Server returned a user error message: */
    char	szErrorMsg [ 1024 ];
    strncpy ( szErrorMsg,
              ( pResult->pszErrorMsg && pResult->pszErrorMsg [ 0 ] ) ?
              (LPCSTR) pResult->pszErrorMsg : (LPCSTR) szEmpty,
              sizeof ( szErrorMsg ) );
    szErrorMsg [ sizeof ( szErrorMsg ) - 1 ]	= (char) 0;
    xdr_free ( (xdrproc_t) xdr_fnServerBtreemapFirst_rets, (char *) pResult );
    RPC_CLIENT_SERROR ( pResult->nErrorLvl, __procedure__,
                        szErrorMsg );
  } else {
    xdr_free ( (xdrproc_t) xdr_fnServerBtreemapFirst_rets, (char *) pResult );
  }
  if ( 
       lpoShortObjIdMapper == NULL ) {
    /* Error handling for passing a NULL pointer on */
    /* out argument: */
    char	szError [ 256 ];
    sprintf ( szError, szFormatNullPassed,
              __procedure__, "lpoShortObjIdMapper" );
    RPC_CLIENT_CERROR ( szContNullOutPassed, szError );
  }
  if ( 
       pResult->pnValueKey.int_vector_t_len != 0 &&
       pnValueKey == NULL ) {
    /* Error handling for passing a NULL pointer on */
    /* out argument: */
    char	szError [ 256 ];
    sprintf ( szError, szFormatNullPassed,
              __procedure__, "pnValueKey" );
    RPC_CLIENT_CERROR ( szContNullOutPassed, szError );
  } else if ( pResult->pnValueKey.int_vector_t_len > nMap ) {
      /* Error handling for an output buffer overflow, */
      /* i.e. the buffer size passed is too small: */
      /* For example, signal a CERROR here ... */
      char	szError [ 256 ];
      sprintf ( szError, szFormatBufferOverflow,
                __procedure__, "pnValueKey", 
                nMap, 
                pResult->pnValueKey.int_vector_t_len );
      RPC_CLIENT_CERROR ( szContBufferOverflow, szError );
  }
  if ( 
       pResult->pnTypeTagKey.u_int_vector_t_len != 0 &&
       pnTypeTagKey == NULL ) {
    /* Error handling for passing a NULL pointer on */
    /* out argument: */
    char	szError [ 256 ];
    sprintf ( szError, szFormatNullPassed,
              __procedure__, "pnTypeTagKey" );
    RPC_CLIENT_CERROR ( szContNullOutPassed, szError );
  } else if ( pResult->pnTypeTagKey.u_int_vector_t_len > nMap ) {
      /* Error handling for an output buffer overflow, */
      /* i.e. the buffer size passed is too small: */
      /* For example, signal a CERROR here ... */
      char	szError [ 256 ];
      sprintf ( szError, szFormatBufferOverflow,
                __procedure__, "pnTypeTagKey", 
                nMap, 
                pResult->pnTypeTagKey.u_int_vector_t_len );
      RPC_CLIENT_CERROR ( szContBufferOverflow, szError );
  }
  if ( 
       pResult->pnValueData.int_vector_t_len != 0 &&
       pnValueData == NULL ) {
    /* Error handling for passing a NULL pointer on */
    /* out argument: */
    char	szError [ 256 ];
    sprintf ( szError, szFormatNullPassed,
              __procedure__, "pnValueData" );
    RPC_CLIENT_CERROR ( szContNullOutPassed, szError );
  } else if ( pResult->pnValueData.int_vector_t_len > nMap ) {
      /* Error handling for an output buffer overflow, */
      /* i.e. the buffer size passed is too small: */
      /* For example, signal a CERROR here ... */
      char	szError [ 256 ];
      sprintf ( szError, szFormatBufferOverflow,
                __procedure__, "pnValueData", 
                nMap, 
                pResult->pnValueData.int_vector_t_len );
      RPC_CLIENT_CERROR ( szContBufferOverflow, szError );
  }
  if ( 
       pResult->pnTypeTagData.u_int_vector_t_len != 0 &&
       pnTypeTagData == NULL ) {
    /* Error handling for passing a NULL pointer on */
    /* out argument: */
    char	szError [ 256 ];
    sprintf ( szError, szFormatNullPassed,
              __procedure__, "pnTypeTagData" );
    RPC_CLIENT_CERROR ( szContNullOutPassed, szError );
  } else if ( pResult->pnTypeTagData.u_int_vector_t_len > nMap ) {
      /* Error handling for an output buffer overflow, */
      /* i.e. the buffer size passed is too small: */
      /* For example, signal a CERROR here ... */
      char	szError [ 256 ];
      sprintf ( szError, szFormatBufferOverflow,
                __procedure__, "pnTypeTagData", 
                nMap, 
                pResult->pnTypeTagData.u_int_vector_t_len );
      RPC_CLIENT_CERROR ( szContBufferOverflow, szError );
  }

  return Result.ReturnValue;

} /* fnServerBtreemapFirst */



int DLLEXPORT fnServerBtreemapFirstByFloat
	(SHORTOBJID * lpoShortObjIdMapper ,
	  SHORTOBJID oShortObjIdHeap ,
	  SHORTOBJID oShortObjIdBTree ,
	  float fKeyLower ,
	  SHTYPETAG nTypeTagKeyLower ,
	  COMPARETAG eCompareLower ,
	  float fKeyUpper ,
	  SHTYPETAG nTypeTagKeyUpper ,
	  COMPARETAG eCompareUpper ,
	  bool_t bDescending ,
	  int nMap ,
	  int * /* _vector_t<nMap> */  pnValueKey ,
	  u_int * /* _vector_t<nMap> */  pnTypeTagKey ,
	  int * /* _vector_t<nMap> */  pnValueData ,
	  u_int * /* _vector_t<nMap> */  pnTypeTagData)
{
  static const char	__procedure__[]	= "client:fnServerBtreemapFirstByFloat";
  static fnServerBtreemapFirstByFloat_rets	ZeroResult;
  fnServerBtreemapFirstByFloat_rets		* pResult = NULL;
  fnServerBtreemapFirstByFloat_rets		Result = ZeroResult;
  fnServerBtreemapFirstByFloat_args	InArguments;

  /* Client initialization: */
  if ( __bClientInitialize__ ) {
    __bClientInitialize__	= FALSE;
    RPC_CLIENT_INITIALIZE();
  }

#if	CLIENT_CREATE_BY_USER
  if ( __pClient__ == NULL ) {
    __pClient__	= RPC_CLIENT_CREATE ( __szHost__, __szTransport__ );
    if ( __pClient__ == NULL ) {
      /* Error handling for a not connected client: */
      char	szError [ 256 ];
      sprintf ( szError, szFormatNoServer, __procedure__ );
      RPC_CLIENT_ERROR ( szError );
      return Result.ReturnValue;
    }
  }
#else
  while ( __pClient__ == NULL ) {
    __pClient__	= RPC_CLIENT_CREATE ( __szHost__, __szTransport__ );
    if ( __pClient__ == NULL ) {
      /* Error handling for a not connected client: */
      char	szError [ 256 ];
      sprintf ( szError, szFormatNoServer, __procedure__ );
      RPC_CLIENT_CERROR ( szContNoServer, szError );
    }
  }
#endif	/* CLIENT_CREATE_BY_USER */

  /* Copy in the oShortObjIdHeap argument: */
  InArguments.oShortObjIdHeap	= oShortObjIdHeap;
  /* Copy in the oShortObjIdBTree argument: */
  InArguments.oShortObjIdBTree	= oShortObjIdBTree;
  /* Copy in the fKeyLower argument: */
  InArguments.fKeyLower	= fKeyLower;
  /* Copy in the nTypeTagKeyLower argument: */
  InArguments.nTypeTagKeyLower	= nTypeTagKeyLower;
  /* Copy in the eCompareLower argument: */
  InArguments.eCompareLower	= eCompareLower;
  /* Copy in the fKeyUpper argument: */
  InArguments.fKeyUpper	= fKeyUpper;
  /* Copy in the nTypeTagKeyUpper argument: */
  InArguments.nTypeTagKeyUpper	= nTypeTagKeyUpper;
  /* Copy in the eCompareUpper argument: */
  InArguments.eCompareUpper	= eCompareUpper;
  /* Copy in the bDescending argument: */
  InArguments.bDescending	= bDescending;
  /* Copy in the nMap argument: */
  InArguments.nMap	= nMap;
  InArguments.pnValueKeySize	= nMap;
  InArguments.pnTypeTagKeySize	= nMap;
  InArguments.pnValueDataSize	= nMap;
  InArguments.pnTypeTagDataSize	= nMap;

  pResult	=
#ifdef MULTITHREAD
    (
#else
    (fnServerBtreemapFirstByFloat_rets *)
#endif
    fnrpc_fnserverbtreemapfirstbyfloat_1 (
	&InArguments,
#ifdef MULTITHREAD
	&Result,
#endif
	__pClient__ )
#ifdef MULTITHREAD
	== RPC_SUCCESS ) ? &Result : NULL
#endif
	;

  if ( pResult == NULL ) {
    /* Error handling for a failed RPC call, */
    /* i.e. the server did not respond: */
    char	szError [ 256 ];
    sprintf ( szError, szFormatRpcFailed, __procedure__,
              clnt_sperror ( __pClient__, __szHost__ ) );
    __pClient__	= RPC_CLIENT_DESTROY ( __pClient__ );
    RPC_CLIENT_CERROR ( szContRpcFailed, szError );
    Result	= ZeroResult;
    return Result.ReturnValue;
  }
#ifndef MULTITHREAD
  Result	= * pResult;
#endif

  /* Copy out the lpoShortObjIdMapper argument: */
  if ( ! ( 
       lpoShortObjIdMapper == NULL ) ) {
    *lpoShortObjIdMapper	= pResult->lpoShortObjIdMapper;
  }
  /* Copy out the pnValueKey argument: */
  if ( ! ( 
       pResult->pnValueKey.int_vector_t_len != 0 &&
       pnValueKey == NULL ) ) {
    memcpy ( pnValueKey,
             pResult->pnValueKey.int_vector_t_val,
             MIN ( pResult->pnValueKey.int_vector_t_len,
                   nMap ) *
             SIZEOF ( *(pResult->pnValueKey.int_vector_t_val) ) );
  }
  /* Copy out the pnTypeTagKey argument: */
  if ( ! ( 
       pResult->pnTypeTagKey.u_int_vector_t_len != 0 &&
       pnTypeTagKey == NULL ) ) {
    memcpy ( pnTypeTagKey,
             pResult->pnTypeTagKey.u_int_vector_t_val,
             MIN ( pResult->pnTypeTagKey.u_int_vector_t_len,
                   nMap ) *
             SIZEOF ( *(pResult->pnTypeTagKey.u_int_vector_t_val) ) );
  }
  /* Copy out the pnValueData argument: */
  if ( ! ( 
       pResult->pnValueData.int_vector_t_len != 0 &&
       pnValueData == NULL ) ) {
    memcpy ( pnValueData,
             pResult->pnValueData.int_vector_t_val,
             MIN ( pResult->pnValueData.int_vector_t_len,
                   nMap ) *
             SIZEOF ( *(pResult->pnValueData.int_vector_t_val) ) );
  }
  /* Copy out the pnTypeTagData argument: */
  if ( ! ( 
       pResult->pnTypeTagData.u_int_vector_t_len != 0 &&
       pnTypeTagData == NULL ) ) {
    memcpy ( pnTypeTagData,
             pResult->pnTypeTagData.u_int_vector_t_val,
             MIN ( pResult->pnTypeTagData.u_int_vector_t_len,
                   nMap ) *
             SIZEOF ( *(pResult->pnTypeTagData.u_int_vector_t_val) ) );
  }

  if ( pResult && pResult->nErrorLvl ) {
    /* Server returned a user error message: */
    char	szErrorMsg [ 1024 ];
    strncpy ( szErrorMsg,
              ( pResult->pszErrorMsg && pResult->pszErrorMsg [ 0 ] ) ?
              (LPCSTR) pResult->pszErrorMsg : (LPCSTR) szEmpty,
              sizeof ( szErrorMsg ) );
    szErrorMsg [ sizeof ( szErrorMsg ) - 1 ]	= (char) 0;
    xdr_free ( (xdrproc_t) xdr_fnServerBtreemapFirstByFloat_rets, (char *) pResult );
    RPC_CLIENT_SERROR ( pResult->nErrorLvl, __procedure__,
                        szErrorMsg );
  } else {
    xdr_free ( (xdrproc_t) xdr_fnServerBtreemapFirstByFloat_rets, (char *) pResult );
  }
  if ( 
       lpoShortObjIdMapper == NULL ) {
    /* Error handling for passing a NULL pointer on */
    /* out argument: */
    char	szError [ 256 ];
    sprintf ( szError, szFormatNullPassed,
              __procedure__, "lpoShortObjIdMapper" );
    RPC_CLIENT_CERROR ( szContNullOutPassed, szError );
  }
  if ( 
       pResult->pnValueKey.int_vector_t_len != 0 &&
       pnValueKey == NULL ) {
    /* Error handling for passing a NULL pointer on */
    /* out argument: */
    char	szError [ 256 ];
    sprintf ( szError, szFormatNullPassed,
              __procedure__, "pnValueKey" );
    RPC_CLIENT_CERROR ( szContNullOutPassed, szError );
  } else if ( pResult->pnValueKey.int_vector_t_len > nMap ) {
      /* Error handling for an output buffer overflow, */
      /* i.e. the buffer size passed is too small: */
      /* For example, signal a CERROR here ... */
      char	szError [ 256 ];
      sprintf ( szError, szFormatBufferOverflow,
                __procedure__, "pnValueKey", 
                nMap, 
                pResult->pnValueKey.int_vector_t_len );
      RPC_CLIENT_CERROR ( szContBufferOverflow, szError );
  }
  if ( 
       pResult->pnTypeTagKey.u_int_vector_t_len != 0 &&
       pnTypeTagKey == NULL ) {
    /* Error handling for passing a NULL pointer on */
    /* out argument: */
    char	szError [ 256 ];
    sprintf ( szError, szFormatNullPassed,
              __procedure__, "pnTypeTagKey" );
    RPC_CLIENT_CERROR ( szContNullOutPassed, szError );
  } else if ( pResult->pnTypeTagKey.u_int_vector_t_len > nMap ) {
      /* Error handling for an output buffer overflow, */
      /* i.e. the buffer size passed is too small: */
      /* For example, signal a CERROR here ... */
      char	szError [ 256 ];
      sprintf ( szError, szFormatBufferOverflow,
                __procedure__, "pnTypeTagKey", 
                nMap, 
                pResult->pnTypeTagKey.u_int_vector_t_len );
      RPC_CLIENT_CERROR ( szContBufferOverflow, szError );
  }
  if ( 
       pResult->pnValueData.int_vector_t_len != 0 &&
       pnValueData == NULL ) {
    /* Error handling for passing a NULL pointer on */
    /* out argument: */
    char	szError [ 256 ];
    sprintf ( szError, szFormatNullPassed,
              __procedure__, "pnValueData" );
    RPC_CLIENT_CERROR ( szContNullOutPassed, szError );
  } else if ( pResult->pnValueData.int_vector_t_len > nMap ) {
      /* Error handling for an output buffer overflow, */
      /* i.e. the buffer size passed is too small: */
      /* For example, signal a CERROR here ... */
      char	szError [ 256 ];
      sprintf ( szError, szFormatBufferOverflow,
                __procedure__, "pnValueData", 
                nMap, 
                pResult->pnValueData.int_vector_t_len );
      RPC_CLIENT_CERROR ( szContBufferOverflow, szError );
  }
  if ( 
       pResult->pnTypeTagData.u_int_vector_t_len != 0 &&
       pnTypeTagData == NULL ) {
    /* Error handling for passing a NULL pointer on */
    /* out argument: */
    char	szError [ 256 ];
    sprintf ( szError, szFormatNullPassed,
              __procedure__, "pnTypeTagData" );
    RPC_CLIENT_CERROR ( szContNullOutPassed, szError );
  } else if ( pResult->pnTypeTagData.u_int_vector_t_len > nMap ) {
      /* Error handling for an output buffer overflow, */
      /* i.e. the buffer size passed is too small: */
      /* For example, signal a CERROR here ... */
      char	szError [ 256 ];
      sprintf ( szError, szFormatBufferOverflow,
                __procedure__, "pnTypeTagData", 
                nMap, 
                pResult->pnTypeTagData.u_int_vector_t_len );
      RPC_CLIENT_CERROR ( szContBufferOverflow, szError );
  }

  return Result.ReturnValue;

} /* fnServerBtreemapFirstByFloat */



int DLLEXPORT fnServerBtreemapFirstByDouble
	(SHORTOBJID * lpoShortObjIdMapper ,
	  SHORTOBJID oShortObjIdHeap ,
	  SHORTOBJID oShortObjIdBTree ,
	  double fKeyLower ,
	  COMPARETAG eCompareLower ,
	  SHTYPETAG nTypeTagKeyLower ,
	  double fKeyUpper ,
	  SHTYPETAG nTypeTagKeyUpper ,
	  COMPARETAG eCompareUpper ,
	  bool_t bDescending ,
	  int nMap ,
	  int * /* _vector_t<nMap> */  pnValueKey ,
	  u_int * /* _vector_t<nMap> */  pnTypeTagKey ,
	  int * /* _vector_t<nMap> */  pnValueData ,
	  u_int * /* _vector_t<nMap> */  pnTypeTagData)
{
  static const char	__procedure__[]	= "client:fnServerBtreemapFirstByDouble";
  static fnServerBtreemapFirstByDouble_rets	ZeroResult;
  fnServerBtreemapFirstByDouble_rets		* pResult = NULL;
  fnServerBtreemapFirstByDouble_rets		Result = ZeroResult;
  fnServerBtreemapFirstByDouble_args	InArguments;

  /* Client initialization: */
  if ( __bClientInitialize__ ) {
    __bClientInitialize__	= FALSE;
    RPC_CLIENT_INITIALIZE();
  }

#if	CLIENT_CREATE_BY_USER
  if ( __pClient__ == NULL ) {
    __pClient__	= RPC_CLIENT_CREATE ( __szHost__, __szTransport__ );
    if ( __pClient__ == NULL ) {
      /* Error handling for a not connected client: */
      char	szError [ 256 ];
      sprintf ( szError, szFormatNoServer, __procedure__ );
      RPC_CLIENT_ERROR ( szError );
      return Result.ReturnValue;
    }
  }
#else
  while ( __pClient__ == NULL ) {
    __pClient__	= RPC_CLIENT_CREATE ( __szHost__, __szTransport__ );
    if ( __pClient__ == NULL ) {
      /* Error handling for a not connected client: */
      char	szError [ 256 ];
      sprintf ( szError, szFormatNoServer, __procedure__ );
      RPC_CLIENT_CERROR ( szContNoServer, szError );
    }
  }
#endif	/* CLIENT_CREATE_BY_USER */

  /* Copy in the oShortObjIdHeap argument: */
  InArguments.oShortObjIdHeap	= oShortObjIdHeap;
  /* Copy in the oShortObjIdBTree argument: */
  InArguments.oShortObjIdBTree	= oShortObjIdBTree;
  /* Copy in the fKeyLower argument: */
  InArguments.fKeyLower	= fKeyLower;
  /* Copy in the eCompareLower argument: */
  InArguments.eCompareLower	= eCompareLower;
  /* Copy in the nTypeTagKeyLower argument: */
  InArguments.nTypeTagKeyLower	= nTypeTagKeyLower;
  /* Copy in the fKeyUpper argument: */
  InArguments.fKeyUpper	= fKeyUpper;
  /* Copy in the nTypeTagKeyUpper argument: */
  InArguments.nTypeTagKeyUpper	= nTypeTagKeyUpper;
  /* Copy in the eCompareUpper argument: */
  InArguments.eCompareUpper	= eCompareUpper;
  /* Copy in the bDescending argument: */
  InArguments.bDescending	= bDescending;
  /* Copy in the nMap argument: */
  InArguments.nMap	= nMap;
  InArguments.pnValueKeySize	= nMap;
  InArguments.pnTypeTagKeySize	= nMap;
  InArguments.pnValueDataSize	= nMap;
  InArguments.pnTypeTagDataSize	= nMap;

  pResult	=
#ifdef MULTITHREAD
    (
#else
    (fnServerBtreemapFirstByDouble_rets *)
#endif
    fnrpc_fnserverbtreemapfirstbydouble_1 (
	&InArguments,
#ifdef MULTITHREAD
	&Result,
#endif
	__pClient__ )
#ifdef MULTITHREAD
	== RPC_SUCCESS ) ? &Result : NULL
#endif
	;

  if ( pResult == NULL ) {
    /* Error handling for a failed RPC call, */
    /* i.e. the server did not respond: */
    char	szError [ 256 ];
    sprintf ( szError, szFormatRpcFailed, __procedure__,
              clnt_sperror ( __pClient__, __szHost__ ) );
    __pClient__	= RPC_CLIENT_DESTROY ( __pClient__ );
    RPC_CLIENT_CERROR ( szContRpcFailed, szError );
    Result	= ZeroResult;
    return Result.ReturnValue;
  }
#ifndef MULTITHREAD
  Result	= * pResult;
#endif

  /* Copy out the lpoShortObjIdMapper argument: */
  if ( ! ( 
       lpoShortObjIdMapper == NULL ) ) {
    *lpoShortObjIdMapper	= pResult->lpoShortObjIdMapper;
  }
  /* Copy out the pnValueKey argument: */
  if ( ! ( 
       pResult->pnValueKey.int_vector_t_len != 0 &&
       pnValueKey == NULL ) ) {
    memcpy ( pnValueKey,
             pResult->pnValueKey.int_vector_t_val,
             MIN ( pResult->pnValueKey.int_vector_t_len,
                   nMap ) *
             SIZEOF ( *(pResult->pnValueKey.int_vector_t_val) ) );
  }
  /* Copy out the pnTypeTagKey argument: */
  if ( ! ( 
       pResult->pnTypeTagKey.u_int_vector_t_len != 0 &&
       pnTypeTagKey == NULL ) ) {
    memcpy ( pnTypeTagKey,
             pResult->pnTypeTagKey.u_int_vector_t_val,
             MIN ( pResult->pnTypeTagKey.u_int_vector_t_len,
                   nMap ) *
             SIZEOF ( *(pResult->pnTypeTagKey.u_int_vector_t_val) ) );
  }
  /* Copy out the pnValueData argument: */
  if ( ! ( 
       pResult->pnValueData.int_vector_t_len != 0 &&
       pnValueData == NULL ) ) {
    memcpy ( pnValueData,
             pResult->pnValueData.int_vector_t_val,
             MIN ( pResult->pnValueData.int_vector_t_len,
                   nMap ) *
             SIZEOF ( *(pResult->pnValueData.int_vector_t_val) ) );
  }
  /* Copy out the pnTypeTagData argument: */
  if ( ! ( 
       pResult->pnTypeTagData.u_int_vector_t_len != 0 &&
       pnTypeTagData == NULL ) ) {
    memcpy ( pnTypeTagData,
             pResult->pnTypeTagData.u_int_vector_t_val,
             MIN ( pResult->pnTypeTagData.u_int_vector_t_len,
                   nMap ) *
             SIZEOF ( *(pResult->pnTypeTagData.u_int_vector_t_val) ) );
  }

  if ( pResult && pResult->nErrorLvl ) {
    /* Server returned a user error message: */
    char	szErrorMsg [ 1024 ];
    strncpy ( szErrorMsg,
              ( pResult->pszErrorMsg && pResult->pszErrorMsg [ 0 ] ) ?
              (LPCSTR) pResult->pszErrorMsg : (LPCSTR) szEmpty,
              sizeof ( szErrorMsg ) );
    szErrorMsg [ sizeof ( szErrorMsg ) - 1 ]	= (char) 0;
    xdr_free ( (xdrproc_t) xdr_fnServerBtreemapFirstByDouble_rets, (char *) pResult );
    RPC_CLIENT_SERROR ( pResult->nErrorLvl, __procedure__,
                        szErrorMsg );
  } else {
    xdr_free ( (xdrproc_t) xdr_fnServerBtreemapFirstByDouble_rets, (char *) pResult );
  }
  if ( 
       lpoShortObjIdMapper == NULL ) {
    /* Error handling for passing a NULL pointer on */
    /* out argument: */
    char	szError [ 256 ];
    sprintf ( szError, szFormatNullPassed,
              __procedure__, "lpoShortObjIdMapper" );
    RPC_CLIENT_CERROR ( szContNullOutPassed, szError );
  }
  if ( 
       pResult->pnValueKey.int_vector_t_len != 0 &&
       pnValueKey == NULL ) {
    /* Error handling for passing a NULL pointer on */
    /* out argument: */
    char	szError [ 256 ];
    sprintf ( szError, szFormatNullPassed,
              __procedure__, "pnValueKey" );
    RPC_CLIENT_CERROR ( szContNullOutPassed, szError );
  } else if ( pResult->pnValueKey.int_vector_t_len > nMap ) {
      /* Error handling for an output buffer overflow, */
      /* i.e. the buffer size passed is too small: */
      /* For example, signal a CERROR here ... */
      char	szError [ 256 ];
      sprintf ( szError, szFormatBufferOverflow,
                __procedure__, "pnValueKey", 
                nMap, 
                pResult->pnValueKey.int_vector_t_len );
      RPC_CLIENT_CERROR ( szContBufferOverflow, szError );
  }
  if ( 
       pResult->pnTypeTagKey.u_int_vector_t_len != 0 &&
       pnTypeTagKey == NULL ) {
    /* Error handling for passing a NULL pointer on */
    /* out argument: */
    char	szError [ 256 ];
    sprintf ( szError, szFormatNullPassed,
              __procedure__, "pnTypeTagKey" );
    RPC_CLIENT_CERROR ( szContNullOutPassed, szError );
  } else if ( pResult->pnTypeTagKey.u_int_vector_t_len > nMap ) {
      /* Error handling for an output buffer overflow, */
      /* i.e. the buffer size passed is too small: */
      /* For example, signal a CERROR here ... */
      char	szError [ 256 ];
      sprintf ( szError, szFormatBufferOverflow,
                __procedure__, "pnTypeTagKey", 
                nMap, 
                pResult->pnTypeTagKey.u_int_vector_t_len );
      RPC_CLIENT_CERROR ( szContBufferOverflow, szError );
  }
  if ( 
       pResult->pnValueData.int_vector_t_len != 0 &&
       pnValueData == NULL ) {
    /* Error handling for passing a NULL pointer on */
    /* out argument: */
    char	szError [ 256 ];
    sprintf ( szError, szFormatNullPassed,
              __procedure__, "pnValueData" );
    RPC_CLIENT_CERROR ( szContNullOutPassed, szError );
  } else if ( pResult->pnValueData.int_vector_t_len > nMap ) {
      /* Error handling for an output buffer overflow, */
      /* i.e. the buffer size passed is too small: */
      /* For example, signal a CERROR here ... */
      char	szError [ 256 ];
      sprintf ( szError, szFormatBufferOverflow,
                __procedure__, "pnValueData", 
                nMap, 
                pResult->pnValueData.int_vector_t_len );
      RPC_CLIENT_CERROR ( szContBufferOverflow, szError );
  }
  if ( 
       pResult->pnTypeTagData.u_int_vector_t_len != 0 &&
       pnTypeTagData == NULL ) {
    /* Error handling for passing a NULL pointer on */
    /* out argument: */
    char	szError [ 256 ];
    sprintf ( szError, szFormatNullPassed,
              __procedure__, "pnTypeTagData" );
    RPC_CLIENT_CERROR ( szContNullOutPassed, szError );
  } else if ( pResult->pnTypeTagData.u_int_vector_t_len > nMap ) {
      /* Error handling for an output buffer overflow, */
      /* i.e. the buffer size passed is too small: */
      /* For example, signal a CERROR here ... */
      char	szError [ 256 ];
      sprintf ( szError, szFormatBufferOverflow,
                __procedure__, "pnTypeTagData", 
                nMap, 
                pResult->pnTypeTagData.u_int_vector_t_len );
      RPC_CLIENT_CERROR ( szContBufferOverflow, szError );
  }

  return Result.ReturnValue;

} /* fnServerBtreemapFirstByDouble */



int DLLEXPORT fnServerBtreemapFirstByString
	(SHORTOBJID * lpoShortObjIdMapper ,
	  SHORTOBJID oShortObjIdHeap ,
	  SHORTOBJID oShortObjIdBTree ,
	  string_t /* string_t<@conststring@> */ szKeyLower ,
	  SHTYPETAG nTypeTagKeyLower ,
	  COMPARETAG eCompareLower ,
	  string_t /* string_t<@conststring@> */ szKeyUpper ,
	  SHTYPETAG nTypeTagKeyUpper ,
	  COMPARETAG eCompareUpper ,
	  bool_t bDescending ,
	  int nMap ,
	  int * /* _vector_t<nMap> */  pnValueKey ,
	  u_int * /* _vector_t<nMap> */  pnTypeTagKey ,
	  int * /* _vector_t<nMap> */  pnValueData ,
	  u_int * /* _vector_t<nMap> */  pnTypeTagData)
{
  static const char	__procedure__[]	= "client:fnServerBtreemapFirstByString";
  static fnServerBtreemapFirstByString_rets	ZeroResult;
  fnServerBtreemapFirstByString_rets		* pResult = NULL;
  fnServerBtreemapFirstByString_rets		Result = ZeroResult;
  fnServerBtreemapFirstByString_args	InArguments;

  /* Client initialization: */
  if ( __bClientInitialize__ ) {
    __bClientInitialize__	= FALSE;
    RPC_CLIENT_INITIALIZE();
  }

#if	CLIENT_CREATE_BY_USER
  if ( __pClient__ == NULL ) {
    __pClient__	= RPC_CLIENT_CREATE ( __szHost__, __szTransport__ );
    if ( __pClient__ == NULL ) {
      /* Error handling for a not connected client: */
      char	szError [ 256 ];
      sprintf ( szError, szFormatNoServer, __procedure__ );
      RPC_CLIENT_ERROR ( szError );
      return Result.ReturnValue;
    }
  }
#else
  while ( __pClient__ == NULL ) {
    __pClient__	= RPC_CLIENT_CREATE ( __szHost__, __szTransport__ );
    if ( __pClient__ == NULL ) {
      /* Error handling for a not connected client: */
      char	szError [ 256 ];
      sprintf ( szError, szFormatNoServer, __procedure__ );
      RPC_CLIENT_CERROR ( szContNoServer, szError );
    }
  }
#endif	/* CLIENT_CREATE_BY_USER */

  /* Copy in the oShortObjIdHeap argument: */
  InArguments.oShortObjIdHeap	= oShortObjIdHeap;
  /* Copy in the oShortObjIdBTree argument: */
  InArguments.oShortObjIdBTree	= oShortObjIdBTree;
  /* Copy in the szKeyLower argument: */
  InArguments.szKeyLower	= szKeyLower;
  if ( szKeyLower == NULL ) {
    /* Error handling for passing a NULL string pointer: */
    char	szError [ 256 ];
    InArguments.szKeyLower	= (LPSTR) szEmpty;
    sprintf ( szError, szFormatNullString,
              __procedure__, "szKeyLower" );
    RPC_CLIENT_CERROR ( szContNullString, szError );
  }
  /* Copy in the nTypeTagKeyLower argument: */
  InArguments.nTypeTagKeyLower	= nTypeTagKeyLower;
  /* Copy in the eCompareLower argument: */
  InArguments.eCompareLower	= eCompareLower;
  /* Copy in the szKeyUpper argument: */
  InArguments.szKeyUpper	= szKeyUpper;
  if ( szKeyUpper == NULL ) {
    /* Error handling for passing a NULL string pointer: */
    char	szError [ 256 ];
    InArguments.szKeyUpper	= (LPSTR) szEmpty;
    sprintf ( szError, szFormatNullString,
              __procedure__, "szKeyUpper" );
    RPC_CLIENT_CERROR ( szContNullString, szError );
  }
  /* Copy in the nTypeTagKeyUpper argument: */
  InArguments.nTypeTagKeyUpper	= nTypeTagKeyUpper;
  /* Copy in the eCompareUpper argument: */
  InArguments.eCompareUpper	= eCompareUpper;
  /* Copy in the bDescending argument: */
  InArguments.bDescending	= bDescending;
  /* Copy in the nMap argument: */
  InArguments.nMap	= nMap;
  InArguments.pnValueKeySize	= nMap;
  InArguments.pnTypeTagKeySize	= nMap;
  InArguments.pnValueDataSize	= nMap;
  InArguments.pnTypeTagDataSize	= nMap;

  pResult	=
#ifdef MULTITHREAD
    (
#else
    (fnServerBtreemapFirstByString_rets *)
#endif
    fnrpc_fnserverbtreemapfirstbystring_1 (
	&InArguments,
#ifdef MULTITHREAD
	&Result,
#endif
	__pClient__ )
#ifdef MULTITHREAD
	== RPC_SUCCESS ) ? &Result : NULL
#endif
	;

  if ( pResult == NULL ) {
    /* Error handling for a failed RPC call, */
    /* i.e. the server did not respond: */
    char	szError [ 256 ];
    sprintf ( szError, szFormatRpcFailed, __procedure__,
              clnt_sperror ( __pClient__, __szHost__ ) );
    __pClient__	= RPC_CLIENT_DESTROY ( __pClient__ );
    RPC_CLIENT_CERROR ( szContRpcFailed, szError );
    Result	= ZeroResult;
    return Result.ReturnValue;
  }
#ifndef MULTITHREAD
  Result	= * pResult;
#endif

  /* Copy out the lpoShortObjIdMapper argument: */
  if ( ! ( 
       lpoShortObjIdMapper == NULL ) ) {
    *lpoShortObjIdMapper	= pResult->lpoShortObjIdMapper;
  }
  /* Copy out the pnValueKey argument: */
  if ( ! ( 
       pResult->pnValueKey.int_vector_t_len != 0 &&
       pnValueKey == NULL ) ) {
    memcpy ( pnValueKey,
             pResult->pnValueKey.int_vector_t_val,
             MIN ( pResult->pnValueKey.int_vector_t_len,
                   nMap ) *
             SIZEOF ( *(pResult->pnValueKey.int_vector_t_val) ) );
  }
  /* Copy out the pnTypeTagKey argument: */
  if ( ! ( 
       pResult->pnTypeTagKey.u_int_vector_t_len != 0 &&
       pnTypeTagKey == NULL ) ) {
    memcpy ( pnTypeTagKey,
             pResult->pnTypeTagKey.u_int_vector_t_val,
             MIN ( pResult->pnTypeTagKey.u_int_vector_t_len,
                   nMap ) *
             SIZEOF ( *(pResult->pnTypeTagKey.u_int_vector_t_val) ) );
  }
  /* Copy out the pnValueData argument: */
  if ( ! ( 
       pResult->pnValueData.int_vector_t_len != 0 &&
       pnValueData == NULL ) ) {
    memcpy ( pnValueData,
             pResult->pnValueData.int_vector_t_val,
             MIN ( pResult->pnValueData.int_vector_t_len,
                   nMap ) *
             SIZEOF ( *(pResult->pnValueData.int_vector_t_val) ) );
  }
  /* Copy out the pnTypeTagData argument: */
  if ( ! ( 
       pResult->pnTypeTagData.u_int_vector_t_len != 0 &&
       pnTypeTagData == NULL ) ) {
    memcpy ( pnTypeTagData,
             pResult->pnTypeTagData.u_int_vector_t_val,
             MIN ( pResult->pnTypeTagData.u_int_vector_t_len,
                   nMap ) *
             SIZEOF ( *(pResult->pnTypeTagData.u_int_vector_t_val) ) );
  }

  if ( pResult && pResult->nErrorLvl ) {
    /* Server returned a user error message: */
    char	szErrorMsg [ 1024 ];
    strncpy ( szErrorMsg,
              ( pResult->pszErrorMsg && pResult->pszErrorMsg [ 0 ] ) ?
              (LPCSTR) pResult->pszErrorMsg : (LPCSTR) szEmpty,
              sizeof ( szErrorMsg ) );
    szErrorMsg [ sizeof ( szErrorMsg ) - 1 ]	= (char) 0;
    xdr_free ( (xdrproc_t) xdr_fnServerBtreemapFirstByString_rets, (char *) pResult );
    RPC_CLIENT_SERROR ( pResult->nErrorLvl, __procedure__,
                        szErrorMsg );
  } else {
    xdr_free ( (xdrproc_t) xdr_fnServerBtreemapFirstByString_rets, (char *) pResult );
  }
  if ( 
       lpoShortObjIdMapper == NULL ) {
    /* Error handling for passing a NULL pointer on */
    /* out argument: */
    char	szError [ 256 ];
    sprintf ( szError, szFormatNullPassed,
              __procedure__, "lpoShortObjIdMapper" );
    RPC_CLIENT_CERROR ( szContNullOutPassed, szError );
  }
  if ( 
       pResult->pnValueKey.int_vector_t_len != 0 &&
       pnValueKey == NULL ) {
    /* Error handling for passing a NULL pointer on */
    /* out argument: */
    char	szError [ 256 ];
    sprintf ( szError, szFormatNullPassed,
              __procedure__, "pnValueKey" );
    RPC_CLIENT_CERROR ( szContNullOutPassed, szError );
  } else if ( pResult->pnValueKey.int_vector_t_len > nMap ) {
      /* Error handling for an output buffer overflow, */
      /* i.e. the buffer size passed is too small: */
      /* For example, signal a CERROR here ... */
      char	szError [ 256 ];
      sprintf ( szError, szFormatBufferOverflow,
                __procedure__, "pnValueKey", 
                nMap, 
                pResult->pnValueKey.int_vector_t_len );
      RPC_CLIENT_CERROR ( szContBufferOverflow, szError );
  }
  if ( 
       pResult->pnTypeTagKey.u_int_vector_t_len != 0 &&
       pnTypeTagKey == NULL ) {
    /* Error handling for passing a NULL pointer on */
    /* out argument: */
    char	szError [ 256 ];
    sprintf ( szError, szFormatNullPassed,
              __procedure__, "pnTypeTagKey" );
    RPC_CLIENT_CERROR ( szContNullOutPassed, szError );
  } else if ( pResult->pnTypeTagKey.u_int_vector_t_len > nMap ) {
      /* Error handling for an output buffer overflow, */
      /* i.e. the buffer size passed is too small: */
      /* For example, signal a CERROR here ... */
      char	szError [ 256 ];
      sprintf ( szError, szFormatBufferOverflow,
                __procedure__, "pnTypeTagKey", 
                nMap, 
                pResult->pnTypeTagKey.u_int_vector_t_len );
      RPC_CLIENT_CERROR ( szContBufferOverflow, szError );
  }
  if ( 
       pResult->pnValueData.int_vector_t_len != 0 &&
       pnValueData == NULL ) {
    /* Error handling for passing a NULL pointer on */
    /* out argument: */
    char	szError [ 256 ];
    sprintf ( szError, szFormatNullPassed,
              __procedure__, "pnValueData" );
    RPC_CLIENT_CERROR ( szContNullOutPassed, szError );
  } else if ( pResult->pnValueData.int_vector_t_len > nMap ) {
      /* Error handling for an output buffer overflow, */
      /* i.e. the buffer size passed is too small: */
      /* For example, signal a CERROR here ... */
      char	szError [ 256 ];
      sprintf ( szError, szFormatBufferOverflow,
                __procedure__, "pnValueData", 
                nMap, 
                pResult->pnValueData.int_vector_t_len );
      RPC_CLIENT_CERROR ( szContBufferOverflow, szError );
  }
  if ( 
       pResult->pnTypeTagData.u_int_vector_t_len != 0 &&
       pnTypeTagData == NULL ) {
    /* Error handling for passing a NULL pointer on */
    /* out argument: */
    char	szError [ 256 ];
    sprintf ( szError, szFormatNullPassed,
              __procedure__, "pnTypeTagData" );
    RPC_CLIENT_CERROR ( szContNullOutPassed, szError );
  } else if ( pResult->pnTypeTagData.u_int_vector_t_len > nMap ) {
      /* Error handling for an output buffer overflow, */
      /* i.e. the buffer size passed is too small: */
      /* For example, signal a CERROR here ... */
      char	szError [ 256 ];
      sprintf ( szError, szFormatBufferOverflow,
                __procedure__, "pnTypeTagData", 
                nMap, 
                pResult->pnTypeTagData.u_int_vector_t_len );
      RPC_CLIENT_CERROR ( szContBufferOverflow, szError );
  }

  return Result.ReturnValue;

} /* fnServerBtreemapFirstByString */



int DLLEXPORT fnClientBtreemapNext
	(SHORTOBJID oShortObjIdMapper ,
	  SHORTOBJID oShortObjIdHeap ,
	  int nMap ,
	  int * /* _vector_t<nMap> */  pnValueKey ,
	  u_int * /* _vector_t<nMap> */  pnTypeTagKey ,
	  int * /* _vector_t<nMap> */  pnValueData ,
	  u_int * /* _vector_t<nMap> */  pnTypeTagData)
{
  static const char	__procedure__[]	= "client:fnClientBtreemapNext";
  static fnClientBtreemapNext_rets	ZeroResult;
  fnClientBtreemapNext_rets		* pResult = NULL;
  fnClientBtreemapNext_rets		Result = ZeroResult;
  fnClientBtreemapNext_args	InArguments;

  /* Client initialization: */
  if ( __bClientInitialize__ ) {
    __bClientInitialize__	= FALSE;
    RPC_CLIENT_INITIALIZE();
  }

#if	CLIENT_CREATE_BY_USER
  if ( __pClient__ == NULL ) {
    __pClient__	= RPC_CLIENT_CREATE ( __szHost__, __szTransport__ );
    if ( __pClient__ == NULL ) {
      /* Error handling for a not connected client: */
      char	szError [ 256 ];
      sprintf ( szError, szFormatNoServer, __procedure__ );
      RPC_CLIENT_ERROR ( szError );
      return Result.ReturnValue;
    }
  }
#else
  while ( __pClient__ == NULL ) {
    __pClient__	= RPC_CLIENT_CREATE ( __szHost__, __szTransport__ );
    if ( __pClient__ == NULL ) {
      /* Error handling for a not connected client: */
      char	szError [ 256 ];
      sprintf ( szError, szFormatNoServer, __procedure__ );
      RPC_CLIENT_CERROR ( szContNoServer, szError );
    }
  }
#endif	/* CLIENT_CREATE_BY_USER */

  /* Copy in the oShortObjIdMapper argument: */
  InArguments.oShortObjIdMapper	= oShortObjIdMapper;
  /* Copy in the oShortObjIdHeap argument: */
  InArguments.oShortObjIdHeap	= oShortObjIdHeap;
  /* Copy in the nMap argument: */
  InArguments.nMap	= nMap;
  InArguments.pnValueKeySize	= nMap;
  InArguments.pnTypeTagKeySize	= nMap;
  InArguments.pnValueDataSize	= nMap;
  InArguments.pnTypeTagDataSize	= nMap;

  pResult	=
#ifdef MULTITHREAD
    (
#else
    (fnClientBtreemapNext_rets *)
#endif
    fnrpc_fnclientbtreemapnext_1 (
	&InArguments,
#ifdef MULTITHREAD
	&Result,
#endif
	__pClient__ )
#ifdef MULTITHREAD
	== RPC_SUCCESS ) ? &Result : NULL
#endif
	;

  if ( pResult == NULL ) {
    /* Error handling for a failed RPC call, */
    /* i.e. the server did not respond: */
    char	szError [ 256 ];
    sprintf ( szError, szFormatRpcFailed, __procedure__,
              clnt_sperror ( __pClient__, __szHost__ ) );
    __pClient__	= RPC_CLIENT_DESTROY ( __pClient__ );
    RPC_CLIENT_CERROR ( szContRpcFailed, szError );
    Result	= ZeroResult;
    return Result.ReturnValue;
  }
#ifndef MULTITHREAD
  Result	= * pResult;
#endif

  /* Copy out the pnValueKey argument: */
  if ( ! ( 
       pResult->pnValueKey.int_vector_t_len != 0 &&
       pnValueKey == NULL ) ) {
    memcpy ( pnValueKey,
             pResult->pnValueKey.int_vector_t_val,
             MIN ( pResult->pnValueKey.int_vector_t_len,
                   nMap ) *
             SIZEOF ( *(pResult->pnValueKey.int_vector_t_val) ) );
  }
  /* Copy out the pnTypeTagKey argument: */
  if ( ! ( 
       pResult->pnTypeTagKey.u_int_vector_t_len != 0 &&
       pnTypeTagKey == NULL ) ) {
    memcpy ( pnTypeTagKey,
             pResult->pnTypeTagKey.u_int_vector_t_val,
             MIN ( pResult->pnTypeTagKey.u_int_vector_t_len,
                   nMap ) *
             SIZEOF ( *(pResult->pnTypeTagKey.u_int_vector_t_val) ) );
  }
  /* Copy out the pnValueData argument: */
  if ( ! ( 
       pResult->pnValueData.int_vector_t_len != 0 &&
       pnValueData == NULL ) ) {
    memcpy ( pnValueData,
             pResult->pnValueData.int_vector_t_val,
             MIN ( pResult->pnValueData.int_vector_t_len,
                   nMap ) *
             SIZEOF ( *(pResult->pnValueData.int_vector_t_val) ) );
  }
  /* Copy out the pnTypeTagData argument: */
  if ( ! ( 
       pResult->pnTypeTagData.u_int_vector_t_len != 0 &&
       pnTypeTagData == NULL ) ) {
    memcpy ( pnTypeTagData,
             pResult->pnTypeTagData.u_int_vector_t_val,
             MIN ( pResult->pnTypeTagData.u_int_vector_t_len,
                   nMap ) *
             SIZEOF ( *(pResult->pnTypeTagData.u_int_vector_t_val) ) );
  }

  if ( pResult && pResult->nErrorLvl ) {
    /* Server returned a user error message: */
    char	szErrorMsg [ 1024 ];
    strncpy ( szErrorMsg,
              ( pResult->pszErrorMsg && pResult->pszErrorMsg [ 0 ] ) ?
              (LPCSTR) pResult->pszErrorMsg : (LPCSTR) szEmpty,
              sizeof ( szErrorMsg ) );
    szErrorMsg [ sizeof ( szErrorMsg ) - 1 ]	= (char) 0;
    xdr_free ( (xdrproc_t) xdr_fnClientBtreemapNext_rets, (char *) pResult );
    RPC_CLIENT_SERROR ( pResult->nErrorLvl, __procedure__,
                        szErrorMsg );
  } else {
    xdr_free ( (xdrproc_t) xdr_fnClientBtreemapNext_rets, (char *) pResult );
  }
  if ( 
       pResult->pnValueKey.int_vector_t_len != 0 &&
       pnValueKey == NULL ) {
    /* Error handling for passing a NULL pointer on */
    /* out argument: */
    char	szError [ 256 ];
    sprintf ( szError, szFormatNullPassed,
              __procedure__, "pnValueKey" );
    RPC_CLIENT_CERROR ( szContNullOutPassed, szError );
  } else if ( pResult->pnValueKey.int_vector_t_len > nMap ) {
      /* Error handling for an output buffer overflow, */
      /* i.e. the buffer size passed is too small: */
      /* For example, signal a CERROR here ... */
      char	szError [ 256 ];
      sprintf ( szError, szFormatBufferOverflow,
                __procedure__, "pnValueKey", 
                nMap, 
                pResult->pnValueKey.int_vector_t_len );
      RPC_CLIENT_CERROR ( szContBufferOverflow, szError );
  }
  if ( 
       pResult->pnTypeTagKey.u_int_vector_t_len != 0 &&
       pnTypeTagKey == NULL ) {
    /* Error handling for passing a NULL pointer on */
    /* out argument: */
    char	szError [ 256 ];
    sprintf ( szError, szFormatNullPassed,
              __procedure__, "pnTypeTagKey" );
    RPC_CLIENT_CERROR ( szContNullOutPassed, szError );
  } else if ( pResult->pnTypeTagKey.u_int_vector_t_len > nMap ) {
      /* Error handling for an output buffer overflow, */
      /* i.e. the buffer size passed is too small: */
      /* For example, signal a CERROR here ... */
      char	szError [ 256 ];
      sprintf ( szError, szFormatBufferOverflow,
                __procedure__, "pnTypeTagKey", 
                nMap, 
                pResult->pnTypeTagKey.u_int_vector_t_len );
      RPC_CLIENT_CERROR ( szContBufferOverflow, szError );
  }
  if ( 
       pResult->pnValueData.int_vector_t_len != 0 &&
       pnValueData == NULL ) {
    /* Error handling for passing a NULL pointer on */
    /* out argument: */
    char	szError [ 256 ];
    sprintf ( szError, szFormatNullPassed,
              __procedure__, "pnValueData" );
    RPC_CLIENT_CERROR ( szContNullOutPassed, szError );
  } else if ( pResult->pnValueData.int_vector_t_len > nMap ) {
      /* Error handling for an output buffer overflow, */
      /* i.e. the buffer size passed is too small: */
      /* For example, signal a CERROR here ... */
      char	szError [ 256 ];
      sprintf ( szError, szFormatBufferOverflow,
                __procedure__, "pnValueData", 
                nMap, 
                pResult->pnValueData.int_vector_t_len );
      RPC_CLIENT_CERROR ( szContBufferOverflow, szError );
  }
  if ( 
       pResult->pnTypeTagData.u_int_vector_t_len != 0 &&
       pnTypeTagData == NULL ) {
    /* Error handling for passing a NULL pointer on */
    /* out argument: */
    char	szError [ 256 ];
    sprintf ( szError, szFormatNullPassed,
              __procedure__, "pnTypeTagData" );
    RPC_CLIENT_CERROR ( szContNullOutPassed, szError );
  } else if ( pResult->pnTypeTagData.u_int_vector_t_len > nMap ) {
      /* Error handling for an output buffer overflow, */
      /* i.e. the buffer size passed is too small: */
      /* For example, signal a CERROR here ... */
      char	szError [ 256 ];
      sprintf ( szError, szFormatBufferOverflow,
                __procedure__, "pnTypeTagData", 
                nMap, 
                pResult->pnTypeTagData.u_int_vector_t_len );
      RPC_CLIENT_CERROR ( szContBufferOverflow, szError );
  }

  return Result.ReturnValue;

} /* fnClientBtreemapNext */



SHORTOBJID DLLEXPORT fnClientBtreemapLast
	(SHORTOBJID oShortObjIdMapper ,
	  SHORTOBJID oShortObjIdHeap)
{
  static const char	__procedure__[]	= "client:fnClientBtreemapLast";
  static fnClientBtreemapLast_rets	ZeroResult;
  fnClientBtreemapLast_rets		* pResult = NULL;
  fnClientBtreemapLast_rets		Result = ZeroResult;
  fnClientBtreemapLast_args	InArguments;

  /* Client initialization: */
  if ( __bClientInitialize__ ) {
    __bClientInitialize__	= FALSE;
    RPC_CLIENT_INITIALIZE();
  }

#if	CLIENT_CREATE_BY_USER
  if ( __pClient__ == NULL ) {
    __pClient__	= RPC_CLIENT_CREATE ( __szHost__, __szTransport__ );
    if ( __pClient__ == NULL ) {
      /* Error handling for a not connected client: */
      char	szError [ 256 ];
      sprintf ( szError, szFormatNoServer, __procedure__ );
      RPC_CLIENT_ERROR ( szError );
      return Result.ReturnValue;
    }
  }
#else
  while ( __pClient__ == NULL ) {
    __pClient__	= RPC_CLIENT_CREATE ( __szHost__, __szTransport__ );
    if ( __pClient__ == NULL ) {
      /* Error handling for a not connected client: */
      char	szError [ 256 ];
      sprintf ( szError, szFormatNoServer, __procedure__ );
      RPC_CLIENT_CERROR ( szContNoServer, szError );
    }
  }
#endif	/* CLIENT_CREATE_BY_USER */

  /* Copy in the oShortObjIdMapper argument: */
  InArguments.oShortObjIdMapper	= oShortObjIdMapper;
  /* Copy in the oShortObjIdHeap argument: */
  InArguments.oShortObjIdHeap	= oShortObjIdHeap;

  pResult	=
#ifdef MULTITHREAD
    (
#else
    (fnClientBtreemapLast_rets *)
#endif
    fnrpc_fnclientbtreemaplast_1 (
	&InArguments,
#ifdef MULTITHREAD
	&Result,
#endif
	__pClient__ )
#ifdef MULTITHREAD
	== RPC_SUCCESS ) ? &Result : NULL
#endif
	;

  if ( pResult == NULL ) {
    /* Error handling for a failed RPC call, */
    /* i.e. the server did not respond: */
    char	szError [ 256 ];
    sprintf ( szError, szFormatRpcFailed, __procedure__,
              clnt_sperror ( __pClient__, __szHost__ ) );
    __pClient__	= RPC_CLIENT_DESTROY ( __pClient__ );
    RPC_CLIENT_CERROR ( szContRpcFailed, szError );
    Result	= ZeroResult;
    return Result.ReturnValue;
  }
#ifndef MULTITHREAD
  Result	= * pResult;
#endif


  if ( pResult && pResult->nErrorLvl ) {
    /* Server returned a user error message: */
    char	szErrorMsg [ 1024 ];
    strncpy ( szErrorMsg,
              ( pResult->pszErrorMsg && pResult->pszErrorMsg [ 0 ] ) ?
              (LPCSTR) pResult->pszErrorMsg : (LPCSTR) szEmpty,
              sizeof ( szErrorMsg ) );
    szErrorMsg [ sizeof ( szErrorMsg ) - 1 ]	= (char) 0;
    xdr_free ( (xdrproc_t) xdr_fnClientBtreemapLast_rets, (char *) pResult );
    RPC_CLIENT_SERROR ( pResult->nErrorLvl, __procedure__,
                        szErrorMsg );
  } else {
    xdr_free ( (xdrproc_t) xdr_fnClientBtreemapLast_rets, (char *) pResult );
  }

  return Result.ReturnValue;

} /* fnClientBtreemapLast */



int DLLEXPORT fnClientBtreePrint
	(SHORTOBJID oShortObjIdHeap ,
	  SHORTOBJID oShortObjIdBTree ,
	  NUMERICSTDSTREAM nStdStream)
{
  static const char	__procedure__[]	= "client:fnClientBtreePrint";
  static fnClientBtreePrint_rets	ZeroResult;
  fnClientBtreePrint_rets		* pResult = NULL;
  fnClientBtreePrint_rets		Result = ZeroResult;
  fnClientBtreePrint_args	InArguments;

  /* Client initialization: */
  if ( __bClientInitialize__ ) {
    __bClientInitialize__	= FALSE;
    RPC_CLIENT_INITIALIZE();
  }

#if	CLIENT_CREATE_BY_USER
  if ( __pClient__ == NULL ) {
    __pClient__	= RPC_CLIENT_CREATE ( __szHost__, __szTransport__ );
    if ( __pClient__ == NULL ) {
      /* Error handling for a not connected client: */
      char	szError [ 256 ];
      sprintf ( szError, szFormatNoServer, __procedure__ );
      RPC_CLIENT_ERROR ( szError );
      return Result.ReturnValue;
    }
  }
#else
  while ( __pClient__ == NULL ) {
    __pClient__	= RPC_CLIENT_CREATE ( __szHost__, __szTransport__ );
    if ( __pClient__ == NULL ) {
      /* Error handling for a not connected client: */
      char	szError [ 256 ];
      sprintf ( szError, szFormatNoServer, __procedure__ );
      RPC_CLIENT_CERROR ( szContNoServer, szError );
    }
  }
#endif	/* CLIENT_CREATE_BY_USER */

  /* Copy in the oShortObjIdHeap argument: */
  InArguments.oShortObjIdHeap	= oShortObjIdHeap;
  /* Copy in the oShortObjIdBTree argument: */
  InArguments.oShortObjIdBTree	= oShortObjIdBTree;
  /* Copy in the nStdStream argument: */
  InArguments.nStdStream	= nStdStream;

  pResult	=
#ifdef MULTITHREAD
    (
#else
    (fnClientBtreePrint_rets *)
#endif
    fnrpc_fnclientbtreeprint_1 (
	&InArguments,
#ifdef MULTITHREAD
	&Result,
#endif
	__pClient__ )
#ifdef MULTITHREAD
	== RPC_SUCCESS ) ? &Result : NULL
#endif
	;

  if ( pResult == NULL ) {
    /* Error handling for a failed RPC call, */
    /* i.e. the server did not respond: */
    char	szError [ 256 ];
    sprintf ( szError, szFormatRpcFailed, __procedure__,
              clnt_sperror ( __pClient__, __szHost__ ) );
    __pClient__	= RPC_CLIENT_DESTROY ( __pClient__ );
    RPC_CLIENT_CERROR ( szContRpcFailed, szError );
    Result	= ZeroResult;
    return Result.ReturnValue;
  }
#ifndef MULTITHREAD
  Result	= * pResult;
#endif


  if ( pResult && pResult->nErrorLvl ) {
    /* Server returned a user error message: */
    char	szErrorMsg [ 1024 ];
    strncpy ( szErrorMsg,
              ( pResult->pszErrorMsg && pResult->pszErrorMsg [ 0 ] ) ?
              (LPCSTR) pResult->pszErrorMsg : (LPCSTR) szEmpty,
              sizeof ( szErrorMsg ) );
    szErrorMsg [ sizeof ( szErrorMsg ) - 1 ]	= (char) 0;
    xdr_free ( (xdrproc_t) xdr_fnClientBtreePrint_rets, (char *) pResult );
    RPC_CLIENT_SERROR ( pResult->nErrorLvl, __procedure__,
                        szErrorMsg );
  } else {
    xdr_free ( (xdrproc_t) xdr_fnClientBtreePrint_rets, (char *) pResult );
  }

  return Result.ReturnValue;

} /* fnClientBtreePrint */



BTREERESULT DLLEXPORT fnServerBtreeSearch
	(SHORTOBJID oShortObjIdHeap ,
	  SHORTOBJID oShortObjIdBTree ,
	  int nValueKey ,
	  SHTYPETAG nTypeTagKey ,
	  int * pnValueKey ,
	  SHTYPETAG * pnTypeTagKey ,
	  int * pnValueData ,
	  SHTYPETAG * pnTypeTagData)
{
  static const char	__procedure__[]	= "client:fnServerBtreeSearch";
  static fnServerBtreeSearch_rets	ZeroResult;
  fnServerBtreeSearch_rets		* pResult = NULL;
  fnServerBtreeSearch_rets		Result = ZeroResult;
  fnServerBtreeSearch_args	InArguments;

  /* Client initialization: */
  if ( __bClientInitialize__ ) {
    __bClientInitialize__	= FALSE;
    RPC_CLIENT_INITIALIZE();
  }

#if	CLIENT_CREATE_BY_USER
  if ( __pClient__ == NULL ) {
    __pClient__	= RPC_CLIENT_CREATE ( __szHost__, __szTransport__ );
    if ( __pClient__ == NULL ) {
      /* Error handling for a not connected client: */
      char	szError [ 256 ];
      sprintf ( szError, szFormatNoServer, __procedure__ );
      RPC_CLIENT_ERROR ( szError );
      return Result.ReturnValue;
    }
  }
#else
  while ( __pClient__ == NULL ) {
    __pClient__	= RPC_CLIENT_CREATE ( __szHost__, __szTransport__ );
    if ( __pClient__ == NULL ) {
      /* Error handling for a not connected client: */
      char	szError [ 256 ];
      sprintf ( szError, szFormatNoServer, __procedure__ );
      RPC_CLIENT_CERROR ( szContNoServer, szError );
    }
  }
#endif	/* CLIENT_CREATE_BY_USER */

  /* Copy in the oShortObjIdHeap argument: */
  InArguments.oShortObjIdHeap	= oShortObjIdHeap;
  /* Copy in the oShortObjIdBTree argument: */
  InArguments.oShortObjIdBTree	= oShortObjIdBTree;
  /* Copy in the nValueKey argument: */
  InArguments.nValueKey	= nValueKey;
  /* Copy in the nTypeTagKey argument: */
  InArguments.nTypeTagKey	= nTypeTagKey;

  pResult	=
#ifdef MULTITHREAD
    (
#else
    (fnServerBtreeSearch_rets *)
#endif
    fnrpc_fnserverbtreesearch_1 (
	&InArguments,
#ifdef MULTITHREAD
	&Result,
#endif
	__pClient__ )
#ifdef MULTITHREAD
	== RPC_SUCCESS ) ? &Result : NULL
#endif
	;

  if ( pResult == NULL ) {
    /* Error handling for a failed RPC call, */
    /* i.e. the server did not respond: */
    char	szError [ 256 ];
    sprintf ( szError, szFormatRpcFailed, __procedure__,
              clnt_sperror ( __pClient__, __szHost__ ) );
    __pClient__	= RPC_CLIENT_DESTROY ( __pClient__ );
    RPC_CLIENT_CERROR ( szContRpcFailed, szError );
    Result	= ZeroResult;
    return Result.ReturnValue;
  }
#ifndef MULTITHREAD
  Result	= * pResult;
#endif

  /* Copy out the pnValueKey argument: */
  if ( ! ( 
       pnValueKey == NULL ) ) {
    *pnValueKey	= pResult->pnValueKey;
  }
  /* Copy out the pnTypeTagKey argument: */
  if ( ! ( 
       pnTypeTagKey == NULL ) ) {
    *pnTypeTagKey	= pResult->pnTypeTagKey;
  }
  /* Copy out the pnValueData argument: */
  if ( ! ( 
       pnValueData == NULL ) ) {
    *pnValueData	= pResult->pnValueData;
  }
  /* Copy out the pnTypeTagData argument: */
  if ( ! ( 
       pnTypeTagData == NULL ) ) {
    *pnTypeTagData	= pResult->pnTypeTagData;
  }

  if ( pResult && pResult->nErrorLvl ) {
    /* Server returned a user error message: */
    char	szErrorMsg [ 1024 ];
    strncpy ( szErrorMsg,
              ( pResult->pszErrorMsg && pResult->pszErrorMsg [ 0 ] ) ?
              (LPCSTR) pResult->pszErrorMsg : (LPCSTR) szEmpty,
              sizeof ( szErrorMsg ) );
    szErrorMsg [ sizeof ( szErrorMsg ) - 1 ]	= (char) 0;
    xdr_free ( (xdrproc_t) xdr_fnServerBtreeSearch_rets, (char *) pResult );
    RPC_CLIENT_SERROR ( pResult->nErrorLvl, __procedure__,
                        szErrorMsg );
  } else {
    xdr_free ( (xdrproc_t) xdr_fnServerBtreeSearch_rets, (char *) pResult );
  }
  if ( 
       pnValueKey == NULL ) {
    /* Error handling for passing a NULL pointer on */
    /* out argument: */
    char	szError [ 256 ];
    sprintf ( szError, szFormatNullPassed,
              __procedure__, "pnValueKey" );
    RPC_CLIENT_CERROR ( szContNullOutPassed, szError );
  }
  if ( 
       pnTypeTagKey == NULL ) {
    /* Error handling for passing a NULL pointer on */
    /* out argument: */
    char	szError [ 256 ];
    sprintf ( szError, szFormatNullPassed,
              __procedure__, "pnTypeTagKey" );
    RPC_CLIENT_CERROR ( szContNullOutPassed, szError );
  }
  if ( 
       pnValueData == NULL ) {
    /* Error handling for passing a NULL pointer on */
    /* out argument: */
    char	szError [ 256 ];
    sprintf ( szError, szFormatNullPassed,
              __procedure__, "pnValueData" );
    RPC_CLIENT_CERROR ( szContNullOutPassed, szError );
  }
  if ( 
       pnTypeTagData == NULL ) {
    /* Error handling for passing a NULL pointer on */
    /* out argument: */
    char	szError [ 256 ];
    sprintf ( szError, szFormatNullPassed,
              __procedure__, "pnTypeTagData" );
    RPC_CLIENT_CERROR ( szContNullOutPassed, szError );
  }

  return Result.ReturnValue;

} /* fnServerBtreeSearch */



BTREERESULT DLLEXPORT fnServerBtreeSearchByFloat
	(SHORTOBJID oShortObjIdHeap ,
	  SHORTOBJID oShortObjIdBTree ,
	  float fKey ,
	  SHTYPETAG nTypeTagKey ,
	  int * pnValueKey ,
	  SHTYPETAG * pnTypeTagKey ,
	  int * pnValueData ,
	  SHTYPETAG * pnTypeTagData)
{
  static const char	__procedure__[]	= "client:fnServerBtreeSearchByFloat";
  static fnServerBtreeSearchByFloat_rets	ZeroResult;
  fnServerBtreeSearchByFloat_rets		* pResult = NULL;
  fnServerBtreeSearchByFloat_rets		Result = ZeroResult;
  fnServerBtreeSearchByFloat_args	InArguments;

  /* Client initialization: */
  if ( __bClientInitialize__ ) {
    __bClientInitialize__	= FALSE;
    RPC_CLIENT_INITIALIZE();
  }

#if	CLIENT_CREATE_BY_USER
  if ( __pClient__ == NULL ) {
    __pClient__	= RPC_CLIENT_CREATE ( __szHost__, __szTransport__ );
    if ( __pClient__ == NULL ) {
      /* Error handling for a not connected client: */
      char	szError [ 256 ];
      sprintf ( szError, szFormatNoServer, __procedure__ );
      RPC_CLIENT_ERROR ( szError );
      return Result.ReturnValue;
    }
  }
#else
  while ( __pClient__ == NULL ) {
    __pClient__	= RPC_CLIENT_CREATE ( __szHost__, __szTransport__ );
    if ( __pClient__ == NULL ) {
      /* Error handling for a not connected client: */
      char	szError [ 256 ];
      sprintf ( szError, szFormatNoServer, __procedure__ );
      RPC_CLIENT_CERROR ( szContNoServer, szError );
    }
  }
#endif	/* CLIENT_CREATE_BY_USER */

  /* Copy in the oShortObjIdHeap argument: */
  InArguments.oShortObjIdHeap	= oShortObjIdHeap;
  /* Copy in the oShortObjIdBTree argument: */
  InArguments.oShortObjIdBTree	= oShortObjIdBTree;
  /* Copy in the fKey argument: */
  InArguments.fKey	= fKey;
  /* Copy in the nTypeTagKey argument: */
  InArguments.nTypeTagKey	= nTypeTagKey;

  pResult	=
#ifdef MULTITHREAD
    (
#else
    (fnServerBtreeSearchByFloat_rets *)
#endif
    fnrpc_fnserverbtreesearchbyfloat_1 (
	&InArguments,
#ifdef MULTITHREAD
	&Result,
#endif
	__pClient__ )
#ifdef MULTITHREAD
	== RPC_SUCCESS ) ? &Result : NULL
#endif
	;

  if ( pResult == NULL ) {
    /* Error handling for a failed RPC call, */
    /* i.e. the server did not respond: */
    char	szError [ 256 ];
    sprintf ( szError, szFormatRpcFailed, __procedure__,
              clnt_sperror ( __pClient__, __szHost__ ) );
    __pClient__	= RPC_CLIENT_DESTROY ( __pClient__ );
    RPC_CLIENT_CERROR ( szContRpcFailed, szError );
    Result	= ZeroResult;
    return Result.ReturnValue;
  }
#ifndef MULTITHREAD
  Result	= * pResult;
#endif

  /* Copy out the pnValueKey argument: */
  if ( ! ( 
       pnValueKey == NULL ) ) {
    *pnValueKey	= pResult->pnValueKey;
  }
  /* Copy out the pnTypeTagKey argument: */
  if ( ! ( 
       pnTypeTagKey == NULL ) ) {
    *pnTypeTagKey	= pResult->pnTypeTagKey;
  }
  /* Copy out the pnValueData argument: */
  if ( ! ( 
       pnValueData == NULL ) ) {
    *pnValueData	= pResult->pnValueData;
  }
  /* Copy out the pnTypeTagData argument: */
  if ( ! ( 
       pnTypeTagData == NULL ) ) {
    *pnTypeTagData	= pResult->pnTypeTagData;
  }

  if ( pResult && pResult->nErrorLvl ) {
    /* Server returned a user error message: */
    char	szErrorMsg [ 1024 ];
    strncpy ( szErrorMsg,
              ( pResult->pszErrorMsg && pResult->pszErrorMsg [ 0 ] ) ?
              (LPCSTR) pResult->pszErrorMsg : (LPCSTR) szEmpty,
              sizeof ( szErrorMsg ) );
    szErrorMsg [ sizeof ( szErrorMsg ) - 1 ]	= (char) 0;
    xdr_free ( (xdrproc_t) xdr_fnServerBtreeSearchByFloat_rets, (char *) pResult );
    RPC_CLIENT_SERROR ( pResult->nErrorLvl, __procedure__,
                        szErrorMsg );
  } else {
    xdr_free ( (xdrproc_t) xdr_fnServerBtreeSearchByFloat_rets, (char *) pResult );
  }
  if ( 
       pnValueKey == NULL ) {
    /* Error handling for passing a NULL pointer on */
    /* out argument: */
    char	szError [ 256 ];
    sprintf ( szError, szFormatNullPassed,
              __procedure__, "pnValueKey" );
    RPC_CLIENT_CERROR ( szContNullOutPassed, szError );
  }
  if ( 
       pnTypeTagKey == NULL ) {
    /* Error handling for passing a NULL pointer on */
    /* out argument: */
    char	szError [ 256 ];
    sprintf ( szError, szFormatNullPassed,
              __procedure__, "pnTypeTagKey" );
    RPC_CLIENT_CERROR ( szContNullOutPassed, szError );
  }
  if ( 
       pnValueData == NULL ) {
    /* Error handling for passing a NULL pointer on */
    /* out argument: */
    char	szError [ 256 ];
    sprintf ( szError, szFormatNullPassed,
              __procedure__, "pnValueData" );
    RPC_CLIENT_CERROR ( szContNullOutPassed, szError );
  }
  if ( 
       pnTypeTagData == NULL ) {
    /* Error handling for passing a NULL pointer on */
    /* out argument: */
    char	szError [ 256 ];
    sprintf ( szError, szFormatNullPassed,
              __procedure__, "pnTypeTagData" );
    RPC_CLIENT_CERROR ( szContNullOutPassed, szError );
  }

  return Result.ReturnValue;

} /* fnServerBtreeSearchByFloat */



BTREERESULT DLLEXPORT fnServerBtreeSearchByDouble
	(SHORTOBJID oShortObjIdHeap ,
	  SHORTOBJID oShortObjIdBTree ,
	  double fKey ,
	  SHTYPETAG nTypeTagKey ,
	  int * pnValueKey ,
	  SHTYPETAG * pnTypeTagKey ,
	  int * pnValueData ,
	  SHTYPETAG * pnTypeTagData)
{
  static const char	__procedure__[]	= "client:fnServerBtreeSearchByDouble";
  static fnServerBtreeSearchByDouble_rets	ZeroResult;
  fnServerBtreeSearchByDouble_rets		* pResult = NULL;
  fnServerBtreeSearchByDouble_rets		Result = ZeroResult;
  fnServerBtreeSearchByDouble_args	InArguments;

  /* Client initialization: */
  if ( __bClientInitialize__ ) {
    __bClientInitialize__	= FALSE;
    RPC_CLIENT_INITIALIZE();
  }

#if	CLIENT_CREATE_BY_USER
  if ( __pClient__ == NULL ) {
    __pClient__	= RPC_CLIENT_CREATE ( __szHost__, __szTransport__ );
    if ( __pClient__ == NULL ) {
      /* Error handling for a not connected client: */
      char	szError [ 256 ];
      sprintf ( szError, szFormatNoServer, __procedure__ );
      RPC_CLIENT_ERROR ( szError );
      return Result.ReturnValue;
    }
  }
#else
  while ( __pClient__ == NULL ) {
    __pClient__	= RPC_CLIENT_CREATE ( __szHost__, __szTransport__ );
    if ( __pClient__ == NULL ) {
      /* Error handling for a not connected client: */
      char	szError [ 256 ];
      sprintf ( szError, szFormatNoServer, __procedure__ );
      RPC_CLIENT_CERROR ( szContNoServer, szError );
    }
  }
#endif	/* CLIENT_CREATE_BY_USER */

  /* Copy in the oShortObjIdHeap argument: */
  InArguments.oShortObjIdHeap	= oShortObjIdHeap;
  /* Copy in the oShortObjIdBTree argument: */
  InArguments.oShortObjIdBTree	= oShortObjIdBTree;
  /* Copy in the fKey argument: */
  InArguments.fKey	= fKey;
  /* Copy in the nTypeTagKey argument: */
  InArguments.nTypeTagKey	= nTypeTagKey;

  pResult	=
#ifdef MULTITHREAD
    (
#else
    (fnServerBtreeSearchByDouble_rets *)
#endif
    fnrpc_fnserverbtreesearchbydouble_1 (
	&InArguments,
#ifdef MULTITHREAD
	&Result,
#endif
	__pClient__ )
#ifdef MULTITHREAD
	== RPC_SUCCESS ) ? &Result : NULL
#endif
	;

  if ( pResult == NULL ) {
    /* Error handling for a failed RPC call, */
    /* i.e. the server did not respond: */
    char	szError [ 256 ];
    sprintf ( szError, szFormatRpcFailed, __procedure__,
              clnt_sperror ( __pClient__, __szHost__ ) );
    __pClient__	= RPC_CLIENT_DESTROY ( __pClient__ );
    RPC_CLIENT_CERROR ( szContRpcFailed, szError );
    Result	= ZeroResult;
    return Result.ReturnValue;
  }
#ifndef MULTITHREAD
  Result	= * pResult;
#endif

  /* Copy out the pnValueKey argument: */
  if ( ! ( 
       pnValueKey == NULL ) ) {
    *pnValueKey	= pResult->pnValueKey;
  }
  /* Copy out the pnTypeTagKey argument: */
  if ( ! ( 
       pnTypeTagKey == NULL ) ) {
    *pnTypeTagKey	= pResult->pnTypeTagKey;
  }
  /* Copy out the pnValueData argument: */
  if ( ! ( 
       pnValueData == NULL ) ) {
    *pnValueData	= pResult->pnValueData;
  }
  /* Copy out the pnTypeTagData argument: */
  if ( ! ( 
       pnTypeTagData == NULL ) ) {
    *pnTypeTagData	= pResult->pnTypeTagData;
  }

  if ( pResult && pResult->nErrorLvl ) {
    /* Server returned a user error message: */
    char	szErrorMsg [ 1024 ];
    strncpy ( szErrorMsg,
              ( pResult->pszErrorMsg && pResult->pszErrorMsg [ 0 ] ) ?
              (LPCSTR) pResult->pszErrorMsg : (LPCSTR) szEmpty,
              sizeof ( szErrorMsg ) );
    szErrorMsg [ sizeof ( szErrorMsg ) - 1 ]	= (char) 0;
    xdr_free ( (xdrproc_t) xdr_fnServerBtreeSearchByDouble_rets, (char *) pResult );
    RPC_CLIENT_SERROR ( pResult->nErrorLvl, __procedure__,
                        szErrorMsg );
  } else {
    xdr_free ( (xdrproc_t) xdr_fnServerBtreeSearchByDouble_rets, (char *) pResult );
  }
  if ( 
       pnValueKey == NULL ) {
    /* Error handling for passing a NULL pointer on */
    /* out argument: */
    char	szError [ 256 ];
    sprintf ( szError, szFormatNullPassed,
              __procedure__, "pnValueKey" );
    RPC_CLIENT_CERROR ( szContNullOutPassed, szError );
  }
  if ( 
       pnTypeTagKey == NULL ) {
    /* Error handling for passing a NULL pointer on */
    /* out argument: */
    char	szError [ 256 ];
    sprintf ( szError, szFormatNullPassed,
              __procedure__, "pnTypeTagKey" );
    RPC_CLIENT_CERROR ( szContNullOutPassed, szError );
  }
  if ( 
       pnValueData == NULL ) {
    /* Error handling for passing a NULL pointer on */
    /* out argument: */
    char	szError [ 256 ];
    sprintf ( szError, szFormatNullPassed,
              __procedure__, "pnValueData" );
    RPC_CLIENT_CERROR ( szContNullOutPassed, szError );
  }
  if ( 
       pnTypeTagData == NULL ) {
    /* Error handling for passing a NULL pointer on */
    /* out argument: */
    char	szError [ 256 ];
    sprintf ( szError, szFormatNullPassed,
              __procedure__, "pnTypeTagData" );
    RPC_CLIENT_CERROR ( szContNullOutPassed, szError );
  }

  return Result.ReturnValue;

} /* fnServerBtreeSearchByDouble */



BTREERESULT DLLEXPORT fnServerBtreeSearchByString
	(SHORTOBJID oShortObjIdHeap ,
	  SHORTOBJID oShortObjIdBTree ,
	  string_t /* string_t<@conststring@> */ szKey ,
	  SHTYPETAG nTypeTagKey ,
	  int * pnValueKey ,
	  SHTYPETAG * pnTypeTagKey ,
	  int * pnValueData ,
	  SHTYPETAG * pnTypeTagData)
{
  static const char	__procedure__[]	= "client:fnServerBtreeSearchByString";
  static fnServerBtreeSearchByString_rets	ZeroResult;
  fnServerBtreeSearchByString_rets		* pResult = NULL;
  fnServerBtreeSearchByString_rets		Result = ZeroResult;
  fnServerBtreeSearchByString_args	InArguments;

  /* Client initialization: */
  if ( __bClientInitialize__ ) {
    __bClientInitialize__	= FALSE;
    RPC_CLIENT_INITIALIZE();
  }

#if	CLIENT_CREATE_BY_USER
  if ( __pClient__ == NULL ) {
    __pClient__	= RPC_CLIENT_CREATE ( __szHost__, __szTransport__ );
    if ( __pClient__ == NULL ) {
      /* Error handling for a not connected client: */
      char	szError [ 256 ];
      sprintf ( szError, szFormatNoServer, __procedure__ );
      RPC_CLIENT_ERROR ( szError );
      return Result.ReturnValue;
    }
  }
#else
  while ( __pClient__ == NULL ) {
    __pClient__	= RPC_CLIENT_CREATE ( __szHost__, __szTransport__ );
    if ( __pClient__ == NULL ) {
      /* Error handling for a not connected client: */
      char	szError [ 256 ];
      sprintf ( szError, szFormatNoServer, __procedure__ );
      RPC_CLIENT_CERROR ( szContNoServer, szError );
    }
  }
#endif	/* CLIENT_CREATE_BY_USER */

  /* Copy in the oShortObjIdHeap argument: */
  InArguments.oShortObjIdHeap	= oShortObjIdHeap;
  /* Copy in the oShortObjIdBTree argument: */
  InArguments.oShortObjIdBTree	= oShortObjIdBTree;
  /* Copy in the szKey argument: */
  InArguments.szKey	= szKey;
  if ( szKey == NULL ) {
    /* Error handling for passing a NULL string pointer: */
    char	szError [ 256 ];
    InArguments.szKey	= (LPSTR) szEmpty;
    sprintf ( szError, szFormatNullString,
              __procedure__, "szKey" );
    RPC_CLIENT_CERROR ( szContNullString, szError );
  }
  /* Copy in the nTypeTagKey argument: */
  InArguments.nTypeTagKey	= nTypeTagKey;

  pResult	=
#ifdef MULTITHREAD
    (
#else
    (fnServerBtreeSearchByString_rets *)
#endif
    fnrpc_fnserverbtreesearchbystring_1 (
	&InArguments,
#ifdef MULTITHREAD
	&Result,
#endif
	__pClient__ )
#ifdef MULTITHREAD
	== RPC_SUCCESS ) ? &Result : NULL
#endif
	;

  if ( pResult == NULL ) {
    /* Error handling for a failed RPC call, */
    /* i.e. the server did not respond: */
    char	szError [ 256 ];
    sprintf ( szError, szFormatRpcFailed, __procedure__,
              clnt_sperror ( __pClient__, __szHost__ ) );
    __pClient__	= RPC_CLIENT_DESTROY ( __pClient__ );
    RPC_CLIENT_CERROR ( szContRpcFailed, szError );
    Result	= ZeroResult;
    return Result.ReturnValue;
  }
#ifndef MULTITHREAD
  Result	= * pResult;
#endif

  /* Copy out the pnValueKey argument: */
  if ( ! ( 
       pnValueKey == NULL ) ) {
    *pnValueKey	= pResult->pnValueKey;
  }
  /* Copy out the pnTypeTagKey argument: */
  if ( ! ( 
       pnTypeTagKey == NULL ) ) {
    *pnTypeTagKey	= pResult->pnTypeTagKey;
  }
  /* Copy out the pnValueData argument: */
  if ( ! ( 
       pnValueData == NULL ) ) {
    *pnValueData	= pResult->pnValueData;
  }
  /* Copy out the pnTypeTagData argument: */
  if ( ! ( 
       pnTypeTagData == NULL ) ) {
    *pnTypeTagData	= pResult->pnTypeTagData;
  }

  if ( pResult && pResult->nErrorLvl ) {
    /* Server returned a user error message: */
    char	szErrorMsg [ 1024 ];
    strncpy ( szErrorMsg,
              ( pResult->pszErrorMsg && pResult->pszErrorMsg [ 0 ] ) ?
              (LPCSTR) pResult->pszErrorMsg : (LPCSTR) szEmpty,
              sizeof ( szErrorMsg ) );
    szErrorMsg [ sizeof ( szErrorMsg ) - 1 ]	= (char) 0;
    xdr_free ( (xdrproc_t) xdr_fnServerBtreeSearchByString_rets, (char *) pResult );
    RPC_CLIENT_SERROR ( pResult->nErrorLvl, __procedure__,
                        szErrorMsg );
  } else {
    xdr_free ( (xdrproc_t) xdr_fnServerBtreeSearchByString_rets, (char *) pResult );
  }
  if ( 
       pnValueKey == NULL ) {
    /* Error handling for passing a NULL pointer on */
    /* out argument: */
    char	szError [ 256 ];
    sprintf ( szError, szFormatNullPassed,
              __procedure__, "pnValueKey" );
    RPC_CLIENT_CERROR ( szContNullOutPassed, szError );
  }
  if ( 
       pnTypeTagKey == NULL ) {
    /* Error handling for passing a NULL pointer on */
    /* out argument: */
    char	szError [ 256 ];
    sprintf ( szError, szFormatNullPassed,
              __procedure__, "pnTypeTagKey" );
    RPC_CLIENT_CERROR ( szContNullOutPassed, szError );
  }
  if ( 
       pnValueData == NULL ) {
    /* Error handling for passing a NULL pointer on */
    /* out argument: */
    char	szError [ 256 ];
    sprintf ( szError, szFormatNullPassed,
              __procedure__, "pnValueData" );
    RPC_CLIENT_CERROR ( szContNullOutPassed, szError );
  }
  if ( 
       pnTypeTagData == NULL ) {
    /* Error handling for passing a NULL pointer on */
    /* out argument: */
    char	szError [ 256 ];
    sprintf ( szError, szFormatNullPassed,
              __procedure__, "pnTypeTagData" );
    RPC_CLIENT_CERROR ( szContNullOutPassed, szError );
  }

  return Result.ReturnValue;

} /* fnServerBtreeSearchByString */



SHORTOBJID DLLEXPORT fnClientBtreeRoot
	(SHORTOBJID oShortObjIdHeap ,
	  SHORTOBJID oShortObjIdBTree)
{
  static const char	__procedure__[]	= "client:fnClientBtreeRoot";
  static fnClientBtreeRoot_rets	ZeroResult;
  fnClientBtreeRoot_rets		* pResult = NULL;
  fnClientBtreeRoot_rets		Result = ZeroResult;
  fnClientBtreeRoot_args	InArguments;

  /* Client initialization: */
  if ( __bClientInitialize__ ) {
    __bClientInitialize__	= FALSE;
    RPC_CLIENT_INITIALIZE();
  }

#if	CLIENT_CREATE_BY_USER
  if ( __pClient__ == NULL ) {
    __pClient__	= RPC_CLIENT_CREATE ( __szHost__, __szTransport__ );
    if ( __pClient__ == NULL ) {
      /* Error handling for a not connected client: */
      char	szError [ 256 ];
      sprintf ( szError, szFormatNoServer, __procedure__ );
      RPC_CLIENT_ERROR ( szError );
      return Result.ReturnValue;
    }
  }
#else
  while ( __pClient__ == NULL ) {
    __pClient__	= RPC_CLIENT_CREATE ( __szHost__, __szTransport__ );
    if ( __pClient__ == NULL ) {
      /* Error handling for a not connected client: */
      char	szError [ 256 ];
      sprintf ( szError, szFormatNoServer, __procedure__ );
      RPC_CLIENT_CERROR ( szContNoServer, szError );
    }
  }
#endif	/* CLIENT_CREATE_BY_USER */

  /* Copy in the oShortObjIdHeap argument: */
  InArguments.oShortObjIdHeap	= oShortObjIdHeap;
  /* Copy in the oShortObjIdBTree argument: */
  InArguments.oShortObjIdBTree	= oShortObjIdBTree;

  pResult	=
#ifdef MULTITHREAD
    (
#else
    (fnClientBtreeRoot_rets *)
#endif
    fnrpc_fnclientbtreeroot_1 (
	&InArguments,
#ifdef MULTITHREAD
	&Result,
#endif
	__pClient__ )
#ifdef MULTITHREAD
	== RPC_SUCCESS ) ? &Result : NULL
#endif
	;

  if ( pResult == NULL ) {
    /* Error handling for a failed RPC call, */
    /* i.e. the server did not respond: */
    char	szError [ 256 ];
    sprintf ( szError, szFormatRpcFailed, __procedure__,
              clnt_sperror ( __pClient__, __szHost__ ) );
    __pClient__	= RPC_CLIENT_DESTROY ( __pClient__ );
    RPC_CLIENT_CERROR ( szContRpcFailed, szError );
    Result	= ZeroResult;
    return Result.ReturnValue;
  }
#ifndef MULTITHREAD
  Result	= * pResult;
#endif


  if ( pResult && pResult->nErrorLvl ) {
    /* Server returned a user error message: */
    char	szErrorMsg [ 1024 ];
    strncpy ( szErrorMsg,
              ( pResult->pszErrorMsg && pResult->pszErrorMsg [ 0 ] ) ?
              (LPCSTR) pResult->pszErrorMsg : (LPCSTR) szEmpty,
              sizeof ( szErrorMsg ) );
    szErrorMsg [ sizeof ( szErrorMsg ) - 1 ]	= (char) 0;
    xdr_free ( (xdrproc_t) xdr_fnClientBtreeRoot_rets, (char *) pResult );
    RPC_CLIENT_SERROR ( pResult->nErrorLvl, __procedure__,
                        szErrorMsg );
  } else {
    xdr_free ( (xdrproc_t) xdr_fnClientBtreeRoot_rets, (char *) pResult );
  }

  return Result.ReturnValue;

} /* fnClientBtreeRoot */



int DLLEXPORT fnClientBtreeSize
	(SHORTOBJID oShortObjIdHeap ,
	  SHORTOBJID oShortObjIdBTree)
{
  static const char	__procedure__[]	= "client:fnClientBtreeSize";
  static fnClientBtreeSize_rets	ZeroResult;
  fnClientBtreeSize_rets		* pResult = NULL;
  fnClientBtreeSize_rets		Result = ZeroResult;
  fnClientBtreeSize_args	InArguments;

  /* Client initialization: */
  if ( __bClientInitialize__ ) {
    __bClientInitialize__	= FALSE;
    RPC_CLIENT_INITIALIZE();
  }

#if	CLIENT_CREATE_BY_USER
  if ( __pClient__ == NULL ) {
    __pClient__	= RPC_CLIENT_CREATE ( __szHost__, __szTransport__ );
    if ( __pClient__ == NULL ) {
      /* Error handling for a not connected client: */
      char	szError [ 256 ];
      sprintf ( szError, szFormatNoServer, __procedure__ );
      RPC_CLIENT_ERROR ( szError );
      return Result.ReturnValue;
    }
  }
#else
  while ( __pClient__ == NULL ) {
    __pClient__	= RPC_CLIENT_CREATE ( __szHost__, __szTransport__ );
    if ( __pClient__ == NULL ) {
      /* Error handling for a not connected client: */
      char	szError [ 256 ];
      sprintf ( szError, szFormatNoServer, __procedure__ );
      RPC_CLIENT_CERROR ( szContNoServer, szError );
    }
  }
#endif	/* CLIENT_CREATE_BY_USER */

  /* Copy in the oShortObjIdHeap argument: */
  InArguments.oShortObjIdHeap	= oShortObjIdHeap;
  /* Copy in the oShortObjIdBTree argument: */
  InArguments.oShortObjIdBTree	= oShortObjIdBTree;

  pResult	=
#ifdef MULTITHREAD
    (
#else
    (fnClientBtreeSize_rets *)
#endif
    fnrpc_fnclientbtreesize_1 (
	&InArguments,
#ifdef MULTITHREAD
	&Result,
#endif
	__pClient__ )
#ifdef MULTITHREAD
	== RPC_SUCCESS ) ? &Result : NULL
#endif
	;

  if ( pResult == NULL ) {
    /* Error handling for a failed RPC call, */
    /* i.e. the server did not respond: */
    char	szError [ 256 ];
    sprintf ( szError, szFormatRpcFailed, __procedure__,
              clnt_sperror ( __pClient__, __szHost__ ) );
    __pClient__	= RPC_CLIENT_DESTROY ( __pClient__ );
    RPC_CLIENT_CERROR ( szContRpcFailed, szError );
    Result	= ZeroResult;
    return Result.ReturnValue;
  }
#ifndef MULTITHREAD
  Result	= * pResult;
#endif


  if ( pResult && pResult->nErrorLvl ) {
    /* Server returned a user error message: */
    char	szErrorMsg [ 1024 ];
    strncpy ( szErrorMsg,
              ( pResult->pszErrorMsg && pResult->pszErrorMsg [ 0 ] ) ?
              (LPCSTR) pResult->pszErrorMsg : (LPCSTR) szEmpty,
              sizeof ( szErrorMsg ) );
    szErrorMsg [ sizeof ( szErrorMsg ) - 1 ]	= (char) 0;
    xdr_free ( (xdrproc_t) xdr_fnClientBtreeSize_rets, (char *) pResult );
    RPC_CLIENT_SERROR ( pResult->nErrorLvl, __procedure__,
                        szErrorMsg );
  } else {
    xdr_free ( (xdrproc_t) xdr_fnClientBtreeSize_rets, (char *) pResult );
  }

  return Result.ReturnValue;

} /* fnClientBtreeSize */



COMPARETAG DLLEXPORT fnClientBtreeTestMode
	(SHORTOBJID oShortObjIdHeap ,
	  SHORTOBJID oShortObjIdBTree ,
	  COMPARETAG nNewTestMode)
{
  static const char	__procedure__[]	= "client:fnClientBtreeTestMode";
  static fnClientBtreeTestMode_rets	ZeroResult;
  fnClientBtreeTestMode_rets		* pResult = NULL;
  fnClientBtreeTestMode_rets		Result = ZeroResult;
  fnClientBtreeTestMode_args	InArguments;

  /* Client initialization: */
  if ( __bClientInitialize__ ) {
    __bClientInitialize__	= FALSE;
    RPC_CLIENT_INITIALIZE();
  }

#if	CLIENT_CREATE_BY_USER
  if ( __pClient__ == NULL ) {
    __pClient__	= RPC_CLIENT_CREATE ( __szHost__, __szTransport__ );
    if ( __pClient__ == NULL ) {
      /* Error handling for a not connected client: */
      char	szError [ 256 ];
      sprintf ( szError, szFormatNoServer, __procedure__ );
      RPC_CLIENT_ERROR ( szError );
      return Result.ReturnValue;
    }
  }
#else
  while ( __pClient__ == NULL ) {
    __pClient__	= RPC_CLIENT_CREATE ( __szHost__, __szTransport__ );
    if ( __pClient__ == NULL ) {
      /* Error handling for a not connected client: */
      char	szError [ 256 ];
      sprintf ( szError, szFormatNoServer, __procedure__ );
      RPC_CLIENT_CERROR ( szContNoServer, szError );
    }
  }
#endif	/* CLIENT_CREATE_BY_USER */

  /* Copy in the oShortObjIdHeap argument: */
  InArguments.oShortObjIdHeap	= oShortObjIdHeap;
  /* Copy in the oShortObjIdBTree argument: */
  InArguments.oShortObjIdBTree	= oShortObjIdBTree;
  /* Copy in the nNewTestMode argument: */
  InArguments.nNewTestMode	= nNewTestMode;

  pResult	=
#ifdef MULTITHREAD
    (
#else
    (fnClientBtreeTestMode_rets *)
#endif
    fnrpc_fnclientbtreetestmode_1 (
	&InArguments,
#ifdef MULTITHREAD
	&Result,
#endif
	__pClient__ )
#ifdef MULTITHREAD
	== RPC_SUCCESS ) ? &Result : NULL
#endif
	;

  if ( pResult == NULL ) {
    /* Error handling for a failed RPC call, */
    /* i.e. the server did not respond: */
    char	szError [ 256 ];
    sprintf ( szError, szFormatRpcFailed, __procedure__,
              clnt_sperror ( __pClient__, __szHost__ ) );
    __pClient__	= RPC_CLIENT_DESTROY ( __pClient__ );
    RPC_CLIENT_CERROR ( szContRpcFailed, szError );
    Result	= ZeroResult;
    return Result.ReturnValue;
  }
#ifndef MULTITHREAD
  Result	= * pResult;
#endif


  if ( pResult && pResult->nErrorLvl ) {
    /* Server returned a user error message: */
    char	szErrorMsg [ 1024 ];
    strncpy ( szErrorMsg,
              ( pResult->pszErrorMsg && pResult->pszErrorMsg [ 0 ] ) ?
              (LPCSTR) pResult->pszErrorMsg : (LPCSTR) szEmpty,
              sizeof ( szErrorMsg ) );
    szErrorMsg [ sizeof ( szErrorMsg ) - 1 ]	= (char) 0;
    xdr_free ( (xdrproc_t) xdr_fnClientBtreeTestMode_rets, (char *) pResult );
    RPC_CLIENT_SERROR ( pResult->nErrorLvl, __procedure__,
                        szErrorMsg );
  } else {
    xdr_free ( (xdrproc_t) xdr_fnClientBtreeTestMode_rets, (char *) pResult );
  }

  return Result.ReturnValue;

} /* fnClientBtreeTestMode */



int DLLEXPORT fnClientBtreePageSize
	(SHORTOBJID oShortObjIdHeap ,
	  SHORTOBJID oShortObjIdBTree ,
	  int nNewPageSize)
{
  static const char	__procedure__[]	= "client:fnClientBtreePageSize";
  static fnClientBtreePageSize_rets	ZeroResult;
  fnClientBtreePageSize_rets		* pResult = NULL;
  fnClientBtreePageSize_rets		Result = ZeroResult;
  fnClientBtreePageSize_args	InArguments;

  /* Client initialization: */
  if ( __bClientInitialize__ ) {
    __bClientInitialize__	= FALSE;
    RPC_CLIENT_INITIALIZE();
  }

#if	CLIENT_CREATE_BY_USER
  if ( __pClient__ == NULL ) {
    __pClient__	= RPC_CLIENT_CREATE ( __szHost__, __szTransport__ );
    if ( __pClient__ == NULL ) {
      /* Error handling for a not connected client: */
      char	szError [ 256 ];
      sprintf ( szError, szFormatNoServer, __procedure__ );
      RPC_CLIENT_ERROR ( szError );
      return Result.ReturnValue;
    }
  }
#else
  while ( __pClient__ == NULL ) {
    __pClient__	= RPC_CLIENT_CREATE ( __szHost__, __szTransport__ );
    if ( __pClient__ == NULL ) {
      /* Error handling for a not connected client: */
      char	szError [ 256 ];
      sprintf ( szError, szFormatNoServer, __procedure__ );
      RPC_CLIENT_CERROR ( szContNoServer, szError );
    }
  }
#endif	/* CLIENT_CREATE_BY_USER */

  /* Copy in the oShortObjIdHeap argument: */
  InArguments.oShortObjIdHeap	= oShortObjIdHeap;
  /* Copy in the oShortObjIdBTree argument: */
  InArguments.oShortObjIdBTree	= oShortObjIdBTree;
  /* Copy in the nNewPageSize argument: */
  InArguments.nNewPageSize	= nNewPageSize;

  pResult	=
#ifdef MULTITHREAD
    (
#else
    (fnClientBtreePageSize_rets *)
#endif
    fnrpc_fnclientbtreepagesize_1 (
	&InArguments,
#ifdef MULTITHREAD
	&Result,
#endif
	__pClient__ )
#ifdef MULTITHREAD
	== RPC_SUCCESS ) ? &Result : NULL
#endif
	;

  if ( pResult == NULL ) {
    /* Error handling for a failed RPC call, */
    /* i.e. the server did not respond: */
    char	szError [ 256 ];
    sprintf ( szError, szFormatRpcFailed, __procedure__,
              clnt_sperror ( __pClient__, __szHost__ ) );
    __pClient__	= RPC_CLIENT_DESTROY ( __pClient__ );
    RPC_CLIENT_CERROR ( szContRpcFailed, szError );
    Result	= ZeroResult;
    return Result.ReturnValue;
  }
#ifndef MULTITHREAD
  Result	= * pResult;
#endif


  if ( pResult && pResult->nErrorLvl ) {
    /* Server returned a user error message: */
    char	szErrorMsg [ 1024 ];
    strncpy ( szErrorMsg,
              ( pResult->pszErrorMsg && pResult->pszErrorMsg [ 0 ] ) ?
              (LPCSTR) pResult->pszErrorMsg : (LPCSTR) szEmpty,
              sizeof ( szErrorMsg ) );
    szErrorMsg [ sizeof ( szErrorMsg ) - 1 ]	= (char) 0;
    xdr_free ( (xdrproc_t) xdr_fnClientBtreePageSize_rets, (char *) pResult );
    RPC_CLIENT_SERROR ( pResult->nErrorLvl, __procedure__,
                        szErrorMsg );
  } else {
    xdr_free ( (xdrproc_t) xdr_fnClientBtreePageSize_rets, (char *) pResult );
  }

  return Result.ReturnValue;

} /* fnClientBtreePageSize */



OBJID DLLEXPORT fnClientBtreepageParent
	(SHORTOBJID oShortObjIdHeap ,
	  SHORTOBJID oShortObjIdBTreePage)
{
  static const char	__procedure__[]	= "client:fnClientBtreepageParent";
  static fnClientBtreepageParent_rets	ZeroResult;
  fnClientBtreepageParent_rets		* pResult = NULL;
  fnClientBtreepageParent_rets		Result = ZeroResult;
  fnClientBtreepageParent_args	InArguments;

  /* Client initialization: */
  if ( __bClientInitialize__ ) {
    __bClientInitialize__	= FALSE;
    RPC_CLIENT_INITIALIZE();
  }

#if	CLIENT_CREATE_BY_USER
  if ( __pClient__ == NULL ) {
    __pClient__	= RPC_CLIENT_CREATE ( __szHost__, __szTransport__ );
    if ( __pClient__ == NULL ) {
      /* Error handling for a not connected client: */
      char	szError [ 256 ];
      sprintf ( szError, szFormatNoServer, __procedure__ );
      RPC_CLIENT_ERROR ( szError );
      return Result.ReturnValue;
    }
  }
#else
  while ( __pClient__ == NULL ) {
    __pClient__	= RPC_CLIENT_CREATE ( __szHost__, __szTransport__ );
    if ( __pClient__ == NULL ) {
      /* Error handling for a not connected client: */
      char	szError [ 256 ];
      sprintf ( szError, szFormatNoServer, __procedure__ );
      RPC_CLIENT_CERROR ( szContNoServer, szError );
    }
  }
#endif	/* CLIENT_CREATE_BY_USER */

  /* Copy in the oShortObjIdHeap argument: */
  InArguments.oShortObjIdHeap	= oShortObjIdHeap;
  /* Copy in the oShortObjIdBTreePage argument: */
  InArguments.oShortObjIdBTreePage	= oShortObjIdBTreePage;

  pResult	=
#ifdef MULTITHREAD
    (
#else
    (fnClientBtreepageParent_rets *)
#endif
    fnrpc_fnclientbtreepageparent_1 (
	&InArguments,
#ifdef MULTITHREAD
	&Result,
#endif
	__pClient__ )
#ifdef MULTITHREAD
	== RPC_SUCCESS ) ? &Result : NULL
#endif
	;

  if ( pResult == NULL ) {
    /* Error handling for a failed RPC call, */
    /* i.e. the server did not respond: */
    char	szError [ 256 ];
    sprintf ( szError, szFormatRpcFailed, __procedure__,
              clnt_sperror ( __pClient__, __szHost__ ) );
    __pClient__	= RPC_CLIENT_DESTROY ( __pClient__ );
    RPC_CLIENT_CERROR ( szContRpcFailed, szError );
    Result	= ZeroResult;
    return Result.ReturnValue;
  }
#ifndef MULTITHREAD
  Result	= * pResult;
#endif


  if ( pResult && pResult->nErrorLvl ) {
    /* Server returned a user error message: */
    char	szErrorMsg [ 1024 ];
    strncpy ( szErrorMsg,
              ( pResult->pszErrorMsg && pResult->pszErrorMsg [ 0 ] ) ?
              (LPCSTR) pResult->pszErrorMsg : (LPCSTR) szEmpty,
              sizeof ( szErrorMsg ) );
    szErrorMsg [ sizeof ( szErrorMsg ) - 1 ]	= (char) 0;
    xdr_free ( (xdrproc_t) xdr_fnClientBtreepageParent_rets, (char *) pResult );
    RPC_CLIENT_SERROR ( pResult->nErrorLvl, __procedure__,
                        szErrorMsg );
  } else {
    xdr_free ( (xdrproc_t) xdr_fnClientBtreepageParent_rets, (char *) pResult );
  }

  return Result.ReturnValue;

} /* fnClientBtreepageParent */



int DLLEXPORT fnClientBtreepageCount
	(SHORTOBJID oShortObjIdHeap ,
	  SHORTOBJID oShortObjIdBTreePage)
{
  static const char	__procedure__[]	= "client:fnClientBtreepageCount";
  static fnClientBtreepageCount_rets	ZeroResult;
  fnClientBtreepageCount_rets		* pResult = NULL;
  fnClientBtreepageCount_rets		Result = ZeroResult;
  fnClientBtreepageCount_args	InArguments;

  /* Client initialization: */
  if ( __bClientInitialize__ ) {
    __bClientInitialize__	= FALSE;
    RPC_CLIENT_INITIALIZE();
  }

#if	CLIENT_CREATE_BY_USER
  if ( __pClient__ == NULL ) {
    __pClient__	= RPC_CLIENT_CREATE ( __szHost__, __szTransport__ );
    if ( __pClient__ == NULL ) {
      /* Error handling for a not connected client: */
      char	szError [ 256 ];
      sprintf ( szError, szFormatNoServer, __procedure__ );
      RPC_CLIENT_ERROR ( szError );
      return Result.ReturnValue;
    }
  }
#else
  while ( __pClient__ == NULL ) {
    __pClient__	= RPC_CLIENT_CREATE ( __szHost__, __szTransport__ );
    if ( __pClient__ == NULL ) {
      /* Error handling for a not connected client: */
      char	szError [ 256 ];
      sprintf ( szError, szFormatNoServer, __procedure__ );
      RPC_CLIENT_CERROR ( szContNoServer, szError );
    }
  }
#endif	/* CLIENT_CREATE_BY_USER */

  /* Copy in the oShortObjIdHeap argument: */
  InArguments.oShortObjIdHeap	= oShortObjIdHeap;
  /* Copy in the oShortObjIdBTreePage argument: */
  InArguments.oShortObjIdBTreePage	= oShortObjIdBTreePage;

  pResult	=
#ifdef MULTITHREAD
    (
#else
    (fnClientBtreepageCount_rets *)
#endif
    fnrpc_fnclientbtreepagecount_1 (
	&InArguments,
#ifdef MULTITHREAD
	&Result,
#endif
	__pClient__ )
#ifdef MULTITHREAD
	== RPC_SUCCESS ) ? &Result : NULL
#endif
	;

  if ( pResult == NULL ) {
    /* Error handling for a failed RPC call, */
    /* i.e. the server did not respond: */
    char	szError [ 256 ];
    sprintf ( szError, szFormatRpcFailed, __procedure__,
              clnt_sperror ( __pClient__, __szHost__ ) );
    __pClient__	= RPC_CLIENT_DESTROY ( __pClient__ );
    RPC_CLIENT_CERROR ( szContRpcFailed, szError );
    Result	= ZeroResult;
    return Result.ReturnValue;
  }
#ifndef MULTITHREAD
  Result	= * pResult;
#endif


  if ( pResult && pResult->nErrorLvl ) {
    /* Server returned a user error message: */
    char	szErrorMsg [ 1024 ];
    strncpy ( szErrorMsg,
              ( pResult->pszErrorMsg && pResult->pszErrorMsg [ 0 ] ) ?
              (LPCSTR) pResult->pszErrorMsg : (LPCSTR) szEmpty,
              sizeof ( szErrorMsg ) );
    szErrorMsg [ sizeof ( szErrorMsg ) - 1 ]	= (char) 0;
    xdr_free ( (xdrproc_t) xdr_fnClientBtreepageCount_rets, (char *) pResult );
    RPC_CLIENT_SERROR ( pResult->nErrorLvl, __procedure__,
                        szErrorMsg );
  } else {
    xdr_free ( (xdrproc_t) xdr_fnClientBtreepageCount_rets, (char *) pResult );
  }

  return Result.ReturnValue;

} /* fnClientBtreepageCount */



int DLLEXPORT fnClientBtreepageGetSize
	(SHORTOBJID oShortObjIdHeap ,
	  SHORTOBJID oShortObjIdBTreePage)
{
  static const char	__procedure__[]	= "client:fnClientBtreepageGetSize";
  static fnClientBtreepageGetSize_rets	ZeroResult;
  fnClientBtreepageGetSize_rets		* pResult = NULL;
  fnClientBtreepageGetSize_rets		Result = ZeroResult;
  fnClientBtreepageGetSize_args	InArguments;

  /* Client initialization: */
  if ( __bClientInitialize__ ) {
    __bClientInitialize__	= FALSE;
    RPC_CLIENT_INITIALIZE();
  }

#if	CLIENT_CREATE_BY_USER
  if ( __pClient__ == NULL ) {
    __pClient__	= RPC_CLIENT_CREATE ( __szHost__, __szTransport__ );
    if ( __pClient__ == NULL ) {
      /* Error handling for a not connected client: */
      char	szError [ 256 ];
      sprintf ( szError, szFormatNoServer, __procedure__ );
      RPC_CLIENT_ERROR ( szError );
      return Result.ReturnValue;
    }
  }
#else
  while ( __pClient__ == NULL ) {
    __pClient__	= RPC_CLIENT_CREATE ( __szHost__, __szTransport__ );
    if ( __pClient__ == NULL ) {
      /* Error handling for a not connected client: */
      char	szError [ 256 ];
      sprintf ( szError, szFormatNoServer, __procedure__ );
      RPC_CLIENT_CERROR ( szContNoServer, szError );
    }
  }
#endif	/* CLIENT_CREATE_BY_USER */

  /* Copy in the oShortObjIdHeap argument: */
  InArguments.oShortObjIdHeap	= oShortObjIdHeap;
  /* Copy in the oShortObjIdBTreePage argument: */
  InArguments.oShortObjIdBTreePage	= oShortObjIdBTreePage;

  pResult	=
#ifdef MULTITHREAD
    (
#else
    (fnClientBtreepageGetSize_rets *)
#endif
    fnrpc_fnclientbtreepagegetsize_1 (
	&InArguments,
#ifdef MULTITHREAD
	&Result,
#endif
	__pClient__ )
#ifdef MULTITHREAD
	== RPC_SUCCESS ) ? &Result : NULL
#endif
	;

  if ( pResult == NULL ) {
    /* Error handling for a failed RPC call, */
    /* i.e. the server did not respond: */
    char	szError [ 256 ];
    sprintf ( szError, szFormatRpcFailed, __procedure__,
              clnt_sperror ( __pClient__, __szHost__ ) );
    __pClient__	= RPC_CLIENT_DESTROY ( __pClient__ );
    RPC_CLIENT_CERROR ( szContRpcFailed, szError );
    Result	= ZeroResult;
    return Result.ReturnValue;
  }
#ifndef MULTITHREAD
  Result	= * pResult;
#endif


  if ( pResult && pResult->nErrorLvl ) {
    /* Server returned a user error message: */
    char	szErrorMsg [ 1024 ];
    strncpy ( szErrorMsg,
              ( pResult->pszErrorMsg && pResult->pszErrorMsg [ 0 ] ) ?
              (LPCSTR) pResult->pszErrorMsg : (LPCSTR) szEmpty,
              sizeof ( szErrorMsg ) );
    szErrorMsg [ sizeof ( szErrorMsg ) - 1 ]	= (char) 0;
    xdr_free ( (xdrproc_t) xdr_fnClientBtreepageGetSize_rets, (char *) pResult );
    RPC_CLIENT_SERROR ( pResult->nErrorLvl, __procedure__,
                        szErrorMsg );
  } else {
    xdr_free ( (xdrproc_t) xdr_fnClientBtreepageGetSize_rets, (char *) pResult );
  }

  return Result.ReturnValue;

} /* fnClientBtreepageGetSize */



int DLLEXPORT fnClientBtreepageItem
	(SHORTOBJID oShortObjIdHeap ,
	  SHORTOBJID oShortObjIdBTreePage ,
	  int nIndex ,
	  int nItems ,
	  int * /* _vector_t<nItems> */  pnValueKey ,
	  u_int * /* _vector_t<nItems> */  pnTypeTagKey ,
	  int * /* _vector_t<nItems> */  pnValueData ,
	  u_int * /* _vector_t<nItems> */  pnTypeTagData ,
	  u_int * /* _vector_t<nItems> */  poNext)
{
  static const char	__procedure__[]	= "client:fnClientBtreepageItem";
  static fnClientBtreepageItem_rets	ZeroResult;
  fnClientBtreepageItem_rets		* pResult = NULL;
  fnClientBtreepageItem_rets		Result = ZeroResult;
  fnClientBtreepageItem_args	InArguments;

  /* Client initialization: */
  if ( __bClientInitialize__ ) {
    __bClientInitialize__	= FALSE;
    RPC_CLIENT_INITIALIZE();
  }

#if	CLIENT_CREATE_BY_USER
  if ( __pClient__ == NULL ) {
    __pClient__	= RPC_CLIENT_CREATE ( __szHost__, __szTransport__ );
    if ( __pClient__ == NULL ) {
      /* Error handling for a not connected client: */
      char	szError [ 256 ];
      sprintf ( szError, szFormatNoServer, __procedure__ );
      RPC_CLIENT_ERROR ( szError );
      return Result.ReturnValue;
    }
  }
#else
  while ( __pClient__ == NULL ) {
    __pClient__	= RPC_CLIENT_CREATE ( __szHost__, __szTransport__ );
    if ( __pClient__ == NULL ) {
      /* Error handling for a not connected client: */
      char	szError [ 256 ];
      sprintf ( szError, szFormatNoServer, __procedure__ );
      RPC_CLIENT_CERROR ( szContNoServer, szError );
    }
  }
#endif	/* CLIENT_CREATE_BY_USER */

  /* Copy in the oShortObjIdHeap argument: */
  InArguments.oShortObjIdHeap	= oShortObjIdHeap;
  /* Copy in the oShortObjIdBTreePage argument: */
  InArguments.oShortObjIdBTreePage	= oShortObjIdBTreePage;
  /* Copy in the nIndex argument: */
  InArguments.nIndex	= nIndex;
  /* Copy in the nItems argument: */
  InArguments.nItems	= nItems;
  InArguments.pnValueKeySize	= nItems;
  InArguments.pnTypeTagKeySize	= nItems;
  InArguments.pnValueDataSize	= nItems;
  InArguments.pnTypeTagDataSize	= nItems;
  InArguments.poNextSize	= nItems;

  pResult	=
#ifdef MULTITHREAD
    (
#else
    (fnClientBtreepageItem_rets *)
#endif
    fnrpc_fnclientbtreepageitem_1 (
	&InArguments,
#ifdef MULTITHREAD
	&Result,
#endif
	__pClient__ )
#ifdef MULTITHREAD
	== RPC_SUCCESS ) ? &Result : NULL
#endif
	;

  if ( pResult == NULL ) {
    /* Error handling for a failed RPC call, */
    /* i.e. the server did not respond: */
    char	szError [ 256 ];
    sprintf ( szError, szFormatRpcFailed, __procedure__,
              clnt_sperror ( __pClient__, __szHost__ ) );
    __pClient__	= RPC_CLIENT_DESTROY ( __pClient__ );
    RPC_CLIENT_CERROR ( szContRpcFailed, szError );
    Result	= ZeroResult;
    return Result.ReturnValue;
  }
#ifndef MULTITHREAD
  Result	= * pResult;
#endif

  /* Copy out the pnValueKey argument: */
  if ( ! ( 
       pResult->pnValueKey.int_vector_t_len != 0 &&
       pnValueKey == NULL ) ) {
    memcpy ( pnValueKey,
             pResult->pnValueKey.int_vector_t_val,
             MIN ( pResult->pnValueKey.int_vector_t_len,
                   nItems ) *
             SIZEOF ( *(pResult->pnValueKey.int_vector_t_val) ) );
  }
  /* Copy out the pnTypeTagKey argument: */
  if ( ! ( 
       pResult->pnTypeTagKey.u_int_vector_t_len != 0 &&
       pnTypeTagKey == NULL ) ) {
    memcpy ( pnTypeTagKey,
             pResult->pnTypeTagKey.u_int_vector_t_val,
             MIN ( pResult->pnTypeTagKey.u_int_vector_t_len,
                   nItems ) *
             SIZEOF ( *(pResult->pnTypeTagKey.u_int_vector_t_val) ) );
  }
  /* Copy out the pnValueData argument: */
  if ( ! ( 
       pResult->pnValueData.int_vector_t_len != 0 &&
       pnValueData == NULL ) ) {
    memcpy ( pnValueData,
             pResult->pnValueData.int_vector_t_val,
             MIN ( pResult->pnValueData.int_vector_t_len,
                   nItems ) *
             SIZEOF ( *(pResult->pnValueData.int_vector_t_val) ) );
  }
  /* Copy out the pnTypeTagData argument: */
  if ( ! ( 
       pResult->pnTypeTagData.u_int_vector_t_len != 0 &&
       pnTypeTagData == NULL ) ) {
    memcpy ( pnTypeTagData,
             pResult->pnTypeTagData.u_int_vector_t_val,
             MIN ( pResult->pnTypeTagData.u_int_vector_t_len,
                   nItems ) *
             SIZEOF ( *(pResult->pnTypeTagData.u_int_vector_t_val) ) );
  }
  /* Copy out the poNext argument: */
  if ( ! ( 
       pResult->poNext.u_int_vector_t_len != 0 &&
       poNext == NULL ) ) {
    memcpy ( poNext,
             pResult->poNext.u_int_vector_t_val,
             MIN ( pResult->poNext.u_int_vector_t_len,
                   nItems ) *
             SIZEOF ( *(pResult->poNext.u_int_vector_t_val) ) );
  }

  if ( pResult && pResult->nErrorLvl ) {
    /* Server returned a user error message: */
    char	szErrorMsg [ 1024 ];
    strncpy ( szErrorMsg,
              ( pResult->pszErrorMsg && pResult->pszErrorMsg [ 0 ] ) ?
              (LPCSTR) pResult->pszErrorMsg : (LPCSTR) szEmpty,
              sizeof ( szErrorMsg ) );
    szErrorMsg [ sizeof ( szErrorMsg ) - 1 ]	= (char) 0;
    xdr_free ( (xdrproc_t) xdr_fnClientBtreepageItem_rets, (char *) pResult );
    RPC_CLIENT_SERROR ( pResult->nErrorLvl, __procedure__,
                        szErrorMsg );
  } else {
    xdr_free ( (xdrproc_t) xdr_fnClientBtreepageItem_rets, (char *) pResult );
  }
  if ( 
       pResult->pnValueKey.int_vector_t_len != 0 &&
       pnValueKey == NULL ) {
    /* Error handling for passing a NULL pointer on */
    /* out argument: */
    char	szError [ 256 ];
    sprintf ( szError, szFormatNullPassed,
              __procedure__, "pnValueKey" );
    RPC_CLIENT_CERROR ( szContNullOutPassed, szError );
  } else if ( pResult->pnValueKey.int_vector_t_len > nItems ) {
      /* Error handling for an output buffer overflow, */
      /* i.e. the buffer size passed is too small: */
      /* For example, signal a CERROR here ... */
      char	szError [ 256 ];
      sprintf ( szError, szFormatBufferOverflow,
                __procedure__, "pnValueKey", 
                nItems, 
                pResult->pnValueKey.int_vector_t_len );
      RPC_CLIENT_CERROR ( szContBufferOverflow, szError );
  }
  if ( 
       pResult->pnTypeTagKey.u_int_vector_t_len != 0 &&
       pnTypeTagKey == NULL ) {
    /* Error handling for passing a NULL pointer on */
    /* out argument: */
    char	szError [ 256 ];
    sprintf ( szError, szFormatNullPassed,
              __procedure__, "pnTypeTagKey" );
    RPC_CLIENT_CERROR ( szContNullOutPassed, szError );
  } else if ( pResult->pnTypeTagKey.u_int_vector_t_len > nItems ) {
      /* Error handling for an output buffer overflow, */
      /* i.e. the buffer size passed is too small: */
      /* For example, signal a CERROR here ... */
      char	szError [ 256 ];
      sprintf ( szError, szFormatBufferOverflow,
                __procedure__, "pnTypeTagKey", 
                nItems, 
                pResult->pnTypeTagKey.u_int_vector_t_len );
      RPC_CLIENT_CERROR ( szContBufferOverflow, szError );
  }
  if ( 
       pResult->pnValueData.int_vector_t_len != 0 &&
       pnValueData == NULL ) {
    /* Error handling for passing a NULL pointer on */
    /* out argument: */
    char	szError [ 256 ];
    sprintf ( szError, szFormatNullPassed,
              __procedure__, "pnValueData" );
    RPC_CLIENT_CERROR ( szContNullOutPassed, szError );
  } else if ( pResult->pnValueData.int_vector_t_len > nItems ) {
      /* Error handling for an output buffer overflow, */
      /* i.e. the buffer size passed is too small: */
      /* For example, signal a CERROR here ... */
      char	szError [ 256 ];
      sprintf ( szError, szFormatBufferOverflow,
                __procedure__, "pnValueData", 
                nItems, 
                pResult->pnValueData.int_vector_t_len );
      RPC_CLIENT_CERROR ( szContBufferOverflow, szError );
  }
  if ( 
       pResult->pnTypeTagData.u_int_vector_t_len != 0 &&
       pnTypeTagData == NULL ) {
    /* Error handling for passing a NULL pointer on */
    /* out argument: */
    char	szError [ 256 ];
    sprintf ( szError, szFormatNullPassed,
              __procedure__, "pnTypeTagData" );
    RPC_CLIENT_CERROR ( szContNullOutPassed, szError );
  } else if ( pResult->pnTypeTagData.u_int_vector_t_len > nItems ) {
      /* Error handling for an output buffer overflow, */
      /* i.e. the buffer size passed is too small: */
      /* For example, signal a CERROR here ... */
      char	szError [ 256 ];
      sprintf ( szError, szFormatBufferOverflow,
                __procedure__, "pnTypeTagData", 
                nItems, 
                pResult->pnTypeTagData.u_int_vector_t_len );
      RPC_CLIENT_CERROR ( szContBufferOverflow, szError );
  }
  if ( 
       pResult->poNext.u_int_vector_t_len != 0 &&
       poNext == NULL ) {
    /* Error handling for passing a NULL pointer on */
    /* out argument: */
    char	szError [ 256 ];
    sprintf ( szError, szFormatNullPassed,
              __procedure__, "poNext" );
    RPC_CLIENT_CERROR ( szContNullOutPassed, szError );
  } else if ( pResult->poNext.u_int_vector_t_len > nItems ) {
      /* Error handling for an output buffer overflow, */
      /* i.e. the buffer size passed is too small: */
      /* For example, signal a CERROR here ... */
      char	szError [ 256 ];
      sprintf ( szError, szFormatBufferOverflow,
                __procedure__, "poNext", 
                nItems, 
                pResult->poNext.u_int_vector_t_len );
      RPC_CLIENT_CERROR ( szContBufferOverflow, szError );
  }

  return Result.ReturnValue;

} /* fnClientBtreepageItem */


/* ------------------------------------------------------------------------
| End of plobd.x
 ----------------------------------------------------------------------- */

/* Default timeout can be changed using clnt_control() */
static struct timeval TIMEOUT = { 25, 0 };

#ifdef MULTITHREAD
enum clnt_stat
#else
fnClientDbReadRoot_rets *
#endif
fnrpc_fnclientdbreadroot_1
#ifdef MULTITHREAD
	(argp, clnt_res, clnt)
#else
	(argp, clnt)
#endif
	SHORTOBJID *argp;
#ifdef MULTITHREAD
	fnClientDbReadRoot_rets *clnt_res;
#endif
	CLIENT *clnt;
{
#ifdef MULTITHREAD
	bzero((char *)clnt_res, sizeof(*clnt_res));
	return (clnt_call(clnt, fnRpc_fnClientDbReadRoot,
	                  (xdrproc_t) xdr_SHORTOBJID,
	                  (caddr_t)   argp,
	                  (xdrproc_t) xdr_fnClientDbReadRoot_rets,
	                  (caddr_t)   clnt_res,
	                  TIMEOUT));
#else
	static fnClientDbReadRoot_rets res;

	bzero((char *)&res, sizeof(res));
	if (clnt_call(clnt, fnRpc_fnClientDbReadRoot,
	              (xdrproc_t) xdr_SHORTOBJID,
	              (caddr_t)   argp,
	              (xdrproc_t) xdr_fnClientDbReadRoot_rets,
	              (caddr_t)   &res,
	              TIMEOUT) != RPC_SUCCESS) {
		return (NULL);
	}
	return (&res);
#endif
}


#ifdef MULTITHREAD
enum clnt_stat
#else
fnServerDbWriteRoot_rets *
#endif
fnrpc_fnserverdbwriteroot_1
#ifdef MULTITHREAD
	(argp, clnt_res, clnt)
#else
	(argp, clnt)
#endif
	fnServerDbWriteRoot_args *argp;
#ifdef MULTITHREAD
	fnServerDbWriteRoot_rets *clnt_res;
#endif
	CLIENT *clnt;
{
#ifdef MULTITHREAD
	bzero((char *)clnt_res, sizeof(*clnt_res));
	return (clnt_call(clnt, fnRpc_fnServerDbWriteRoot,
	                  (xdrproc_t) xdr_fnServerDbWriteRoot_args,
	                  (caddr_t)   argp,
	                  (xdrproc_t) xdr_fnServerDbWriteRoot_rets,
	                  (caddr_t)   clnt_res,
	                  TIMEOUT));
#else
	static fnServerDbWriteRoot_rets res;

	bzero((char *)&res, sizeof(res));
	if (clnt_call(clnt, fnRpc_fnServerDbWriteRoot,
	              (xdrproc_t) xdr_fnServerDbWriteRoot_args,
	              (caddr_t)   argp,
	              (xdrproc_t) xdr_fnServerDbWriteRoot_rets,
	              (caddr_t)   &res,
	              TIMEOUT) != RPC_SUCCESS) {
		return (NULL);
	}
	return (&res);
#endif
}


#ifdef MULTITHREAD
enum clnt_stat
#else
fnClientDbSessions_rets *
#endif
fnrpc_fnclientdbsessions_1
#ifdef MULTITHREAD
	(argp, clnt_res, clnt)
#else
	(argp, clnt)
#endif
	SHORTOBJID *argp;
#ifdef MULTITHREAD
	fnClientDbSessions_rets *clnt_res;
#endif
	CLIENT *clnt;
{
#ifdef MULTITHREAD
	bzero((char *)clnt_res, sizeof(*clnt_res));
	return (clnt_call(clnt, fnRpc_fnClientDbSessions,
	                  (xdrproc_t) xdr_SHORTOBJID,
	                  (caddr_t)   argp,
	                  (xdrproc_t) xdr_fnClientDbSessions_rets,
	                  (caddr_t)   clnt_res,
	                  TIMEOUT));
#else
	static fnClientDbSessions_rets res;

	bzero((char *)&res, sizeof(res));
	if (clnt_call(clnt, fnRpc_fnClientDbSessions,
	              (xdrproc_t) xdr_SHORTOBJID,
	              (caddr_t)   argp,
	              (xdrproc_t) xdr_fnClientDbSessions_rets,
	              (caddr_t)   &res,
	              TIMEOUT) != RPC_SUCCESS) {
		return (NULL);
	}
	return (&res);
#endif
}


#ifdef MULTITHREAD
enum clnt_stat
#else
fnServerGetVersion_rets *
#endif
fnrpc_fnservergetversion_1
#ifdef MULTITHREAD
	(argp, clnt_res, clnt)
#else
	(argp, clnt)
#endif
	fnServerGetVersion_args *argp;
#ifdef MULTITHREAD
	fnServerGetVersion_rets *clnt_res;
#endif
	CLIENT *clnt;
{
#ifdef MULTITHREAD
	bzero((char *)clnt_res, sizeof(*clnt_res));
	return (clnt_call(clnt, fnRpc_fnServerGetVersion,
	                  (xdrproc_t) xdr_fnServerGetVersion_args,
	                  (caddr_t)   argp,
	                  (xdrproc_t) xdr_fnServerGetVersion_rets,
	                  (caddr_t)   clnt_res,
	                  TIMEOUT));
#else
	static fnServerGetVersion_rets res;

	bzero((char *)&res, sizeof(res));
	if (clnt_call(clnt, fnRpc_fnServerGetVersion,
	              (xdrproc_t) xdr_fnServerGetVersion_args,
	              (caddr_t)   argp,
	              (xdrproc_t) xdr_fnServerGetVersion_rets,
	              (caddr_t)   &res,
	              TIMEOUT) != RPC_SUCCESS) {
		return (NULL);
	}
	return (&res);
#endif
}


#ifdef MULTITHREAD
enum clnt_stat
#else
fnClientDbCreateMachine_rets *
#endif
fnrpc_fnclientdbcreatemachine_1
#ifdef MULTITHREAD
	(argp, clnt_res, clnt)
#else
	(argp, clnt)
#endif
	fnClientDbCreateMachine_args *argp;
#ifdef MULTITHREAD
	fnClientDbCreateMachine_rets *clnt_res;
#endif
	CLIENT *clnt;
{
#ifdef MULTITHREAD
	bzero((char *)clnt_res, sizeof(*clnt_res));
	return (clnt_call(clnt, fnRpc_fnClientDbCreateMachine,
	                  (xdrproc_t) xdr_fnClientDbCreateMachine_args,
	                  (caddr_t)   argp,
	                  (xdrproc_t) xdr_fnClientDbCreateMachine_rets,
	                  (caddr_t)   clnt_res,
	                  TIMEOUT));
#else
	static fnClientDbCreateMachine_rets res;

	bzero((char *)&res, sizeof(res));
	if (clnt_call(clnt, fnRpc_fnClientDbCreateMachine,
	              (xdrproc_t) xdr_fnClientDbCreateMachine_args,
	              (caddr_t)   argp,
	              (xdrproc_t) xdr_fnClientDbCreateMachine_rets,
	              (caddr_t)   &res,
	              TIMEOUT) != RPC_SUCCESS) {
		return (NULL);
	}
	return (&res);
#endif
}


#ifdef MULTITHREAD
enum clnt_stat
#else
fnClientMachineLoginP_rets *
#endif
fnrpc_fnclientmachineloginp_1
#ifdef MULTITHREAD
	(argp, clnt_res, clnt)
#else
	(argp, clnt)
#endif
	fnClientMachineLoginP_args *argp;
#ifdef MULTITHREAD
	fnClientMachineLoginP_rets *clnt_res;
#endif
	CLIENT *clnt;
{
#ifdef MULTITHREAD
	bzero((char *)clnt_res, sizeof(*clnt_res));
	return (clnt_call(clnt, fnRpc_fnClientMachineLoginP,
	                  (xdrproc_t) xdr_fnClientMachineLoginP_args,
	                  (caddr_t)   argp,
	                  (xdrproc_t) xdr_fnClientMachineLoginP_rets,
	                  (caddr_t)   clnt_res,
	                  TIMEOUT));
#else
	static fnClientMachineLoginP_rets res;

	bzero((char *)&res, sizeof(res));
	if (clnt_call(clnt, fnRpc_fnClientMachineLoginP,
	              (xdrproc_t) xdr_fnClientMachineLoginP_args,
	              (caddr_t)   argp,
	              (xdrproc_t) xdr_fnClientMachineLoginP_rets,
	              (caddr_t)   &res,
	              TIMEOUT) != RPC_SUCCESS) {
		return (NULL);
	}
	return (&res);
#endif
}


#ifdef MULTITHREAD
enum clnt_stat
#else
fnClientMachineAddr_rets *
#endif
fnrpc_fnclientmachineaddr_1
#ifdef MULTITHREAD
	(argp, clnt_res, clnt)
#else
	(argp, clnt)
#endif
	fnClientMachineAddr_args *argp;
#ifdef MULTITHREAD
	fnClientMachineAddr_rets *clnt_res;
#endif
	CLIENT *clnt;
{
#ifdef MULTITHREAD
	bzero((char *)clnt_res, sizeof(*clnt_res));
	return (clnt_call(clnt, fnRpc_fnClientMachineAddr,
	                  (xdrproc_t) xdr_fnClientMachineAddr_args,
	                  (caddr_t)   argp,
	                  (xdrproc_t) xdr_fnClientMachineAddr_rets,
	                  (caddr_t)   clnt_res,
	                  TIMEOUT));
#else
	static fnClientMachineAddr_rets res;

	bzero((char *)&res, sizeof(res));
	if (clnt_call(clnt, fnRpc_fnClientMachineAddr,
	              (xdrproc_t) xdr_fnClientMachineAddr_args,
	              (caddr_t)   argp,
	              (xdrproc_t) xdr_fnClientMachineAddr_rets,
	              (caddr_t)   &res,
	              TIMEOUT) != RPC_SUCCESS) {
		return (NULL);
	}
	return (&res);
#endif
}


#ifdef MULTITHREAD
enum clnt_stat
#else
fnClientDbMachineSearch_rets *
#endif
fnrpc_fnclientdbmachinesearch_1
#ifdef MULTITHREAD
	(argp, clnt_res, clnt)
#else
	(argp, clnt)
#endif
	fnClientDbMachineSearch_args *argp;
#ifdef MULTITHREAD
	fnClientDbMachineSearch_rets *clnt_res;
#endif
	CLIENT *clnt;
{
#ifdef MULTITHREAD
	bzero((char *)clnt_res, sizeof(*clnt_res));
	return (clnt_call(clnt, fnRpc_fnClientDbMachineSearch,
	                  (xdrproc_t) xdr_fnClientDbMachineSearch_args,
	                  (caddr_t)   argp,
	                  (xdrproc_t) xdr_fnClientDbMachineSearch_rets,
	                  (caddr_t)   clnt_res,
	                  TIMEOUT));
#else
	static fnClientDbMachineSearch_rets res;

	bzero((char *)&res, sizeof(res));
	if (clnt_call(clnt, fnRpc_fnClientDbMachineSearch,
	              (xdrproc_t) xdr_fnClientDbMachineSearch_args,
	              (caddr_t)   argp,
	              (xdrproc_t) xdr_fnClientDbMachineSearch_rets,
	              (caddr_t)   &res,
	              TIMEOUT) != RPC_SUCCESS) {
		return (NULL);
	}
	return (&res);
#endif
}


#ifdef MULTITHREAD
enum clnt_stat
#else
fnClientDbMachineDelete_rets *
#endif
fnrpc_fnclientdbmachinedelete_1
#ifdef MULTITHREAD
	(argp, clnt_res, clnt)
#else
	(argp, clnt)
#endif
	fnClientDbMachineDelete_args *argp;
#ifdef MULTITHREAD
	fnClientDbMachineDelete_rets *clnt_res;
#endif
	CLIENT *clnt;
{
#ifdef MULTITHREAD
	bzero((char *)clnt_res, sizeof(*clnt_res));
	return (clnt_call(clnt, fnRpc_fnClientDbMachineDelete,
	                  (xdrproc_t) xdr_fnClientDbMachineDelete_args,
	                  (caddr_t)   argp,
	                  (xdrproc_t) xdr_fnClientDbMachineDelete_rets,
	                  (caddr_t)   clnt_res,
	                  TIMEOUT));
#else
	static fnClientDbMachineDelete_rets res;

	bzero((char *)&res, sizeof(res));
	if (clnt_call(clnt, fnRpc_fnClientDbMachineDelete,
	              (xdrproc_t) xdr_fnClientDbMachineDelete_args,
	              (caddr_t)   argp,
	              (xdrproc_t) xdr_fnClientDbMachineDelete_rets,
	              (caddr_t)   &res,
	              TIMEOUT) != RPC_SUCCESS) {
		return (NULL);
	}
	return (&res);
#endif
}


#ifdef MULTITHREAD
enum clnt_stat
#else
fnClientDbMachineInsert_rets *
#endif
fnrpc_fnclientdbmachineinsert_1
#ifdef MULTITHREAD
	(argp, clnt_res, clnt)
#else
	(argp, clnt)
#endif
	fnClientDbMachineInsert_args *argp;
#ifdef MULTITHREAD
	fnClientDbMachineInsert_rets *clnt_res;
#endif
	CLIENT *clnt;
{
#ifdef MULTITHREAD
	bzero((char *)clnt_res, sizeof(*clnt_res));
	return (clnt_call(clnt, fnRpc_fnClientDbMachineInsert,
	                  (xdrproc_t) xdr_fnClientDbMachineInsert_args,
	                  (caddr_t)   argp,
	                  (xdrproc_t) xdr_fnClientDbMachineInsert_rets,
	                  (caddr_t)   clnt_res,
	                  TIMEOUT));
#else
	static fnClientDbMachineInsert_rets res;

	bzero((char *)&res, sizeof(res));
	if (clnt_call(clnt, fnRpc_fnClientDbMachineInsert,
	              (xdrproc_t) xdr_fnClientDbMachineInsert_args,
	              (caddr_t)   argp,
	              (xdrproc_t) xdr_fnClientDbMachineInsert_rets,
	              (caddr_t)   &res,
	              TIMEOUT) != RPC_SUCCESS) {
		return (NULL);
	}
	return (&res);
#endif
}


#ifdef MULTITHREAD
enum clnt_stat
#else
fnClientDbMachines_rets *
#endif
fnrpc_fnclientdbmachines_1
#ifdef MULTITHREAD
	(argp, clnt_res, clnt)
#else
	(argp, clnt)
#endif
	SHORTOBJID *argp;
#ifdef MULTITHREAD
	fnClientDbMachines_rets *clnt_res;
#endif
	CLIENT *clnt;
{
#ifdef MULTITHREAD
	bzero((char *)clnt_res, sizeof(*clnt_res));
	return (clnt_call(clnt, fnRpc_fnClientDbMachines,
	                  (xdrproc_t) xdr_SHORTOBJID,
	                  (caddr_t)   argp,
	                  (xdrproc_t) xdr_fnClientDbMachines_rets,
	                  (caddr_t)   clnt_res,
	                  TIMEOUT));
#else
	static fnClientDbMachines_rets res;

	bzero((char *)&res, sizeof(res));
	if (clnt_call(clnt, fnRpc_fnClientDbMachines,
	              (xdrproc_t) xdr_SHORTOBJID,
	              (caddr_t)   argp,
	              (xdrproc_t) xdr_fnClientDbMachines_rets,
	              (caddr_t)   &res,
	              TIMEOUT) != RPC_SUCCESS) {
		return (NULL);
	}
	return (&res);
#endif
}


#ifdef MULTITHREAD
enum clnt_stat
#else
fnServerGetPortByDirectory_rets *
#endif
fnrpc_fnservergetportbydirectory_1
#ifdef MULTITHREAD
	(argp, clnt_res, clnt)
#else
	(argp, clnt)
#endif
	fnServerGetPortByDirectory_args *argp;
#ifdef MULTITHREAD
	fnServerGetPortByDirectory_rets *clnt_res;
#endif
	CLIENT *clnt;
{
#ifdef MULTITHREAD
	bzero((char *)clnt_res, sizeof(*clnt_res));
	return (clnt_call(clnt, fnRpc_fnServerGetPortByDirectory,
	                  (xdrproc_t) xdr_fnServerGetPortByDirectory_args,
	                  (caddr_t)   argp,
	                  (xdrproc_t) xdr_fnServerGetPortByDirectory_rets,
	                  (caddr_t)   clnt_res,
	                  TIMEOUT));
#else
	static fnServerGetPortByDirectory_rets res;

	bzero((char *)&res, sizeof(res));
	if (clnt_call(clnt, fnRpc_fnServerGetPortByDirectory,
	              (xdrproc_t) xdr_fnServerGetPortByDirectory_args,
	              (caddr_t)   argp,
	              (xdrproc_t) xdr_fnServerGetPortByDirectory_rets,
	              (caddr_t)   &res,
	              TIMEOUT) != RPC_SUCCESS) {
		return (NULL);
	}
	return (&res);
#endif
}


#ifdef MULTITHREAD
enum clnt_stat
#else
fnServerGetPID_rets *
#endif
fnrpc_fnservergetpid_1
#ifdef MULTITHREAD
	(argp, clnt_res, clnt)
#else
	(argp, clnt)
#endif
	void *argp;
#ifdef MULTITHREAD
	fnServerGetPID_rets *clnt_res;
#endif
	CLIENT *clnt;
{
#ifdef MULTITHREAD
	bzero((char *)clnt_res, sizeof(*clnt_res));
	return (clnt_call(clnt, fnRpc_fnServerGetPID,
	                  (xdrproc_t) xdr_void,
	                  (caddr_t)   argp,
	                  (xdrproc_t) xdr_fnServerGetPID_rets,
	                  (caddr_t)   clnt_res,
	                  TIMEOUT));
#else
	static fnServerGetPID_rets res;

	bzero((char *)&res, sizeof(res));
	if (clnt_call(clnt, fnRpc_fnServerGetPID,
	              (xdrproc_t) xdr_void,
	              (caddr_t)   argp,
	              (xdrproc_t) xdr_fnServerGetPID_rets,
	              (caddr_t)   &res,
	              TIMEOUT) != RPC_SUCCESS) {
		return (NULL);
	}
	return (&res);
#endif
}


#ifdef MULTITHREAD
enum clnt_stat
#else
fnServerGetDirectory_rets *
#endif
fnrpc_fnservergetdirectory_1
#ifdef MULTITHREAD
	(argp, clnt_res, clnt)
#else
	(argp, clnt)
#endif
	fnServerGetDirectory_args *argp;
#ifdef MULTITHREAD
	fnServerGetDirectory_rets *clnt_res;
#endif
	CLIENT *clnt;
{
#ifdef MULTITHREAD
	bzero((char *)clnt_res, sizeof(*clnt_res));
	return (clnt_call(clnt, fnRpc_fnServerGetDirectory,
	                  (xdrproc_t) xdr_fnServerGetDirectory_args,
	                  (caddr_t)   argp,
	                  (xdrproc_t) xdr_fnServerGetDirectory_rets,
	                  (caddr_t)   clnt_res,
	                  TIMEOUT));
#else
	static fnServerGetDirectory_rets res;

	bzero((char *)&res, sizeof(res));
	if (clnt_call(clnt, fnRpc_fnServerGetDirectory,
	              (xdrproc_t) xdr_fnServerGetDirectory_args,
	              (caddr_t)   argp,
	              (xdrproc_t) xdr_fnServerGetDirectory_rets,
	              (caddr_t)   &res,
	              TIMEOUT) != RPC_SUCCESS) {
		return (NULL);
	}
	return (&res);
#endif
}


#ifdef MULTITHREAD
enum clnt_stat
#else
fnServerExit_rets *
#endif
fnrpc_fnserverexit_1
#ifdef MULTITHREAD
	(argp, clnt_res, clnt)
#else
	(argp, clnt)
#endif
	fnServerExit_args *argp;
#ifdef MULTITHREAD
	fnServerExit_rets *clnt_res;
#endif
	CLIENT *clnt;
{
#ifdef MULTITHREAD
	bzero((char *)clnt_res, sizeof(*clnt_res));
	return (clnt_call(clnt, fnRpc_fnServerExit,
	                  (xdrproc_t) xdr_fnServerExit_args,
	                  (caddr_t)   argp,
	                  (xdrproc_t) xdr_fnServerExit_rets,
	                  (caddr_t)   clnt_res,
	                  TIMEOUT));
#else
	static fnServerExit_rets res;

	bzero((char *)&res, sizeof(res));
	if (clnt_call(clnt, fnRpc_fnServerExit,
	              (xdrproc_t) xdr_fnServerExit_args,
	              (caddr_t)   argp,
	              (xdrproc_t) xdr_fnServerExit_rets,
	              (caddr_t)   &res,
	              TIMEOUT) != RPC_SUCCESS) {
		return (NULL);
	}
	return (&res);
#endif
}


#ifdef MULTITHREAD
enum clnt_stat
#else
fnServerDbReset_rets *
#endif
fnrpc_fnserverdbreset_1
#ifdef MULTITHREAD
	(argp, clnt_res, clnt)
#else
	(argp, clnt)
#endif
	fnServerDbReset_args *argp;
#ifdef MULTITHREAD
	fnServerDbReset_rets *clnt_res;
#endif
	CLIENT *clnt;
{
#ifdef MULTITHREAD
	bzero((char *)clnt_res, sizeof(*clnt_res));
	return (clnt_call(clnt, fnRpc_fnServerDbReset,
	                  (xdrproc_t) xdr_fnServerDbReset_args,
	                  (caddr_t)   argp,
	                  (xdrproc_t) xdr_fnServerDbReset_rets,
	                  (caddr_t)   clnt_res,
	                  TIMEOUT));
#else
	static fnServerDbReset_rets res;

	bzero((char *)&res, sizeof(res));
	if (clnt_call(clnt, fnRpc_fnServerDbReset,
	              (xdrproc_t) xdr_fnServerDbReset_args,
	              (caddr_t)   argp,
	              (xdrproc_t) xdr_fnServerDbReset_rets,
	              (caddr_t)   &res,
	              TIMEOUT) != RPC_SUCCESS) {
		return (NULL);
	}
	return (&res);
#endif
}


#ifdef MULTITHREAD
enum clnt_stat
#else
fnServerRestart_rets *
#endif
fnrpc_fnserverrestart_1
#ifdef MULTITHREAD
	(argp, clnt_res, clnt)
#else
	(argp, clnt)
#endif
	fnServerRestart_args *argp;
#ifdef MULTITHREAD
	fnServerRestart_rets *clnt_res;
#endif
	CLIENT *clnt;
{
#ifdef MULTITHREAD
	bzero((char *)clnt_res, sizeof(*clnt_res));
	return (clnt_call(clnt, fnRpc_fnServerRestart,
	                  (xdrproc_t) xdr_fnServerRestart_args,
	                  (caddr_t)   argp,
	                  (xdrproc_t) xdr_fnServerRestart_rets,
	                  (caddr_t)   clnt_res,
	                  TIMEOUT));
#else
	static fnServerRestart_rets res;

	bzero((char *)&res, sizeof(res));
	if (clnt_call(clnt, fnRpc_fnServerRestart,
	              (xdrproc_t) xdr_fnServerRestart_args,
	              (caddr_t)   argp,
	              (xdrproc_t) xdr_fnServerRestart_rets,
	              (caddr_t)   &res,
	              TIMEOUT) != RPC_SUCCESS) {
		return (NULL);
	}
	return (&res);
#endif
}


#ifdef MULTITHREAD
enum clnt_stat
#else
fnClientObjectCanModify_rets *
#endif
fnrpc_fnclientobjectcanmodify_1
#ifdef MULTITHREAD
	(argp, clnt_res, clnt)
#else
	(argp, clnt)
#endif
	fnClientObjectCanModify_args *argp;
#ifdef MULTITHREAD
	fnClientObjectCanModify_rets *clnt_res;
#endif
	CLIENT *clnt;
{
#ifdef MULTITHREAD
	bzero((char *)clnt_res, sizeof(*clnt_res));
	return (clnt_call(clnt, fnRpc_fnClientObjectCanModify,
	                  (xdrproc_t) xdr_fnClientObjectCanModify_args,
	                  (caddr_t)   argp,
	                  (xdrproc_t) xdr_fnClientObjectCanModify_rets,
	                  (caddr_t)   clnt_res,
	                  TIMEOUT));
#else
	static fnClientObjectCanModify_rets res;

	bzero((char *)&res, sizeof(res));
	if (clnt_call(clnt, fnRpc_fnClientObjectCanModify,
	              (xdrproc_t) xdr_fnClientObjectCanModify_args,
	              (caddr_t)   argp,
	              (xdrproc_t) xdr_fnClientObjectCanModify_rets,
	              (caddr_t)   &res,
	              TIMEOUT) != RPC_SUCCESS) {
		return (NULL);
	}
	return (&res);
#endif
}


#ifdef MULTITHREAD
enum clnt_stat
#else
void *
#endif
fnrpc_fnserverdbclose_batch_1
#ifdef MULTITHREAD
	(argp, clnt_res, clnt)
#else
	(argp, clnt)
#endif
	fnServerDbClose_args *argp;
#ifdef MULTITHREAD
	void *clnt_res;
#endif
	CLIENT *clnt;
{
#ifdef MULTITHREAD
	return (clnt_call(clnt, fnRpc_fnServerDbClose_batch,
	                  (xdrproc_t) xdr_fnServerDbClose_args,
	                  (caddr_t)   argp,
	                  (xdrproc_t) xdr_void,
	                  (caddr_t)   clnt_res,
	                  TIMEOUT));
#else
	static char res;

	bzero((char *)&res, sizeof(res));
	if (clnt_call(clnt, fnRpc_fnServerDbClose_batch,
	              (xdrproc_t) xdr_fnServerDbClose_args,
	              (caddr_t)   argp,
	              (xdrproc_t) xdr_void,
	              (caddr_t)   &res,
	              TIMEOUT) != RPC_SUCCESS) {
		return (NULL);
	}
	return ((void *)&res);
#endif
}


#ifdef MULTITHREAD
enum clnt_stat
#else
fnClientDbConfiguration_rets *
#endif
fnrpc_fnclientdbconfiguration_1
#ifdef MULTITHREAD
	(argp, clnt_res, clnt)
#else
	(argp, clnt)
#endif
	SHORTOBJID *argp;
#ifdef MULTITHREAD
	fnClientDbConfiguration_rets *clnt_res;
#endif
	CLIENT *clnt;
{
#ifdef MULTITHREAD
	bzero((char *)clnt_res, sizeof(*clnt_res));
	return (clnt_call(clnt, fnRpc_fnClientDbConfiguration,
	                  (xdrproc_t) xdr_SHORTOBJID,
	                  (caddr_t)   argp,
	                  (xdrproc_t) xdr_fnClientDbConfiguration_rets,
	                  (caddr_t)   clnt_res,
	                  TIMEOUT));
#else
	static fnClientDbConfiguration_rets res;

	bzero((char *)&res, sizeof(res));
	if (clnt_call(clnt, fnRpc_fnClientDbConfiguration,
	              (xdrproc_t) xdr_SHORTOBJID,
	              (caddr_t)   argp,
	              (xdrproc_t) xdr_fnClientDbConfiguration_rets,
	              (caddr_t)   &res,
	              TIMEOUT) != RPC_SUCCESS) {
		return (NULL);
	}
	return (&res);
#endif
}


#ifdef MULTITHREAD
enum clnt_stat
#else
fnServerDbCreateObject_rets *
#endif
fnrpc_fnserverdbcreateobject_1
#ifdef MULTITHREAD
	(argp, clnt_res, clnt)
#else
	(argp, clnt)
#endif
	fnServerDbCreateObject_args *argp;
#ifdef MULTITHREAD
	fnServerDbCreateObject_rets *clnt_res;
#endif
	CLIENT *clnt;
{
#ifdef MULTITHREAD
	bzero((char *)clnt_res, sizeof(*clnt_res));
	return (clnt_call(clnt, fnRpc_fnServerDbCreateObject,
	                  (xdrproc_t) xdr_fnServerDbCreateObject_args,
	                  (caddr_t)   argp,
	                  (xdrproc_t) xdr_fnServerDbCreateObject_rets,
	                  (caddr_t)   clnt_res,
	                  TIMEOUT));
#else
	static fnServerDbCreateObject_rets res;

	bzero((char *)&res, sizeof(res));
	if (clnt_call(clnt, fnRpc_fnServerDbCreateObject,
	              (xdrproc_t) xdr_fnServerDbCreateObject_args,
	              (caddr_t)   argp,
	              (xdrproc_t) xdr_fnServerDbCreateObject_rets,
	              (caddr_t)   &res,
	              TIMEOUT) != RPC_SUCCESS) {
		return (NULL);
	}
	return (&res);
#endif
}


#ifdef MULTITHREAD
enum clnt_stat
#else
fnServerDbCreateObjects_rets *
#endif
fnrpc_fnserverdbcreateobjects_1
#ifdef MULTITHREAD
	(argp, clnt_res, clnt)
#else
	(argp, clnt)
#endif
	fnServerDbCreateObjects_args *argp;
#ifdef MULTITHREAD
	fnServerDbCreateObjects_rets *clnt_res;
#endif
	CLIENT *clnt;
{
#ifdef MULTITHREAD
	bzero((char *)clnt_res, sizeof(*clnt_res));
	return (clnt_call(clnt, fnRpc_fnServerDbCreateObjects,
	                  (xdrproc_t) xdr_fnServerDbCreateObjects_args,
	                  (caddr_t)   argp,
	                  (xdrproc_t) xdr_fnServerDbCreateObjects_rets,
	                  (caddr_t)   clnt_res,
	                  TIMEOUT));
#else
	static fnServerDbCreateObjects_rets res;

	bzero((char *)&res, sizeof(res));
	if (clnt_call(clnt, fnRpc_fnServerDbCreateObjects,
	              (xdrproc_t) xdr_fnServerDbCreateObjects_args,
	              (caddr_t)   argp,
	              (xdrproc_t) xdr_fnServerDbCreateObjects_rets,
	              (caddr_t)   &res,
	              TIMEOUT) != RPC_SUCCESS) {
		return (NULL);
	}
	return (&res);
#endif
}


#ifdef MULTITHREAD
enum clnt_stat
#else
void *
#endif
fnrpc_fnserverobjectdestroy_batch_1
#ifdef MULTITHREAD
	(argp, clnt_res, clnt)
#else
	(argp, clnt)
#endif
	fnServerObjectDestroy_args *argp;
#ifdef MULTITHREAD
	void *clnt_res;
#endif
	CLIENT *clnt;
{
#ifdef MULTITHREAD
	return (clnt_call(clnt, fnRpc_fnServerObjectDestroy_batch,
	                  (xdrproc_t) xdr_fnServerObjectDestroy_args,
	                  (caddr_t)   argp,
	                  (xdrproc_t) xdr_void,
	                  (caddr_t)   clnt_res,
	                  TIMEOUT));
#else
	static char res;

	bzero((char *)&res, sizeof(res));
	if (clnt_call(clnt, fnRpc_fnServerObjectDestroy_batch,
	              (xdrproc_t) xdr_fnServerObjectDestroy_args,
	              (caddr_t)   argp,
	              (xdrproc_t) xdr_void,
	              (caddr_t)   &res,
	              TIMEOUT) != RPC_SUCCESS) {
		return (NULL);
	}
	return ((void *)&res);
#endif
}


#ifdef MULTITHREAD
enum clnt_stat
#else
fnServerObjectObjIdSize_rets *
#endif
fnrpc_fnserverobjectobjidsize_1
#ifdef MULTITHREAD
	(argp, clnt_res, clnt)
#else
	(argp, clnt)
#endif
	fnServerObjectObjIdSize_args *argp;
#ifdef MULTITHREAD
	fnServerObjectObjIdSize_rets *clnt_res;
#endif
	CLIENT *clnt;
{
#ifdef MULTITHREAD
	bzero((char *)clnt_res, sizeof(*clnt_res));
	return (clnt_call(clnt, fnRpc_fnServerObjectObjIdSize,
	                  (xdrproc_t) xdr_fnServerObjectObjIdSize_args,
	                  (caddr_t)   argp,
	                  (xdrproc_t) xdr_fnServerObjectObjIdSize_rets,
	                  (caddr_t)   clnt_res,
	                  TIMEOUT));
#else
	static fnServerObjectObjIdSize_rets res;

	bzero((char *)&res, sizeof(res));
	if (clnt_call(clnt, fnRpc_fnServerObjectObjIdSize,
	              (xdrproc_t) xdr_fnServerObjectObjIdSize_args,
	              (caddr_t)   argp,
	              (xdrproc_t) xdr_fnServerObjectObjIdSize_rets,
	              (caddr_t)   &res,
	              TIMEOUT) != RPC_SUCCESS) {
		return (NULL);
	}
	return (&res);
#endif
}


#ifdef MULTITHREAD
enum clnt_stat
#else
fnServerDbOpen_rets *
#endif
fnrpc_fnserverdbopen_1
#ifdef MULTITHREAD
	(argp, clnt_res, clnt)
#else
	(argp, clnt)
#endif
	fnServerDbOpen_args *argp;
#ifdef MULTITHREAD
	fnServerDbOpen_rets *clnt_res;
#endif
	CLIENT *clnt;
{
#ifdef MULTITHREAD
	bzero((char *)clnt_res, sizeof(*clnt_res));
	return (clnt_call(clnt, fnRpc_fnServerDbOpen,
	                  (xdrproc_t) xdr_fnServerDbOpen_args,
	                  (caddr_t)   argp,
	                  (xdrproc_t) xdr_fnServerDbOpen_rets,
	                  (caddr_t)   clnt_res,
	                  TIMEOUT));
#else
	static fnServerDbOpen_rets res;

	bzero((char *)&res, sizeof(res));
	if (clnt_call(clnt, fnRpc_fnServerDbOpen,
	              (xdrproc_t) xdr_fnServerDbOpen_args,
	              (caddr_t)   argp,
	              (xdrproc_t) xdr_fnServerDbOpen_rets,
	              (caddr_t)   &res,
	              TIMEOUT) != RPC_SUCCESS) {
		return (NULL);
	}
	return (&res);
#endif
}


#ifdef MULTITHREAD
enum clnt_stat
#else
fnServerObjectFlush_rets *
#endif
fnrpc_fnserverobjectflush_1
#ifdef MULTITHREAD
	(argp, clnt_res, clnt)
#else
	(argp, clnt)
#endif
	fnServerObjectFlush_args *argp;
#ifdef MULTITHREAD
	fnServerObjectFlush_rets *clnt_res;
#endif
	CLIENT *clnt;
{
#ifdef MULTITHREAD
	bzero((char *)clnt_res, sizeof(*clnt_res));
	return (clnt_call(clnt, fnRpc_fnServerObjectFlush,
	                  (xdrproc_t) xdr_fnServerObjectFlush_args,
	                  (caddr_t)   argp,
	                  (xdrproc_t) xdr_fnServerObjectFlush_rets,
	                  (caddr_t)   clnt_res,
	                  TIMEOUT));
#else
	static fnServerObjectFlush_rets res;

	bzero((char *)&res, sizeof(res));
	if (clnt_call(clnt, fnRpc_fnServerObjectFlush,
	              (xdrproc_t) xdr_fnServerObjectFlush_args,
	              (caddr_t)   argp,
	              (xdrproc_t) xdr_fnServerObjectFlush_rets,
	              (caddr_t)   &res,
	              TIMEOUT) != RPC_SUCCESS) {
		return (NULL);
	}
	return (&res);
#endif
}


#ifdef MULTITHREAD
enum clnt_stat
#else
fnServerObjectReadAtIndex_rets *
#endif
fnrpc_fnserverobjectreadatindex_1
#ifdef MULTITHREAD
	(argp, clnt_res, clnt)
#else
	(argp, clnt)
#endif
	fnServerObjectReadAtIndex_args *argp;
#ifdef MULTITHREAD
	fnServerObjectReadAtIndex_rets *clnt_res;
#endif
	CLIENT *clnt;
{
#ifdef MULTITHREAD
	bzero((char *)clnt_res, sizeof(*clnt_res));
	return (clnt_call(clnt, fnRpc_fnServerObjectReadAtIndex,
	                  (xdrproc_t) xdr_fnServerObjectReadAtIndex_args,
	                  (caddr_t)   argp,
	                  (xdrproc_t) xdr_fnServerObjectReadAtIndex_rets,
	                  (caddr_t)   clnt_res,
	                  TIMEOUT));
#else
	static fnServerObjectReadAtIndex_rets res;

	bzero((char *)&res, sizeof(res));
	if (clnt_call(clnt, fnRpc_fnServerObjectReadAtIndex,
	              (xdrproc_t) xdr_fnServerObjectReadAtIndex_args,
	              (caddr_t)   argp,
	              (xdrproc_t) xdr_fnServerObjectReadAtIndex_rets,
	              (caddr_t)   &res,
	              TIMEOUT) != RPC_SUCCESS) {
		return (NULL);
	}
	return (&res);
#endif
}


#ifdef MULTITHREAD
enum clnt_stat
#else
fnServerObjectReadAtIndices_rets *
#endif
fnrpc_fnserverobjectreadatindices_1
#ifdef MULTITHREAD
	(argp, clnt_res, clnt)
#else
	(argp, clnt)
#endif
	fnServerObjectReadAtIndices_args *argp;
#ifdef MULTITHREAD
	fnServerObjectReadAtIndices_rets *clnt_res;
#endif
	CLIENT *clnt;
{
#ifdef MULTITHREAD
	bzero((char *)clnt_res, sizeof(*clnt_res));
	return (clnt_call(clnt, fnRpc_fnServerObjectReadAtIndices,
	                  (xdrproc_t) xdr_fnServerObjectReadAtIndices_args,
	                  (caddr_t)   argp,
	                  (xdrproc_t) xdr_fnServerObjectReadAtIndices_rets,
	                  (caddr_t)   clnt_res,
	                  TIMEOUT));
#else
	static fnServerObjectReadAtIndices_rets res;

	bzero((char *)&res, sizeof(res));
	if (clnt_call(clnt, fnRpc_fnServerObjectReadAtIndices,
	              (xdrproc_t) xdr_fnServerObjectReadAtIndices_args,
	              (caddr_t)   argp,
	              (xdrproc_t) xdr_fnServerObjectReadAtIndices_rets,
	              (caddr_t)   &res,
	              TIMEOUT) != RPC_SUCCESS) {
		return (NULL);
	}
	return (&res);
#endif
}


#ifdef MULTITHREAD
enum clnt_stat
#else
fnServerObjectReadObjId_rets *
#endif
fnrpc_fnserverobjectreadobjid_1
#ifdef MULTITHREAD
	(argp, clnt_res, clnt)
#else
	(argp, clnt)
#endif
	fnServerObjectReadObjId_args *argp;
#ifdef MULTITHREAD
	fnServerObjectReadObjId_rets *clnt_res;
#endif
	CLIENT *clnt;
{
#ifdef MULTITHREAD
	bzero((char *)clnt_res, sizeof(*clnt_res));
	return (clnt_call(clnt, fnRpc_fnServerObjectReadObjId,
	                  (xdrproc_t) xdr_fnServerObjectReadObjId_args,
	                  (caddr_t)   argp,
	                  (xdrproc_t) xdr_fnServerObjectReadObjId_rets,
	                  (caddr_t)   clnt_res,
	                  TIMEOUT));
#else
	static fnServerObjectReadObjId_rets res;

	bzero((char *)&res, sizeof(res));
	if (clnt_call(clnt, fnRpc_fnServerObjectReadObjId,
	              (xdrproc_t) xdr_fnServerObjectReadObjId_args,
	              (caddr_t)   argp,
	              (xdrproc_t) xdr_fnServerObjectReadObjId_rets,
	              (caddr_t)   &res,
	              TIMEOUT) != RPC_SUCCESS) {
		return (NULL);
	}
	return (&res);
#endif
}


#ifdef MULTITHREAD
enum clnt_stat
#else
fnServerObjectReadValues_rets *
#endif
fnrpc_fnserverobjectreadvalues_1
#ifdef MULTITHREAD
	(argp, clnt_res, clnt)
#else
	(argp, clnt)
#endif
	fnServerObjectReadValues_args *argp;
#ifdef MULTITHREAD
	fnServerObjectReadValues_rets *clnt_res;
#endif
	CLIENT *clnt;
{
#ifdef MULTITHREAD
	bzero((char *)clnt_res, sizeof(*clnt_res));
	return (clnt_call(clnt, fnRpc_fnServerObjectReadValues,
	                  (xdrproc_t) xdr_fnServerObjectReadValues_args,
	                  (caddr_t)   argp,
	                  (xdrproc_t) xdr_fnServerObjectReadValues_rets,
	                  (caddr_t)   clnt_res,
	                  TIMEOUT));
#else
	static fnServerObjectReadValues_rets res;

	bzero((char *)&res, sizeof(res));
	if (clnt_call(clnt, fnRpc_fnServerObjectReadValues,
	              (xdrproc_t) xdr_fnServerObjectReadValues_args,
	              (caddr_t)   argp,
	              (xdrproc_t) xdr_fnServerObjectReadValues_rets,
	              (caddr_t)   &res,
	              TIMEOUT) != RPC_SUCCESS) {
		return (NULL);
	}
	return (&res);
#endif
}


#ifdef MULTITHREAD
enum clnt_stat
#else
fnClientDbStatistics_rets *
#endif
fnrpc_fnclientdbstatistics_1
#ifdef MULTITHREAD
	(argp, clnt_res, clnt)
#else
	(argp, clnt)
#endif
	SHORTOBJID *argp;
#ifdef MULTITHREAD
	fnClientDbStatistics_rets *clnt_res;
#endif
	CLIENT *clnt;
{
#ifdef MULTITHREAD
	bzero((char *)clnt_res, sizeof(*clnt_res));
	return (clnt_call(clnt, fnRpc_fnClientDbStatistics,
	                  (xdrproc_t) xdr_SHORTOBJID,
	                  (caddr_t)   argp,
	                  (xdrproc_t) xdr_fnClientDbStatistics_rets,
	                  (caddr_t)   clnt_res,
	                  TIMEOUT));
#else
	static fnClientDbStatistics_rets res;

	bzero((char *)&res, sizeof(res));
	if (clnt_call(clnt, fnRpc_fnClientDbStatistics,
	              (xdrproc_t) xdr_SHORTOBJID,
	              (caddr_t)   argp,
	              (xdrproc_t) xdr_fnClientDbStatistics_rets,
	              (caddr_t)   &res,
	              TIMEOUT) != RPC_SUCCESS) {
		return (NULL);
	}
	return (&res);
#endif
}


#ifdef MULTITHREAD
enum clnt_stat
#else
void *
#endif
fnrpc_fnserverdbstabilise_batch_1
#ifdef MULTITHREAD
	(argp, clnt_res, clnt)
#else
	(argp, clnt)
#endif
	SHORTOBJID *argp;
#ifdef MULTITHREAD
	void *clnt_res;
#endif
	CLIENT *clnt;
{
#ifdef MULTITHREAD
	return (clnt_call(clnt, fnRpc_fnServerDbStabilise_batch,
	                  (xdrproc_t) xdr_SHORTOBJID,
	                  (caddr_t)   argp,
	                  (xdrproc_t) xdr_void,
	                  (caddr_t)   clnt_res,
	                  TIMEOUT));
#else
	static char res;

	bzero((char *)&res, sizeof(res));
	if (clnt_call(clnt, fnRpc_fnServerDbStabilise_batch,
	              (xdrproc_t) xdr_SHORTOBJID,
	              (caddr_t)   argp,
	              (xdrproc_t) xdr_void,
	              (caddr_t)   &res,
	              TIMEOUT) != RPC_SUCCESS) {
		return (NULL);
	}
	return ((void *)&res);
#endif
}


#ifdef MULTITHREAD
enum clnt_stat
#else
fnServerObjectTypeTag_rets *
#endif
fnrpc_fnserverobjecttypetag_1
#ifdef MULTITHREAD
	(argp, clnt_res, clnt)
#else
	(argp, clnt)
#endif
	fnServerObjectTypeTag_args *argp;
#ifdef MULTITHREAD
	fnServerObjectTypeTag_rets *clnt_res;
#endif
	CLIENT *clnt;
{
#ifdef MULTITHREAD
	bzero((char *)clnt_res, sizeof(*clnt_res));
	return (clnt_call(clnt, fnRpc_fnServerObjectTypeTag,
	                  (xdrproc_t) xdr_fnServerObjectTypeTag_args,
	                  (caddr_t)   argp,
	                  (xdrproc_t) xdr_fnServerObjectTypeTag_rets,
	                  (caddr_t)   clnt_res,
	                  TIMEOUT));
#else
	static fnServerObjectTypeTag_rets res;

	bzero((char *)&res, sizeof(res));
	if (clnt_call(clnt, fnRpc_fnServerObjectTypeTag,
	              (xdrproc_t) xdr_fnServerObjectTypeTag_args,
	              (caddr_t)   argp,
	              (xdrproc_t) xdr_fnServerObjectTypeTag_rets,
	              (caddr_t)   &res,
	              TIMEOUT) != RPC_SUCCESS) {
		return (NULL);
	}
	return (&res);
#endif
}


#ifdef MULTITHREAD
enum clnt_stat
#else
fnServerObjectValueSize_rets *
#endif
fnrpc_fnserverobjectvaluesize_1
#ifdef MULTITHREAD
	(argp, clnt_res, clnt)
#else
	(argp, clnt)
#endif
	fnServerObjectValueSize_args *argp;
#ifdef MULTITHREAD
	fnServerObjectValueSize_rets *clnt_res;
#endif
	CLIENT *clnt;
{
#ifdef MULTITHREAD
	bzero((char *)clnt_res, sizeof(*clnt_res));
	return (clnt_call(clnt, fnRpc_fnServerObjectValueSize,
	                  (xdrproc_t) xdr_fnServerObjectValueSize_args,
	                  (caddr_t)   argp,
	                  (xdrproc_t) xdr_fnServerObjectValueSize_rets,
	                  (caddr_t)   clnt_res,
	                  TIMEOUT));
#else
	static fnServerObjectValueSize_rets res;

	bzero((char *)&res, sizeof(res));
	if (clnt_call(clnt, fnRpc_fnServerObjectValueSize,
	              (xdrproc_t) xdr_fnServerObjectValueSize_args,
	              (caddr_t)   argp,
	              (xdrproc_t) xdr_fnServerObjectValueSize_rets,
	              (caddr_t)   &res,
	              TIMEOUT) != RPC_SUCCESS) {
		return (NULL);
	}
	return (&res);
#endif
}


#ifdef MULTITHREAD
enum clnt_stat
#else
fnServerObjectWriteAtIndex_rets *
#endif
fnrpc_fnserverobjectwriteatindex_1
#ifdef MULTITHREAD
	(argp, clnt_res, clnt)
#else
	(argp, clnt)
#endif
	fnServerObjectWriteAtIndex_args *argp;
#ifdef MULTITHREAD
	fnServerObjectWriteAtIndex_rets *clnt_res;
#endif
	CLIENT *clnt;
{
#ifdef MULTITHREAD
	bzero((char *)clnt_res, sizeof(*clnt_res));
	return (clnt_call(clnt, fnRpc_fnServerObjectWriteAtIndex,
	                  (xdrproc_t) xdr_fnServerObjectWriteAtIndex_args,
	                  (caddr_t)   argp,
	                  (xdrproc_t) xdr_fnServerObjectWriteAtIndex_rets,
	                  (caddr_t)   clnt_res,
	                  TIMEOUT));
#else
	static fnServerObjectWriteAtIndex_rets res;

	bzero((char *)&res, sizeof(res));
	if (clnt_call(clnt, fnRpc_fnServerObjectWriteAtIndex,
	              (xdrproc_t) xdr_fnServerObjectWriteAtIndex_args,
	              (caddr_t)   argp,
	              (xdrproc_t) xdr_fnServerObjectWriteAtIndex_rets,
	              (caddr_t)   &res,
	              TIMEOUT) != RPC_SUCCESS) {
		return (NULL);
	}
	return (&res);
#endif
}


#ifdef MULTITHREAD
enum clnt_stat
#else
fnServerObjectWriteAtIndices_rets *
#endif
fnrpc_fnserverobjectwriteatindices_1
#ifdef MULTITHREAD
	(argp, clnt_res, clnt)
#else
	(argp, clnt)
#endif
	fnServerObjectWriteAtIndices_args *argp;
#ifdef MULTITHREAD
	fnServerObjectWriteAtIndices_rets *clnt_res;
#endif
	CLIENT *clnt;
{
#ifdef MULTITHREAD
	bzero((char *)clnt_res, sizeof(*clnt_res));
	return (clnt_call(clnt, fnRpc_fnServerObjectWriteAtIndices,
	                  (xdrproc_t) xdr_fnServerObjectWriteAtIndices_args,
	                  (caddr_t)   argp,
	                  (xdrproc_t) xdr_fnServerObjectWriteAtIndices_rets,
	                  (caddr_t)   clnt_res,
	                  TIMEOUT));
#else
	static fnServerObjectWriteAtIndices_rets res;

	bzero((char *)&res, sizeof(res));
	if (clnt_call(clnt, fnRpc_fnServerObjectWriteAtIndices,
	              (xdrproc_t) xdr_fnServerObjectWriteAtIndices_args,
	              (caddr_t)   argp,
	              (xdrproc_t) xdr_fnServerObjectWriteAtIndices_rets,
	              (caddr_t)   &res,
	              TIMEOUT) != RPC_SUCCESS) {
		return (NULL);
	}
	return (&res);
#endif
}


#ifdef MULTITHREAD
enum clnt_stat
#else
fnServerObjectWriteObjId_rets *
#endif
fnrpc_fnserverobjectwriteobjid_1
#ifdef MULTITHREAD
	(argp, clnt_res, clnt)
#else
	(argp, clnt)
#endif
	fnServerObjectWriteObjId_args *argp;
#ifdef MULTITHREAD
	fnServerObjectWriteObjId_rets *clnt_res;
#endif
	CLIENT *clnt;
{
#ifdef MULTITHREAD
	bzero((char *)clnt_res, sizeof(*clnt_res));
	return (clnt_call(clnt, fnRpc_fnServerObjectWriteObjId,
	                  (xdrproc_t) xdr_fnServerObjectWriteObjId_args,
	                  (caddr_t)   argp,
	                  (xdrproc_t) xdr_fnServerObjectWriteObjId_rets,
	                  (caddr_t)   clnt_res,
	                  TIMEOUT));
#else
	static fnServerObjectWriteObjId_rets res;

	bzero((char *)&res, sizeof(res));
	if (clnt_call(clnt, fnRpc_fnServerObjectWriteObjId,
	              (xdrproc_t) xdr_fnServerObjectWriteObjId_args,
	              (caddr_t)   argp,
	              (xdrproc_t) xdr_fnServerObjectWriteObjId_rets,
	              (caddr_t)   &res,
	              TIMEOUT) != RPC_SUCCESS) {
		return (NULL);
	}
	return (&res);
#endif
}


#ifdef MULTITHREAD
enum clnt_stat
#else
fnServerObjectWriteValues_rets *
#endif
fnrpc_fnserverobjectwritevalues_1
#ifdef MULTITHREAD
	(argp, clnt_res, clnt)
#else
	(argp, clnt)
#endif
	fnServerObjectWriteValues_args *argp;
#ifdef MULTITHREAD
	fnServerObjectWriteValues_rets *clnt_res;
#endif
	CLIENT *clnt;
{
#ifdef MULTITHREAD
	bzero((char *)clnt_res, sizeof(*clnt_res));
	return (clnt_call(clnt, fnRpc_fnServerObjectWriteValues,
	                  (xdrproc_t) xdr_fnServerObjectWriteValues_args,
	                  (caddr_t)   argp,
	                  (xdrproc_t) xdr_fnServerObjectWriteValues_rets,
	                  (caddr_t)   clnt_res,
	                  TIMEOUT));
#else
	static fnServerObjectWriteValues_rets res;

	bzero((char *)&res, sizeof(res));
	if (clnt_call(clnt, fnRpc_fnServerObjectWriteValues,
	              (xdrproc_t) xdr_fnServerObjectWriteValues_args,
	              (caddr_t)   argp,
	              (xdrproc_t) xdr_fnServerObjectWriteValues_rets,
	              (caddr_t)   &res,
	              TIMEOUT) != RPC_SUCCESS) {
		return (NULL);
	}
	return (&res);
#endif
}


#ifdef MULTITHREAD
enum clnt_stat
#else
fnShortMakeDependent_rets *
#endif
fnrpc_fnshortmakedependent_1
#ifdef MULTITHREAD
	(argp, clnt_res, clnt)
#else
	(argp, clnt)
#endif
	fnShortMakeDependent_args *argp;
#ifdef MULTITHREAD
	fnShortMakeDependent_rets *clnt_res;
#endif
	CLIENT *clnt;
{
#ifdef MULTITHREAD
	bzero((char *)clnt_res, sizeof(*clnt_res));
	return (clnt_call(clnt, fnRpc_fnShortMakeDependent,
	                  (xdrproc_t) xdr_fnShortMakeDependent_args,
	                  (caddr_t)   argp,
	                  (xdrproc_t) xdr_fnShortMakeDependent_rets,
	                  (caddr_t)   clnt_res,
	                  TIMEOUT));
#else
	static fnShortMakeDependent_rets res;

	bzero((char *)&res, sizeof(res));
	if (clnt_call(clnt, fnRpc_fnShortMakeDependent,
	              (xdrproc_t) xdr_fnShortMakeDependent_args,
	              (caddr_t)   argp,
	              (xdrproc_t) xdr_fnShortMakeDependent_rets,
	              (caddr_t)   &res,
	              TIMEOUT) != RPC_SUCCESS) {
		return (NULL);
	}
	return (&res);
#endif
}


#ifdef MULTITHREAD
enum clnt_stat
#else
fnServerObjectPeekSlots_rets *
#endif
fnrpc_fnserverobjectpeekslots_1
#ifdef MULTITHREAD
	(argp, clnt_res, clnt)
#else
	(argp, clnt)
#endif
	fnServerObjectPeekSlots_args *argp;
#ifdef MULTITHREAD
	fnServerObjectPeekSlots_rets *clnt_res;
#endif
	CLIENT *clnt;
{
#ifdef MULTITHREAD
	bzero((char *)clnt_res, sizeof(*clnt_res));
	return (clnt_call(clnt, fnRpc_fnServerObjectPeekSlots,
	                  (xdrproc_t) xdr_fnServerObjectPeekSlots_args,
	                  (caddr_t)   argp,
	                  (xdrproc_t) xdr_fnServerObjectPeekSlots_rets,
	                  (caddr_t)   clnt_res,
	                  TIMEOUT));
#else
	static fnServerObjectPeekSlots_rets res;

	bzero((char *)&res, sizeof(res));
	if (clnt_call(clnt, fnRpc_fnServerObjectPeekSlots,
	              (xdrproc_t) xdr_fnServerObjectPeekSlots_args,
	              (caddr_t)   argp,
	              (xdrproc_t) xdr_fnServerObjectPeekSlots_rets,
	              (caddr_t)   &res,
	              TIMEOUT) != RPC_SUCCESS) {
		return (NULL);
	}
	return (&res);
#endif
}


#ifdef MULTITHREAD
enum clnt_stat
#else
fnServerObjectPeekValues_rets *
#endif
fnrpc_fnserverobjectpeekvalues_1
#ifdef MULTITHREAD
	(argp, clnt_res, clnt)
#else
	(argp, clnt)
#endif
	fnServerObjectPeekValues_args *argp;
#ifdef MULTITHREAD
	fnServerObjectPeekValues_rets *clnt_res;
#endif
	CLIENT *clnt;
{
#ifdef MULTITHREAD
	bzero((char *)clnt_res, sizeof(*clnt_res));
	return (clnt_call(clnt, fnRpc_fnServerObjectPeekValues,
	                  (xdrproc_t) xdr_fnServerObjectPeekValues_args,
	                  (caddr_t)   argp,
	                  (xdrproc_t) xdr_fnServerObjectPeekValues_rets,
	                  (caddr_t)   clnt_res,
	                  TIMEOUT));
#else
	static fnServerObjectPeekValues_rets res;

	bzero((char *)&res, sizeof(res));
	if (clnt_call(clnt, fnRpc_fnServerObjectPeekValues,
	              (xdrproc_t) xdr_fnServerObjectPeekValues_args,
	              (caddr_t)   argp,
	              (xdrproc_t) xdr_fnServerObjectPeekValues_rets,
	              (caddr_t)   &res,
	              TIMEOUT) != RPC_SUCCESS) {
		return (NULL);
	}
	return (&res);
#endif
}


#ifdef MULTITHREAD
enum clnt_stat
#else
void *
#endif
fnrpc_fnserverobjectpoke_batch_1
#ifdef MULTITHREAD
	(argp, clnt_res, clnt)
#else
	(argp, clnt)
#endif
	fnServerObjectPoke_args *argp;
#ifdef MULTITHREAD
	void *clnt_res;
#endif
	CLIENT *clnt;
{
#ifdef MULTITHREAD
	return (clnt_call(clnt, fnRpc_fnServerObjectPoke_batch,
	                  (xdrproc_t) xdr_fnServerObjectPoke_args,
	                  (caddr_t)   argp,
	                  (xdrproc_t) xdr_void,
	                  (caddr_t)   clnt_res,
	                  TIMEOUT));
#else
	static char res;

	bzero((char *)&res, sizeof(res));
	if (clnt_call(clnt, fnRpc_fnServerObjectPoke_batch,
	              (xdrproc_t) xdr_fnServerObjectPoke_args,
	              (caddr_t)   argp,
	              (xdrproc_t) xdr_void,
	              (caddr_t)   &res,
	              TIMEOUT) != RPC_SUCCESS) {
		return (NULL);
	}
	return ((void *)&res);
#endif
}


#ifdef MULTITHREAD
enum clnt_stat
#else
fnFlushMode_rets *
#endif
fnrpc_fnflushmode_1
#ifdef MULTITHREAD
	(argp, clnt_res, clnt)
#else
	(argp, clnt)
#endif
	fnFlushMode_args *argp;
#ifdef MULTITHREAD
	fnFlushMode_rets *clnt_res;
#endif
	CLIENT *clnt;
{
#ifdef MULTITHREAD
	bzero((char *)clnt_res, sizeof(*clnt_res));
	return (clnt_call(clnt, fnRpc_fnFlushMode,
	                  (xdrproc_t) xdr_fnFlushMode_args,
	                  (caddr_t)   argp,
	                  (xdrproc_t) xdr_fnFlushMode_rets,
	                  (caddr_t)   clnt_res,
	                  TIMEOUT));
#else
	static fnFlushMode_rets res;

	bzero((char *)&res, sizeof(res));
	if (clnt_call(clnt, fnRpc_fnFlushMode,
	              (xdrproc_t) xdr_fnFlushMode_args,
	              (caddr_t)   argp,
	              (xdrproc_t) xdr_fnFlushMode_rets,
	              (caddr_t)   &res,
	              TIMEOUT) != RPC_SUCCESS) {
		return (NULL);
	}
	return (&res);
#endif
}


#ifdef MULTITHREAD
enum clnt_stat
#else
fnFlagWord_rets *
#endif
fnrpc_fnflagword_1
#ifdef MULTITHREAD
	(argp, clnt_res, clnt)
#else
	(argp, clnt)
#endif
	fnFlagWord_args *argp;
#ifdef MULTITHREAD
	fnFlagWord_rets *clnt_res;
#endif
	CLIENT *clnt;
{
#ifdef MULTITHREAD
	bzero((char *)clnt_res, sizeof(*clnt_res));
	return (clnt_call(clnt, fnRpc_fnFlagWord,
	                  (xdrproc_t) xdr_fnFlagWord_args,
	                  (caddr_t)   argp,
	                  (xdrproc_t) xdr_fnFlagWord_rets,
	                  (caddr_t)   clnt_res,
	                  TIMEOUT));
#else
	static fnFlagWord_rets res;

	bzero((char *)&res, sizeof(res));
	if (clnt_call(clnt, fnRpc_fnFlagWord,
	              (xdrproc_t) xdr_fnFlagWord_args,
	              (caddr_t)   argp,
	              (xdrproc_t) xdr_fnFlagWord_rets,
	              (caddr_t)   &res,
	              TIMEOUT) != RPC_SUCCESS) {
		return (NULL);
	}
	return (&res);
#endif
}


#ifdef MULTITHREAD
enum clnt_stat
#else
fnShortMakeIVector_rets *
#endif
fnrpc_fnshortmakeivector_1
#ifdef MULTITHREAD
	(argp, clnt_res, clnt)
#else
	(argp, clnt)
#endif
	fnShortMakeIVector_args *argp;
#ifdef MULTITHREAD
	fnShortMakeIVector_rets *clnt_res;
#endif
	CLIENT *clnt;
{
#ifdef MULTITHREAD
	bzero((char *)clnt_res, sizeof(*clnt_res));
	return (clnt_call(clnt, fnRpc_fnShortMakeIVector,
	                  (xdrproc_t) xdr_fnShortMakeIVector_args,
	                  (caddr_t)   argp,
	                  (xdrproc_t) xdr_fnShortMakeIVector_rets,
	                  (caddr_t)   clnt_res,
	                  TIMEOUT));
#else
	static fnShortMakeIVector_rets res;

	bzero((char *)&res, sizeof(res));
	if (clnt_call(clnt, fnRpc_fnShortMakeIVector,
	              (xdrproc_t) xdr_fnShortMakeIVector_args,
	              (caddr_t)   argp,
	              (xdrproc_t) xdr_fnShortMakeIVector_rets,
	              (caddr_t)   &res,
	              TIMEOUT) != RPC_SUCCESS) {
		return (NULL);
	}
	return (&res);
#endif
}


#ifdef MULTITHREAD
enum clnt_stat
#else
fnShortMakeString_rets *
#endif
fnrpc_fnshortmakestring_1
#ifdef MULTITHREAD
	(argp, clnt_res, clnt)
#else
	(argp, clnt)
#endif
	fnShortMakeString_args *argp;
#ifdef MULTITHREAD
	fnShortMakeString_rets *clnt_res;
#endif
	CLIENT *clnt;
{
#ifdef MULTITHREAD
	bzero((char *)clnt_res, sizeof(*clnt_res));
	return (clnt_call(clnt, fnRpc_fnShortMakeString,
	                  (xdrproc_t) xdr_fnShortMakeString_args,
	                  (caddr_t)   argp,
	                  (xdrproc_t) xdr_fnShortMakeString_rets,
	                  (caddr_t)   clnt_res,
	                  TIMEOUT));
#else
	static fnShortMakeString_rets res;

	bzero((char *)&res, sizeof(res));
	if (clnt_call(clnt, fnRpc_fnShortMakeString,
	              (xdrproc_t) xdr_fnShortMakeString_args,
	              (caddr_t)   argp,
	              (xdrproc_t) xdr_fnShortMakeString_rets,
	              (caddr_t)   &res,
	              TIMEOUT) != RPC_SUCCESS) {
		return (NULL);
	}
	return (&res);
#endif
}


#ifdef MULTITHREAD
enum clnt_stat
#else
fnServerDbCreateStructures_rets *
#endif
fnrpc_fnserverdbcreatestructures_1
#ifdef MULTITHREAD
	(argp, clnt_res, clnt)
#else
	(argp, clnt)
#endif
	fnServerDbCreateStructures_args *argp;
#ifdef MULTITHREAD
	fnServerDbCreateStructures_rets *clnt_res;
#endif
	CLIENT *clnt;
{
#ifdef MULTITHREAD
	bzero((char *)clnt_res, sizeof(*clnt_res));
	return (clnt_call(clnt, fnRpc_fnServerDbCreateStructures,
	                  (xdrproc_t) xdr_fnServerDbCreateStructures_args,
	                  (caddr_t)   argp,
	                  (xdrproc_t) xdr_fnServerDbCreateStructures_rets,
	                  (caddr_t)   clnt_res,
	                  TIMEOUT));
#else
	static fnServerDbCreateStructures_rets res;

	bzero((char *)&res, sizeof(res));
	if (clnt_call(clnt, fnRpc_fnServerDbCreateStructures,
	              (xdrproc_t) xdr_fnServerDbCreateStructures_args,
	              (caddr_t)   argp,
	              (xdrproc_t) xdr_fnServerDbCreateStructures_rets,
	              (caddr_t)   &res,
	              TIMEOUT) != RPC_SUCCESS) {
		return (NULL);
	}
	return (&res);
#endif
}


#ifdef MULTITHREAD
enum clnt_stat
#else
fnServerDbCreateInstances_rets *
#endif
fnrpc_fnserverdbcreateinstances_1
#ifdef MULTITHREAD
	(argp, clnt_res, clnt)
#else
	(argp, clnt)
#endif
	fnServerDbCreateInstances_args *argp;
#ifdef MULTITHREAD
	fnServerDbCreateInstances_rets *clnt_res;
#endif
	CLIENT *clnt;
{
#ifdef MULTITHREAD
	bzero((char *)clnt_res, sizeof(*clnt_res));
	return (clnt_call(clnt, fnRpc_fnServerDbCreateInstances,
	                  (xdrproc_t) xdr_fnServerDbCreateInstances_args,
	                  (caddr_t)   argp,
	                  (xdrproc_t) xdr_fnServerDbCreateInstances_rets,
	                  (caddr_t)   clnt_res,
	                  TIMEOUT));
#else
	static fnServerDbCreateInstances_rets res;

	bzero((char *)&res, sizeof(res));
	if (clnt_call(clnt, fnRpc_fnServerDbCreateInstances,
	              (xdrproc_t) xdr_fnServerDbCreateInstances_args,
	              (caddr_t)   argp,
	              (xdrproc_t) xdr_fnServerDbCreateInstances_rets,
	              (caddr_t)   &res,
	              TIMEOUT) != RPC_SUCCESS) {
		return (NULL);
	}
	return (&res);
#endif
}


#ifdef MULTITHREAD
enum clnt_stat
#else
fnServerInstanceWriteWrapper_rets *
#endif
fnrpc_fnserverinstancewritewrapper_1
#ifdef MULTITHREAD
	(argp, clnt_res, clnt)
#else
	(argp, clnt)
#endif
	fnServerInstanceWriteWrapper_args *argp;
#ifdef MULTITHREAD
	fnServerInstanceWriteWrapper_rets *clnt_res;
#endif
	CLIENT *clnt;
{
#ifdef MULTITHREAD
	bzero((char *)clnt_res, sizeof(*clnt_res));
	return (clnt_call(clnt, fnRpc_fnServerInstanceWriteWrapper,
	                  (xdrproc_t) xdr_fnServerInstanceWriteWrapper_args,
	                  (caddr_t)   argp,
	                  (xdrproc_t) xdr_fnServerInstanceWriteWrapper_rets,
	                  (caddr_t)   clnt_res,
	                  TIMEOUT));
#else
	static fnServerInstanceWriteWrapper_rets res;

	bzero((char *)&res, sizeof(res));
	if (clnt_call(clnt, fnRpc_fnServerInstanceWriteWrapper,
	              (xdrproc_t) xdr_fnServerInstanceWriteWrapper_args,
	              (caddr_t)   argp,
	              (xdrproc_t) xdr_fnServerInstanceWriteWrapper_rets,
	              (caddr_t)   &res,
	              TIMEOUT) != RPC_SUCCESS) {
		return (NULL);
	}
	return (&res);
#endif
}


#ifdef MULTITHREAD
enum clnt_stat
#else
fnServerInstanceWriteData_rets *
#endif
fnrpc_fnserverinstancewritedata_1
#ifdef MULTITHREAD
	(argp, clnt_res, clnt)
#else
	(argp, clnt)
#endif
	fnServerInstanceWriteData_args *argp;
#ifdef MULTITHREAD
	fnServerInstanceWriteData_rets *clnt_res;
#endif
	CLIENT *clnt;
{
#ifdef MULTITHREAD
	bzero((char *)clnt_res, sizeof(*clnt_res));
	return (clnt_call(clnt, fnRpc_fnServerInstanceWriteData,
	                  (xdrproc_t) xdr_fnServerInstanceWriteData_args,
	                  (caddr_t)   argp,
	                  (xdrproc_t) xdr_fnServerInstanceWriteData_rets,
	                  (caddr_t)   clnt_res,
	                  TIMEOUT));
#else
	static fnServerInstanceWriteData_rets res;

	bzero((char *)&res, sizeof(res));
	if (clnt_call(clnt, fnRpc_fnServerInstanceWriteData,
	              (xdrproc_t) xdr_fnServerInstanceWriteData_args,
	              (caddr_t)   argp,
	              (xdrproc_t) xdr_fnServerInstanceWriteData_rets,
	              (caddr_t)   &res,
	              TIMEOUT) != RPC_SUCCESS) {
		return (NULL);
	}
	return (&res);
#endif
}


#ifdef MULTITHREAD
enum clnt_stat
#else
fnServerDbTypeTagName_rets *
#endif
fnrpc_fnserverdbtypetagname_1
#ifdef MULTITHREAD
	(argp, clnt_res, clnt)
#else
	(argp, clnt)
#endif
	SHTYPETAG *argp;
#ifdef MULTITHREAD
	fnServerDbTypeTagName_rets *clnt_res;
#endif
	CLIENT *clnt;
{
#ifdef MULTITHREAD
	bzero((char *)clnt_res, sizeof(*clnt_res));
	return (clnt_call(clnt, fnRpc_fnServerDbTypeTagName,
	                  (xdrproc_t) xdr_SHTYPETAG,
	                  (caddr_t)   argp,
	                  (xdrproc_t) xdr_fnServerDbTypeTagName_rets,
	                  (caddr_t)   clnt_res,
	                  TIMEOUT));
#else
	static fnServerDbTypeTagName_rets res;

	bzero((char *)&res, sizeof(res));
	if (clnt_call(clnt, fnRpc_fnServerDbTypeTagName,
	              (xdrproc_t) xdr_SHTYPETAG,
	              (caddr_t)   argp,
	              (xdrproc_t) xdr_fnServerDbTypeTagName_rets,
	              (caddr_t)   &res,
	              TIMEOUT) != RPC_SUCCESS) {
		return (NULL);
	}
	return (&res);
#endif
}


#ifdef MULTITHREAD
enum clnt_stat
#else
fnServerObjectPrettyPrint_rets *
#endif
fnrpc_fnserverobjectprettyprint_1
#ifdef MULTITHREAD
	(argp, clnt_res, clnt)
#else
	(argp, clnt)
#endif
	fnServerObjectPrettyPrint_args *argp;
#ifdef MULTITHREAD
	fnServerObjectPrettyPrint_rets *clnt_res;
#endif
	CLIENT *clnt;
{
#ifdef MULTITHREAD
	bzero((char *)clnt_res, sizeof(*clnt_res));
	return (clnt_call(clnt, fnRpc_fnServerObjectPrettyPrint,
	                  (xdrproc_t) xdr_fnServerObjectPrettyPrint_args,
	                  (caddr_t)   argp,
	                  (xdrproc_t) xdr_fnServerObjectPrettyPrint_rets,
	                  (caddr_t)   clnt_res,
	                  TIMEOUT));
#else
	static fnServerObjectPrettyPrint_rets res;

	bzero((char *)&res, sizeof(res));
	if (clnt_call(clnt, fnRpc_fnServerObjectPrettyPrint,
	              (xdrproc_t) xdr_fnServerObjectPrettyPrint_args,
	              (caddr_t)   argp,
	              (xdrproc_t) xdr_fnServerObjectPrettyPrint_rets,
	              (caddr_t)   &res,
	              TIMEOUT) != RPC_SUCCESS) {
		return (NULL);
	}
	return (&res);
#endif
}


#ifdef MULTITHREAD
enum clnt_stat
#else
fnShortPrintSymbol_rets *
#endif
fnrpc_fnshortprintsymbol_1
#ifdef MULTITHREAD
	(argp, clnt_res, clnt)
#else
	(argp, clnt)
#endif
	fnShortPrintSymbol_args *argp;
#ifdef MULTITHREAD
	fnShortPrintSymbol_rets *clnt_res;
#endif
	CLIENT *clnt;
{
#ifdef MULTITHREAD
	bzero((char *)clnt_res, sizeof(*clnt_res));
	return (clnt_call(clnt, fnRpc_fnShortPrintSymbol,
	                  (xdrproc_t) xdr_fnShortPrintSymbol_args,
	                  (caddr_t)   argp,
	                  (xdrproc_t) xdr_fnShortPrintSymbol_rets,
	                  (caddr_t)   clnt_res,
	                  TIMEOUT));
#else
	static fnShortPrintSymbol_rets res;

	bzero((char *)&res, sizeof(res));
	if (clnt_call(clnt, fnRpc_fnShortPrintSymbol,
	              (xdrproc_t) xdr_fnShortPrintSymbol_args,
	              (caddr_t)   argp,
	              (xdrproc_t) xdr_fnShortPrintSymbol_rets,
	              (caddr_t)   &res,
	              TIMEOUT) != RPC_SUCCESS) {
		return (NULL);
	}
	return (&res);
#endif
}


#ifdef MULTITHREAD
enum clnt_stat
#else
fnShortMakeSingleFloat_rets *
#endif
fnrpc_fnshortmakesinglefloat_1
#ifdef MULTITHREAD
	(argp, clnt_res, clnt)
#else
	(argp, clnt)
#endif
	fnShortMakeSingleFloat_args *argp;
#ifdef MULTITHREAD
	fnShortMakeSingleFloat_rets *clnt_res;
#endif
	CLIENT *clnt;
{
#ifdef MULTITHREAD
	bzero((char *)clnt_res, sizeof(*clnt_res));
	return (clnt_call(clnt, fnRpc_fnShortMakeSingleFloat,
	                  (xdrproc_t) xdr_fnShortMakeSingleFloat_args,
	                  (caddr_t)   argp,
	                  (xdrproc_t) xdr_fnShortMakeSingleFloat_rets,
	                  (caddr_t)   clnt_res,
	                  TIMEOUT));
#else
	static fnShortMakeSingleFloat_rets res;

	bzero((char *)&res, sizeof(res));
	if (clnt_call(clnt, fnRpc_fnShortMakeSingleFloat,
	              (xdrproc_t) xdr_fnShortMakeSingleFloat_args,
	              (caddr_t)   argp,
	              (xdrproc_t) xdr_fnShortMakeSingleFloat_rets,
	              (caddr_t)   &res,
	              TIMEOUT) != RPC_SUCCESS) {
		return (NULL);
	}
	return (&res);
#endif
}


#ifdef MULTITHREAD
enum clnt_stat
#else
fnShortMakeDoubleFloat_rets *
#endif
fnrpc_fnshortmakedoublefloat_1
#ifdef MULTITHREAD
	(argp, clnt_res, clnt)
#else
	(argp, clnt)
#endif
	fnShortMakeDoubleFloat_args *argp;
#ifdef MULTITHREAD
	fnShortMakeDoubleFloat_rets *clnt_res;
#endif
	CLIENT *clnt;
{
#ifdef MULTITHREAD
	bzero((char *)clnt_res, sizeof(*clnt_res));
	return (clnt_call(clnt, fnRpc_fnShortMakeDoubleFloat,
	                  (xdrproc_t) xdr_fnShortMakeDoubleFloat_args,
	                  (caddr_t)   argp,
	                  (xdrproc_t) xdr_fnShortMakeDoubleFloat_rets,
	                  (caddr_t)   clnt_res,
	                  TIMEOUT));
#else
	static fnShortMakeDoubleFloat_rets res;

	bzero((char *)&res, sizeof(res));
	if (clnt_call(clnt, fnRpc_fnShortMakeDoubleFloat,
	              (xdrproc_t) xdr_fnShortMakeDoubleFloat_args,
	              (caddr_t)   argp,
	              (xdrproc_t) xdr_fnShortMakeDoubleFloat_rets,
	              (caddr_t)   &res,
	              TIMEOUT) != RPC_SUCCESS) {
		return (NULL);
	}
	return (&res);
#endif
}


#ifdef MULTITHREAD
enum clnt_stat
#else
fnServerDbMakeBignum_rets *
#endif
fnrpc_fnserverdbmakebignum_1
#ifdef MULTITHREAD
	(argp, clnt_res, clnt)
#else
	(argp, clnt)
#endif
	fnServerDbMakeBignum_args *argp;
#ifdef MULTITHREAD
	fnServerDbMakeBignum_rets *clnt_res;
#endif
	CLIENT *clnt;
{
#ifdef MULTITHREAD
	bzero((char *)clnt_res, sizeof(*clnt_res));
	return (clnt_call(clnt, fnRpc_fnServerDbMakeBignum,
	                  (xdrproc_t) xdr_fnServerDbMakeBignum_args,
	                  (caddr_t)   argp,
	                  (xdrproc_t) xdr_fnServerDbMakeBignum_rets,
	                  (caddr_t)   clnt_res,
	                  TIMEOUT));
#else
	static fnServerDbMakeBignum_rets res;

	bzero((char *)&res, sizeof(res));
	if (clnt_call(clnt, fnRpc_fnServerDbMakeBignum,
	              (xdrproc_t) xdr_fnServerDbMakeBignum_args,
	              (caddr_t)   argp,
	              (xdrproc_t) xdr_fnServerDbMakeBignum_rets,
	              (caddr_t)   &res,
	              TIMEOUT) != RPC_SUCCESS) {
		return (NULL);
	}
	return (&res);
#endif
}


#ifdef MULTITHREAD
enum clnt_stat
#else
fnServerObjectReadBignum_rets *
#endif
fnrpc_fnserverobjectreadbignum_1
#ifdef MULTITHREAD
	(argp, clnt_res, clnt)
#else
	(argp, clnt)
#endif
	fnServerObjectReadBignum_args *argp;
#ifdef MULTITHREAD
	fnServerObjectReadBignum_rets *clnt_res;
#endif
	CLIENT *clnt;
{
#ifdef MULTITHREAD
	bzero((char *)clnt_res, sizeof(*clnt_res));
	return (clnt_call(clnt, fnRpc_fnServerObjectReadBignum,
	                  (xdrproc_t) xdr_fnServerObjectReadBignum_args,
	                  (caddr_t)   argp,
	                  (xdrproc_t) xdr_fnServerObjectReadBignum_rets,
	                  (caddr_t)   clnt_res,
	                  TIMEOUT));
#else
	static fnServerObjectReadBignum_rets res;

	bzero((char *)&res, sizeof(res));
	if (clnt_call(clnt, fnRpc_fnServerObjectReadBignum,
	              (xdrproc_t) xdr_fnServerObjectReadBignum_args,
	              (caddr_t)   argp,
	              (xdrproc_t) xdr_fnServerObjectReadBignum_rets,
	              (caddr_t)   &res,
	              TIMEOUT) != RPC_SUCCESS) {
		return (NULL);
	}
	return (&res);
#endif
}


#ifdef MULTITHREAD
enum clnt_stat
#else
fnServerObjectReadDoubleFloat_rets *
#endif
fnrpc_fnserverobjectreaddoublefloat_1
#ifdef MULTITHREAD
	(argp, clnt_res, clnt)
#else
	(argp, clnt)
#endif
	fnServerObjectReadDoubleFloat_args *argp;
#ifdef MULTITHREAD
	fnServerObjectReadDoubleFloat_rets *clnt_res;
#endif
	CLIENT *clnt;
{
#ifdef MULTITHREAD
	bzero((char *)clnt_res, sizeof(*clnt_res));
	return (clnt_call(clnt, fnRpc_fnServerObjectReadDoubleFloat,
	                  (xdrproc_t) xdr_fnServerObjectReadDoubleFloat_args,
	                  (caddr_t)   argp,
	                  (xdrproc_t) xdr_fnServerObjectReadDoubleFloat_rets,
	                  (caddr_t)   clnt_res,
	                  TIMEOUT));
#else
	static fnServerObjectReadDoubleFloat_rets res;

	bzero((char *)&res, sizeof(res));
	if (clnt_call(clnt, fnRpc_fnServerObjectReadDoubleFloat,
	              (xdrproc_t) xdr_fnServerObjectReadDoubleFloat_args,
	              (caddr_t)   argp,
	              (xdrproc_t) xdr_fnServerObjectReadDoubleFloat_rets,
	              (caddr_t)   &res,
	              TIMEOUT) != RPC_SUCCESS) {
		return (NULL);
	}
	return (&res);
#endif
}


#ifdef MULTITHREAD
enum clnt_stat
#else
fnServerObjectReadFixnum_rets *
#endif
fnrpc_fnserverobjectreadfixnum_1
#ifdef MULTITHREAD
	(argp, clnt_res, clnt)
#else
	(argp, clnt)
#endif
	fnServerObjectReadFixnum_args *argp;
#ifdef MULTITHREAD
	fnServerObjectReadFixnum_rets *clnt_res;
#endif
	CLIENT *clnt;
{
#ifdef MULTITHREAD
	bzero((char *)clnt_res, sizeof(*clnt_res));
	return (clnt_call(clnt, fnRpc_fnServerObjectReadFixnum,
	                  (xdrproc_t) xdr_fnServerObjectReadFixnum_args,
	                  (caddr_t)   argp,
	                  (xdrproc_t) xdr_fnServerObjectReadFixnum_rets,
	                  (caddr_t)   clnt_res,
	                  TIMEOUT));
#else
	static fnServerObjectReadFixnum_rets res;

	bzero((char *)&res, sizeof(res));
	if (clnt_call(clnt, fnRpc_fnServerObjectReadFixnum,
	              (xdrproc_t) xdr_fnServerObjectReadFixnum_args,
	              (caddr_t)   argp,
	              (xdrproc_t) xdr_fnServerObjectReadFixnum_rets,
	              (caddr_t)   &res,
	              TIMEOUT) != RPC_SUCCESS) {
		return (NULL);
	}
	return (&res);
#endif
}


#ifdef MULTITHREAD
enum clnt_stat
#else
fnServerObjectReadSingleFloat_rets *
#endif
fnrpc_fnserverobjectreadsinglefloat_1
#ifdef MULTITHREAD
	(argp, clnt_res, clnt)
#else
	(argp, clnt)
#endif
	fnServerObjectReadSingleFloat_args *argp;
#ifdef MULTITHREAD
	fnServerObjectReadSingleFloat_rets *clnt_res;
#endif
	CLIENT *clnt;
{
#ifdef MULTITHREAD
	bzero((char *)clnt_res, sizeof(*clnt_res));
	return (clnt_call(clnt, fnRpc_fnServerObjectReadSingleFloat,
	                  (xdrproc_t) xdr_fnServerObjectReadSingleFloat_args,
	                  (caddr_t)   argp,
	                  (xdrproc_t) xdr_fnServerObjectReadSingleFloat_rets,
	                  (caddr_t)   clnt_res,
	                  TIMEOUT));
#else
	static fnServerObjectReadSingleFloat_rets res;

	bzero((char *)&res, sizeof(res));
	if (clnt_call(clnt, fnRpc_fnServerObjectReadSingleFloat,
	              (xdrproc_t) xdr_fnServerObjectReadSingleFloat_args,
	              (caddr_t)   argp,
	              (xdrproc_t) xdr_fnServerObjectReadSingleFloat_rets,
	              (caddr_t)   &res,
	              TIMEOUT) != RPC_SUCCESS) {
		return (NULL);
	}
	return (&res);
#endif
}


#ifdef MULTITHREAD
enum clnt_stat
#else
fnServerObjectWriteBignum_rets *
#endif
fnrpc_fnserverobjectwritebignum_1
#ifdef MULTITHREAD
	(argp, clnt_res, clnt)
#else
	(argp, clnt)
#endif
	fnServerObjectWriteBignum_args *argp;
#ifdef MULTITHREAD
	fnServerObjectWriteBignum_rets *clnt_res;
#endif
	CLIENT *clnt;
{
#ifdef MULTITHREAD
	bzero((char *)clnt_res, sizeof(*clnt_res));
	return (clnt_call(clnt, fnRpc_fnServerObjectWriteBignum,
	                  (xdrproc_t) xdr_fnServerObjectWriteBignum_args,
	                  (caddr_t)   argp,
	                  (xdrproc_t) xdr_fnServerObjectWriteBignum_rets,
	                  (caddr_t)   clnt_res,
	                  TIMEOUT));
#else
	static fnServerObjectWriteBignum_rets res;

	bzero((char *)&res, sizeof(res));
	if (clnt_call(clnt, fnRpc_fnServerObjectWriteBignum,
	              (xdrproc_t) xdr_fnServerObjectWriteBignum_args,
	              (caddr_t)   argp,
	              (xdrproc_t) xdr_fnServerObjectWriteBignum_rets,
	              (caddr_t)   &res,
	              TIMEOUT) != RPC_SUCCESS) {
		return (NULL);
	}
	return (&res);
#endif
}


#ifdef MULTITHREAD
enum clnt_stat
#else
fnServerObjectWriteDoubleFloat_rets *
#endif
fnrpc_fnserverobjectwritedoublefloat_1
#ifdef MULTITHREAD
	(argp, clnt_res, clnt)
#else
	(argp, clnt)
#endif
	fnServerObjectWriteDoubleFloat_args *argp;
#ifdef MULTITHREAD
	fnServerObjectWriteDoubleFloat_rets *clnt_res;
#endif
	CLIENT *clnt;
{
#ifdef MULTITHREAD
	bzero((char *)clnt_res, sizeof(*clnt_res));
	return (clnt_call(clnt, fnRpc_fnServerObjectWriteDoubleFloat,
	                  (xdrproc_t) xdr_fnServerObjectWriteDoubleFloat_args,
	                  (caddr_t)   argp,
	                  (xdrproc_t) xdr_fnServerObjectWriteDoubleFloat_rets,
	                  (caddr_t)   clnt_res,
	                  TIMEOUT));
#else
	static fnServerObjectWriteDoubleFloat_rets res;

	bzero((char *)&res, sizeof(res));
	if (clnt_call(clnt, fnRpc_fnServerObjectWriteDoubleFloat,
	              (xdrproc_t) xdr_fnServerObjectWriteDoubleFloat_args,
	              (caddr_t)   argp,
	              (xdrproc_t) xdr_fnServerObjectWriteDoubleFloat_rets,
	              (caddr_t)   &res,
	              TIMEOUT) != RPC_SUCCESS) {
		return (NULL);
	}
	return (&res);
#endif
}


#ifdef MULTITHREAD
enum clnt_stat
#else
fnServerObjectWriteFixnum_rets *
#endif
fnrpc_fnserverobjectwritefixnum_1
#ifdef MULTITHREAD
	(argp, clnt_res, clnt)
#else
	(argp, clnt)
#endif
	fnServerObjectWriteFixnum_args *argp;
#ifdef MULTITHREAD
	fnServerObjectWriteFixnum_rets *clnt_res;
#endif
	CLIENT *clnt;
{
#ifdef MULTITHREAD
	bzero((char *)clnt_res, sizeof(*clnt_res));
	return (clnt_call(clnt, fnRpc_fnServerObjectWriteFixnum,
	                  (xdrproc_t) xdr_fnServerObjectWriteFixnum_args,
	                  (caddr_t)   argp,
	                  (xdrproc_t) xdr_fnServerObjectWriteFixnum_rets,
	                  (caddr_t)   clnt_res,
	                  TIMEOUT));
#else
	static fnServerObjectWriteFixnum_rets res;

	bzero((char *)&res, sizeof(res));
	if (clnt_call(clnt, fnRpc_fnServerObjectWriteFixnum,
	              (xdrproc_t) xdr_fnServerObjectWriteFixnum_args,
	              (caddr_t)   argp,
	              (xdrproc_t) xdr_fnServerObjectWriteFixnum_rets,
	              (caddr_t)   &res,
	              TIMEOUT) != RPC_SUCCESS) {
		return (NULL);
	}
	return (&res);
#endif
}


#ifdef MULTITHREAD
enum clnt_stat
#else
fnServerObjectWriteSingleFloat_rets *
#endif
fnrpc_fnserverobjectwritesinglefloat_1
#ifdef MULTITHREAD
	(argp, clnt_res, clnt)
#else
	(argp, clnt)
#endif
	fnServerObjectWriteSingleFloat_args *argp;
#ifdef MULTITHREAD
	fnServerObjectWriteSingleFloat_rets *clnt_res;
#endif
	CLIENT *clnt;
{
#ifdef MULTITHREAD
	bzero((char *)clnt_res, sizeof(*clnt_res));
	return (clnt_call(clnt, fnRpc_fnServerObjectWriteSingleFloat,
	                  (xdrproc_t) xdr_fnServerObjectWriteSingleFloat_args,
	                  (caddr_t)   argp,
	                  (xdrproc_t) xdr_fnServerObjectWriteSingleFloat_rets,
	                  (caddr_t)   clnt_res,
	                  TIMEOUT));
#else
	static fnServerObjectWriteSingleFloat_rets res;

	bzero((char *)&res, sizeof(res));
	if (clnt_call(clnt, fnRpc_fnServerObjectWriteSingleFloat,
	              (xdrproc_t) xdr_fnServerObjectWriteSingleFloat_args,
	              (caddr_t)   argp,
	              (xdrproc_t) xdr_fnServerObjectWriteSingleFloat_rets,
	              (caddr_t)   &res,
	              TIMEOUT) != RPC_SUCCESS) {
		return (NULL);
	}
	return (&res);
#endif
}


#ifdef MULTITHREAD
enum clnt_stat
#else
fnClientLockPrint_rets *
#endif
fnrpc_fnclientlockprint_1
#ifdef MULTITHREAD
	(argp, clnt_res, clnt)
#else
	(argp, clnt)
#endif
	fnClientLockPrint_args *argp;
#ifdef MULTITHREAD
	fnClientLockPrint_rets *clnt_res;
#endif
	CLIENT *clnt;
{
#ifdef MULTITHREAD
	bzero((char *)clnt_res, sizeof(*clnt_res));
	return (clnt_call(clnt, fnRpc_fnClientLockPrint,
	                  (xdrproc_t) xdr_fnClientLockPrint_args,
	                  (caddr_t)   argp,
	                  (xdrproc_t) xdr_fnClientLockPrint_rets,
	                  (caddr_t)   clnt_res,
	                  TIMEOUT));
#else
	static fnClientLockPrint_rets res;

	bzero((char *)&res, sizeof(res));
	if (clnt_call(clnt, fnRpc_fnClientLockPrint,
	              (xdrproc_t) xdr_fnClientLockPrint_args,
	              (caddr_t)   argp,
	              (xdrproc_t) xdr_fnClientLockPrint_rets,
	              (caddr_t)   &res,
	              TIMEOUT) != RPC_SUCCESS) {
		return (NULL);
	}
	return (&res);
#endif
}


#ifdef MULTITHREAD
enum clnt_stat
#else
fnClientTransactionLockGet_rets *
#endif
fnrpc_fnclienttransactionlockget_1
#ifdef MULTITHREAD
	(argp, clnt_res, clnt)
#else
	(argp, clnt)
#endif
	fnClientTransactionLockGet_args *argp;
#ifdef MULTITHREAD
	fnClientTransactionLockGet_rets *clnt_res;
#endif
	CLIENT *clnt;
{
#ifdef MULTITHREAD
	bzero((char *)clnt_res, sizeof(*clnt_res));
	return (clnt_call(clnt, fnRpc_fnClientTransactionLockGet,
	                  (xdrproc_t) xdr_fnClientTransactionLockGet_args,
	                  (caddr_t)   argp,
	                  (xdrproc_t) xdr_fnClientTransactionLockGet_rets,
	                  (caddr_t)   clnt_res,
	                  TIMEOUT));
#else
	static fnClientTransactionLockGet_rets res;

	bzero((char *)&res, sizeof(res));
	if (clnt_call(clnt, fnRpc_fnClientTransactionLockGet,
	              (xdrproc_t) xdr_fnClientTransactionLockGet_args,
	              (caddr_t)   argp,
	              (xdrproc_t) xdr_fnClientTransactionLockGet_rets,
	              (caddr_t)   &res,
	              TIMEOUT) != RPC_SUCCESS) {
		return (NULL);
	}
	return (&res);
#endif
}


#ifdef MULTITHREAD
enum clnt_stat
#else
fnServerTransactionLockInsert_rets *
#endif
fnrpc_fnservertransactionlockinsert_1
#ifdef MULTITHREAD
	(argp, clnt_res, clnt)
#else
	(argp, clnt)
#endif
	fnServerTransactionLockInsert_args *argp;
#ifdef MULTITHREAD
	fnServerTransactionLockInsert_rets *clnt_res;
#endif
	CLIENT *clnt;
{
#ifdef MULTITHREAD
	bzero((char *)clnt_res, sizeof(*clnt_res));
	return (clnt_call(clnt, fnRpc_fnServerTransactionLockInsert,
	                  (xdrproc_t) xdr_fnServerTransactionLockInsert_args,
	                  (caddr_t)   argp,
	                  (xdrproc_t) xdr_fnServerTransactionLockInsert_rets,
	                  (caddr_t)   clnt_res,
	                  TIMEOUT));
#else
	static fnServerTransactionLockInsert_rets res;

	bzero((char *)&res, sizeof(res));
	if (clnt_call(clnt, fnRpc_fnServerTransactionLockInsert,
	              (xdrproc_t) xdr_fnServerTransactionLockInsert_args,
	              (caddr_t)   argp,
	              (xdrproc_t) xdr_fnServerTransactionLockInsert_rets,
	              (caddr_t)   &res,
	              TIMEOUT) != RPC_SUCCESS) {
		return (NULL);
	}
	return (&res);
#endif
}


#ifdef MULTITHREAD
enum clnt_stat
#else
fnServerTransactionLockSet_rets *
#endif
fnrpc_fnservertransactionlockset_1
#ifdef MULTITHREAD
	(argp, clnt_res, clnt)
#else
	(argp, clnt)
#endif
	fnServerTransactionLockSet_args *argp;
#ifdef MULTITHREAD
	fnServerTransactionLockSet_rets *clnt_res;
#endif
	CLIENT *clnt;
{
#ifdef MULTITHREAD
	bzero((char *)clnt_res, sizeof(*clnt_res));
	return (clnt_call(clnt, fnRpc_fnServerTransactionLockSet,
	                  (xdrproc_t) xdr_fnServerTransactionLockSet_args,
	                  (caddr_t)   argp,
	                  (xdrproc_t) xdr_fnServerTransactionLockSet_rets,
	                  (caddr_t)   clnt_res,
	                  TIMEOUT));
#else
	static fnServerTransactionLockSet_rets res;

	bzero((char *)&res, sizeof(res));
	if (clnt_call(clnt, fnRpc_fnServerTransactionLockSet,
	              (xdrproc_t) xdr_fnServerTransactionLockSet_args,
	              (caddr_t)   argp,
	              (xdrproc_t) xdr_fnServerTransactionLockSet_rets,
	              (caddr_t)   &res,
	              TIMEOUT) != RPC_SUCCESS) {
		return (NULL);
	}
	return (&res);
#endif
}


#ifdef MULTITHREAD
enum clnt_stat
#else
fnServerTransactionUnlock_rets *
#endif
fnrpc_fnservertransactionunlock_1
#ifdef MULTITHREAD
	(argp, clnt_res, clnt)
#else
	(argp, clnt)
#endif
	fnServerTransactionUnlock_args *argp;
#ifdef MULTITHREAD
	fnServerTransactionUnlock_rets *clnt_res;
#endif
	CLIENT *clnt;
{
#ifdef MULTITHREAD
	bzero((char *)clnt_res, sizeof(*clnt_res));
	return (clnt_call(clnt, fnRpc_fnServerTransactionUnlock,
	                  (xdrproc_t) xdr_fnServerTransactionUnlock_args,
	                  (caddr_t)   argp,
	                  (xdrproc_t) xdr_fnServerTransactionUnlock_rets,
	                  (caddr_t)   clnt_res,
	                  TIMEOUT));
#else
	static fnServerTransactionUnlock_rets res;

	bzero((char *)&res, sizeof(res));
	if (clnt_call(clnt, fnRpc_fnServerTransactionUnlock,
	              (xdrproc_t) xdr_fnServerTransactionUnlock_args,
	              (caddr_t)   argp,
	              (xdrproc_t) xdr_fnServerTransactionUnlock_rets,
	              (caddr_t)   &res,
	              TIMEOUT) != RPC_SUCCESS) {
		return (NULL);
	}
	return (&res);
#endif
}


#ifdef MULTITHREAD
enum clnt_stat
#else
fnServerTransactionUnlockAll_rets *
#endif
fnrpc_fnservertransactionunlockall_1
#ifdef MULTITHREAD
	(argp, clnt_res, clnt)
#else
	(argp, clnt)
#endif
	fnServerTransactionUnlockAll_args *argp;
#ifdef MULTITHREAD
	fnServerTransactionUnlockAll_rets *clnt_res;
#endif
	CLIENT *clnt;
{
#ifdef MULTITHREAD
	bzero((char *)clnt_res, sizeof(*clnt_res));
	return (clnt_call(clnt, fnRpc_fnServerTransactionUnlockAll,
	                  (xdrproc_t) xdr_fnServerTransactionUnlockAll_args,
	                  (caddr_t)   argp,
	                  (xdrproc_t) xdr_fnServerTransactionUnlockAll_rets,
	                  (caddr_t)   clnt_res,
	                  TIMEOUT));
#else
	static fnServerTransactionUnlockAll_rets res;

	bzero((char *)&res, sizeof(res));
	if (clnt_call(clnt, fnRpc_fnServerTransactionUnlockAll,
	              (xdrproc_t) xdr_fnServerTransactionUnlockAll_args,
	              (caddr_t)   argp,
	              (xdrproc_t) xdr_fnServerTransactionUnlockAll_rets,
	              (caddr_t)   &res,
	              TIMEOUT) != RPC_SUCCESS) {
		return (NULL);
	}
	return (&res);
#endif
}


#ifdef MULTITHREAD
enum clnt_stat
#else
fnServerTransactionUnlockAllAll_rets *
#endif
fnrpc_fnservertransactionunlockallall_1
#ifdef MULTITHREAD
	(argp, clnt_res, clnt)
#else
	(argp, clnt)
#endif
	fnServerTransactionUnlockAllAll_args *argp;
#ifdef MULTITHREAD
	fnServerTransactionUnlockAllAll_rets *clnt_res;
#endif
	CLIENT *clnt;
{
#ifdef MULTITHREAD
	bzero((char *)clnt_res, sizeof(*clnt_res));
	return (clnt_call(clnt, fnRpc_fnServerTransactionUnlockAllAll,
	                  (xdrproc_t) xdr_fnServerTransactionUnlockAllAll_args,
	                  (caddr_t)   argp,
	                  (xdrproc_t) xdr_fnServerTransactionUnlockAllAll_rets,
	                  (caddr_t)   clnt_res,
	                  TIMEOUT));
#else
	static fnServerTransactionUnlockAllAll_rets res;

	bzero((char *)&res, sizeof(res));
	if (clnt_call(clnt, fnRpc_fnServerTransactionUnlockAllAll,
	              (xdrproc_t) xdr_fnServerTransactionUnlockAllAll_args,
	              (caddr_t)   argp,
	              (xdrproc_t) xdr_fnServerTransactionUnlockAllAll_rets,
	              (caddr_t)   &res,
	              TIMEOUT) != RPC_SUCCESS) {
		return (NULL);
	}
	return (&res);
#endif
}


#ifdef MULTITHREAD
enum clnt_stat
#else
fnShortMakeReadOnly_rets *
#endif
fnrpc_fnshortmakereadonly_1
#ifdef MULTITHREAD
	(argp, clnt_res, clnt)
#else
	(argp, clnt)
#endif
	fnShortMakeReadOnly_args *argp;
#ifdef MULTITHREAD
	fnShortMakeReadOnly_rets *clnt_res;
#endif
	CLIENT *clnt;
{
#ifdef MULTITHREAD
	bzero((char *)clnt_res, sizeof(*clnt_res));
	return (clnt_call(clnt, fnRpc_fnShortMakeReadOnly,
	                  (xdrproc_t) xdr_fnShortMakeReadOnly_args,
	                  (caddr_t)   argp,
	                  (xdrproc_t) xdr_fnShortMakeReadOnly_rets,
	                  (caddr_t)   clnt_res,
	                  TIMEOUT));
#else
	static fnShortMakeReadOnly_rets res;

	bzero((char *)&res, sizeof(res));
	if (clnt_call(clnt, fnRpc_fnShortMakeReadOnly,
	              (xdrproc_t) xdr_fnShortMakeReadOnly_args,
	              (caddr_t)   argp,
	              (xdrproc_t) xdr_fnShortMakeReadOnly_rets,
	              (caddr_t)   &res,
	              TIMEOUT) != RPC_SUCCESS) {
		return (NULL);
	}
	return (&res);
#endif
}


#ifdef MULTITHREAD
enum clnt_stat
#else
fnServerTransactionBegin_rets *
#endif
fnrpc_fnservertransactionbegin_1
#ifdef MULTITHREAD
	(argp, clnt_res, clnt)
#else
	(argp, clnt)
#endif
	fnServerTransactionBegin_args *argp;
#ifdef MULTITHREAD
	fnServerTransactionBegin_rets *clnt_res;
#endif
	CLIENT *clnt;
{
#ifdef MULTITHREAD
	bzero((char *)clnt_res, sizeof(*clnt_res));
	return (clnt_call(clnt, fnRpc_fnServerTransactionBegin,
	                  (xdrproc_t) xdr_fnServerTransactionBegin_args,
	                  (caddr_t)   argp,
	                  (xdrproc_t) xdr_fnServerTransactionBegin_rets,
	                  (caddr_t)   clnt_res,
	                  TIMEOUT));
#else
	static fnServerTransactionBegin_rets res;

	bzero((char *)&res, sizeof(res));
	if (clnt_call(clnt, fnRpc_fnServerTransactionBegin,
	              (xdrproc_t) xdr_fnServerTransactionBegin_args,
	              (caddr_t)   argp,
	              (xdrproc_t) xdr_fnServerTransactionBegin_rets,
	              (caddr_t)   &res,
	              TIMEOUT) != RPC_SUCCESS) {
		return (NULL);
	}
	return (&res);
#endif
}


#ifdef MULTITHREAD
enum clnt_stat
#else
fnServerTransactionCancel_rets *
#endif
fnrpc_fnservertransactioncancel_1
#ifdef MULTITHREAD
	(argp, clnt_res, clnt)
#else
	(argp, clnt)
#endif
	fnServerTransactionCancel_args *argp;
#ifdef MULTITHREAD
	fnServerTransactionCancel_rets *clnt_res;
#endif
	CLIENT *clnt;
{
#ifdef MULTITHREAD
	bzero((char *)clnt_res, sizeof(*clnt_res));
	return (clnt_call(clnt, fnRpc_fnServerTransactionCancel,
	                  (xdrproc_t) xdr_fnServerTransactionCancel_args,
	                  (caddr_t)   argp,
	                  (xdrproc_t) xdr_fnServerTransactionCancel_rets,
	                  (caddr_t)   clnt_res,
	                  TIMEOUT));
#else
	static fnServerTransactionCancel_rets res;

	bzero((char *)&res, sizeof(res));
	if (clnt_call(clnt, fnRpc_fnServerTransactionCancel,
	              (xdrproc_t) xdr_fnServerTransactionCancel_args,
	              (caddr_t)   argp,
	              (xdrproc_t) xdr_fnServerTransactionCancel_rets,
	              (caddr_t)   &res,
	              TIMEOUT) != RPC_SUCCESS) {
		return (NULL);
	}
	return (&res);
#endif
}


#ifdef MULTITHREAD
enum clnt_stat
#else
fnServerTransactionEnd_rets *
#endif
fnrpc_fnservertransactionend_1
#ifdef MULTITHREAD
	(argp, clnt_res, clnt)
#else
	(argp, clnt)
#endif
	fnServerTransactionEnd_args *argp;
#ifdef MULTITHREAD
	fnServerTransactionEnd_rets *clnt_res;
#endif
	CLIENT *clnt;
{
#ifdef MULTITHREAD
	bzero((char *)clnt_res, sizeof(*clnt_res));
	return (clnt_call(clnt, fnRpc_fnServerTransactionEnd,
	                  (xdrproc_t) xdr_fnServerTransactionEnd_args,
	                  (caddr_t)   argp,
	                  (xdrproc_t) xdr_fnServerTransactionEnd_rets,
	                  (caddr_t)   clnt_res,
	                  TIMEOUT));
#else
	static fnServerTransactionEnd_rets res;

	bzero((char *)&res, sizeof(res));
	if (clnt_call(clnt, fnRpc_fnServerTransactionEnd,
	              (xdrproc_t) xdr_fnServerTransactionEnd_args,
	              (caddr_t)   argp,
	              (xdrproc_t) xdr_fnServerTransactionEnd_rets,
	              (caddr_t)   &res,
	              TIMEOUT) != RPC_SUCCESS) {
		return (NULL);
	}
	return (&res);
#endif
}


#ifdef MULTITHREAD
enum clnt_stat
#else
void *
#endif
fnrpc_fnservertransactionflush_batch_1
#ifdef MULTITHREAD
	(argp, clnt_res, clnt)
#else
	(argp, clnt)
#endif
	SHORTOBJID *argp;
#ifdef MULTITHREAD
	void *clnt_res;
#endif
	CLIENT *clnt;
{
#ifdef MULTITHREAD
	return (clnt_call(clnt, fnRpc_fnServerTransactionFlush_batch,
	                  (xdrproc_t) xdr_SHORTOBJID,
	                  (caddr_t)   argp,
	                  (xdrproc_t) xdr_void,
	                  (caddr_t)   clnt_res,
	                  TIMEOUT));
#else
	static char res;

	bzero((char *)&res, sizeof(res));
	if (clnt_call(clnt, fnRpc_fnServerTransactionFlush_batch,
	              (xdrproc_t) xdr_SHORTOBJID,
	              (caddr_t)   argp,
	              (xdrproc_t) xdr_void,
	              (caddr_t)   &res,
	              TIMEOUT) != RPC_SUCCESS) {
		return (NULL);
	}
	return ((void *)&res);
#endif
}


#ifdef MULTITHREAD
enum clnt_stat
#else
fnServerDbTransactionP_rets *
#endif
fnrpc_fnserverdbtransactionp_1
#ifdef MULTITHREAD
	(argp, clnt_res, clnt)
#else
	(argp, clnt)
#endif
	fnServerDbTransactionP_args *argp;
#ifdef MULTITHREAD
	fnServerDbTransactionP_rets *clnt_res;
#endif
	CLIENT *clnt;
{
#ifdef MULTITHREAD
	bzero((char *)clnt_res, sizeof(*clnt_res));
	return (clnt_call(clnt, fnRpc_fnServerDbTransactionP,
	                  (xdrproc_t) xdr_fnServerDbTransactionP_args,
	                  (caddr_t)   argp,
	                  (xdrproc_t) xdr_fnServerDbTransactionP_rets,
	                  (caddr_t)   clnt_res,
	                  TIMEOUT));
#else
	static fnServerDbTransactionP_rets res;

	bzero((char *)&res, sizeof(res));
	if (clnt_call(clnt, fnRpc_fnServerDbTransactionP,
	              (xdrproc_t) xdr_fnServerDbTransactionP_args,
	              (caddr_t)   argp,
	              (xdrproc_t) xdr_fnServerDbTransactionP_rets,
	              (caddr_t)   &res,
	              TIMEOUT) != RPC_SUCCESS) {
		return (NULL);
	}
	return (&res);
#endif
}


#ifdef MULTITHREAD
enum clnt_stat
#else
fnClientBtreeClear_rets *
#endif
fnrpc_fnclientbtreeclear_1
#ifdef MULTITHREAD
	(argp, clnt_res, clnt)
#else
	(argp, clnt)
#endif
	fnClientBtreeClear_args *argp;
#ifdef MULTITHREAD
	fnClientBtreeClear_rets *clnt_res;
#endif
	CLIENT *clnt;
{
#ifdef MULTITHREAD
	bzero((char *)clnt_res, sizeof(*clnt_res));
	return (clnt_call(clnt, fnRpc_fnClientBtreeClear,
	                  (xdrproc_t) xdr_fnClientBtreeClear_args,
	                  (caddr_t)   argp,
	                  (xdrproc_t) xdr_fnClientBtreeClear_rets,
	                  (caddr_t)   clnt_res,
	                  TIMEOUT));
#else
	static fnClientBtreeClear_rets res;

	bzero((char *)&res, sizeof(res));
	if (clnt_call(clnt, fnRpc_fnClientBtreeClear,
	              (xdrproc_t) xdr_fnClientBtreeClear_args,
	              (caddr_t)   argp,
	              (xdrproc_t) xdr_fnClientBtreeClear_rets,
	              (caddr_t)   &res,
	              TIMEOUT) != RPC_SUCCESS) {
		return (NULL);
	}
	return (&res);
#endif
}


#ifdef MULTITHREAD
enum clnt_stat
#else
fnClientBtreeCount_rets *
#endif
fnrpc_fnclientbtreecount_1
#ifdef MULTITHREAD
	(argp, clnt_res, clnt)
#else
	(argp, clnt)
#endif
	fnClientBtreeCount_args *argp;
#ifdef MULTITHREAD
	fnClientBtreeCount_rets *clnt_res;
#endif
	CLIENT *clnt;
{
#ifdef MULTITHREAD
	bzero((char *)clnt_res, sizeof(*clnt_res));
	return (clnt_call(clnt, fnRpc_fnClientBtreeCount,
	                  (xdrproc_t) xdr_fnClientBtreeCount_args,
	                  (caddr_t)   argp,
	                  (xdrproc_t) xdr_fnClientBtreeCount_rets,
	                  (caddr_t)   clnt_res,
	                  TIMEOUT));
#else
	static fnClientBtreeCount_rets res;

	bzero((char *)&res, sizeof(res));
	if (clnt_call(clnt, fnRpc_fnClientBtreeCount,
	              (xdrproc_t) xdr_fnClientBtreeCount_args,
	              (caddr_t)   argp,
	              (xdrproc_t) xdr_fnClientBtreeCount_rets,
	              (caddr_t)   &res,
	              TIMEOUT) != RPC_SUCCESS) {
		return (NULL);
	}
	return (&res);
#endif
}


#ifdef MULTITHREAD
enum clnt_stat
#else
fnServerBtreeDelete_rets *
#endif
fnrpc_fnserverbtreedelete_1
#ifdef MULTITHREAD
	(argp, clnt_res, clnt)
#else
	(argp, clnt)
#endif
	fnServerBtreeDelete_args *argp;
#ifdef MULTITHREAD
	fnServerBtreeDelete_rets *clnt_res;
#endif
	CLIENT *clnt;
{
#ifdef MULTITHREAD
	bzero((char *)clnt_res, sizeof(*clnt_res));
	return (clnt_call(clnt, fnRpc_fnServerBtreeDelete,
	                  (xdrproc_t) xdr_fnServerBtreeDelete_args,
	                  (caddr_t)   argp,
	                  (xdrproc_t) xdr_fnServerBtreeDelete_rets,
	                  (caddr_t)   clnt_res,
	                  TIMEOUT));
#else
	static fnServerBtreeDelete_rets res;

	bzero((char *)&res, sizeof(res));
	if (clnt_call(clnt, fnRpc_fnServerBtreeDelete,
	              (xdrproc_t) xdr_fnServerBtreeDelete_args,
	              (caddr_t)   argp,
	              (xdrproc_t) xdr_fnServerBtreeDelete_rets,
	              (caddr_t)   &res,
	              TIMEOUT) != RPC_SUCCESS) {
		return (NULL);
	}
	return (&res);
#endif
}


#ifdef MULTITHREAD
enum clnt_stat
#else
fnServerBtreeDeleteByFloat_rets *
#endif
fnrpc_fnserverbtreedeletebyfloat_1
#ifdef MULTITHREAD
	(argp, clnt_res, clnt)
#else
	(argp, clnt)
#endif
	fnServerBtreeDeleteByFloat_args *argp;
#ifdef MULTITHREAD
	fnServerBtreeDeleteByFloat_rets *clnt_res;
#endif
	CLIENT *clnt;
{
#ifdef MULTITHREAD
	bzero((char *)clnt_res, sizeof(*clnt_res));
	return (clnt_call(clnt, fnRpc_fnServerBtreeDeleteByFloat,
	                  (xdrproc_t) xdr_fnServerBtreeDeleteByFloat_args,
	                  (caddr_t)   argp,
	                  (xdrproc_t) xdr_fnServerBtreeDeleteByFloat_rets,
	                  (caddr_t)   clnt_res,
	                  TIMEOUT));
#else
	static fnServerBtreeDeleteByFloat_rets res;

	bzero((char *)&res, sizeof(res));
	if (clnt_call(clnt, fnRpc_fnServerBtreeDeleteByFloat,
	              (xdrproc_t) xdr_fnServerBtreeDeleteByFloat_args,
	              (caddr_t)   argp,
	              (xdrproc_t) xdr_fnServerBtreeDeleteByFloat_rets,
	              (caddr_t)   &res,
	              TIMEOUT) != RPC_SUCCESS) {
		return (NULL);
	}
	return (&res);
#endif
}


#ifdef MULTITHREAD
enum clnt_stat
#else
fnServerBtreeDeleteByDouble_rets *
#endif
fnrpc_fnserverbtreedeletebydouble_1
#ifdef MULTITHREAD
	(argp, clnt_res, clnt)
#else
	(argp, clnt)
#endif
	fnServerBtreeDeleteByDouble_args *argp;
#ifdef MULTITHREAD
	fnServerBtreeDeleteByDouble_rets *clnt_res;
#endif
	CLIENT *clnt;
{
#ifdef MULTITHREAD
	bzero((char *)clnt_res, sizeof(*clnt_res));
	return (clnt_call(clnt, fnRpc_fnServerBtreeDeleteByDouble,
	                  (xdrproc_t) xdr_fnServerBtreeDeleteByDouble_args,
	                  (caddr_t)   argp,
	                  (xdrproc_t) xdr_fnServerBtreeDeleteByDouble_rets,
	                  (caddr_t)   clnt_res,
	                  TIMEOUT));
#else
	static fnServerBtreeDeleteByDouble_rets res;

	bzero((char *)&res, sizeof(res));
	if (clnt_call(clnt, fnRpc_fnServerBtreeDeleteByDouble,
	              (xdrproc_t) xdr_fnServerBtreeDeleteByDouble_args,
	              (caddr_t)   argp,
	              (xdrproc_t) xdr_fnServerBtreeDeleteByDouble_rets,
	              (caddr_t)   &res,
	              TIMEOUT) != RPC_SUCCESS) {
		return (NULL);
	}
	return (&res);
#endif
}


#ifdef MULTITHREAD
enum clnt_stat
#else
fnServerBtreeDeleteByString_rets *
#endif
fnrpc_fnserverbtreedeletebystring_1
#ifdef MULTITHREAD
	(argp, clnt_res, clnt)
#else
	(argp, clnt)
#endif
	fnServerBtreeDeleteByString_args *argp;
#ifdef MULTITHREAD
	fnServerBtreeDeleteByString_rets *clnt_res;
#endif
	CLIENT *clnt;
{
#ifdef MULTITHREAD
	bzero((char *)clnt_res, sizeof(*clnt_res));
	return (clnt_call(clnt, fnRpc_fnServerBtreeDeleteByString,
	                  (xdrproc_t) xdr_fnServerBtreeDeleteByString_args,
	                  (caddr_t)   argp,
	                  (xdrproc_t) xdr_fnServerBtreeDeleteByString_rets,
	                  (caddr_t)   clnt_res,
	                  TIMEOUT));
#else
	static fnServerBtreeDeleteByString_rets res;

	bzero((char *)&res, sizeof(res));
	if (clnt_call(clnt, fnRpc_fnServerBtreeDeleteByString,
	              (xdrproc_t) xdr_fnServerBtreeDeleteByString_args,
	              (caddr_t)   argp,
	              (xdrproc_t) xdr_fnServerBtreeDeleteByString_rets,
	              (caddr_t)   &res,
	              TIMEOUT) != RPC_SUCCESS) {
		return (NULL);
	}
	return (&res);
#endif
}


#ifdef MULTITHREAD
enum clnt_stat
#else
fnServerBtreeInsert_rets *
#endif
fnrpc_fnserverbtreeinsert_1
#ifdef MULTITHREAD
	(argp, clnt_res, clnt)
#else
	(argp, clnt)
#endif
	fnServerBtreeInsert_args *argp;
#ifdef MULTITHREAD
	fnServerBtreeInsert_rets *clnt_res;
#endif
	CLIENT *clnt;
{
#ifdef MULTITHREAD
	bzero((char *)clnt_res, sizeof(*clnt_res));
	return (clnt_call(clnt, fnRpc_fnServerBtreeInsert,
	                  (xdrproc_t) xdr_fnServerBtreeInsert_args,
	                  (caddr_t)   argp,
	                  (xdrproc_t) xdr_fnServerBtreeInsert_rets,
	                  (caddr_t)   clnt_res,
	                  TIMEOUT));
#else
	static fnServerBtreeInsert_rets res;

	bzero((char *)&res, sizeof(res));
	if (clnt_call(clnt, fnRpc_fnServerBtreeInsert,
	              (xdrproc_t) xdr_fnServerBtreeInsert_args,
	              (caddr_t)   argp,
	              (xdrproc_t) xdr_fnServerBtreeInsert_rets,
	              (caddr_t)   &res,
	              TIMEOUT) != RPC_SUCCESS) {
		return (NULL);
	}
	return (&res);
#endif
}


#ifdef MULTITHREAD
enum clnt_stat
#else
fnServerBtreeInsertByFloat_rets *
#endif
fnrpc_fnserverbtreeinsertbyfloat_1
#ifdef MULTITHREAD
	(argp, clnt_res, clnt)
#else
	(argp, clnt)
#endif
	fnServerBtreeInsertByFloat_args *argp;
#ifdef MULTITHREAD
	fnServerBtreeInsertByFloat_rets *clnt_res;
#endif
	CLIENT *clnt;
{
#ifdef MULTITHREAD
	bzero((char *)clnt_res, sizeof(*clnt_res));
	return (clnt_call(clnt, fnRpc_fnServerBtreeInsertByFloat,
	                  (xdrproc_t) xdr_fnServerBtreeInsertByFloat_args,
	                  (caddr_t)   argp,
	                  (xdrproc_t) xdr_fnServerBtreeInsertByFloat_rets,
	                  (caddr_t)   clnt_res,
	                  TIMEOUT));
#else
	static fnServerBtreeInsertByFloat_rets res;

	bzero((char *)&res, sizeof(res));
	if (clnt_call(clnt, fnRpc_fnServerBtreeInsertByFloat,
	              (xdrproc_t) xdr_fnServerBtreeInsertByFloat_args,
	              (caddr_t)   argp,
	              (xdrproc_t) xdr_fnServerBtreeInsertByFloat_rets,
	              (caddr_t)   &res,
	              TIMEOUT) != RPC_SUCCESS) {
		return (NULL);
	}
	return (&res);
#endif
}


#ifdef MULTITHREAD
enum clnt_stat
#else
fnServerBtreeInsertByDouble_rets *
#endif
fnrpc_fnserverbtreeinsertbydouble_1
#ifdef MULTITHREAD
	(argp, clnt_res, clnt)
#else
	(argp, clnt)
#endif
	fnServerBtreeInsertByDouble_args *argp;
#ifdef MULTITHREAD
	fnServerBtreeInsertByDouble_rets *clnt_res;
#endif
	CLIENT *clnt;
{
#ifdef MULTITHREAD
	bzero((char *)clnt_res, sizeof(*clnt_res));
	return (clnt_call(clnt, fnRpc_fnServerBtreeInsertByDouble,
	                  (xdrproc_t) xdr_fnServerBtreeInsertByDouble_args,
	                  (caddr_t)   argp,
	                  (xdrproc_t) xdr_fnServerBtreeInsertByDouble_rets,
	                  (caddr_t)   clnt_res,
	                  TIMEOUT));
#else
	static fnServerBtreeInsertByDouble_rets res;

	bzero((char *)&res, sizeof(res));
	if (clnt_call(clnt, fnRpc_fnServerBtreeInsertByDouble,
	              (xdrproc_t) xdr_fnServerBtreeInsertByDouble_args,
	              (caddr_t)   argp,
	              (xdrproc_t) xdr_fnServerBtreeInsertByDouble_rets,
	              (caddr_t)   &res,
	              TIMEOUT) != RPC_SUCCESS) {
		return (NULL);
	}
	return (&res);
#endif
}


#ifdef MULTITHREAD
enum clnt_stat
#else
fnServerBtreeInsertByString_rets *
#endif
fnrpc_fnserverbtreeinsertbystring_1
#ifdef MULTITHREAD
	(argp, clnt_res, clnt)
#else
	(argp, clnt)
#endif
	fnServerBtreeInsertByString_args *argp;
#ifdef MULTITHREAD
	fnServerBtreeInsertByString_rets *clnt_res;
#endif
	CLIENT *clnt;
{
#ifdef MULTITHREAD
	bzero((char *)clnt_res, sizeof(*clnt_res));
	return (clnt_call(clnt, fnRpc_fnServerBtreeInsertByString,
	                  (xdrproc_t) xdr_fnServerBtreeInsertByString_args,
	                  (caddr_t)   argp,
	                  (xdrproc_t) xdr_fnServerBtreeInsertByString_rets,
	                  (caddr_t)   clnt_res,
	                  TIMEOUT));
#else
	static fnServerBtreeInsertByString_rets res;

	bzero((char *)&res, sizeof(res));
	if (clnt_call(clnt, fnRpc_fnServerBtreeInsertByString,
	              (xdrproc_t) xdr_fnServerBtreeInsertByString_args,
	              (caddr_t)   argp,
	              (xdrproc_t) xdr_fnServerBtreeInsertByString_rets,
	              (caddr_t)   &res,
	              TIMEOUT) != RPC_SUCCESS) {
		return (NULL);
	}
	return (&res);
#endif
}


#ifdef MULTITHREAD
enum clnt_stat
#else
fnServerBtreemapSearch_rets *
#endif
fnrpc_fnserverbtreemapsearch_1
#ifdef MULTITHREAD
	(argp, clnt_res, clnt)
#else
	(argp, clnt)
#endif
	fnServerBtreemapSearch_args *argp;
#ifdef MULTITHREAD
	fnServerBtreemapSearch_rets *clnt_res;
#endif
	CLIENT *clnt;
{
#ifdef MULTITHREAD
	bzero((char *)clnt_res, sizeof(*clnt_res));
	return (clnt_call(clnt, fnRpc_fnServerBtreemapSearch,
	                  (xdrproc_t) xdr_fnServerBtreemapSearch_args,
	                  (caddr_t)   argp,
	                  (xdrproc_t) xdr_fnServerBtreemapSearch_rets,
	                  (caddr_t)   clnt_res,
	                  TIMEOUT));
#else
	static fnServerBtreemapSearch_rets res;

	bzero((char *)&res, sizeof(res));
	if (clnt_call(clnt, fnRpc_fnServerBtreemapSearch,
	              (xdrproc_t) xdr_fnServerBtreemapSearch_args,
	              (caddr_t)   argp,
	              (xdrproc_t) xdr_fnServerBtreemapSearch_rets,
	              (caddr_t)   &res,
	              TIMEOUT) != RPC_SUCCESS) {
		return (NULL);
	}
	return (&res);
#endif
}


#ifdef MULTITHREAD
enum clnt_stat
#else
fnServerBtreemapSearchByFloat_rets *
#endif
fnrpc_fnserverbtreemapsearchbyfloat_1
#ifdef MULTITHREAD
	(argp, clnt_res, clnt)
#else
	(argp, clnt)
#endif
	fnServerBtreemapSearchByFloat_args *argp;
#ifdef MULTITHREAD
	fnServerBtreemapSearchByFloat_rets *clnt_res;
#endif
	CLIENT *clnt;
{
#ifdef MULTITHREAD
	bzero((char *)clnt_res, sizeof(*clnt_res));
	return (clnt_call(clnt, fnRpc_fnServerBtreemapSearchByFloat,
	                  (xdrproc_t) xdr_fnServerBtreemapSearchByFloat_args,
	                  (caddr_t)   argp,
	                  (xdrproc_t) xdr_fnServerBtreemapSearchByFloat_rets,
	                  (caddr_t)   clnt_res,
	                  TIMEOUT));
#else
	static fnServerBtreemapSearchByFloat_rets res;

	bzero((char *)&res, sizeof(res));
	if (clnt_call(clnt, fnRpc_fnServerBtreemapSearchByFloat,
	              (xdrproc_t) xdr_fnServerBtreemapSearchByFloat_args,
	              (caddr_t)   argp,
	              (xdrproc_t) xdr_fnServerBtreemapSearchByFloat_rets,
	              (caddr_t)   &res,
	              TIMEOUT) != RPC_SUCCESS) {
		return (NULL);
	}
	return (&res);
#endif
}


#ifdef MULTITHREAD
enum clnt_stat
#else
fnServerBtreemapSearchByDouble_rets *
#endif
fnrpc_fnserverbtreemapsearchbydouble_1
#ifdef MULTITHREAD
	(argp, clnt_res, clnt)
#else
	(argp, clnt)
#endif
	fnServerBtreemapSearchByDouble_args *argp;
#ifdef MULTITHREAD
	fnServerBtreemapSearchByDouble_rets *clnt_res;
#endif
	CLIENT *clnt;
{
#ifdef MULTITHREAD
	bzero((char *)clnt_res, sizeof(*clnt_res));
	return (clnt_call(clnt, fnRpc_fnServerBtreemapSearchByDouble,
	                  (xdrproc_t) xdr_fnServerBtreemapSearchByDouble_args,
	                  (caddr_t)   argp,
	                  (xdrproc_t) xdr_fnServerBtreemapSearchByDouble_rets,
	                  (caddr_t)   clnt_res,
	                  TIMEOUT));
#else
	static fnServerBtreemapSearchByDouble_rets res;

	bzero((char *)&res, sizeof(res));
	if (clnt_call(clnt, fnRpc_fnServerBtreemapSearchByDouble,
	              (xdrproc_t) xdr_fnServerBtreemapSearchByDouble_args,
	              (caddr_t)   argp,
	              (xdrproc_t) xdr_fnServerBtreemapSearchByDouble_rets,
	              (caddr_t)   &res,
	              TIMEOUT) != RPC_SUCCESS) {
		return (NULL);
	}
	return (&res);
#endif
}


#ifdef MULTITHREAD
enum clnt_stat
#else
fnServerBtreemapSearchByString_rets *
#endif
fnrpc_fnserverbtreemapsearchbystring_1
#ifdef MULTITHREAD
	(argp, clnt_res, clnt)
#else
	(argp, clnt)
#endif
	fnServerBtreemapSearchByString_args *argp;
#ifdef MULTITHREAD
	fnServerBtreemapSearchByString_rets *clnt_res;
#endif
	CLIENT *clnt;
{
#ifdef MULTITHREAD
	bzero((char *)clnt_res, sizeof(*clnt_res));
	return (clnt_call(clnt, fnRpc_fnServerBtreemapSearchByString,
	                  (xdrproc_t) xdr_fnServerBtreemapSearchByString_args,
	                  (caddr_t)   argp,
	                  (xdrproc_t) xdr_fnServerBtreemapSearchByString_rets,
	                  (caddr_t)   clnt_res,
	                  TIMEOUT));
#else
	static fnServerBtreemapSearchByString_rets res;

	bzero((char *)&res, sizeof(res));
	if (clnt_call(clnt, fnRpc_fnServerBtreemapSearchByString,
	              (xdrproc_t) xdr_fnServerBtreemapSearchByString_args,
	              (caddr_t)   argp,
	              (xdrproc_t) xdr_fnServerBtreemapSearchByString_rets,
	              (caddr_t)   &res,
	              TIMEOUT) != RPC_SUCCESS) {
		return (NULL);
	}
	return (&res);
#endif
}


#ifdef MULTITHREAD
enum clnt_stat
#else
fnServerBtreemapSeek_rets *
#endif
fnrpc_fnserverbtreemapseek_1
#ifdef MULTITHREAD
	(argp, clnt_res, clnt)
#else
	(argp, clnt)
#endif
	fnServerBtreemapSeek_args *argp;
#ifdef MULTITHREAD
	fnServerBtreemapSeek_rets *clnt_res;
#endif
	CLIENT *clnt;
{
#ifdef MULTITHREAD
	bzero((char *)clnt_res, sizeof(*clnt_res));
	return (clnt_call(clnt, fnRpc_fnServerBtreemapSeek,
	                  (xdrproc_t) xdr_fnServerBtreemapSeek_args,
	                  (caddr_t)   argp,
	                  (xdrproc_t) xdr_fnServerBtreemapSeek_rets,
	                  (caddr_t)   clnt_res,
	                  TIMEOUT));
#else
	static fnServerBtreemapSeek_rets res;

	bzero((char *)&res, sizeof(res));
	if (clnt_call(clnt, fnRpc_fnServerBtreemapSeek,
	              (xdrproc_t) xdr_fnServerBtreemapSeek_args,
	              (caddr_t)   argp,
	              (xdrproc_t) xdr_fnServerBtreemapSeek_rets,
	              (caddr_t)   &res,
	              TIMEOUT) != RPC_SUCCESS) {
		return (NULL);
	}
	return (&res);
#endif
}


#ifdef MULTITHREAD
enum clnt_stat
#else
fnServerBtreemapSeekSet_rets *
#endif
fnrpc_fnserverbtreemapseekset_1
#ifdef MULTITHREAD
	(argp, clnt_res, clnt)
#else
	(argp, clnt)
#endif
	fnServerBtreemapSeekSet_args *argp;
#ifdef MULTITHREAD
	fnServerBtreemapSeekSet_rets *clnt_res;
#endif
	CLIENT *clnt;
{
#ifdef MULTITHREAD
	bzero((char *)clnt_res, sizeof(*clnt_res));
	return (clnt_call(clnt, fnRpc_fnServerBtreemapSeekSet,
	                  (xdrproc_t) xdr_fnServerBtreemapSeekSet_args,
	                  (caddr_t)   argp,
	                  (xdrproc_t) xdr_fnServerBtreemapSeekSet_rets,
	                  (caddr_t)   clnt_res,
	                  TIMEOUT));
#else
	static fnServerBtreemapSeekSet_rets res;

	bzero((char *)&res, sizeof(res));
	if (clnt_call(clnt, fnRpc_fnServerBtreemapSeekSet,
	              (xdrproc_t) xdr_fnServerBtreemapSeekSet_args,
	              (caddr_t)   argp,
	              (xdrproc_t) xdr_fnServerBtreemapSeekSet_rets,
	              (caddr_t)   &res,
	              TIMEOUT) != RPC_SUCCESS) {
		return (NULL);
	}
	return (&res);
#endif
}


#ifdef MULTITHREAD
enum clnt_stat
#else
fnServerBtreemapFirst_rets *
#endif
fnrpc_fnserverbtreemapfirst_1
#ifdef MULTITHREAD
	(argp, clnt_res, clnt)
#else
	(argp, clnt)
#endif
	fnServerBtreemapFirst_args *argp;
#ifdef MULTITHREAD
	fnServerBtreemapFirst_rets *clnt_res;
#endif
	CLIENT *clnt;
{
#ifdef MULTITHREAD
	bzero((char *)clnt_res, sizeof(*clnt_res));
	return (clnt_call(clnt, fnRpc_fnServerBtreemapFirst,
	                  (xdrproc_t) xdr_fnServerBtreemapFirst_args,
	                  (caddr_t)   argp,
	                  (xdrproc_t) xdr_fnServerBtreemapFirst_rets,
	                  (caddr_t)   clnt_res,
	                  TIMEOUT));
#else
	static fnServerBtreemapFirst_rets res;

	bzero((char *)&res, sizeof(res));
	if (clnt_call(clnt, fnRpc_fnServerBtreemapFirst,
	              (xdrproc_t) xdr_fnServerBtreemapFirst_args,
	              (caddr_t)   argp,
	              (xdrproc_t) xdr_fnServerBtreemapFirst_rets,
	              (caddr_t)   &res,
	              TIMEOUT) != RPC_SUCCESS) {
		return (NULL);
	}
	return (&res);
#endif
}


#ifdef MULTITHREAD
enum clnt_stat
#else
fnServerBtreemapFirstByFloat_rets *
#endif
fnrpc_fnserverbtreemapfirstbyfloat_1
#ifdef MULTITHREAD
	(argp, clnt_res, clnt)
#else
	(argp, clnt)
#endif
	fnServerBtreemapFirstByFloat_args *argp;
#ifdef MULTITHREAD
	fnServerBtreemapFirstByFloat_rets *clnt_res;
#endif
	CLIENT *clnt;
{
#ifdef MULTITHREAD
	bzero((char *)clnt_res, sizeof(*clnt_res));
	return (clnt_call(clnt, fnRpc_fnServerBtreemapFirstByFloat,
	                  (xdrproc_t) xdr_fnServerBtreemapFirstByFloat_args,
	                  (caddr_t)   argp,
	                  (xdrproc_t) xdr_fnServerBtreemapFirstByFloat_rets,
	                  (caddr_t)   clnt_res,
	                  TIMEOUT));
#else
	static fnServerBtreemapFirstByFloat_rets res;

	bzero((char *)&res, sizeof(res));
	if (clnt_call(clnt, fnRpc_fnServerBtreemapFirstByFloat,
	              (xdrproc_t) xdr_fnServerBtreemapFirstByFloat_args,
	              (caddr_t)   argp,
	              (xdrproc_t) xdr_fnServerBtreemapFirstByFloat_rets,
	              (caddr_t)   &res,
	              TIMEOUT) != RPC_SUCCESS) {
		return (NULL);
	}
	return (&res);
#endif
}


#ifdef MULTITHREAD
enum clnt_stat
#else
fnServerBtreemapFirstByDouble_rets *
#endif
fnrpc_fnserverbtreemapfirstbydouble_1
#ifdef MULTITHREAD
	(argp, clnt_res, clnt)
#else
	(argp, clnt)
#endif
	fnServerBtreemapFirstByDouble_args *argp;
#ifdef MULTITHREAD
	fnServerBtreemapFirstByDouble_rets *clnt_res;
#endif
	CLIENT *clnt;
{
#ifdef MULTITHREAD
	bzero((char *)clnt_res, sizeof(*clnt_res));
	return (clnt_call(clnt, fnRpc_fnServerBtreemapFirstByDouble,
	                  (xdrproc_t) xdr_fnServerBtreemapFirstByDouble_args,
	                  (caddr_t)   argp,
	                  (xdrproc_t) xdr_fnServerBtreemapFirstByDouble_rets,
	                  (caddr_t)   clnt_res,
	                  TIMEOUT));
#else
	static fnServerBtreemapFirstByDouble_rets res;

	bzero((char *)&res, sizeof(res));
	if (clnt_call(clnt, fnRpc_fnServerBtreemapFirstByDouble,
	              (xdrproc_t) xdr_fnServerBtreemapFirstByDouble_args,
	              (caddr_t)   argp,
	              (xdrproc_t) xdr_fnServerBtreemapFirstByDouble_rets,
	              (caddr_t)   &res,
	              TIMEOUT) != RPC_SUCCESS) {
		return (NULL);
	}
	return (&res);
#endif
}


#ifdef MULTITHREAD
enum clnt_stat
#else
fnServerBtreemapFirstByString_rets *
#endif
fnrpc_fnserverbtreemapfirstbystring_1
#ifdef MULTITHREAD
	(argp, clnt_res, clnt)
#else
	(argp, clnt)
#endif
	fnServerBtreemapFirstByString_args *argp;
#ifdef MULTITHREAD
	fnServerBtreemapFirstByString_rets *clnt_res;
#endif
	CLIENT *clnt;
{
#ifdef MULTITHREAD
	bzero((char *)clnt_res, sizeof(*clnt_res));
	return (clnt_call(clnt, fnRpc_fnServerBtreemapFirstByString,
	                  (xdrproc_t) xdr_fnServerBtreemapFirstByString_args,
	                  (caddr_t)   argp,
	                  (xdrproc_t) xdr_fnServerBtreemapFirstByString_rets,
	                  (caddr_t)   clnt_res,
	                  TIMEOUT));
#else
	static fnServerBtreemapFirstByString_rets res;

	bzero((char *)&res, sizeof(res));
	if (clnt_call(clnt, fnRpc_fnServerBtreemapFirstByString,
	              (xdrproc_t) xdr_fnServerBtreemapFirstByString_args,
	              (caddr_t)   argp,
	              (xdrproc_t) xdr_fnServerBtreemapFirstByString_rets,
	              (caddr_t)   &res,
	              TIMEOUT) != RPC_SUCCESS) {
		return (NULL);
	}
	return (&res);
#endif
}


#ifdef MULTITHREAD
enum clnt_stat
#else
fnClientBtreemapNext_rets *
#endif
fnrpc_fnclientbtreemapnext_1
#ifdef MULTITHREAD
	(argp, clnt_res, clnt)
#else
	(argp, clnt)
#endif
	fnClientBtreemapNext_args *argp;
#ifdef MULTITHREAD
	fnClientBtreemapNext_rets *clnt_res;
#endif
	CLIENT *clnt;
{
#ifdef MULTITHREAD
	bzero((char *)clnt_res, sizeof(*clnt_res));
	return (clnt_call(clnt, fnRpc_fnClientBtreemapNext,
	                  (xdrproc_t) xdr_fnClientBtreemapNext_args,
	                  (caddr_t)   argp,
	                  (xdrproc_t) xdr_fnClientBtreemapNext_rets,
	                  (caddr_t)   clnt_res,
	                  TIMEOUT));
#else
	static fnClientBtreemapNext_rets res;

	bzero((char *)&res, sizeof(res));
	if (clnt_call(clnt, fnRpc_fnClientBtreemapNext,
	              (xdrproc_t) xdr_fnClientBtreemapNext_args,
	              (caddr_t)   argp,
	              (xdrproc_t) xdr_fnClientBtreemapNext_rets,
	              (caddr_t)   &res,
	              TIMEOUT) != RPC_SUCCESS) {
		return (NULL);
	}
	return (&res);
#endif
}


#ifdef MULTITHREAD
enum clnt_stat
#else
fnClientBtreemapLast_rets *
#endif
fnrpc_fnclientbtreemaplast_1
#ifdef MULTITHREAD
	(argp, clnt_res, clnt)
#else
	(argp, clnt)
#endif
	fnClientBtreemapLast_args *argp;
#ifdef MULTITHREAD
	fnClientBtreemapLast_rets *clnt_res;
#endif
	CLIENT *clnt;
{
#ifdef MULTITHREAD
	bzero((char *)clnt_res, sizeof(*clnt_res));
	return (clnt_call(clnt, fnRpc_fnClientBtreemapLast,
	                  (xdrproc_t) xdr_fnClientBtreemapLast_args,
	                  (caddr_t)   argp,
	                  (xdrproc_t) xdr_fnClientBtreemapLast_rets,
	                  (caddr_t)   clnt_res,
	                  TIMEOUT));
#else
	static fnClientBtreemapLast_rets res;

	bzero((char *)&res, sizeof(res));
	if (clnt_call(clnt, fnRpc_fnClientBtreemapLast,
	              (xdrproc_t) xdr_fnClientBtreemapLast_args,
	              (caddr_t)   argp,
	              (xdrproc_t) xdr_fnClientBtreemapLast_rets,
	              (caddr_t)   &res,
	              TIMEOUT) != RPC_SUCCESS) {
		return (NULL);
	}
	return (&res);
#endif
}


#ifdef MULTITHREAD
enum clnt_stat
#else
fnClientBtreePrint_rets *
#endif
fnrpc_fnclientbtreeprint_1
#ifdef MULTITHREAD
	(argp, clnt_res, clnt)
#else
	(argp, clnt)
#endif
	fnClientBtreePrint_args *argp;
#ifdef MULTITHREAD
	fnClientBtreePrint_rets *clnt_res;
#endif
	CLIENT *clnt;
{
#ifdef MULTITHREAD
	bzero((char *)clnt_res, sizeof(*clnt_res));
	return (clnt_call(clnt, fnRpc_fnClientBtreePrint,
	                  (xdrproc_t) xdr_fnClientBtreePrint_args,
	                  (caddr_t)   argp,
	                  (xdrproc_t) xdr_fnClientBtreePrint_rets,
	                  (caddr_t)   clnt_res,
	                  TIMEOUT));
#else
	static fnClientBtreePrint_rets res;

	bzero((char *)&res, sizeof(res));
	if (clnt_call(clnt, fnRpc_fnClientBtreePrint,
	              (xdrproc_t) xdr_fnClientBtreePrint_args,
	              (caddr_t)   argp,
	              (xdrproc_t) xdr_fnClientBtreePrint_rets,
	              (caddr_t)   &res,
	              TIMEOUT) != RPC_SUCCESS) {
		return (NULL);
	}
	return (&res);
#endif
}


#ifdef MULTITHREAD
enum clnt_stat
#else
fnServerBtreeSearch_rets *
#endif
fnrpc_fnserverbtreesearch_1
#ifdef MULTITHREAD
	(argp, clnt_res, clnt)
#else
	(argp, clnt)
#endif
	fnServerBtreeSearch_args *argp;
#ifdef MULTITHREAD
	fnServerBtreeSearch_rets *clnt_res;
#endif
	CLIENT *clnt;
{
#ifdef MULTITHREAD
	bzero((char *)clnt_res, sizeof(*clnt_res));
	return (clnt_call(clnt, fnRpc_fnServerBtreeSearch,
	                  (xdrproc_t) xdr_fnServerBtreeSearch_args,
	                  (caddr_t)   argp,
	                  (xdrproc_t) xdr_fnServerBtreeSearch_rets,
	                  (caddr_t)   clnt_res,
	                  TIMEOUT));
#else
	static fnServerBtreeSearch_rets res;

	bzero((char *)&res, sizeof(res));
	if (clnt_call(clnt, fnRpc_fnServerBtreeSearch,
	              (xdrproc_t) xdr_fnServerBtreeSearch_args,
	              (caddr_t)   argp,
	              (xdrproc_t) xdr_fnServerBtreeSearch_rets,
	              (caddr_t)   &res,
	              TIMEOUT) != RPC_SUCCESS) {
		return (NULL);
	}
	return (&res);
#endif
}


#ifdef MULTITHREAD
enum clnt_stat
#else
fnServerBtreeSearchByFloat_rets *
#endif
fnrpc_fnserverbtreesearchbyfloat_1
#ifdef MULTITHREAD
	(argp, clnt_res, clnt)
#else
	(argp, clnt)
#endif
	fnServerBtreeSearchByFloat_args *argp;
#ifdef MULTITHREAD
	fnServerBtreeSearchByFloat_rets *clnt_res;
#endif
	CLIENT *clnt;
{
#ifdef MULTITHREAD
	bzero((char *)clnt_res, sizeof(*clnt_res));
	return (clnt_call(clnt, fnRpc_fnServerBtreeSearchByFloat,
	                  (xdrproc_t) xdr_fnServerBtreeSearchByFloat_args,
	                  (caddr_t)   argp,
	                  (xdrproc_t) xdr_fnServerBtreeSearchByFloat_rets,
	                  (caddr_t)   clnt_res,
	                  TIMEOUT));
#else
	static fnServerBtreeSearchByFloat_rets res;

	bzero((char *)&res, sizeof(res));
	if (clnt_call(clnt, fnRpc_fnServerBtreeSearchByFloat,
	              (xdrproc_t) xdr_fnServerBtreeSearchByFloat_args,
	              (caddr_t)   argp,
	              (xdrproc_t) xdr_fnServerBtreeSearchByFloat_rets,
	              (caddr_t)   &res,
	              TIMEOUT) != RPC_SUCCESS) {
		return (NULL);
	}
	return (&res);
#endif
}


#ifdef MULTITHREAD
enum clnt_stat
#else
fnServerBtreeSearchByDouble_rets *
#endif
fnrpc_fnserverbtreesearchbydouble_1
#ifdef MULTITHREAD
	(argp, clnt_res, clnt)
#else
	(argp, clnt)
#endif
	fnServerBtreeSearchByDouble_args *argp;
#ifdef MULTITHREAD
	fnServerBtreeSearchByDouble_rets *clnt_res;
#endif
	CLIENT *clnt;
{
#ifdef MULTITHREAD
	bzero((char *)clnt_res, sizeof(*clnt_res));
	return (clnt_call(clnt, fnRpc_fnServerBtreeSearchByDouble,
	                  (xdrproc_t) xdr_fnServerBtreeSearchByDouble_args,
	                  (caddr_t)   argp,
	                  (xdrproc_t) xdr_fnServerBtreeSearchByDouble_rets,
	                  (caddr_t)   clnt_res,
	                  TIMEOUT));
#else
	static fnServerBtreeSearchByDouble_rets res;

	bzero((char *)&res, sizeof(res));
	if (clnt_call(clnt, fnRpc_fnServerBtreeSearchByDouble,
	              (xdrproc_t) xdr_fnServerBtreeSearchByDouble_args,
	              (caddr_t)   argp,
	              (xdrproc_t) xdr_fnServerBtreeSearchByDouble_rets,
	              (caddr_t)   &res,
	              TIMEOUT) != RPC_SUCCESS) {
		return (NULL);
	}
	return (&res);
#endif
}


#ifdef MULTITHREAD
enum clnt_stat
#else
fnServerBtreeSearchByString_rets *
#endif
fnrpc_fnserverbtreesearchbystring_1
#ifdef MULTITHREAD
	(argp, clnt_res, clnt)
#else
	(argp, clnt)
#endif
	fnServerBtreeSearchByString_args *argp;
#ifdef MULTITHREAD
	fnServerBtreeSearchByString_rets *clnt_res;
#endif
	CLIENT *clnt;
{
#ifdef MULTITHREAD
	bzero((char *)clnt_res, sizeof(*clnt_res));
	return (clnt_call(clnt, fnRpc_fnServerBtreeSearchByString,
	                  (xdrproc_t) xdr_fnServerBtreeSearchByString_args,
	                  (caddr_t)   argp,
	                  (xdrproc_t) xdr_fnServerBtreeSearchByString_rets,
	                  (caddr_t)   clnt_res,
	                  TIMEOUT));
#else
	static fnServerBtreeSearchByString_rets res;

	bzero((char *)&res, sizeof(res));
	if (clnt_call(clnt, fnRpc_fnServerBtreeSearchByString,
	              (xdrproc_t) xdr_fnServerBtreeSearchByString_args,
	              (caddr_t)   argp,
	              (xdrproc_t) xdr_fnServerBtreeSearchByString_rets,
	              (caddr_t)   &res,
	              TIMEOUT) != RPC_SUCCESS) {
		return (NULL);
	}
	return (&res);
#endif
}


#ifdef MULTITHREAD
enum clnt_stat
#else
fnClientBtreeRoot_rets *
#endif
fnrpc_fnclientbtreeroot_1
#ifdef MULTITHREAD
	(argp, clnt_res, clnt)
#else
	(argp, clnt)
#endif
	fnClientBtreeRoot_args *argp;
#ifdef MULTITHREAD
	fnClientBtreeRoot_rets *clnt_res;
#endif
	CLIENT *clnt;
{
#ifdef MULTITHREAD
	bzero((char *)clnt_res, sizeof(*clnt_res));
	return (clnt_call(clnt, fnRpc_fnClientBtreeRoot,
	                  (xdrproc_t) xdr_fnClientBtreeRoot_args,
	                  (caddr_t)   argp,
	                  (xdrproc_t) xdr_fnClientBtreeRoot_rets,
	                  (caddr_t)   clnt_res,
	                  TIMEOUT));
#else
	static fnClientBtreeRoot_rets res;

	bzero((char *)&res, sizeof(res));
	if (clnt_call(clnt, fnRpc_fnClientBtreeRoot,
	              (xdrproc_t) xdr_fnClientBtreeRoot_args,
	              (caddr_t)   argp,
	              (xdrproc_t) xdr_fnClientBtreeRoot_rets,
	              (caddr_t)   &res,
	              TIMEOUT) != RPC_SUCCESS) {
		return (NULL);
	}
	return (&res);
#endif
}


#ifdef MULTITHREAD
enum clnt_stat
#else
fnClientBtreeSize_rets *
#endif
fnrpc_fnclientbtreesize_1
#ifdef MULTITHREAD
	(argp, clnt_res, clnt)
#else
	(argp, clnt)
#endif
	fnClientBtreeSize_args *argp;
#ifdef MULTITHREAD
	fnClientBtreeSize_rets *clnt_res;
#endif
	CLIENT *clnt;
{
#ifdef MULTITHREAD
	bzero((char *)clnt_res, sizeof(*clnt_res));
	return (clnt_call(clnt, fnRpc_fnClientBtreeSize,
	                  (xdrproc_t) xdr_fnClientBtreeSize_args,
	                  (caddr_t)   argp,
	                  (xdrproc_t) xdr_fnClientBtreeSize_rets,
	                  (caddr_t)   clnt_res,
	                  TIMEOUT));
#else
	static fnClientBtreeSize_rets res;

	bzero((char *)&res, sizeof(res));
	if (clnt_call(clnt, fnRpc_fnClientBtreeSize,
	              (xdrproc_t) xdr_fnClientBtreeSize_args,
	              (caddr_t)   argp,
	              (xdrproc_t) xdr_fnClientBtreeSize_rets,
	              (caddr_t)   &res,
	              TIMEOUT) != RPC_SUCCESS) {
		return (NULL);
	}
	return (&res);
#endif
}


#ifdef MULTITHREAD
enum clnt_stat
#else
fnClientBtreeTestMode_rets *
#endif
fnrpc_fnclientbtreetestmode_1
#ifdef MULTITHREAD
	(argp, clnt_res, clnt)
#else
	(argp, clnt)
#endif
	fnClientBtreeTestMode_args *argp;
#ifdef MULTITHREAD
	fnClientBtreeTestMode_rets *clnt_res;
#endif
	CLIENT *clnt;
{
#ifdef MULTITHREAD
	bzero((char *)clnt_res, sizeof(*clnt_res));
	return (clnt_call(clnt, fnRpc_fnClientBtreeTestMode,
	                  (xdrproc_t) xdr_fnClientBtreeTestMode_args,
	                  (caddr_t)   argp,
	                  (xdrproc_t) xdr_fnClientBtreeTestMode_rets,
	                  (caddr_t)   clnt_res,
	                  TIMEOUT));
#else
	static fnClientBtreeTestMode_rets res;

	bzero((char *)&res, sizeof(res));
	if (clnt_call(clnt, fnRpc_fnClientBtreeTestMode,
	              (xdrproc_t) xdr_fnClientBtreeTestMode_args,
	              (caddr_t)   argp,
	              (xdrproc_t) xdr_fnClientBtreeTestMode_rets,
	              (caddr_t)   &res,
	              TIMEOUT) != RPC_SUCCESS) {
		return (NULL);
	}
	return (&res);
#endif
}


#ifdef MULTITHREAD
enum clnt_stat
#else
fnClientBtreePageSize_rets *
#endif
fnrpc_fnclientbtreepagesize_1
#ifdef MULTITHREAD
	(argp, clnt_res, clnt)
#else
	(argp, clnt)
#endif
	fnClientBtreePageSize_args *argp;
#ifdef MULTITHREAD
	fnClientBtreePageSize_rets *clnt_res;
#endif
	CLIENT *clnt;
{
#ifdef MULTITHREAD
	bzero((char *)clnt_res, sizeof(*clnt_res));
	return (clnt_call(clnt, fnRpc_fnClientBtreePageSize,
	                  (xdrproc_t) xdr_fnClientBtreePageSize_args,
	                  (caddr_t)   argp,
	                  (xdrproc_t) xdr_fnClientBtreePageSize_rets,
	                  (caddr_t)   clnt_res,
	                  TIMEOUT));
#else
	static fnClientBtreePageSize_rets res;

	bzero((char *)&res, sizeof(res));
	if (clnt_call(clnt, fnRpc_fnClientBtreePageSize,
	              (xdrproc_t) xdr_fnClientBtreePageSize_args,
	              (caddr_t)   argp,
	              (xdrproc_t) xdr_fnClientBtreePageSize_rets,
	              (caddr_t)   &res,
	              TIMEOUT) != RPC_SUCCESS) {
		return (NULL);
	}
	return (&res);
#endif
}


#ifdef MULTITHREAD
enum clnt_stat
#else
fnClientBtreepageParent_rets *
#endif
fnrpc_fnclientbtreepageparent_1
#ifdef MULTITHREAD
	(argp, clnt_res, clnt)
#else
	(argp, clnt)
#endif
	fnClientBtreepageParent_args *argp;
#ifdef MULTITHREAD
	fnClientBtreepageParent_rets *clnt_res;
#endif
	CLIENT *clnt;
{
#ifdef MULTITHREAD
	bzero((char *)clnt_res, sizeof(*clnt_res));
	return (clnt_call(clnt, fnRpc_fnClientBtreepageParent,
	                  (xdrproc_t) xdr_fnClientBtreepageParent_args,
	                  (caddr_t)   argp,
	                  (xdrproc_t) xdr_fnClientBtreepageParent_rets,
	                  (caddr_t)   clnt_res,
	                  TIMEOUT));
#else
	static fnClientBtreepageParent_rets res;

	bzero((char *)&res, sizeof(res));
	if (clnt_call(clnt, fnRpc_fnClientBtreepageParent,
	              (xdrproc_t) xdr_fnClientBtreepageParent_args,
	              (caddr_t)   argp,
	              (xdrproc_t) xdr_fnClientBtreepageParent_rets,
	              (caddr_t)   &res,
	              TIMEOUT) != RPC_SUCCESS) {
		return (NULL);
	}
	return (&res);
#endif
}


#ifdef MULTITHREAD
enum clnt_stat
#else
fnClientBtreepageCount_rets *
#endif
fnrpc_fnclientbtreepagecount_1
#ifdef MULTITHREAD
	(argp, clnt_res, clnt)
#else
	(argp, clnt)
#endif
	fnClientBtreepageCount_args *argp;
#ifdef MULTITHREAD
	fnClientBtreepageCount_rets *clnt_res;
#endif
	CLIENT *clnt;
{
#ifdef MULTITHREAD
	bzero((char *)clnt_res, sizeof(*clnt_res));
	return (clnt_call(clnt, fnRpc_fnClientBtreepageCount,
	                  (xdrproc_t) xdr_fnClientBtreepageCount_args,
	                  (caddr_t)   argp,
	                  (xdrproc_t) xdr_fnClientBtreepageCount_rets,
	                  (caddr_t)   clnt_res,
	                  TIMEOUT));
#else
	static fnClientBtreepageCount_rets res;

	bzero((char *)&res, sizeof(res));
	if (clnt_call(clnt, fnRpc_fnClientBtreepageCount,
	              (xdrproc_t) xdr_fnClientBtreepageCount_args,
	              (caddr_t)   argp,
	              (xdrproc_t) xdr_fnClientBtreepageCount_rets,
	              (caddr_t)   &res,
	              TIMEOUT) != RPC_SUCCESS) {
		return (NULL);
	}
	return (&res);
#endif
}


#ifdef MULTITHREAD
enum clnt_stat
#else
fnClientBtreepageGetSize_rets *
#endif
fnrpc_fnclientbtreepagegetsize_1
#ifdef MULTITHREAD
	(argp, clnt_res, clnt)
#else
	(argp, clnt)
#endif
	fnClientBtreepageGetSize_args *argp;
#ifdef MULTITHREAD
	fnClientBtreepageGetSize_rets *clnt_res;
#endif
	CLIENT *clnt;
{
#ifdef MULTITHREAD
	bzero((char *)clnt_res, sizeof(*clnt_res));
	return (clnt_call(clnt, fnRpc_fnClientBtreepageGetSize,
	                  (xdrproc_t) xdr_fnClientBtreepageGetSize_args,
	                  (caddr_t)   argp,
	                  (xdrproc_t) xdr_fnClientBtreepageGetSize_rets,
	                  (caddr_t)   clnt_res,
	                  TIMEOUT));
#else
	static fnClientBtreepageGetSize_rets res;

	bzero((char *)&res, sizeof(res));
	if (clnt_call(clnt, fnRpc_fnClientBtreepageGetSize,
	              (xdrproc_t) xdr_fnClientBtreepageGetSize_args,
	              (caddr_t)   argp,
	              (xdrproc_t) xdr_fnClientBtreepageGetSize_rets,
	              (caddr_t)   &res,
	              TIMEOUT) != RPC_SUCCESS) {
		return (NULL);
	}
	return (&res);
#endif
}


#ifdef MULTITHREAD
enum clnt_stat
#else
fnClientBtreepageItem_rets *
#endif
fnrpc_fnclientbtreepageitem_1
#ifdef MULTITHREAD
	(argp, clnt_res, clnt)
#else
	(argp, clnt)
#endif
	fnClientBtreepageItem_args *argp;
#ifdef MULTITHREAD
	fnClientBtreepageItem_rets *clnt_res;
#endif
	CLIENT *clnt;
{
#ifdef MULTITHREAD
	bzero((char *)clnt_res, sizeof(*clnt_res));
	return (clnt_call(clnt, fnRpc_fnClientBtreepageItem,
	                  (xdrproc_t) xdr_fnClientBtreepageItem_args,
	                  (caddr_t)   argp,
	                  (xdrproc_t) xdr_fnClientBtreepageItem_rets,
	                  (caddr_t)   clnt_res,
	                  TIMEOUT));
#else
	static fnClientBtreepageItem_rets res;

	bzero((char *)&res, sizeof(res));
	if (clnt_call(clnt, fnRpc_fnClientBtreepageItem,
	              (xdrproc_t) xdr_fnClientBtreepageItem_args,
	              (caddr_t)   argp,
	              (xdrproc_t) xdr_fnClientBtreepageItem_rets,
	              (caddr_t)   &res,
	              TIMEOUT) != RPC_SUCCESS) {
		return (NULL);
	}
	return (&res);
#endif
}

