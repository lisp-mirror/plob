#include <stdio.h>
#include <rpc/rpc.h>
#include "plobd.h"

/* ------------------------------------------------------------------------
| plobd.x generated by c2rpc on Tue Feb 13 10:40:22  2001
| c2rpc (C) 1996/09/19 Heiko Kirschke kirschke@informatik.uni-hamburg.de
 ----------------------------------------------------------------------- */

#if RPC_HDR
#include <rpc/rpc.h>
typedef CLIENT * PCLIENT;
#include <global.h>
#endif
#if RPC_CLNT || 1
#include <string.h>
#endif
#ifndef as_is
#define as_is void
#endif
#ifndef ABS
#define ABS(x) (((x)<0)?-(x):(x))
#endif
#ifndef MIN
#define MIN(x,y) (((x)<(y))?(x):(y))
#endif
#ifndef MAX
#define MAX(x,y) (((x)>(y))?(x):(y))
#endif
#ifndef PASTE
#define PASTE(token1,token2) token1##token2
#endif
#ifndef PASTE2
#define PASTE2(token1,token2) PASTE(token1,token2)
#endif
#ifndef EMPTY
#define EMPTY
#endif
#ifndef _SVCSUFFIX
#if LINUX
#define _SVCSUFFIX _svc
#else
#define _SVCSUFFIX EMPTY
#endif
#endif
#if !defined(DLLEXPORT)
#if WIN32
#if (BUILDDLL+0)
#define DLLEXPORT __attribute__(( dllexport )) __attribute__((__cdecl__))
#else
#define DLLEXPORT __attribute__(( dllimport )) __attribute__((__cdecl__))
#endif
#else
#define DLLEXPORT
#endif
#endif
#if !defined(DLLEXPORTVAR)
#if WIN32
#if (BUILDDLL+0)
#define DLLEXPORTVAR __attribute__(( dllexport ))
#else
#define DLLEXPORTVAR __attribute__(( dllimport ))
#endif
#else
#define DLLEXPORTVAR
#endif
#endif
#if WIN32
#define strdup _strdup
#endif


#if ! defined(AlignBitsToWords)
#define AlignBitsToWords( nSizeInBits ) (int ) ( ( (nSizeInBits) + nSizeOfPostoreWord * nBitsPerByte -1 ) / ( nSizeOfPostoreWord * nBitsPerByte ) )
#endif



extern DLLEXPORTVAR int __bInitializePlob__ ;
extern DLLEXPORTVAR int __bDeinitializePlob__ ;
void fnServerInitializePlob ( int argc,char * argv [] );
#if ! defined(INITIALIZEPLOB)
void fnInitializePlob ( void );
#define INITIALIZEPLOB ((__bInitializePlob__)? (fnInitializePlob(),TRUE):FALSE)
#endif

#if (1+0)

extern DLLEXPORTVAR int nGlobalStored;
extern DLLEXPORTVAR OBJID oGlobalSession;

#if !defined(UNSTORESESSION)
#define UNSTORESESSION() (__bJmpBufErrorValid__=FALSE,nGlobalStored=0,oGlobalSession=NULLOBJID)
#endif
#if !defined(UnstoreSession)
#define UnstoreSession() ((--nGlobalStored==0)?(UNSTORESESSION(),TRUE):FALSE)
#endif

extern DLLEXPORTVAR LPCSTR __lpszErrorMessage__;
extern DLLEXPORTVAR ERRLVL __nErrorLevel__;


#define RPC_SERVER_INITIALIZE(argc,argv) fnServerInitializePlob(argc,argv)


#define RPC_SERVER_ENTRY() { UNSTORESESSION (); __nErrorLevel__ = errLvl0; if ( __lpszErrorMessage__ != NULL ) { free ( (LPVOID) __lpszErrorMessage__ ); __lpszErrorMessage__ = (LPCSTR) NULL; } INITIALIZEPLOB;}
#define RPC_SERVER_ERRLVL() ((__bDeinitializePlob__)?0:__nErrorLevel__)
#define RPC_SERVER_ERRMSG() ((__bDeinitializePlob__)?(LPCSTR) NULL:__lpszErrorMessage__)

#include <rpc/rpc.h>
#include <rpc/svc.h>

void fnInitializeAfterRegister ( void );
static void fnSvcRun ( void )
{
 INITIALIZEPLOB;
 fnInitializeAfterRegister ();
 svc_run();
}

#ifdef svc_run
#undef svc_run
#endif
#define svc_run fnSvcRun

#endif

#if (RPC_CLNT+0)

#define RPC_CLIENT_INITIALIZE() INITIALIZEPLOB

extern PCLIENT fnClientCreate ( LPCSTR pszHost,
 LPCSTR pszTransport );
#define RPC_CLIENT_CREATE(host,transport) fnClientCreate ( host,transport )

extern PCLIENT fnClientDestroy ( PCLIENT pClient );
#define RPC_CLIENT_DESTROY(pclient) fnClientDestroy ( pclient )

#define RPC_CLIENT_ERROR(msg) ((__bDeinitializePlob__)? FALSE: (fnLISPerrorCallback(errLvlError,NULL,msg),TRUE))
#define RPC_CLIENT_CERROR(cont,msg) ((__bDeinitializePlob__)? FALSE: (fnLISPerrorCallback(errLvlCError,cont,msg),TRUE))
#define RPC_CLIENT_SERROR(lvl,proc,msg) ((__bDeinitializePlob__)? FALSE: (fnLISPserrorCallback(lvl,proc,msg),TRUE))

#endif

#if (1+0)||(RPC_CLNT+0)

#define xdr_fnServerObjectReadValues_rets xdr_fnPatchedServerObjectReadValues_rets
#define xdr_fnServerObjectWriteValues_args xdr_fnPatchedServerObjectWriteValues_args
#define xdr_fnServerObjectPeekValues_rets xdr_fnPatchedServerObjectPeekValues_rets
#define xdr_fnServerObjectPoke_args xdr_fnPatchedServerObjectPoke_args
#include "plobpxdr.h"

#endif



#define	SIZEOF(type)((sizeof(type)<1)?1:sizeof(type))

static RPCVERSION __Version__ = 1;

RPCVERSION DLLEXPORT	fnPlobdGetVersion	( void )
{
  return __Version__;
} /* fnPlobdGetVersion */

RPCVERSION DLLEXPORT	fnPlobdSetVersion	( RPCVERSION	lVersionNew )
{
  RPCVERSION	lVersionOld	= __Version__;
  __Version__	= lVersionNew;
  return lVersionOld;
} /* fnPlobdSetVersion */

static const RPCPORT __PortOffset__ = 0x20506E62;
static RPCPORT __Port__ = 0;

RPCPORT DLLEXPORT	fnPlobdGetPortOffset	( void )
{
  return __PortOffset__;
} /* fnPlobdGetPortOffset */

RPCPORT DLLEXPORT	fnPlobdGetPort	( void )
{
  return __Port__;
} /* fnPlobdGetPort */

RPCPORT DLLEXPORT	fnPlobdSetPort	( RPCPORT	lPortNew )
{
  RPCPORT	lPortOld	= __Port__;
  __Port__	= lPortNew;
  return lPortOld;
} /* fnPlobdSetPort */

#ifdef PLOBD
#undef PLOBD
#endif /* PLOBD */
#define PLOBD	((u_long)fnPlobdGetPortOffset()+(u_long)fnPlobdGetPort())

#ifdef PLOBDVERS
#undef PLOBDVERS
#endif /* PLOBDVERS */
#define PLOBDVERS	((u_long)fnPlobdGetVersion())

 /* static char		szEmpty []	= ""; */


#include	<stdlib.h>
#include	<rpc/svc.h>
#if WIN32
#include	<rpc/pmap_cln.h>
#else
#include	<rpc/pmap_clnt.h>
#endif

static struct svc_req	* __pRequest__	= NULL;

static struct {
  bool_t	bAnswered;
  void		(*pfnCalled)();
  int		*pnErrorLvl;
  LPCSTR	*ppszErrorMsg;
  void		*pResult;
  void		*pReturnValue;
  size_t	nReturnValueSize;
  bool_t	(*pfnXdrResult)();
}	Reply;

static const char	szFormatMallocFailed []	=
"%s: Allocating a result buffer of size %d for argument %s failed.";

#ifndef	RPC_SERVER_INITIALIZE
#define	RPC_SERVER_INITIALIZE(argc,argv)
#endif	/* ! RPC_SERVER_INITIALIZE */

#ifndef	RPC_SERVER_ERROR
#define	RPC_SERVER_ERROR(msg)(fprintf(stderr,"Error: %s\n",msg),exit(1),0)
#endif	/* ! RPC_SERVER_ERROR */

#ifndef	RPC_SERVER_CERROR
#define	RPC_SERVER_CERROR(cont,msg)(fprintf(stderr,"Continuable error: %s\n%s\n",msg,cont),fflush(stdin),fgetc(stdin),0)
#endif	/* ! RPC_SERVER_CERROR */

#ifndef	RPC_SERVER_ERRLVL
#define	RPC_SERVER_ERRLVL()	0
#endif	/* ! RPC_SERVER_ERRLVL */

#ifndef	RPC_SERVER_ERRMSG
#define	RPC_SERVER_ERRMSG()	NULL
#endif	/* ! RPC_SERVER_ERRMSG */

#ifndef	RPC_SERVER_ENTRY
#define	RPC_SERVER_ENTRY()
#endif	/* ! RPC_SERVER_ENTRY */



extern struct svc_req *	fnServerPlobdRequest	( void )
{
  return __pRequest__;
} /* fnServerPlobdRequest */

extern struct svc_req *	fnServerPlobdReply
	( void (*pfnCalled)(), void * pReturnValue )
{
  struct svc_req	*pRequest = (struct svc_req *) NULL;
  LPCSTR		pszErrorMsg;

  if ( ! Reply.bAnswered && pfnCalled == Reply.pfnCalled ) {
    Reply.bAnswered	= TRUE;
    if ( Reply.pReturnValue != NULL ) {
      if ( pReturnValue ) {
        memcpy ( Reply.pReturnValue, pReturnValue, Reply.nReturnValueSize );
      } else {
        memset ( Reply.pReturnValue, 0, Reply.nReturnValueSize );
      }
    }
    if ( Reply.pnErrorLvl ) {
      *Reply.pnErrorLvl	= RPC_SERVER_ERRLVL();
      if ( *Reply.pnErrorLvl && Reply.ppszErrorMsg != NULL ) {
        pszErrorMsg	= RPC_SERVER_ERRMSG();
        if ( pszErrorMsg && *pszErrorMsg ) {
          *Reply.ppszErrorMsg	= strdup ( pszErrorMsg );
        }
      }
    }
    if ( Reply.ppszErrorMsg != NULL &&
         *Reply.ppszErrorMsg == NULL ) {
      *Reply.ppszErrorMsg	= szEmpty;
    }
    pRequest	= fnServerPlobdRequest ();
    if ( ! svc_sendreply ( pRequest->rq_xprt,
                           (xdrproc_t) Reply.pfnXdrResult,
                           (caddr_t) Reply.pResult ) ) {
      svcerr_systemerr ( pRequest->rq_xprt );
    }
  }
  return pRequest;
} /* fnServerPlobdReply */




extern SHORTOBJID fnClientDbReadRoot
	(SHORTOBJID oShortObjIdHeap);

#ifdef MULTITHREAD
bool_t
#else
fnClientDbReadRoot_rets *
#endif
	PASTE2(fnrpc_fnclientdbreadroot_1,_SVCSUFFIX)
		( SHORTOBJID * pArguments,
#ifdef MULTITHREAD
		  fnClientDbReadRoot_rets * pResult,
#endif
		  struct svc_req * pRequest )
{
  static const char	__procedure__[]	= "server:fnrpc_fnclientdbreadroot_1";
#ifdef MULTITHREAD
  typedef bool_t RESULTTYPE;
#else
  typedef fnClientDbReadRoot_rets * RESULTTYPE;
#endif
#ifndef MULTITHREAD
  static fnClientDbReadRoot_rets	Result;
  RESULTTYPE			pResult = &Result;
#endif
  LPCSTR	pszErrorMsg;

  __pRequest__	= pRequest;

  RPC_SERVER_ENTRY();

#ifndef MULTITHREAD
  if ( pResult->pszErrorMsg == szEmpty ) {
    pResult->pszErrorMsg	= NULL;
  }
  xdr_free ( (xdrproc_t) xdr_fnClientDbReadRoot_rets, (char *) pResult );
#endif
  pResult->nErrorLvl		= 0;

  Reply.bAnswered		= FALSE;
  Reply.pfnCalled		= (void(*)()) fnClientDbReadRoot;
  Reply.pfnXdrResult		= (bool_t(*)()) xdr_fnClientDbReadRoot_rets;
  Reply.pnErrorLvl		= &pResult->nErrorLvl;
  Reply.ppszErrorMsg		= (LPCSTR *) &pResult->pszErrorMsg;
  Reply.pResult		= pResult;
  Reply.pReturnValue		= &pResult->ReturnValue;
  Reply.nReturnValueSize	= sizeof ( pResult->ReturnValue );

  pResult->ReturnValue		=
  fnClientDbReadRoot (
	(*pArguments) );

  if ( Reply.bAnswered ) {
    __pRequest__	= NULL;
    return (RESULTTYPE) NULL;
  }

  pResult->nErrorLvl	= RPC_SERVER_ERRLVL();
  if ( pResult->nErrorLvl > 0 ) {
    pszErrorMsg		= RPC_SERVER_ERRMSG();
    if ( pszErrorMsg && *pszErrorMsg ) {
      pResult->pszErrorMsg	= strdup ( pszErrorMsg );
    }
  }
  if ( pResult->pszErrorMsg == NULL ) {
#ifdef MULTITHREAD
    pResult->pszErrorMsg	= strdup ( szEmpty );
#else
    pResult->pszErrorMsg	= (LPSTR) szEmpty;
#endif
  }
  __pRequest__	= NULL;
  return (RESULTTYPE) pResult;
} /* fnrpc_fnclientdbreadroot_1 */




extern SHORTOBJID fnServerDbWriteRoot
	(SHORTOBJID oShortObjIdHeap ,
	  SHORTOBJID oShortObjId);

#ifdef MULTITHREAD
bool_t
#else
fnServerDbWriteRoot_rets *
#endif
	PASTE2(fnrpc_fnserverdbwriteroot_1,_SVCSUFFIX)
		( fnServerDbWriteRoot_args * pArguments,
#ifdef MULTITHREAD
		  fnServerDbWriteRoot_rets * pResult,
#endif
		  struct svc_req * pRequest )
{
  static const char	__procedure__[]	= "server:fnrpc_fnserverdbwriteroot_1";
#ifdef MULTITHREAD
  typedef bool_t RESULTTYPE;
#else
  typedef fnServerDbWriteRoot_rets * RESULTTYPE;
#endif
#ifndef MULTITHREAD
  static fnServerDbWriteRoot_rets	Result;
  RESULTTYPE			pResult = &Result;
#endif
  LPCSTR	pszErrorMsg;

  __pRequest__	= pRequest;

  RPC_SERVER_ENTRY();

#ifndef MULTITHREAD
  if ( pResult->pszErrorMsg == szEmpty ) {
    pResult->pszErrorMsg	= NULL;
  }
  xdr_free ( (xdrproc_t) xdr_fnServerDbWriteRoot_rets, (char *) pResult );
#endif
  pResult->nErrorLvl		= 0;

  Reply.bAnswered		= FALSE;
  Reply.pfnCalled		= (void(*)()) fnServerDbWriteRoot;
  Reply.pfnXdrResult		= (bool_t(*)()) xdr_fnServerDbWriteRoot_rets;
  Reply.pnErrorLvl		= &pResult->nErrorLvl;
  Reply.ppszErrorMsg		= (LPCSTR *) &pResult->pszErrorMsg;
  Reply.pResult		= pResult;
  Reply.pReturnValue		= &pResult->ReturnValue;
  Reply.nReturnValueSize	= sizeof ( pResult->ReturnValue );

  pResult->ReturnValue		=
  fnServerDbWriteRoot (
	pArguments->oShortObjIdHeap,
	pArguments->oShortObjId );

  if ( Reply.bAnswered ) {
    __pRequest__	= NULL;
    return (RESULTTYPE) NULL;
  }

  pResult->nErrorLvl	= RPC_SERVER_ERRLVL();
  if ( pResult->nErrorLvl > 0 ) {
    pszErrorMsg		= RPC_SERVER_ERRMSG();
    if ( pszErrorMsg && *pszErrorMsg ) {
      pResult->pszErrorMsg	= strdup ( pszErrorMsg );
    }
  }
  if ( pResult->pszErrorMsg == NULL ) {
#ifdef MULTITHREAD
    pResult->pszErrorMsg	= strdup ( szEmpty );
#else
    pResult->pszErrorMsg	= (LPSTR) szEmpty;
#endif
  }
  __pRequest__	= NULL;
  return (RESULTTYPE) pResult;
} /* fnrpc_fnserverdbwriteroot_1 */




extern SHORTOBJID fnClientDbSessions
	(SHORTOBJID oShortObjIdHeap);

#ifdef MULTITHREAD
bool_t
#else
fnClientDbSessions_rets *
#endif
	PASTE2(fnrpc_fnclientdbsessions_1,_SVCSUFFIX)
		( SHORTOBJID * pArguments,
#ifdef MULTITHREAD
		  fnClientDbSessions_rets * pResult,
#endif
		  struct svc_req * pRequest )
{
  static const char	__procedure__[]	= "server:fnrpc_fnclientdbsessions_1";
#ifdef MULTITHREAD
  typedef bool_t RESULTTYPE;
#else
  typedef fnClientDbSessions_rets * RESULTTYPE;
#endif
#ifndef MULTITHREAD
  static fnClientDbSessions_rets	Result;
  RESULTTYPE			pResult = &Result;
#endif
  LPCSTR	pszErrorMsg;

  __pRequest__	= pRequest;

  RPC_SERVER_ENTRY();

#ifndef MULTITHREAD
  if ( pResult->pszErrorMsg == szEmpty ) {
    pResult->pszErrorMsg	= NULL;
  }
  xdr_free ( (xdrproc_t) xdr_fnClientDbSessions_rets, (char *) pResult );
#endif
  pResult->nErrorLvl		= 0;

  Reply.bAnswered		= FALSE;
  Reply.pfnCalled		= (void(*)()) fnClientDbSessions;
  Reply.pfnXdrResult		= (bool_t(*)()) xdr_fnClientDbSessions_rets;
  Reply.pnErrorLvl		= &pResult->nErrorLvl;
  Reply.ppszErrorMsg		= (LPCSTR *) &pResult->pszErrorMsg;
  Reply.pResult		= pResult;
  Reply.pReturnValue		= &pResult->ReturnValue;
  Reply.nReturnValueSize	= sizeof ( pResult->ReturnValue );

  pResult->ReturnValue		=
  fnClientDbSessions (
	(*pArguments) );

  if ( Reply.bAnswered ) {
    __pRequest__	= NULL;
    return (RESULTTYPE) NULL;
  }

  pResult->nErrorLvl	= RPC_SERVER_ERRLVL();
  if ( pResult->nErrorLvl > 0 ) {
    pszErrorMsg		= RPC_SERVER_ERRMSG();
    if ( pszErrorMsg && *pszErrorMsg ) {
      pResult->pszErrorMsg	= strdup ( pszErrorMsg );
    }
  }
  if ( pResult->pszErrorMsg == NULL ) {
#ifdef MULTITHREAD
    pResult->pszErrorMsg	= strdup ( szEmpty );
#else
    pResult->pszErrorMsg	= (LPSTR) szEmpty;
#endif
  }
  __pRequest__	= NULL;
  return (RESULTTYPE) pResult;
} /* fnrpc_fnclientdbsessions_1 */




extern int fnServerGetVersion
	(SHORTOBJID oShortObjIdHeap ,
	  GETVERSION eWhat);

#ifdef MULTITHREAD
bool_t
#else
fnServerGetVersion_rets *
#endif
	PASTE2(fnrpc_fnservergetversion_1,_SVCSUFFIX)
		( fnServerGetVersion_args * pArguments,
#ifdef MULTITHREAD
		  fnServerGetVersion_rets * pResult,
#endif
		  struct svc_req * pRequest )
{
  static const char	__procedure__[]	= "server:fnrpc_fnservergetversion_1";
#ifdef MULTITHREAD
  typedef bool_t RESULTTYPE;
#else
  typedef fnServerGetVersion_rets * RESULTTYPE;
#endif
#ifndef MULTITHREAD
  static fnServerGetVersion_rets	Result;
  RESULTTYPE			pResult = &Result;
#endif
  LPCSTR	pszErrorMsg;

  __pRequest__	= pRequest;

  RPC_SERVER_ENTRY();

#ifndef MULTITHREAD
  if ( pResult->pszErrorMsg == szEmpty ) {
    pResult->pszErrorMsg	= NULL;
  }
  xdr_free ( (xdrproc_t) xdr_fnServerGetVersion_rets, (char *) pResult );
#endif
  pResult->nErrorLvl		= 0;

  Reply.bAnswered		= FALSE;
  Reply.pfnCalled		= (void(*)()) fnServerGetVersion;
  Reply.pfnXdrResult		= (bool_t(*)()) xdr_fnServerGetVersion_rets;
  Reply.pnErrorLvl		= &pResult->nErrorLvl;
  Reply.ppszErrorMsg		= (LPCSTR *) &pResult->pszErrorMsg;
  Reply.pResult		= pResult;
  Reply.pReturnValue		= &pResult->ReturnValue;
  Reply.nReturnValueSize	= sizeof ( pResult->ReturnValue );

  pResult->ReturnValue		=
  fnServerGetVersion (
	pArguments->oShortObjIdHeap,
	pArguments->eWhat );

  if ( Reply.bAnswered ) {
    __pRequest__	= NULL;
    return (RESULTTYPE) NULL;
  }

  pResult->nErrorLvl	= RPC_SERVER_ERRLVL();
  if ( pResult->nErrorLvl > 0 ) {
    pszErrorMsg		= RPC_SERVER_ERRMSG();
    if ( pszErrorMsg && *pszErrorMsg ) {
      pResult->pszErrorMsg	= strdup ( pszErrorMsg );
    }
  }
  if ( pResult->pszErrorMsg == NULL ) {
#ifdef MULTITHREAD
    pResult->pszErrorMsg	= strdup ( szEmpty );
#else
    pResult->pszErrorMsg	= (LPSTR) szEmpty;
#endif
  }
  __pRequest__	= NULL;
  return (RESULTTYPE) pResult;
} /* fnrpc_fnservergetversion_1 */




extern SHORTOBJID fnClientDbCreateMachine
	(SHORTOBJID oShortObjIdHeap ,
	  int * /* _vector_t<4> */ nAddr ,
	  MACHLOGINP eLoginP);

#ifdef MULTITHREAD
bool_t
#else
fnClientDbCreateMachine_rets *
#endif
	PASTE2(fnrpc_fnclientdbcreatemachine_1,_SVCSUFFIX)
		( fnClientDbCreateMachine_args * pArguments,
#ifdef MULTITHREAD
		  fnClientDbCreateMachine_rets * pResult,
#endif
		  struct svc_req * pRequest )
{
  static const char	__procedure__[]	= "server:fnrpc_fnclientdbcreatemachine_1";
#ifdef MULTITHREAD
  typedef bool_t RESULTTYPE;
#else
  typedef fnClientDbCreateMachine_rets * RESULTTYPE;
#endif
#ifndef MULTITHREAD
  static fnClientDbCreateMachine_rets	Result;
  RESULTTYPE			pResult = &Result;
#endif
  LPCSTR	pszErrorMsg;

  __pRequest__	= pRequest;

  RPC_SERVER_ENTRY();

#ifndef MULTITHREAD
  if ( pResult->pszErrorMsg == szEmpty ) {
    pResult->pszErrorMsg	= NULL;
  }
  xdr_free ( (xdrproc_t) xdr_fnClientDbCreateMachine_rets, (char *) pResult );
#endif
  pResult->nErrorLvl		= 0;

  Reply.bAnswered		= FALSE;
  Reply.pfnCalled		= (void(*)()) fnClientDbCreateMachine;
  Reply.pfnXdrResult		= (bool_t(*)()) xdr_fnClientDbCreateMachine_rets;
  Reply.pnErrorLvl		= &pResult->nErrorLvl;
  Reply.ppszErrorMsg		= (LPCSTR *) &pResult->pszErrorMsg;
  Reply.pResult		= pResult;
  Reply.pReturnValue		= &pResult->ReturnValue;
  Reply.nReturnValueSize	= sizeof ( pResult->ReturnValue );

  pResult->ReturnValue		=
  fnClientDbCreateMachine (
	pArguments->oShortObjIdHeap,
	pArguments->nAddr.int_vector_t_val,
	pArguments->eLoginP );

  if ( Reply.bAnswered ) {
    __pRequest__	= NULL;
    return (RESULTTYPE) NULL;
  }

  pResult->nErrorLvl	= RPC_SERVER_ERRLVL();
  if ( pResult->nErrorLvl > 0 ) {
    pszErrorMsg		= RPC_SERVER_ERRMSG();
    if ( pszErrorMsg && *pszErrorMsg ) {
      pResult->pszErrorMsg	= strdup ( pszErrorMsg );
    }
  }
  if ( pResult->pszErrorMsg == NULL ) {
#ifdef MULTITHREAD
    pResult->pszErrorMsg	= strdup ( szEmpty );
#else
    pResult->pszErrorMsg	= (LPSTR) szEmpty;
#endif
  }
  __pRequest__	= NULL;
  return (RESULTTYPE) pResult;
} /* fnrpc_fnclientdbcreatemachine_1 */




extern MACHLOGINP fnClientMachineLoginP
	(SHORTOBJID oShortObjIdHeap ,
	  SHORTOBJID oShortMachine ,
	  MACHLOGINP eLoginP);

#ifdef MULTITHREAD
bool_t
#else
fnClientMachineLoginP_rets *
#endif
	PASTE2(fnrpc_fnclientmachineloginp_1,_SVCSUFFIX)
		( fnClientMachineLoginP_args * pArguments,
#ifdef MULTITHREAD
		  fnClientMachineLoginP_rets * pResult,
#endif
		  struct svc_req * pRequest )
{
  static const char	__procedure__[]	= "server:fnrpc_fnclientmachineloginp_1";
#ifdef MULTITHREAD
  typedef bool_t RESULTTYPE;
#else
  typedef fnClientMachineLoginP_rets * RESULTTYPE;
#endif
#ifndef MULTITHREAD
  static fnClientMachineLoginP_rets	Result;
  RESULTTYPE			pResult = &Result;
#endif
  LPCSTR	pszErrorMsg;

  __pRequest__	= pRequest;

  RPC_SERVER_ENTRY();

#ifndef MULTITHREAD
  if ( pResult->pszErrorMsg == szEmpty ) {
    pResult->pszErrorMsg	= NULL;
  }
  xdr_free ( (xdrproc_t) xdr_fnClientMachineLoginP_rets, (char *) pResult );
#endif
  pResult->nErrorLvl		= 0;

  Reply.bAnswered		= FALSE;
  Reply.pfnCalled		= (void(*)()) fnClientMachineLoginP;
  Reply.pfnXdrResult		= (bool_t(*)()) xdr_fnClientMachineLoginP_rets;
  Reply.pnErrorLvl		= &pResult->nErrorLvl;
  Reply.ppszErrorMsg		= (LPCSTR *) &pResult->pszErrorMsg;
  Reply.pResult		= pResult;
  Reply.pReturnValue		= &pResult->ReturnValue;
  Reply.nReturnValueSize	= sizeof ( pResult->ReturnValue );

  pResult->ReturnValue		=
  fnClientMachineLoginP (
	pArguments->oShortObjIdHeap,
	pArguments->oShortMachine,
	pArguments->eLoginP );

  if ( Reply.bAnswered ) {
    __pRequest__	= NULL;
    return (RESULTTYPE) NULL;
  }

  pResult->nErrorLvl	= RPC_SERVER_ERRLVL();
  if ( pResult->nErrorLvl > 0 ) {
    pszErrorMsg		= RPC_SERVER_ERRMSG();
    if ( pszErrorMsg && *pszErrorMsg ) {
      pResult->pszErrorMsg	= strdup ( pszErrorMsg );
    }
  }
  if ( pResult->pszErrorMsg == NULL ) {
#ifdef MULTITHREAD
    pResult->pszErrorMsg	= strdup ( szEmpty );
#else
    pResult->pszErrorMsg	= (LPSTR) szEmpty;
#endif
  }
  __pRequest__	= NULL;
  return (RESULTTYPE) pResult;
} /* fnrpc_fnclientmachineloginp_1 */




extern bool_t fnClientMachineAddr
	(SHORTOBJID oShortObjIdHeap ,
	  SHORTOBJID oShortMachine ,
	  int * /* _vector_t<4> */  pnAddr);

#ifdef MULTITHREAD
bool_t
#else
fnClientMachineAddr_rets *
#endif
	PASTE2(fnrpc_fnclientmachineaddr_1,_SVCSUFFIX)
		( fnClientMachineAddr_args * pArguments,
#ifdef MULTITHREAD
		  fnClientMachineAddr_rets * pResult,
#endif
		  struct svc_req * pRequest )
{
  static const char	__procedure__[]	= "server:fnrpc_fnclientmachineaddr_1";
#ifdef MULTITHREAD
  typedef bool_t RESULTTYPE;
#else
  typedef fnClientMachineAddr_rets * RESULTTYPE;
#endif
#ifndef MULTITHREAD
  static fnClientMachineAddr_rets	Result;
  RESULTTYPE			pResult = &Result;
#endif
  LPCSTR	pszErrorMsg;

  __pRequest__	= pRequest;

  RPC_SERVER_ENTRY();

#ifndef MULTITHREAD
  if ( pResult->pszErrorMsg == szEmpty ) {
    pResult->pszErrorMsg	= NULL;
  }
  xdr_free ( (xdrproc_t) xdr_fnClientMachineAddr_rets, (char *) pResult );
#endif
  pResult->nErrorLvl		= 0;

  pResult->pnAddr.int_vector_t_len	= pArguments->pnAddrSize;
  if ( pArguments->pnAddrSize == 0 ) {
    pResult->pnAddr.int_vector_t_val	= NULL;
  } else {
    pResult->pnAddr.int_vector_t_val	=
      (int*) malloc ( pArguments->pnAddrSize *
               SIZEOF ( *(pResult->pnAddr.int_vector_t_val) ) );
    if ( pResult->pnAddr.int_vector_t_val == NULL ) {
      char	szError [ 256 ];
      sprintf ( szError, szFormatMallocFailed,
                __procedure__, pArguments->pnAddrSize,
                "pnAddr" );
      RPC_SERVER_ERROR ( szError );
      return (RESULTTYPE) NULL;
    }
  }
  Reply.bAnswered		= FALSE;
  Reply.pfnCalled		= (void(*)()) fnClientMachineAddr;
  Reply.pfnXdrResult		= (bool_t(*)()) xdr_fnClientMachineAddr_rets;
  Reply.pnErrorLvl		= &pResult->nErrorLvl;
  Reply.ppszErrorMsg		= (LPCSTR *) &pResult->pszErrorMsg;
  Reply.pResult		= pResult;
  Reply.pReturnValue		= &pResult->ReturnValue;
  Reply.nReturnValueSize	= sizeof ( pResult->ReturnValue );

  pResult->ReturnValue		=
  fnClientMachineAddr (
	pArguments->oShortObjIdHeap,
	pArguments->oShortMachine,
	pResult->pnAddr.int_vector_t_val );

  if ( Reply.bAnswered ) {
    __pRequest__	= NULL;
    return (RESULTTYPE) NULL;
  }

  pResult->nErrorLvl	= RPC_SERVER_ERRLVL();
  if ( pResult->nErrorLvl > 0 ) {
    pszErrorMsg		= RPC_SERVER_ERRMSG();
    if ( pszErrorMsg && *pszErrorMsg ) {
      pResult->pszErrorMsg	= strdup ( pszErrorMsg );
    }
  }
  if ( pResult->pszErrorMsg == NULL ) {
#ifdef MULTITHREAD
    pResult->pszErrorMsg	= strdup ( szEmpty );
#else
    pResult->pszErrorMsg	= (LPSTR) szEmpty;
#endif
  }
  __pRequest__	= NULL;
  return (RESULTTYPE) pResult;
} /* fnrpc_fnclientmachineaddr_1 */




extern SHORTOBJID fnClientDbMachineSearch
	(SHORTOBJID oShortObjIdHeap ,
	  int * /* _vector_t<4> */ nAddr);

#ifdef MULTITHREAD
bool_t
#else
fnClientDbMachineSearch_rets *
#endif
	PASTE2(fnrpc_fnclientdbmachinesearch_1,_SVCSUFFIX)
		( fnClientDbMachineSearch_args * pArguments,
#ifdef MULTITHREAD
		  fnClientDbMachineSearch_rets * pResult,
#endif
		  struct svc_req * pRequest )
{
  static const char	__procedure__[]	= "server:fnrpc_fnclientdbmachinesearch_1";
#ifdef MULTITHREAD
  typedef bool_t RESULTTYPE;
#else
  typedef fnClientDbMachineSearch_rets * RESULTTYPE;
#endif
#ifndef MULTITHREAD
  static fnClientDbMachineSearch_rets	Result;
  RESULTTYPE			pResult = &Result;
#endif
  LPCSTR	pszErrorMsg;

  __pRequest__	= pRequest;

  RPC_SERVER_ENTRY();

#ifndef MULTITHREAD
  if ( pResult->pszErrorMsg == szEmpty ) {
    pResult->pszErrorMsg	= NULL;
  }
  xdr_free ( (xdrproc_t) xdr_fnClientDbMachineSearch_rets, (char *) pResult );
#endif
  pResult->nErrorLvl		= 0;

  Reply.bAnswered		= FALSE;
  Reply.pfnCalled		= (void(*)()) fnClientDbMachineSearch;
  Reply.pfnXdrResult		= (bool_t(*)()) xdr_fnClientDbMachineSearch_rets;
  Reply.pnErrorLvl		= &pResult->nErrorLvl;
  Reply.ppszErrorMsg		= (LPCSTR *) &pResult->pszErrorMsg;
  Reply.pResult		= pResult;
  Reply.pReturnValue		= &pResult->ReturnValue;
  Reply.nReturnValueSize	= sizeof ( pResult->ReturnValue );

  pResult->ReturnValue		=
  fnClientDbMachineSearch (
	pArguments->oShortObjIdHeap,
	pArguments->nAddr.int_vector_t_val );

  if ( Reply.bAnswered ) {
    __pRequest__	= NULL;
    return (RESULTTYPE) NULL;
  }

  pResult->nErrorLvl	= RPC_SERVER_ERRLVL();
  if ( pResult->nErrorLvl > 0 ) {
    pszErrorMsg		= RPC_SERVER_ERRMSG();
    if ( pszErrorMsg && *pszErrorMsg ) {
      pResult->pszErrorMsg	= strdup ( pszErrorMsg );
    }
  }
  if ( pResult->pszErrorMsg == NULL ) {
#ifdef MULTITHREAD
    pResult->pszErrorMsg	= strdup ( szEmpty );
#else
    pResult->pszErrorMsg	= (LPSTR) szEmpty;
#endif
  }
  __pRequest__	= NULL;
  return (RESULTTYPE) pResult;
} /* fnrpc_fnclientdbmachinesearch_1 */




extern SHORTOBJID fnClientDbMachineDelete
	(SHORTOBJID oShortObjIdHeap ,
	  int * /* _vector_t<4> */ nAddr);

#ifdef MULTITHREAD
bool_t
#else
fnClientDbMachineDelete_rets *
#endif
	PASTE2(fnrpc_fnclientdbmachinedelete_1,_SVCSUFFIX)
		( fnClientDbMachineDelete_args * pArguments,
#ifdef MULTITHREAD
		  fnClientDbMachineDelete_rets * pResult,
#endif
		  struct svc_req * pRequest )
{
  static const char	__procedure__[]	= "server:fnrpc_fnclientdbmachinedelete_1";
#ifdef MULTITHREAD
  typedef bool_t RESULTTYPE;
#else
  typedef fnClientDbMachineDelete_rets * RESULTTYPE;
#endif
#ifndef MULTITHREAD
  static fnClientDbMachineDelete_rets	Result;
  RESULTTYPE			pResult = &Result;
#endif
  LPCSTR	pszErrorMsg;

  __pRequest__	= pRequest;

  RPC_SERVER_ENTRY();

#ifndef MULTITHREAD
  if ( pResult->pszErrorMsg == szEmpty ) {
    pResult->pszErrorMsg	= NULL;
  }
  xdr_free ( (xdrproc_t) xdr_fnClientDbMachineDelete_rets, (char *) pResult );
#endif
  pResult->nErrorLvl		= 0;

  Reply.bAnswered		= FALSE;
  Reply.pfnCalled		= (void(*)()) fnClientDbMachineDelete;
  Reply.pfnXdrResult		= (bool_t(*)()) xdr_fnClientDbMachineDelete_rets;
  Reply.pnErrorLvl		= &pResult->nErrorLvl;
  Reply.ppszErrorMsg		= (LPCSTR *) &pResult->pszErrorMsg;
  Reply.pResult		= pResult;
  Reply.pReturnValue		= &pResult->ReturnValue;
  Reply.nReturnValueSize	= sizeof ( pResult->ReturnValue );

  pResult->ReturnValue		=
  fnClientDbMachineDelete (
	pArguments->oShortObjIdHeap,
	pArguments->nAddr.int_vector_t_val );

  if ( Reply.bAnswered ) {
    __pRequest__	= NULL;
    return (RESULTTYPE) NULL;
  }

  pResult->nErrorLvl	= RPC_SERVER_ERRLVL();
  if ( pResult->nErrorLvl > 0 ) {
    pszErrorMsg		= RPC_SERVER_ERRMSG();
    if ( pszErrorMsg && *pszErrorMsg ) {
      pResult->pszErrorMsg	= strdup ( pszErrorMsg );
    }
  }
  if ( pResult->pszErrorMsg == NULL ) {
#ifdef MULTITHREAD
    pResult->pszErrorMsg	= strdup ( szEmpty );
#else
    pResult->pszErrorMsg	= (LPSTR) szEmpty;
#endif
  }
  __pRequest__	= NULL;
  return (RESULTTYPE) pResult;
} /* fnrpc_fnclientdbmachinedelete_1 */




extern SHORTOBJID fnClientDbMachineInsert
	(SHORTOBJID oShortObjIdHeap ,
	  SHORTOBJID oShortMachine);

#ifdef MULTITHREAD
bool_t
#else
fnClientDbMachineInsert_rets *
#endif
	PASTE2(fnrpc_fnclientdbmachineinsert_1,_SVCSUFFIX)
		( fnClientDbMachineInsert_args * pArguments,
#ifdef MULTITHREAD
		  fnClientDbMachineInsert_rets * pResult,
#endif
		  struct svc_req * pRequest )
{
  static const char	__procedure__[]	= "server:fnrpc_fnclientdbmachineinsert_1";
#ifdef MULTITHREAD
  typedef bool_t RESULTTYPE;
#else
  typedef fnClientDbMachineInsert_rets * RESULTTYPE;
#endif
#ifndef MULTITHREAD
  static fnClientDbMachineInsert_rets	Result;
  RESULTTYPE			pResult = &Result;
#endif
  LPCSTR	pszErrorMsg;

  __pRequest__	= pRequest;

  RPC_SERVER_ENTRY();

#ifndef MULTITHREAD
  if ( pResult->pszErrorMsg == szEmpty ) {
    pResult->pszErrorMsg	= NULL;
  }
  xdr_free ( (xdrproc_t) xdr_fnClientDbMachineInsert_rets, (char *) pResult );
#endif
  pResult->nErrorLvl		= 0;

  Reply.bAnswered		= FALSE;
  Reply.pfnCalled		= (void(*)()) fnClientDbMachineInsert;
  Reply.pfnXdrResult		= (bool_t(*)()) xdr_fnClientDbMachineInsert_rets;
  Reply.pnErrorLvl		= &pResult->nErrorLvl;
  Reply.ppszErrorMsg		= (LPCSTR *) &pResult->pszErrorMsg;
  Reply.pResult		= pResult;
  Reply.pReturnValue		= &pResult->ReturnValue;
  Reply.nReturnValueSize	= sizeof ( pResult->ReturnValue );

  pResult->ReturnValue		=
  fnClientDbMachineInsert (
	pArguments->oShortObjIdHeap,
	pArguments->oShortMachine );

  if ( Reply.bAnswered ) {
    __pRequest__	= NULL;
    return (RESULTTYPE) NULL;
  }

  pResult->nErrorLvl	= RPC_SERVER_ERRLVL();
  if ( pResult->nErrorLvl > 0 ) {
    pszErrorMsg		= RPC_SERVER_ERRMSG();
    if ( pszErrorMsg && *pszErrorMsg ) {
      pResult->pszErrorMsg	= strdup ( pszErrorMsg );
    }
  }
  if ( pResult->pszErrorMsg == NULL ) {
#ifdef MULTITHREAD
    pResult->pszErrorMsg	= strdup ( szEmpty );
#else
    pResult->pszErrorMsg	= (LPSTR) szEmpty;
#endif
  }
  __pRequest__	= NULL;
  return (RESULTTYPE) pResult;
} /* fnrpc_fnclientdbmachineinsert_1 */




extern SHORTOBJID fnClientDbMachines
	(SHORTOBJID oShortObjIdHeap);

#ifdef MULTITHREAD
bool_t
#else
fnClientDbMachines_rets *
#endif
	PASTE2(fnrpc_fnclientdbmachines_1,_SVCSUFFIX)
		( SHORTOBJID * pArguments,
#ifdef MULTITHREAD
		  fnClientDbMachines_rets * pResult,
#endif
		  struct svc_req * pRequest )
{
  static const char	__procedure__[]	= "server:fnrpc_fnclientdbmachines_1";
#ifdef MULTITHREAD
  typedef bool_t RESULTTYPE;
#else
  typedef fnClientDbMachines_rets * RESULTTYPE;
#endif
#ifndef MULTITHREAD
  static fnClientDbMachines_rets	Result;
  RESULTTYPE			pResult = &Result;
#endif
  LPCSTR	pszErrorMsg;

  __pRequest__	= pRequest;

  RPC_SERVER_ENTRY();

#ifndef MULTITHREAD
  if ( pResult->pszErrorMsg == szEmpty ) {
    pResult->pszErrorMsg	= NULL;
  }
  xdr_free ( (xdrproc_t) xdr_fnClientDbMachines_rets, (char *) pResult );
#endif
  pResult->nErrorLvl		= 0;

  Reply.bAnswered		= FALSE;
  Reply.pfnCalled		= (void(*)()) fnClientDbMachines;
  Reply.pfnXdrResult		= (bool_t(*)()) xdr_fnClientDbMachines_rets;
  Reply.pnErrorLvl		= &pResult->nErrorLvl;
  Reply.ppszErrorMsg		= (LPCSTR *) &pResult->pszErrorMsg;
  Reply.pResult		= pResult;
  Reply.pReturnValue		= &pResult->ReturnValue;
  Reply.nReturnValueSize	= sizeof ( pResult->ReturnValue );

  pResult->ReturnValue		=
  fnClientDbMachines (
	(*pArguments) );

  if ( Reply.bAnswered ) {
    __pRequest__	= NULL;
    return (RESULTTYPE) NULL;
  }

  pResult->nErrorLvl	= RPC_SERVER_ERRLVL();
  if ( pResult->nErrorLvl > 0 ) {
    pszErrorMsg		= RPC_SERVER_ERRMSG();
    if ( pszErrorMsg && *pszErrorMsg ) {
      pResult->pszErrorMsg	= strdup ( pszErrorMsg );
    }
  }
  if ( pResult->pszErrorMsg == NULL ) {
#ifdef MULTITHREAD
    pResult->pszErrorMsg	= strdup ( szEmpty );
#else
    pResult->pszErrorMsg	= (LPSTR) szEmpty;
#endif
  }
  __pRequest__	= NULL;
  return (RESULTTYPE) pResult;
} /* fnrpc_fnclientdbmachines_1 */




extern int fnServerGetPortByDirectory
	(string_t /* string_t<@conststring@> */ szDirectory ,
	  GETACTION eAction);

#ifdef MULTITHREAD
bool_t
#else
fnServerGetPortByDirectory_rets *
#endif
	PASTE2(fnrpc_fnservergetportbydirectory_1,_SVCSUFFIX)
		( fnServerGetPortByDirectory_args * pArguments,
#ifdef MULTITHREAD
		  fnServerGetPortByDirectory_rets * pResult,
#endif
		  struct svc_req * pRequest )
{
  static const char	__procedure__[]	= "server:fnrpc_fnservergetportbydirectory_1";
#ifdef MULTITHREAD
  typedef bool_t RESULTTYPE;
#else
  typedef fnServerGetPortByDirectory_rets * RESULTTYPE;
#endif
#ifndef MULTITHREAD
  static fnServerGetPortByDirectory_rets	Result;
  RESULTTYPE			pResult = &Result;
#endif
  LPCSTR	pszErrorMsg;

  __pRequest__	= pRequest;

  RPC_SERVER_ENTRY();

#ifndef MULTITHREAD
  if ( pResult->pszErrorMsg == szEmpty ) {
    pResult->pszErrorMsg	= NULL;
  }
  xdr_free ( (xdrproc_t) xdr_fnServerGetPortByDirectory_rets, (char *) pResult );
#endif
  pResult->nErrorLvl		= 0;

  Reply.bAnswered		= FALSE;
  Reply.pfnCalled		= (void(*)()) fnServerGetPortByDirectory;
  Reply.pfnXdrResult		= (bool_t(*)()) xdr_fnServerGetPortByDirectory_rets;
  Reply.pnErrorLvl		= &pResult->nErrorLvl;
  Reply.ppszErrorMsg		= (LPCSTR *) &pResult->pszErrorMsg;
  Reply.pResult		= pResult;
  Reply.pReturnValue		= &pResult->ReturnValue;
  Reply.nReturnValueSize	= sizeof ( pResult->ReturnValue );

  pResult->ReturnValue		=
  fnServerGetPortByDirectory (
	pArguments->szDirectory,
	pArguments->eAction );

  if ( Reply.bAnswered ) {
    __pRequest__	= NULL;
    return (RESULTTYPE) NULL;
  }

  pResult->nErrorLvl	= RPC_SERVER_ERRLVL();
  if ( pResult->nErrorLvl > 0 ) {
    pszErrorMsg		= RPC_SERVER_ERRMSG();
    if ( pszErrorMsg && *pszErrorMsg ) {
      pResult->pszErrorMsg	= strdup ( pszErrorMsg );
    }
  }
  if ( pResult->pszErrorMsg == NULL ) {
#ifdef MULTITHREAD
    pResult->pszErrorMsg	= strdup ( szEmpty );
#else
    pResult->pszErrorMsg	= (LPSTR) szEmpty;
#endif
  }
  __pRequest__	= NULL;
  return (RESULTTYPE) pResult;
} /* fnrpc_fnservergetportbydirectory_1 */




extern int fnServerGetPID
	(void);

#ifdef MULTITHREAD
bool_t
#else
fnServerGetPID_rets *
#endif
	PASTE2(fnrpc_fnservergetpid_1,_SVCSUFFIX)
		( void * pArguments,
#ifdef MULTITHREAD
		  fnServerGetPID_rets * pResult,
#endif
		  struct svc_req * pRequest )
{
  static const char	__procedure__[]	= "server:fnrpc_fnservergetpid_1";
#ifdef MULTITHREAD
  typedef bool_t RESULTTYPE;
#else
  typedef fnServerGetPID_rets * RESULTTYPE;
#endif
#ifndef MULTITHREAD
  static fnServerGetPID_rets	Result;
  RESULTTYPE			pResult = &Result;
#endif
  LPCSTR	pszErrorMsg;

  __pRequest__	= pRequest;

  RPC_SERVER_ENTRY();

#ifndef MULTITHREAD
  if ( pResult->pszErrorMsg == szEmpty ) {
    pResult->pszErrorMsg	= NULL;
  }
  xdr_free ( (xdrproc_t) xdr_fnServerGetPID_rets, (char *) pResult );
#endif
  pResult->nErrorLvl		= 0;

  Reply.bAnswered		= FALSE;
  Reply.pfnCalled		= (void(*)()) fnServerGetPID;
  Reply.pfnXdrResult		= (bool_t(*)()) xdr_fnServerGetPID_rets;
  Reply.pnErrorLvl		= &pResult->nErrorLvl;
  Reply.ppszErrorMsg		= (LPCSTR *) &pResult->pszErrorMsg;
  Reply.pResult		= pResult;
  Reply.pReturnValue		= &pResult->ReturnValue;
  Reply.nReturnValueSize	= sizeof ( pResult->ReturnValue );

  pResult->ReturnValue		=
  fnServerGetPID (
	);

  if ( Reply.bAnswered ) {
    __pRequest__	= NULL;
    return (RESULTTYPE) NULL;
  }

  pResult->nErrorLvl	= RPC_SERVER_ERRLVL();
  if ( pResult->nErrorLvl > 0 ) {
    pszErrorMsg		= RPC_SERVER_ERRMSG();
    if ( pszErrorMsg && *pszErrorMsg ) {
      pResult->pszErrorMsg	= strdup ( pszErrorMsg );
    }
  }
  if ( pResult->pszErrorMsg == NULL ) {
#ifdef MULTITHREAD
    pResult->pszErrorMsg	= strdup ( szEmpty );
#else
    pResult->pszErrorMsg	= (LPSTR) szEmpty;
#endif
  }
  __pRequest__	= NULL;
  return (RESULTTYPE) pResult;
} /* fnrpc_fnservergetpid_1 */




extern int fnServerGetDirectory
	(int nDirectory ,
	  string_t /* string_t<nDirectory> */  szDirectory);

#ifdef MULTITHREAD
bool_t
#else
fnServerGetDirectory_rets *
#endif
	PASTE2(fnrpc_fnservergetdirectory_1,_SVCSUFFIX)
		( fnServerGetDirectory_args * pArguments,
#ifdef MULTITHREAD
		  fnServerGetDirectory_rets * pResult,
#endif
		  struct svc_req * pRequest )
{
  static const char	__procedure__[]	= "server:fnrpc_fnservergetdirectory_1";
#ifdef MULTITHREAD
  typedef bool_t RESULTTYPE;
#else
  typedef fnServerGetDirectory_rets * RESULTTYPE;
#endif
#ifndef MULTITHREAD
  static fnServerGetDirectory_rets	Result;
  RESULTTYPE			pResult = &Result;
#endif
  LPCSTR	pszErrorMsg;

  __pRequest__	= pRequest;

  RPC_SERVER_ENTRY();

#ifndef MULTITHREAD
  if ( pResult->pszErrorMsg == szEmpty ) {
    pResult->pszErrorMsg	= NULL;
  }
  xdr_free ( (xdrproc_t) xdr_fnServerGetDirectory_rets, (char *) pResult );
#endif
  pResult->nErrorLvl		= 0;

  if ( pArguments->szDirectorySize == 0 ) {
    pResult->szDirectory	= NULL;
  } else {
    pResult->szDirectory	=
    (string_t) malloc ( pArguments->szDirectorySize );
    if ( pResult->szDirectory == NULL ) {
      char	szError [ 256 ];
      sprintf ( szError, szFormatMallocFailed,
                __procedure__, pArguments->szDirectorySize );
      RPC_SERVER_ERROR ( szError );
      return (RESULTTYPE) NULL;
    }
  }
  Reply.bAnswered		= FALSE;
  Reply.pfnCalled		= (void(*)()) fnServerGetDirectory;
  Reply.pfnXdrResult		= (bool_t(*)()) xdr_fnServerGetDirectory_rets;
  Reply.pnErrorLvl		= &pResult->nErrorLvl;
  Reply.ppszErrorMsg		= (LPCSTR *) &pResult->pszErrorMsg;
  Reply.pResult		= pResult;
  Reply.pReturnValue		= &pResult->ReturnValue;
  Reply.nReturnValueSize	= sizeof ( pResult->ReturnValue );

  pResult->ReturnValue		=
  fnServerGetDirectory (
	pArguments->nDirectory,
	pResult->szDirectory );

  if ( Reply.bAnswered ) {
    __pRequest__	= NULL;
    return (RESULTTYPE) NULL;
  }

  pResult->nErrorLvl	= RPC_SERVER_ERRLVL();
  if ( pResult->nErrorLvl > 0 ) {
    pszErrorMsg		= RPC_SERVER_ERRMSG();
    if ( pszErrorMsg && *pszErrorMsg ) {
      pResult->pszErrorMsg	= strdup ( pszErrorMsg );
    }
  }
  if ( pResult->pszErrorMsg == NULL ) {
#ifdef MULTITHREAD
    pResult->pszErrorMsg	= strdup ( szEmpty );
#else
    pResult->pszErrorMsg	= (LPSTR) szEmpty;
#endif
  }
  __pRequest__	= NULL;
  return (RESULTTYPE) pResult;
} /* fnrpc_fnservergetdirectory_1 */




extern bool_t fnServerExit
	(SHORTOBJID oShortObjIdHeap ,
	  bool_t bForceExit);

#ifdef MULTITHREAD
bool_t
#else
fnServerExit_rets *
#endif
	PASTE2(fnrpc_fnserverexit_1,_SVCSUFFIX)
		( fnServerExit_args * pArguments,
#ifdef MULTITHREAD
		  fnServerExit_rets * pResult,
#endif
		  struct svc_req * pRequest )
{
  static const char	__procedure__[]	= "server:fnrpc_fnserverexit_1";
#ifdef MULTITHREAD
  typedef bool_t RESULTTYPE;
#else
  typedef fnServerExit_rets * RESULTTYPE;
#endif
#ifndef MULTITHREAD
  static fnServerExit_rets	Result;
  RESULTTYPE			pResult = &Result;
#endif
  LPCSTR	pszErrorMsg;

  __pRequest__	= pRequest;

  RPC_SERVER_ENTRY();

#ifndef MULTITHREAD
  if ( pResult->pszErrorMsg == szEmpty ) {
    pResult->pszErrorMsg	= NULL;
  }
  xdr_free ( (xdrproc_t) xdr_fnServerExit_rets, (char *) pResult );
#endif
  pResult->nErrorLvl		= 0;

  Reply.bAnswered		= FALSE;
  Reply.pfnCalled		= (void(*)()) fnServerExit;
  Reply.pfnXdrResult		= (bool_t(*)()) xdr_fnServerExit_rets;
  Reply.pnErrorLvl		= &pResult->nErrorLvl;
  Reply.ppszErrorMsg		= (LPCSTR *) &pResult->pszErrorMsg;
  Reply.pResult		= pResult;
  Reply.pReturnValue		= &pResult->ReturnValue;
  Reply.nReturnValueSize	= sizeof ( pResult->ReturnValue );

  pResult->ReturnValue		=
  fnServerExit (
	pArguments->oShortObjIdHeap,
	pArguments->bForceExit );

  if ( Reply.bAnswered ) {
    __pRequest__	= NULL;
    return (RESULTTYPE) NULL;
  }

  pResult->nErrorLvl	= RPC_SERVER_ERRLVL();
  if ( pResult->nErrorLvl > 0 ) {
    pszErrorMsg		= RPC_SERVER_ERRMSG();
    if ( pszErrorMsg && *pszErrorMsg ) {
      pResult->pszErrorMsg	= strdup ( pszErrorMsg );
    }
  }
  if ( pResult->pszErrorMsg == NULL ) {
#ifdef MULTITHREAD
    pResult->pszErrorMsg	= strdup ( szEmpty );
#else
    pResult->pszErrorMsg	= (LPSTR) szEmpty;
#endif
  }
  __pRequest__	= NULL;
  return (RESULTTYPE) pResult;
} /* fnrpc_fnserverexit_1 */




extern bool_t fnServerDbReset
	(SHORTOBJID oShortObjIdHeap ,
	  bool_t bForceReset);

#ifdef MULTITHREAD
bool_t
#else
fnServerDbReset_rets *
#endif
	PASTE2(fnrpc_fnserverdbreset_1,_SVCSUFFIX)
		( fnServerDbReset_args * pArguments,
#ifdef MULTITHREAD
		  fnServerDbReset_rets * pResult,
#endif
		  struct svc_req * pRequest )
{
  static const char	__procedure__[]	= "server:fnrpc_fnserverdbreset_1";
#ifdef MULTITHREAD
  typedef bool_t RESULTTYPE;
#else
  typedef fnServerDbReset_rets * RESULTTYPE;
#endif
#ifndef MULTITHREAD
  static fnServerDbReset_rets	Result;
  RESULTTYPE			pResult = &Result;
#endif
  LPCSTR	pszErrorMsg;

  __pRequest__	= pRequest;

  RPC_SERVER_ENTRY();

#ifndef MULTITHREAD
  if ( pResult->pszErrorMsg == szEmpty ) {
    pResult->pszErrorMsg	= NULL;
  }
  xdr_free ( (xdrproc_t) xdr_fnServerDbReset_rets, (char *) pResult );
#endif
  pResult->nErrorLvl		= 0;

  Reply.bAnswered		= FALSE;
  Reply.pfnCalled		= (void(*)()) fnServerDbReset;
  Reply.pfnXdrResult		= (bool_t(*)()) xdr_fnServerDbReset_rets;
  Reply.pnErrorLvl		= &pResult->nErrorLvl;
  Reply.ppszErrorMsg		= (LPCSTR *) &pResult->pszErrorMsg;
  Reply.pResult		= pResult;
  Reply.pReturnValue		= &pResult->ReturnValue;
  Reply.nReturnValueSize	= sizeof ( pResult->ReturnValue );

  pResult->ReturnValue		=
  fnServerDbReset (
	pArguments->oShortObjIdHeap,
	pArguments->bForceReset );

  if ( Reply.bAnswered ) {
    __pRequest__	= NULL;
    return (RESULTTYPE) NULL;
  }

  pResult->nErrorLvl	= RPC_SERVER_ERRLVL();
  if ( pResult->nErrorLvl > 0 ) {
    pszErrorMsg		= RPC_SERVER_ERRMSG();
    if ( pszErrorMsg && *pszErrorMsg ) {
      pResult->pszErrorMsg	= strdup ( pszErrorMsg );
    }
  }
  if ( pResult->pszErrorMsg == NULL ) {
#ifdef MULTITHREAD
    pResult->pszErrorMsg	= strdup ( szEmpty );
#else
    pResult->pszErrorMsg	= (LPSTR) szEmpty;
#endif
  }
  __pRequest__	= NULL;
  return (RESULTTYPE) pResult;
} /* fnrpc_fnserverdbreset_1 */




extern bool_t fnServerRestart
	(SHORTOBJID oShortObjIdHeap ,
	  bool_t bForceRestart);

#ifdef MULTITHREAD
bool_t
#else
fnServerRestart_rets *
#endif
	PASTE2(fnrpc_fnserverrestart_1,_SVCSUFFIX)
		( fnServerRestart_args * pArguments,
#ifdef MULTITHREAD
		  fnServerRestart_rets * pResult,
#endif
		  struct svc_req * pRequest )
{
  static const char	__procedure__[]	= "server:fnrpc_fnserverrestart_1";
#ifdef MULTITHREAD
  typedef bool_t RESULTTYPE;
#else
  typedef fnServerRestart_rets * RESULTTYPE;
#endif
#ifndef MULTITHREAD
  static fnServerRestart_rets	Result;
  RESULTTYPE			pResult = &Result;
#endif
  LPCSTR	pszErrorMsg;

  __pRequest__	= pRequest;

  RPC_SERVER_ENTRY();

#ifndef MULTITHREAD
  if ( pResult->pszErrorMsg == szEmpty ) {
    pResult->pszErrorMsg	= NULL;
  }
  xdr_free ( (xdrproc_t) xdr_fnServerRestart_rets, (char *) pResult );
#endif
  pResult->nErrorLvl		= 0;

  Reply.bAnswered		= FALSE;
  Reply.pfnCalled		= (void(*)()) fnServerRestart;
  Reply.pfnXdrResult		= (bool_t(*)()) xdr_fnServerRestart_rets;
  Reply.pnErrorLvl		= &pResult->nErrorLvl;
  Reply.ppszErrorMsg		= (LPCSTR *) &pResult->pszErrorMsg;
  Reply.pResult		= pResult;
  Reply.pReturnValue		= &pResult->ReturnValue;
  Reply.nReturnValueSize	= sizeof ( pResult->ReturnValue );

  pResult->ReturnValue		=
  fnServerRestart (
	pArguments->oShortObjIdHeap,
	pArguments->bForceRestart );

  if ( Reply.bAnswered ) {
    __pRequest__	= NULL;
    return (RESULTTYPE) NULL;
  }

  pResult->nErrorLvl	= RPC_SERVER_ERRLVL();
  if ( pResult->nErrorLvl > 0 ) {
    pszErrorMsg		= RPC_SERVER_ERRMSG();
    if ( pszErrorMsg && *pszErrorMsg ) {
      pResult->pszErrorMsg	= strdup ( pszErrorMsg );
    }
  }
  if ( pResult->pszErrorMsg == NULL ) {
#ifdef MULTITHREAD
    pResult->pszErrorMsg	= strdup ( szEmpty );
#else
    pResult->pszErrorMsg	= (LPSTR) szEmpty;
#endif
  }
  __pRequest__	= NULL;
  return (RESULTTYPE) pResult;
} /* fnrpc_fnserverrestart_1 */




extern bool_t fnClientObjectCanModify
	(SHORTOBJID oShortObjIdHeap ,
	  SHORTOBJID oShortObjId);

#ifdef MULTITHREAD
bool_t
#else
fnClientObjectCanModify_rets *
#endif
	PASTE2(fnrpc_fnclientobjectcanmodify_1,_SVCSUFFIX)
		( fnClientObjectCanModify_args * pArguments,
#ifdef MULTITHREAD
		  fnClientObjectCanModify_rets * pResult,
#endif
		  struct svc_req * pRequest )
{
  static const char	__procedure__[]	= "server:fnrpc_fnclientobjectcanmodify_1";
#ifdef MULTITHREAD
  typedef bool_t RESULTTYPE;
#else
  typedef fnClientObjectCanModify_rets * RESULTTYPE;
#endif
#ifndef MULTITHREAD
  static fnClientObjectCanModify_rets	Result;
  RESULTTYPE			pResult = &Result;
#endif
  LPCSTR	pszErrorMsg;

  __pRequest__	= pRequest;

  RPC_SERVER_ENTRY();

#ifndef MULTITHREAD
  if ( pResult->pszErrorMsg == szEmpty ) {
    pResult->pszErrorMsg	= NULL;
  }
  xdr_free ( (xdrproc_t) xdr_fnClientObjectCanModify_rets, (char *) pResult );
#endif
  pResult->nErrorLvl		= 0;

  Reply.bAnswered		= FALSE;
  Reply.pfnCalled		= (void(*)()) fnClientObjectCanModify;
  Reply.pfnXdrResult		= (bool_t(*)()) xdr_fnClientObjectCanModify_rets;
  Reply.pnErrorLvl		= &pResult->nErrorLvl;
  Reply.ppszErrorMsg		= (LPCSTR *) &pResult->pszErrorMsg;
  Reply.pResult		= pResult;
  Reply.pReturnValue		= &pResult->ReturnValue;
  Reply.nReturnValueSize	= sizeof ( pResult->ReturnValue );

  pResult->ReturnValue		=
  fnClientObjectCanModify (
	pArguments->oShortObjIdHeap,
	pArguments->oShortObjId );

  if ( Reply.bAnswered ) {
    __pRequest__	= NULL;
    return (RESULTTYPE) NULL;
  }

  pResult->nErrorLvl	= RPC_SERVER_ERRLVL();
  if ( pResult->nErrorLvl > 0 ) {
    pszErrorMsg		= RPC_SERVER_ERRMSG();
    if ( pszErrorMsg && *pszErrorMsg ) {
      pResult->pszErrorMsg	= strdup ( pszErrorMsg );
    }
  }
  if ( pResult->pszErrorMsg == NULL ) {
#ifdef MULTITHREAD
    pResult->pszErrorMsg	= strdup ( szEmpty );
#else
    pResult->pszErrorMsg	= (LPSTR) szEmpty;
#endif
  }
  __pRequest__	= NULL;
  return (RESULTTYPE) pResult;
} /* fnrpc_fnclientobjectcanmodify_1 */




extern void fnServerDbClose
	(SHORTOBJID oShortObjIdHeap ,
	  bool_t bWithGarbageCollection);

#ifdef MULTITHREAD
bool_t
#else
void *
#endif
	PASTE2(fnrpc_fnserverdbclose_batch_1,_SVCSUFFIX)
		( fnServerDbClose_args * pArguments,
#ifdef MULTITHREAD
		  void * pResult,
#endif
		  struct svc_req * pRequest )
{
  static const char	__procedure__[]	= "server:fnrpc_fnserverdbclose_batch_1";
#ifdef MULTITHREAD
  typedef bool_t RESULTTYPE;
#else
  typedef void * RESULTTYPE;
#endif

  __pRequest__	= pRequest;

  RPC_SERVER_ENTRY();

  Reply.bAnswered		= TRUE;
  Reply.pfnCalled		= (void(*)()) fnServerDbClose;
  Reply.pfnXdrResult		= (bool_t(*)()) xdr_void;
  Reply.pnErrorLvl		= NULL;
  Reply.ppszErrorMsg		= NULL;
  Reply.pResult			= NULL;
  Reply.pReturnValue		= NULL;
  Reply.nReturnValueSize	= 0;
  fnServerDbClose (
	pArguments->oShortObjIdHeap,
	pArguments->bWithGarbageCollection );
  __pRequest__	= NULL;
  return (RESULTTYPE) NULL;
} /* fnrpc_fnserverdbclose_batch_1 */




extern bool_t fnClientDbConfiguration
	(SHORTOBJID oShortObjIdHeap ,
	  int * pnFlags ,
	  int * pnMinimumKey ,
	  int * pnMaximumKey ,
	  int * pnKeyAlignment);

#ifdef MULTITHREAD
bool_t
#else
fnClientDbConfiguration_rets *
#endif
	PASTE2(fnrpc_fnclientdbconfiguration_1,_SVCSUFFIX)
		( SHORTOBJID * pArguments,
#ifdef MULTITHREAD
		  fnClientDbConfiguration_rets * pResult,
#endif
		  struct svc_req * pRequest )
{
  static const char	__procedure__[]	= "server:fnrpc_fnclientdbconfiguration_1";
#ifdef MULTITHREAD
  typedef bool_t RESULTTYPE;
#else
  typedef fnClientDbConfiguration_rets * RESULTTYPE;
#endif
#ifndef MULTITHREAD
  static fnClientDbConfiguration_rets	Result;
  RESULTTYPE			pResult = &Result;
#endif
  LPCSTR	pszErrorMsg;

  __pRequest__	= pRequest;

  RPC_SERVER_ENTRY();

#ifndef MULTITHREAD
  if ( pResult->pszErrorMsg == szEmpty ) {
    pResult->pszErrorMsg	= NULL;
  }
  xdr_free ( (xdrproc_t) xdr_fnClientDbConfiguration_rets, (char *) pResult );
#endif
  pResult->nErrorLvl		= 0;

  Reply.bAnswered		= FALSE;
  Reply.pfnCalled		= (void(*)()) fnClientDbConfiguration;
  Reply.pfnXdrResult		= (bool_t(*)()) xdr_fnClientDbConfiguration_rets;
  Reply.pnErrorLvl		= &pResult->nErrorLvl;
  Reply.ppszErrorMsg		= (LPCSTR *) &pResult->pszErrorMsg;
  Reply.pResult		= pResult;
  Reply.pReturnValue		= &pResult->ReturnValue;
  Reply.nReturnValueSize	= sizeof ( pResult->ReturnValue );

  pResult->ReturnValue		=
  fnClientDbConfiguration (
	(*pArguments),
	&pResult->pnFlags,
	&pResult->pnMinimumKey,
	&pResult->pnMaximumKey,
	&pResult->pnKeyAlignment );

  if ( Reply.bAnswered ) {
    __pRequest__	= NULL;
    return (RESULTTYPE) NULL;
  }

  pResult->nErrorLvl	= RPC_SERVER_ERRLVL();
  if ( pResult->nErrorLvl > 0 ) {
    pszErrorMsg		= RPC_SERVER_ERRMSG();
    if ( pszErrorMsg && *pszErrorMsg ) {
      pResult->pszErrorMsg	= strdup ( pszErrorMsg );
    }
  }
  if ( pResult->pszErrorMsg == NULL ) {
#ifdef MULTITHREAD
    pResult->pszErrorMsg	= strdup ( szEmpty );
#else
    pResult->pszErrorMsg	= (LPSTR) szEmpty;
#endif
  }
  __pRequest__	= NULL;
  return (RESULTTYPE) pResult;
} /* fnrpc_fnclientdbconfiguration_1 */




extern SHORTOBJID fnServerDbCreateObject
	(SHORTOBJID oShortObjIdHeap ,
	  SHTYPETAG nTypeTag ,
	  int nExtraReferences ,
	  SHTYPETAG eTypeTagValues ,
	  int nExtraValues);

#ifdef MULTITHREAD
bool_t
#else
fnServerDbCreateObject_rets *
#endif
	PASTE2(fnrpc_fnserverdbcreateobject_1,_SVCSUFFIX)
		( fnServerDbCreateObject_args * pArguments,
#ifdef MULTITHREAD
		  fnServerDbCreateObject_rets * pResult,
#endif
		  struct svc_req * pRequest )
{
  static const char	__procedure__[]	= "server:fnrpc_fnserverdbcreateobject_1";
#ifdef MULTITHREAD
  typedef bool_t RESULTTYPE;
#else
  typedef fnServerDbCreateObject_rets * RESULTTYPE;
#endif
#ifndef MULTITHREAD
  static fnServerDbCreateObject_rets	Result;
  RESULTTYPE			pResult = &Result;
#endif
  LPCSTR	pszErrorMsg;

  __pRequest__	= pRequest;

  RPC_SERVER_ENTRY();

#ifndef MULTITHREAD
  if ( pResult->pszErrorMsg == szEmpty ) {
    pResult->pszErrorMsg	= NULL;
  }
  xdr_free ( (xdrproc_t) xdr_fnServerDbCreateObject_rets, (char *) pResult );
#endif
  pResult->nErrorLvl		= 0;

  Reply.bAnswered		= FALSE;
  Reply.pfnCalled		= (void(*)()) fnServerDbCreateObject;
  Reply.pfnXdrResult		= (bool_t(*)()) xdr_fnServerDbCreateObject_rets;
  Reply.pnErrorLvl		= &pResult->nErrorLvl;
  Reply.ppszErrorMsg		= (LPCSTR *) &pResult->pszErrorMsg;
  Reply.pResult		= pResult;
  Reply.pReturnValue		= &pResult->ReturnValue;
  Reply.nReturnValueSize	= sizeof ( pResult->ReturnValue );

  pResult->ReturnValue		=
  fnServerDbCreateObject (
	pArguments->oShortObjIdHeap,
	pArguments->nTypeTag,
	pArguments->nExtraReferences,
	pArguments->eTypeTagValues,
	pArguments->nExtraValues );

  if ( Reply.bAnswered ) {
    __pRequest__	= NULL;
    return (RESULTTYPE) NULL;
  }

  pResult->nErrorLvl	= RPC_SERVER_ERRLVL();
  if ( pResult->nErrorLvl > 0 ) {
    pszErrorMsg		= RPC_SERVER_ERRMSG();
    if ( pszErrorMsg && *pszErrorMsg ) {
      pResult->pszErrorMsg	= strdup ( pszErrorMsg );
    }
  }
  if ( pResult->pszErrorMsg == NULL ) {
#ifdef MULTITHREAD
    pResult->pszErrorMsg	= strdup ( szEmpty );
#else
    pResult->pszErrorMsg	= (LPSTR) szEmpty;
#endif
  }
  __pRequest__	= NULL;
  return (RESULTTYPE) pResult;
} /* fnrpc_fnserverdbcreateobject_1 */




extern int fnServerDbCreateObjects
	(SHORTOBJID oShortObjIdHeap ,
	  SHTYPETAG nTypeTag ,
	  int nExtraReferences ,
	  SHTYPETAG eTypeTagValues ,
	  int nExtraValues ,
	  int nObjIds ,
	  u_int * /* _vector_t<nObjIds> */  pObjIds);

#ifdef MULTITHREAD
bool_t
#else
fnServerDbCreateObjects_rets *
#endif
	PASTE2(fnrpc_fnserverdbcreateobjects_1,_SVCSUFFIX)
		( fnServerDbCreateObjects_args * pArguments,
#ifdef MULTITHREAD
		  fnServerDbCreateObjects_rets * pResult,
#endif
		  struct svc_req * pRequest )
{
  static const char	__procedure__[]	= "server:fnrpc_fnserverdbcreateobjects_1";
#ifdef MULTITHREAD
  typedef bool_t RESULTTYPE;
#else
  typedef fnServerDbCreateObjects_rets * RESULTTYPE;
#endif
#ifndef MULTITHREAD
  static fnServerDbCreateObjects_rets	Result;
  RESULTTYPE			pResult = &Result;
#endif
  LPCSTR	pszErrorMsg;

  __pRequest__	= pRequest;

  RPC_SERVER_ENTRY();

#ifndef MULTITHREAD
  if ( pResult->pszErrorMsg == szEmpty ) {
    pResult->pszErrorMsg	= NULL;
  }
  xdr_free ( (xdrproc_t) xdr_fnServerDbCreateObjects_rets, (char *) pResult );
#endif
  pResult->nErrorLvl		= 0;

  pResult->pObjIds.u_int_vector_t_len	= pArguments->pObjIdsSize;
  if ( pArguments->pObjIdsSize == 0 ) {
    pResult->pObjIds.u_int_vector_t_val	= NULL;
  } else {
    pResult->pObjIds.u_int_vector_t_val	=
      (u_int*) malloc ( pArguments->pObjIdsSize *
               SIZEOF ( *(pResult->pObjIds.u_int_vector_t_val) ) );
    if ( pResult->pObjIds.u_int_vector_t_val == NULL ) {
      char	szError [ 256 ];
      sprintf ( szError, szFormatMallocFailed,
                __procedure__, pArguments->pObjIdsSize,
                "pObjIds" );
      RPC_SERVER_ERROR ( szError );
      return (RESULTTYPE) NULL;
    }
  }
  Reply.bAnswered		= FALSE;
  Reply.pfnCalled		= (void(*)()) fnServerDbCreateObjects;
  Reply.pfnXdrResult		= (bool_t(*)()) xdr_fnServerDbCreateObjects_rets;
  Reply.pnErrorLvl		= &pResult->nErrorLvl;
  Reply.ppszErrorMsg		= (LPCSTR *) &pResult->pszErrorMsg;
  Reply.pResult		= pResult;
  Reply.pReturnValue		= &pResult->ReturnValue;
  Reply.nReturnValueSize	= sizeof ( pResult->ReturnValue );

  pResult->ReturnValue		=
  fnServerDbCreateObjects (
	pArguments->oShortObjIdHeap,
	pArguments->nTypeTag,
	pArguments->nExtraReferences,
	pArguments->eTypeTagValues,
	pArguments->nExtraValues,
	pArguments->nObjIds,
	pResult->pObjIds.u_int_vector_t_val );

  if ( Reply.bAnswered ) {
    __pRequest__	= NULL;
    return (RESULTTYPE) NULL;
  }

  pResult->nErrorLvl	= RPC_SERVER_ERRLVL();
  if ( pResult->nErrorLvl > 0 ) {
    pszErrorMsg		= RPC_SERVER_ERRMSG();
    if ( pszErrorMsg && *pszErrorMsg ) {
      pResult->pszErrorMsg	= strdup ( pszErrorMsg );
    }
  }
  if ( pResult->pszErrorMsg == NULL ) {
#ifdef MULTITHREAD
    pResult->pszErrorMsg	= strdup ( szEmpty );
#else
    pResult->pszErrorMsg	= (LPSTR) szEmpty;
#endif
  }
  __pRequest__	= NULL;
  return (RESULTTYPE) pResult;
} /* fnrpc_fnserverdbcreateobjects_1 */




extern void fnServerObjectDestroy
	(SHORTOBJID oShortObjIdHeap ,
	  SHORTOBJID oShortObjId);

#ifdef MULTITHREAD
bool_t
#else
void *
#endif
	PASTE2(fnrpc_fnserverobjectdestroy_batch_1,_SVCSUFFIX)
		( fnServerObjectDestroy_args * pArguments,
#ifdef MULTITHREAD
		  void * pResult,
#endif
		  struct svc_req * pRequest )
{
  static const char	__procedure__[]	= "server:fnrpc_fnserverobjectdestroy_batch_1";
#ifdef MULTITHREAD
  typedef bool_t RESULTTYPE;
#else
  typedef void * RESULTTYPE;
#endif

  __pRequest__	= pRequest;

  RPC_SERVER_ENTRY();

  Reply.bAnswered		= TRUE;
  Reply.pfnCalled		= (void(*)()) fnServerObjectDestroy;
  Reply.pfnXdrResult		= (bool_t(*)()) xdr_void;
  Reply.pnErrorLvl		= NULL;
  Reply.ppszErrorMsg		= NULL;
  Reply.pResult			= NULL;
  Reply.pReturnValue		= NULL;
  Reply.nReturnValueSize	= 0;
  fnServerObjectDestroy (
	pArguments->oShortObjIdHeap,
	pArguments->oShortObjId );
  __pRequest__	= NULL;
  return (RESULTTYPE) NULL;
} /* fnrpc_fnserverobjectdestroy_batch_1 */




extern int fnServerObjectObjIdSize
	(SHORTOBJID oShortObjIdHeap ,
	  SHORTOBJID oShortObjId);

#ifdef MULTITHREAD
bool_t
#else
fnServerObjectObjIdSize_rets *
#endif
	PASTE2(fnrpc_fnserverobjectobjidsize_1,_SVCSUFFIX)
		( fnServerObjectObjIdSize_args * pArguments,
#ifdef MULTITHREAD
		  fnServerObjectObjIdSize_rets * pResult,
#endif
		  struct svc_req * pRequest )
{
  static const char	__procedure__[]	= "server:fnrpc_fnserverobjectobjidsize_1";
#ifdef MULTITHREAD
  typedef bool_t RESULTTYPE;
#else
  typedef fnServerObjectObjIdSize_rets * RESULTTYPE;
#endif
#ifndef MULTITHREAD
  static fnServerObjectObjIdSize_rets	Result;
  RESULTTYPE			pResult = &Result;
#endif
  LPCSTR	pszErrorMsg;

  __pRequest__	= pRequest;

  RPC_SERVER_ENTRY();

#ifndef MULTITHREAD
  if ( pResult->pszErrorMsg == szEmpty ) {
    pResult->pszErrorMsg	= NULL;
  }
  xdr_free ( (xdrproc_t) xdr_fnServerObjectObjIdSize_rets, (char *) pResult );
#endif
  pResult->nErrorLvl		= 0;

  Reply.bAnswered		= FALSE;
  Reply.pfnCalled		= (void(*)()) fnServerObjectObjIdSize;
  Reply.pfnXdrResult		= (bool_t(*)()) xdr_fnServerObjectObjIdSize_rets;
  Reply.pnErrorLvl		= &pResult->nErrorLvl;
  Reply.ppszErrorMsg		= (LPCSTR *) &pResult->pszErrorMsg;
  Reply.pResult		= pResult;
  Reply.pReturnValue		= &pResult->ReturnValue;
  Reply.nReturnValueSize	= sizeof ( pResult->ReturnValue );

  pResult->ReturnValue		=
  fnServerObjectObjIdSize (
	pArguments->oShortObjIdHeap,
	pArguments->oShortObjId );

  if ( Reply.bAnswered ) {
    __pRequest__	= NULL;
    return (RESULTTYPE) NULL;
  }

  pResult->nErrorLvl	= RPC_SERVER_ERRLVL();
  if ( pResult->nErrorLvl > 0 ) {
    pszErrorMsg		= RPC_SERVER_ERRMSG();
    if ( pszErrorMsg && *pszErrorMsg ) {
      pResult->pszErrorMsg	= strdup ( pszErrorMsg );
    }
  }
  if ( pResult->pszErrorMsg == NULL ) {
#ifdef MULTITHREAD
    pResult->pszErrorMsg	= strdup ( szEmpty );
#else
    pResult->pszErrorMsg	= (LPSTR) szEmpty;
#endif
  }
  __pRequest__	= NULL;
  return (RESULTTYPE) pResult;
} /* fnrpc_fnserverobjectobjidsize_1 */




extern SHORTOBJID fnServerDbOpen
	(string_t /* string_t<@conststring@> */ szDirectory ,
	  string_t /* string_t<@conststring@> */ szUserName ,
	  string_t /* string_t<@conststring@> */ szDescription ,
	  int nMinAddrInK ,
	  OBJID * poObjIdMin ,
	  OBJID * poObjIdMax);

#ifdef MULTITHREAD
bool_t
#else
fnServerDbOpen_rets *
#endif
	PASTE2(fnrpc_fnserverdbopen_1,_SVCSUFFIX)
		( fnServerDbOpen_args * pArguments,
#ifdef MULTITHREAD
		  fnServerDbOpen_rets * pResult,
#endif
		  struct svc_req * pRequest )
{
  static const char	__procedure__[]	= "server:fnrpc_fnserverdbopen_1";
#ifdef MULTITHREAD
  typedef bool_t RESULTTYPE;
#else
  typedef fnServerDbOpen_rets * RESULTTYPE;
#endif
#ifndef MULTITHREAD
  static fnServerDbOpen_rets	Result;
  RESULTTYPE			pResult = &Result;
#endif
  LPCSTR	pszErrorMsg;

  __pRequest__	= pRequest;

  RPC_SERVER_ENTRY();

#ifndef MULTITHREAD
  if ( pResult->pszErrorMsg == szEmpty ) {
    pResult->pszErrorMsg	= NULL;
  }
  xdr_free ( (xdrproc_t) xdr_fnServerDbOpen_rets, (char *) pResult );
#endif
  pResult->nErrorLvl		= 0;

  Reply.bAnswered		= FALSE;
  Reply.pfnCalled		= (void(*)()) fnServerDbOpen;
  Reply.pfnXdrResult		= (bool_t(*)()) xdr_fnServerDbOpen_rets;
  Reply.pnErrorLvl		= &pResult->nErrorLvl;
  Reply.ppszErrorMsg		= (LPCSTR *) &pResult->pszErrorMsg;
  Reply.pResult		= pResult;
  Reply.pReturnValue		= &pResult->ReturnValue;
  Reply.nReturnValueSize	= sizeof ( pResult->ReturnValue );

  pResult->ReturnValue		=
  fnServerDbOpen (
	pArguments->szDirectory,
	pArguments->szUserName,
	pArguments->szDescription,
	pArguments->nMinAddrInK,
	&pResult->poObjIdMin,
	&pResult->poObjIdMax );

  if ( Reply.bAnswered ) {
    __pRequest__	= NULL;
    return (RESULTTYPE) NULL;
  }

  pResult->nErrorLvl	= RPC_SERVER_ERRLVL();
  if ( pResult->nErrorLvl > 0 ) {
    pszErrorMsg		= RPC_SERVER_ERRMSG();
    if ( pszErrorMsg && *pszErrorMsg ) {
      pResult->pszErrorMsg	= strdup ( pszErrorMsg );
    }
  }
  if ( pResult->pszErrorMsg == NULL ) {
#ifdef MULTITHREAD
    pResult->pszErrorMsg	= strdup ( szEmpty );
#else
    pResult->pszErrorMsg	= (LPSTR) szEmpty;
#endif
  }
  __pRequest__	= NULL;
  return (RESULTTYPE) pResult;
} /* fnrpc_fnserverdbopen_1 */




extern bool_t fnServerObjectFlush
	(SHORTOBJID oShortObjIdHeap ,
	  SHORTOBJID oShortObjId);

#ifdef MULTITHREAD
bool_t
#else
fnServerObjectFlush_rets *
#endif
	PASTE2(fnrpc_fnserverobjectflush_1,_SVCSUFFIX)
		( fnServerObjectFlush_args * pArguments,
#ifdef MULTITHREAD
		  fnServerObjectFlush_rets * pResult,
#endif
		  struct svc_req * pRequest )
{
  static const char	__procedure__[]	= "server:fnrpc_fnserverobjectflush_1";
#ifdef MULTITHREAD
  typedef bool_t RESULTTYPE;
#else
  typedef fnServerObjectFlush_rets * RESULTTYPE;
#endif
#ifndef MULTITHREAD
  static fnServerObjectFlush_rets	Result;
  RESULTTYPE			pResult = &Result;
#endif
  LPCSTR	pszErrorMsg;

  __pRequest__	= pRequest;

  RPC_SERVER_ENTRY();

#ifndef MULTITHREAD
  if ( pResult->pszErrorMsg == szEmpty ) {
    pResult->pszErrorMsg	= NULL;
  }
  xdr_free ( (xdrproc_t) xdr_fnServerObjectFlush_rets, (char *) pResult );
#endif
  pResult->nErrorLvl		= 0;

  Reply.bAnswered		= FALSE;
  Reply.pfnCalled		= (void(*)()) fnServerObjectFlush;
  Reply.pfnXdrResult		= (bool_t(*)()) xdr_fnServerObjectFlush_rets;
  Reply.pnErrorLvl		= &pResult->nErrorLvl;
  Reply.ppszErrorMsg		= (LPCSTR *) &pResult->pszErrorMsg;
  Reply.pResult		= pResult;
  Reply.pReturnValue		= &pResult->ReturnValue;
  Reply.nReturnValueSize	= sizeof ( pResult->ReturnValue );

  pResult->ReturnValue		=
  fnServerObjectFlush (
	pArguments->oShortObjIdHeap,
	pArguments->oShortObjId );

  if ( Reply.bAnswered ) {
    __pRequest__	= NULL;
    return (RESULTTYPE) NULL;
  }

  pResult->nErrorLvl	= RPC_SERVER_ERRLVL();
  if ( pResult->nErrorLvl > 0 ) {
    pszErrorMsg		= RPC_SERVER_ERRMSG();
    if ( pszErrorMsg && *pszErrorMsg ) {
      pResult->pszErrorMsg	= strdup ( pszErrorMsg );
    }
  }
  if ( pResult->pszErrorMsg == NULL ) {
#ifdef MULTITHREAD
    pResult->pszErrorMsg	= strdup ( szEmpty );
#else
    pResult->pszErrorMsg	= (LPSTR) szEmpty;
#endif
  }
  __pRequest__	= NULL;
  return (RESULTTYPE) pResult;
} /* fnrpc_fnserverobjectflush_1 */




extern SHLOCK fnServerObjectReadAtIndex
	(SHORTOBJID oShortObjIdHeap ,
	  SHORTOBJID oShortObjId ,
	  SHORTOBJID oExpectingClass ,
	  SHTYPETAG nExpectingTypeTag ,
	  int nIndex ,
	  int * pnValue ,
	  SHTYPETAG * pnTypeTag);

#ifdef MULTITHREAD
bool_t
#else
fnServerObjectReadAtIndex_rets *
#endif
	PASTE2(fnrpc_fnserverobjectreadatindex_1,_SVCSUFFIX)
		( fnServerObjectReadAtIndex_args * pArguments,
#ifdef MULTITHREAD
		  fnServerObjectReadAtIndex_rets * pResult,
#endif
		  struct svc_req * pRequest )
{
  static const char	__procedure__[]	= "server:fnrpc_fnserverobjectreadatindex_1";
#ifdef MULTITHREAD
  typedef bool_t RESULTTYPE;
#else
  typedef fnServerObjectReadAtIndex_rets * RESULTTYPE;
#endif
#ifndef MULTITHREAD
  static fnServerObjectReadAtIndex_rets	Result;
  RESULTTYPE			pResult = &Result;
#endif
  LPCSTR	pszErrorMsg;

  __pRequest__	= pRequest;

  RPC_SERVER_ENTRY();

#ifndef MULTITHREAD
  if ( pResult->pszErrorMsg == szEmpty ) {
    pResult->pszErrorMsg	= NULL;
  }
  xdr_free ( (xdrproc_t) xdr_fnServerObjectReadAtIndex_rets, (char *) pResult );
#endif
  pResult->nErrorLvl		= 0;

  Reply.bAnswered		= FALSE;
  Reply.pfnCalled		= (void(*)()) fnServerObjectReadAtIndex;
  Reply.pfnXdrResult		= (bool_t(*)()) xdr_fnServerObjectReadAtIndex_rets;
  Reply.pnErrorLvl		= &pResult->nErrorLvl;
  Reply.ppszErrorMsg		= (LPCSTR *) &pResult->pszErrorMsg;
  Reply.pResult		= pResult;
  Reply.pReturnValue		= &pResult->ReturnValue;
  Reply.nReturnValueSize	= sizeof ( pResult->ReturnValue );

  pResult->ReturnValue		=
  fnServerObjectReadAtIndex (
	pArguments->oShortObjIdHeap,
	pArguments->oShortObjId,
	pArguments->oExpectingClass,
	pArguments->nExpectingTypeTag,
	pArguments->nIndex,
	&pResult->pnValue,
	&pResult->pnTypeTag );

  if ( Reply.bAnswered ) {
    __pRequest__	= NULL;
    return (RESULTTYPE) NULL;
  }

  pResult->nErrorLvl	= RPC_SERVER_ERRLVL();
  if ( pResult->nErrorLvl > 0 ) {
    pszErrorMsg		= RPC_SERVER_ERRMSG();
    if ( pszErrorMsg && *pszErrorMsg ) {
      pResult->pszErrorMsg	= strdup ( pszErrorMsg );
    }
  }
  if ( pResult->pszErrorMsg == NULL ) {
#ifdef MULTITHREAD
    pResult->pszErrorMsg	= strdup ( szEmpty );
#else
    pResult->pszErrorMsg	= (LPSTR) szEmpty;
#endif
  }
  __pRequest__	= NULL;
  return (RESULTTYPE) pResult;
} /* fnrpc_fnserverobjectreadatindex_1 */




extern int fnServerObjectReadAtIndices
	(SHORTOBJID oShortObjIdHeap ,
	  SHORTOBJID oShortObjId ,
	  SHORTOBJID oExpectingClass ,
	  SHTYPETAG nExpectingTypeTag ,
	  int nIndex ,
	  int nObjIds ,
	  int * /* _vector_t<nObjIds> */  pObjIds ,
	  u_int * /* _vector_t<nObjIds> */  pnTypeTags);

#ifdef MULTITHREAD
bool_t
#else
fnServerObjectReadAtIndices_rets *
#endif
	PASTE2(fnrpc_fnserverobjectreadatindices_1,_SVCSUFFIX)
		( fnServerObjectReadAtIndices_args * pArguments,
#ifdef MULTITHREAD
		  fnServerObjectReadAtIndices_rets * pResult,
#endif
		  struct svc_req * pRequest )
{
  static const char	__procedure__[]	= "server:fnrpc_fnserverobjectreadatindices_1";
#ifdef MULTITHREAD
  typedef bool_t RESULTTYPE;
#else
  typedef fnServerObjectReadAtIndices_rets * RESULTTYPE;
#endif
#ifndef MULTITHREAD
  static fnServerObjectReadAtIndices_rets	Result;
  RESULTTYPE			pResult = &Result;
#endif
  LPCSTR	pszErrorMsg;

  __pRequest__	= pRequest;

  RPC_SERVER_ENTRY();

#ifndef MULTITHREAD
  if ( pResult->pszErrorMsg == szEmpty ) {
    pResult->pszErrorMsg	= NULL;
  }
  xdr_free ( (xdrproc_t) xdr_fnServerObjectReadAtIndices_rets, (char *) pResult );
#endif
  pResult->nErrorLvl		= 0;

  pResult->pObjIds.int_vector_t_len	= pArguments->pObjIdsSize;
  if ( pArguments->pObjIdsSize == 0 ) {
    pResult->pObjIds.int_vector_t_val	= NULL;
  } else {
    pResult->pObjIds.int_vector_t_val	=
      (int*) malloc ( pArguments->pObjIdsSize *
               SIZEOF ( *(pResult->pObjIds.int_vector_t_val) ) );
    if ( pResult->pObjIds.int_vector_t_val == NULL ) {
      char	szError [ 256 ];
      sprintf ( szError, szFormatMallocFailed,
                __procedure__, pArguments->pObjIdsSize,
                "pObjIds" );
      RPC_SERVER_ERROR ( szError );
      return (RESULTTYPE) NULL;
    }
  }
  pResult->pnTypeTags.u_int_vector_t_len	= pArguments->pnTypeTagsSize;
  if ( pArguments->pnTypeTagsSize == 0 ) {
    pResult->pnTypeTags.u_int_vector_t_val	= NULL;
  } else {
    pResult->pnTypeTags.u_int_vector_t_val	=
      (u_int*) malloc ( pArguments->pnTypeTagsSize *
               SIZEOF ( *(pResult->pnTypeTags.u_int_vector_t_val) ) );
    if ( pResult->pnTypeTags.u_int_vector_t_val == NULL ) {
      char	szError [ 256 ];
      sprintf ( szError, szFormatMallocFailed,
                __procedure__, pArguments->pnTypeTagsSize,
                "pnTypeTags" );
      RPC_SERVER_ERROR ( szError );
      return (RESULTTYPE) NULL;
    }
  }
  Reply.bAnswered		= FALSE;
  Reply.pfnCalled		= (void(*)()) fnServerObjectReadAtIndices;
  Reply.pfnXdrResult		= (bool_t(*)()) xdr_fnServerObjectReadAtIndices_rets;
  Reply.pnErrorLvl		= &pResult->nErrorLvl;
  Reply.ppszErrorMsg		= (LPCSTR *) &pResult->pszErrorMsg;
  Reply.pResult		= pResult;
  Reply.pReturnValue		= &pResult->ReturnValue;
  Reply.nReturnValueSize	= sizeof ( pResult->ReturnValue );

  pResult->ReturnValue		=
  fnServerObjectReadAtIndices (
	pArguments->oShortObjIdHeap,
	pArguments->oShortObjId,
	pArguments->oExpectingClass,
	pArguments->nExpectingTypeTag,
	pArguments->nIndex,
	pArguments->nObjIds,
	pResult->pObjIds.int_vector_t_val,
	pResult->pnTypeTags.u_int_vector_t_val );

  if ( Reply.bAnswered ) {
    __pRequest__	= NULL;
    return (RESULTTYPE) NULL;
  }

  pResult->nErrorLvl	= RPC_SERVER_ERRLVL();
  if ( pResult->nErrorLvl > 0 ) {
    pszErrorMsg		= RPC_SERVER_ERRMSG();
    if ( pszErrorMsg && *pszErrorMsg ) {
      pResult->pszErrorMsg	= strdup ( pszErrorMsg );
    }
  }
  if ( pResult->pszErrorMsg == NULL ) {
#ifdef MULTITHREAD
    pResult->pszErrorMsg	= strdup ( szEmpty );
#else
    pResult->pszErrorMsg	= (LPSTR) szEmpty;
#endif
  }
  __pRequest__	= NULL;
  return (RESULTTYPE) pResult;
} /* fnrpc_fnserverobjectreadatindices_1 */




extern SHLOCK fnServerObjectReadObjId
	(SHORTOBJID oShortObjIdHeap ,
	  SHORTOBJID oShortObjId ,
	  SHORTOBJID oExpectingClass ,
	  SHTYPETAG nExpectingTypeTag ,
	  int nIndex ,
	  int * pnObjId);

#ifdef MULTITHREAD
bool_t
#else
fnServerObjectReadObjId_rets *
#endif
	PASTE2(fnrpc_fnserverobjectreadobjid_1,_SVCSUFFIX)
		( fnServerObjectReadObjId_args * pArguments,
#ifdef MULTITHREAD
		  fnServerObjectReadObjId_rets * pResult,
#endif
		  struct svc_req * pRequest )
{
  static const char	__procedure__[]	= "server:fnrpc_fnserverobjectreadobjid_1";
#ifdef MULTITHREAD
  typedef bool_t RESULTTYPE;
#else
  typedef fnServerObjectReadObjId_rets * RESULTTYPE;
#endif
#ifndef MULTITHREAD
  static fnServerObjectReadObjId_rets	Result;
  RESULTTYPE			pResult = &Result;
#endif
  LPCSTR	pszErrorMsg;

  __pRequest__	= pRequest;

  RPC_SERVER_ENTRY();

#ifndef MULTITHREAD
  if ( pResult->pszErrorMsg == szEmpty ) {
    pResult->pszErrorMsg	= NULL;
  }
  xdr_free ( (xdrproc_t) xdr_fnServerObjectReadObjId_rets, (char *) pResult );
#endif
  pResult->nErrorLvl		= 0;

  Reply.bAnswered		= FALSE;
  Reply.pfnCalled		= (void(*)()) fnServerObjectReadObjId;
  Reply.pfnXdrResult		= (bool_t(*)()) xdr_fnServerObjectReadObjId_rets;
  Reply.pnErrorLvl		= &pResult->nErrorLvl;
  Reply.ppszErrorMsg		= (LPCSTR *) &pResult->pszErrorMsg;
  Reply.pResult		= pResult;
  Reply.pReturnValue		= &pResult->ReturnValue;
  Reply.nReturnValueSize	= sizeof ( pResult->ReturnValue );

  pResult->ReturnValue		=
  fnServerObjectReadObjId (
	pArguments->oShortObjIdHeap,
	pArguments->oShortObjId,
	pArguments->oExpectingClass,
	pArguments->nExpectingTypeTag,
	pArguments->nIndex,
	&pResult->pnObjId );

  if ( Reply.bAnswered ) {
    __pRequest__	= NULL;
    return (RESULTTYPE) NULL;
  }

  pResult->nErrorLvl	= RPC_SERVER_ERRLVL();
  if ( pResult->nErrorLvl > 0 ) {
    pszErrorMsg		= RPC_SERVER_ERRMSG();
    if ( pszErrorMsg && *pszErrorMsg ) {
      pResult->pszErrorMsg	= strdup ( pszErrorMsg );
    }
  }
  if ( pResult->pszErrorMsg == NULL ) {
#ifdef MULTITHREAD
    pResult->pszErrorMsg	= strdup ( szEmpty );
#else
    pResult->pszErrorMsg	= (LPSTR) szEmpty;
#endif
  }
  __pRequest__	= NULL;
  return (RESULTTYPE) pResult;
} /* fnrpc_fnserverobjectreadobjid_1 */




extern int fnServerObjectReadValues
	(SHORTOBJID oShortObjIdHeap ,
	  SHORTOBJID oShortObjId ,
	  SHORTOBJID oExpectingClass ,
	  SHTYPETAG nExpectingTypeTag ,
	  int nIndex ,
	  SHTYPETAG nElementTypeTagIn ,
	  int nSizeInElementsIn ,
	  SHTYPETAG * pnElementTypeTagOut ,
	  int * pnSizeInElementsOut ,
	  void * /* _vector_t<((( fnTypeTagSizeValue(1,&nElementTypeTagIn, &nSizeInElementsIn) )*( sizeof(int) )) )> */  pBuffer);

#ifdef MULTITHREAD
bool_t
#else
fnServerObjectReadValues_rets *
#endif
	PASTE2(fnrpc_fnserverobjectreadvalues_1,_SVCSUFFIX)
		( fnServerObjectReadValues_args * pArguments,
#ifdef MULTITHREAD
		  fnServerObjectReadValues_rets * pResult,
#endif
		  struct svc_req * pRequest )
{
  static const char	__procedure__[]	= "server:fnrpc_fnserverobjectreadvalues_1";
#ifdef MULTITHREAD
  typedef bool_t RESULTTYPE;
#else
  typedef fnServerObjectReadValues_rets * RESULTTYPE;
#endif
#ifndef MULTITHREAD
  static fnServerObjectReadValues_rets	Result;
  RESULTTYPE			pResult = &Result;
#endif
  LPCSTR	pszErrorMsg;

  __pRequest__	= pRequest;

  RPC_SERVER_ENTRY();

#ifndef MULTITHREAD
  if ( pResult->pszErrorMsg == szEmpty ) {
    pResult->pszErrorMsg	= NULL;
  }
  xdr_free ( (xdrproc_t) xdr_fnServerObjectReadValues_rets, (char *) pResult );
#endif
  pResult->nErrorLvl		= 0;

  pResult->pBuffer.void_vector_t_len	= pArguments->pBufferSize;
  if ( pArguments->pBufferSize == 0 ) {
    pResult->pBuffer.void_vector_t_val	= NULL;
  } else {
    pResult->pBuffer.void_vector_t_val	=
      (char*) malloc ( pArguments->pBufferSize *
               SIZEOF ( *(pResult->pBuffer.void_vector_t_val) ) );
    if ( pResult->pBuffer.void_vector_t_val == NULL ) {
      char	szError [ 256 ];
      sprintf ( szError, szFormatMallocFailed,
                __procedure__, pArguments->pBufferSize,
                "pBuffer" );
      RPC_SERVER_ERROR ( szError );
      return (RESULTTYPE) NULL;
    }
  }
  Reply.bAnswered		= FALSE;
  Reply.pfnCalled		= (void(*)()) fnServerObjectReadValues;
  Reply.pfnXdrResult		= (bool_t(*)()) xdr_fnServerObjectReadValues_rets;
  Reply.pnErrorLvl		= &pResult->nErrorLvl;
  Reply.ppszErrorMsg		= (LPCSTR *) &pResult->pszErrorMsg;
  Reply.pResult		= pResult;
  Reply.pReturnValue		= &pResult->ReturnValue;
  Reply.nReturnValueSize	= sizeof ( pResult->ReturnValue );

  pResult->ReturnValue		=
  fnServerObjectReadValues (
	pArguments->oShortObjIdHeap,
	pArguments->oShortObjId,
	pArguments->oExpectingClass,
	pArguments->nExpectingTypeTag,
	pArguments->nIndex,
	pArguments->nElementTypeTagIn,
	pArguments->nSizeInElementsIn,
	&pResult->pnElementTypeTagOut,
	&pResult->pnSizeInElementsOut,
	pResult->pBuffer.void_vector_t_val );

  if ( Reply.bAnswered ) {
    __pRequest__	= NULL;
    return (RESULTTYPE) NULL;
  }

  pResult->nErrorLvl	= RPC_SERVER_ERRLVL();
  if ( pResult->nErrorLvl > 0 ) {
    pszErrorMsg		= RPC_SERVER_ERRMSG();
    if ( pszErrorMsg && *pszErrorMsg ) {
      pResult->pszErrorMsg	= strdup ( pszErrorMsg );
    }
  }
  if ( pResult->pszErrorMsg == NULL ) {
#ifdef MULTITHREAD
    pResult->pszErrorMsg	= strdup ( szEmpty );
#else
    pResult->pszErrorMsg	= (LPSTR) szEmpty;
#endif
  }
  __pRequest__	= NULL;
  return (RESULTTYPE) pResult;
} /* fnrpc_fnserverobjectreadvalues_1 */




extern bool_t fnClientDbStatistics
	(SHORTOBJID oShortObjIdHeap ,
	  int * pnMaximumSpace ,
	  int * pnAllocatedSpace ,
	  int * pnUnallocatedSpace ,
	  int * pnUnusedAllocatedSpace ,
	  int * pnAllocatedManagementSpace ,
	  int * pnNumberOfObjects);

#ifdef MULTITHREAD
bool_t
#else
fnClientDbStatistics_rets *
#endif
	PASTE2(fnrpc_fnclientdbstatistics_1,_SVCSUFFIX)
		( SHORTOBJID * pArguments,
#ifdef MULTITHREAD
		  fnClientDbStatistics_rets * pResult,
#endif
		  struct svc_req * pRequest )
{
  static const char	__procedure__[]	= "server:fnrpc_fnclientdbstatistics_1";
#ifdef MULTITHREAD
  typedef bool_t RESULTTYPE;
#else
  typedef fnClientDbStatistics_rets * RESULTTYPE;
#endif
#ifndef MULTITHREAD
  static fnClientDbStatistics_rets	Result;
  RESULTTYPE			pResult = &Result;
#endif
  LPCSTR	pszErrorMsg;

  __pRequest__	= pRequest;

  RPC_SERVER_ENTRY();

#ifndef MULTITHREAD
  if ( pResult->pszErrorMsg == szEmpty ) {
    pResult->pszErrorMsg	= NULL;
  }
  xdr_free ( (xdrproc_t) xdr_fnClientDbStatistics_rets, (char *) pResult );
#endif
  pResult->nErrorLvl		= 0;

  Reply.bAnswered		= FALSE;
  Reply.pfnCalled		= (void(*)()) fnClientDbStatistics;
  Reply.pfnXdrResult		= (bool_t(*)()) xdr_fnClientDbStatistics_rets;
  Reply.pnErrorLvl		= &pResult->nErrorLvl;
  Reply.ppszErrorMsg		= (LPCSTR *) &pResult->pszErrorMsg;
  Reply.pResult		= pResult;
  Reply.pReturnValue		= &pResult->ReturnValue;
  Reply.nReturnValueSize	= sizeof ( pResult->ReturnValue );

  pResult->ReturnValue		=
  fnClientDbStatistics (
	(*pArguments),
	&pResult->pnMaximumSpace,
	&pResult->pnAllocatedSpace,
	&pResult->pnUnallocatedSpace,
	&pResult->pnUnusedAllocatedSpace,
	&pResult->pnAllocatedManagementSpace,
	&pResult->pnNumberOfObjects );

  if ( Reply.bAnswered ) {
    __pRequest__	= NULL;
    return (RESULTTYPE) NULL;
  }

  pResult->nErrorLvl	= RPC_SERVER_ERRLVL();
  if ( pResult->nErrorLvl > 0 ) {
    pszErrorMsg		= RPC_SERVER_ERRMSG();
    if ( pszErrorMsg && *pszErrorMsg ) {
      pResult->pszErrorMsg	= strdup ( pszErrorMsg );
    }
  }
  if ( pResult->pszErrorMsg == NULL ) {
#ifdef MULTITHREAD
    pResult->pszErrorMsg	= strdup ( szEmpty );
#else
    pResult->pszErrorMsg	= (LPSTR) szEmpty;
#endif
  }
  __pRequest__	= NULL;
  return (RESULTTYPE) pResult;
} /* fnrpc_fnclientdbstatistics_1 */




extern void fnServerDbStabilise
	(SHORTOBJID oShortObjIdHeap);

#ifdef MULTITHREAD
bool_t
#else
void *
#endif
	PASTE2(fnrpc_fnserverdbstabilise_batch_1,_SVCSUFFIX)
		( SHORTOBJID * pArguments,
#ifdef MULTITHREAD
		  void * pResult,
#endif
		  struct svc_req * pRequest )
{
  static const char	__procedure__[]	= "server:fnrpc_fnserverdbstabilise_batch_1";
#ifdef MULTITHREAD
  typedef bool_t RESULTTYPE;
#else
  typedef void * RESULTTYPE;
#endif

  __pRequest__	= pRequest;

  RPC_SERVER_ENTRY();

  Reply.bAnswered		= TRUE;
  Reply.pfnCalled		= (void(*)()) fnServerDbStabilise;
  Reply.pfnXdrResult		= (bool_t(*)()) xdr_void;
  Reply.pnErrorLvl		= NULL;
  Reply.ppszErrorMsg		= NULL;
  Reply.pResult			= NULL;
  Reply.pReturnValue		= NULL;
  Reply.nReturnValueSize	= 0;
  fnServerDbStabilise (
	(*pArguments) );
  __pRequest__	= NULL;
  return (RESULTTYPE) NULL;
} /* fnrpc_fnserverdbstabilise_batch_1 */




extern SHTYPETAG fnServerObjectTypeTag
	(SHORTOBJID oShortObjIdHeap ,
	  SHORTOBJID oShortObjId);

#ifdef MULTITHREAD
bool_t
#else
fnServerObjectTypeTag_rets *
#endif
	PASTE2(fnrpc_fnserverobjecttypetag_1,_SVCSUFFIX)
		( fnServerObjectTypeTag_args * pArguments,
#ifdef MULTITHREAD
		  fnServerObjectTypeTag_rets * pResult,
#endif
		  struct svc_req * pRequest )
{
  static const char	__procedure__[]	= "server:fnrpc_fnserverobjecttypetag_1";
#ifdef MULTITHREAD
  typedef bool_t RESULTTYPE;
#else
  typedef fnServerObjectTypeTag_rets * RESULTTYPE;
#endif
#ifndef MULTITHREAD
  static fnServerObjectTypeTag_rets	Result;
  RESULTTYPE			pResult = &Result;
#endif
  LPCSTR	pszErrorMsg;

  __pRequest__	= pRequest;

  RPC_SERVER_ENTRY();

#ifndef MULTITHREAD
  if ( pResult->pszErrorMsg == szEmpty ) {
    pResult->pszErrorMsg	= NULL;
  }
  xdr_free ( (xdrproc_t) xdr_fnServerObjectTypeTag_rets, (char *) pResult );
#endif
  pResult->nErrorLvl		= 0;

  Reply.bAnswered		= FALSE;
  Reply.pfnCalled		= (void(*)()) fnServerObjectTypeTag;
  Reply.pfnXdrResult		= (bool_t(*)()) xdr_fnServerObjectTypeTag_rets;
  Reply.pnErrorLvl		= &pResult->nErrorLvl;
  Reply.ppszErrorMsg		= (LPCSTR *) &pResult->pszErrorMsg;
  Reply.pResult		= pResult;
  Reply.pReturnValue		= &pResult->ReturnValue;
  Reply.nReturnValueSize	= sizeof ( pResult->ReturnValue );

  pResult->ReturnValue		=
  fnServerObjectTypeTag (
	pArguments->oShortObjIdHeap,
	pArguments->oShortObjId );

  if ( Reply.bAnswered ) {
    __pRequest__	= NULL;
    return (RESULTTYPE) NULL;
  }

  pResult->nErrorLvl	= RPC_SERVER_ERRLVL();
  if ( pResult->nErrorLvl > 0 ) {
    pszErrorMsg		= RPC_SERVER_ERRMSG();
    if ( pszErrorMsg && *pszErrorMsg ) {
      pResult->pszErrorMsg	= strdup ( pszErrorMsg );
    }
  }
  if ( pResult->pszErrorMsg == NULL ) {
#ifdef MULTITHREAD
    pResult->pszErrorMsg	= strdup ( szEmpty );
#else
    pResult->pszErrorMsg	= (LPSTR) szEmpty;
#endif
  }
  __pRequest__	= NULL;
  return (RESULTTYPE) pResult;
} /* fnrpc_fnserverobjecttypetag_1 */




extern int fnServerObjectValueSize
	(SHORTOBJID oShortObjIdHeap ,
	  SHORTOBJID oShortObjId);

#ifdef MULTITHREAD
bool_t
#else
fnServerObjectValueSize_rets *
#endif
	PASTE2(fnrpc_fnserverobjectvaluesize_1,_SVCSUFFIX)
		( fnServerObjectValueSize_args * pArguments,
#ifdef MULTITHREAD
		  fnServerObjectValueSize_rets * pResult,
#endif
		  struct svc_req * pRequest )
{
  static const char	__procedure__[]	= "server:fnrpc_fnserverobjectvaluesize_1";
#ifdef MULTITHREAD
  typedef bool_t RESULTTYPE;
#else
  typedef fnServerObjectValueSize_rets * RESULTTYPE;
#endif
#ifndef MULTITHREAD
  static fnServerObjectValueSize_rets	Result;
  RESULTTYPE			pResult = &Result;
#endif
  LPCSTR	pszErrorMsg;

  __pRequest__	= pRequest;

  RPC_SERVER_ENTRY();

#ifndef MULTITHREAD
  if ( pResult->pszErrorMsg == szEmpty ) {
    pResult->pszErrorMsg	= NULL;
  }
  xdr_free ( (xdrproc_t) xdr_fnServerObjectValueSize_rets, (char *) pResult );
#endif
  pResult->nErrorLvl		= 0;

  Reply.bAnswered		= FALSE;
  Reply.pfnCalled		= (void(*)()) fnServerObjectValueSize;
  Reply.pfnXdrResult		= (bool_t(*)()) xdr_fnServerObjectValueSize_rets;
  Reply.pnErrorLvl		= &pResult->nErrorLvl;
  Reply.ppszErrorMsg		= (LPCSTR *) &pResult->pszErrorMsg;
  Reply.pResult		= pResult;
  Reply.pReturnValue		= &pResult->ReturnValue;
  Reply.nReturnValueSize	= sizeof ( pResult->ReturnValue );

  pResult->ReturnValue		=
  fnServerObjectValueSize (
	pArguments->oShortObjIdHeap,
	pArguments->oShortObjId );

  if ( Reply.bAnswered ) {
    __pRequest__	= NULL;
    return (RESULTTYPE) NULL;
  }

  pResult->nErrorLvl	= RPC_SERVER_ERRLVL();
  if ( pResult->nErrorLvl > 0 ) {
    pszErrorMsg		= RPC_SERVER_ERRMSG();
    if ( pszErrorMsg && *pszErrorMsg ) {
      pResult->pszErrorMsg	= strdup ( pszErrorMsg );
    }
  }
  if ( pResult->pszErrorMsg == NULL ) {
#ifdef MULTITHREAD
    pResult->pszErrorMsg	= strdup ( szEmpty );
#else
    pResult->pszErrorMsg	= (LPSTR) szEmpty;
#endif
  }
  __pRequest__	= NULL;
  return (RESULTTYPE) pResult;
} /* fnrpc_fnserverobjectvaluesize_1 */




extern SHLOCK fnServerObjectWriteAtIndex
	(SHORTOBJID oShortObjIdHeap ,
	  SHORTOBJID oShortObjId ,
	  SHORTOBJID oExpectingClass ,
	  SHTYPETAG nExpectingTypeTag ,
	  int nIndex ,
	  int nValue ,
	  SHTYPETAG nTypeTagValue);

#ifdef MULTITHREAD
bool_t
#else
fnServerObjectWriteAtIndex_rets *
#endif
	PASTE2(fnrpc_fnserverobjectwriteatindex_1,_SVCSUFFIX)
		( fnServerObjectWriteAtIndex_args * pArguments,
#ifdef MULTITHREAD
		  fnServerObjectWriteAtIndex_rets * pResult,
#endif
		  struct svc_req * pRequest )
{
  static const char	__procedure__[]	= "server:fnrpc_fnserverobjectwriteatindex_1";
#ifdef MULTITHREAD
  typedef bool_t RESULTTYPE;
#else
  typedef fnServerObjectWriteAtIndex_rets * RESULTTYPE;
#endif
#ifndef MULTITHREAD
  static fnServerObjectWriteAtIndex_rets	Result;
  RESULTTYPE			pResult = &Result;
#endif
  LPCSTR	pszErrorMsg;

  __pRequest__	= pRequest;

  RPC_SERVER_ENTRY();

#ifndef MULTITHREAD
  if ( pResult->pszErrorMsg == szEmpty ) {
    pResult->pszErrorMsg	= NULL;
  }
  xdr_free ( (xdrproc_t) xdr_fnServerObjectWriteAtIndex_rets, (char *) pResult );
#endif
  pResult->nErrorLvl		= 0;

  Reply.bAnswered		= FALSE;
  Reply.pfnCalled		= (void(*)()) fnServerObjectWriteAtIndex;
  Reply.pfnXdrResult		= (bool_t(*)()) xdr_fnServerObjectWriteAtIndex_rets;
  Reply.pnErrorLvl		= &pResult->nErrorLvl;
  Reply.ppszErrorMsg		= (LPCSTR *) &pResult->pszErrorMsg;
  Reply.pResult		= pResult;
  Reply.pReturnValue		= &pResult->ReturnValue;
  Reply.nReturnValueSize	= sizeof ( pResult->ReturnValue );

  pResult->ReturnValue		=
  fnServerObjectWriteAtIndex (
	pArguments->oShortObjIdHeap,
	pArguments->oShortObjId,
	pArguments->oExpectingClass,
	pArguments->nExpectingTypeTag,
	pArguments->nIndex,
	pArguments->nValue,
	pArguments->nTypeTagValue );

  if ( Reply.bAnswered ) {
    __pRequest__	= NULL;
    return (RESULTTYPE) NULL;
  }

  pResult->nErrorLvl	= RPC_SERVER_ERRLVL();
  if ( pResult->nErrorLvl > 0 ) {
    pszErrorMsg		= RPC_SERVER_ERRMSG();
    if ( pszErrorMsg && *pszErrorMsg ) {
      pResult->pszErrorMsg	= strdup ( pszErrorMsg );
    }
  }
  if ( pResult->pszErrorMsg == NULL ) {
#ifdef MULTITHREAD
    pResult->pszErrorMsg	= strdup ( szEmpty );
#else
    pResult->pszErrorMsg	= (LPSTR) szEmpty;
#endif
  }
  __pRequest__	= NULL;
  return (RESULTTYPE) pResult;
} /* fnrpc_fnserverobjectwriteatindex_1 */




extern int fnServerObjectWriteAtIndices
	(SHORTOBJID oShortObjIdHeap ,
	  SHORTOBJID oShortObjId ,
	  SHORTOBJID oExpectingClass ,
	  SHTYPETAG nExpectingTypeTag ,
	  int nIndex ,
	  int nObjIds ,
	  int * /* _vector_t<nObjIds> */ pObjIds ,
	  u_int * /* _vector_t<nObjIds> */ pnTypeTags);

#ifdef MULTITHREAD
bool_t
#else
fnServerObjectWriteAtIndices_rets *
#endif
	PASTE2(fnrpc_fnserverobjectwriteatindices_1,_SVCSUFFIX)
		( fnServerObjectWriteAtIndices_args * pArguments,
#ifdef MULTITHREAD
		  fnServerObjectWriteAtIndices_rets * pResult,
#endif
		  struct svc_req * pRequest )
{
  static const char	__procedure__[]	= "server:fnrpc_fnserverobjectwriteatindices_1";
#ifdef MULTITHREAD
  typedef bool_t RESULTTYPE;
#else
  typedef fnServerObjectWriteAtIndices_rets * RESULTTYPE;
#endif
#ifndef MULTITHREAD
  static fnServerObjectWriteAtIndices_rets	Result;
  RESULTTYPE			pResult = &Result;
#endif
  LPCSTR	pszErrorMsg;

  __pRequest__	= pRequest;

  RPC_SERVER_ENTRY();

#ifndef MULTITHREAD
  if ( pResult->pszErrorMsg == szEmpty ) {
    pResult->pszErrorMsg	= NULL;
  }
  xdr_free ( (xdrproc_t) xdr_fnServerObjectWriteAtIndices_rets, (char *) pResult );
#endif
  pResult->nErrorLvl		= 0;

  Reply.bAnswered		= FALSE;
  Reply.pfnCalled		= (void(*)()) fnServerObjectWriteAtIndices;
  Reply.pfnXdrResult		= (bool_t(*)()) xdr_fnServerObjectWriteAtIndices_rets;
  Reply.pnErrorLvl		= &pResult->nErrorLvl;
  Reply.ppszErrorMsg		= (LPCSTR *) &pResult->pszErrorMsg;
  Reply.pResult		= pResult;
  Reply.pReturnValue		= &pResult->ReturnValue;
  Reply.nReturnValueSize	= sizeof ( pResult->ReturnValue );

  pResult->ReturnValue		=
  fnServerObjectWriteAtIndices (
	pArguments->oShortObjIdHeap,
	pArguments->oShortObjId,
	pArguments->oExpectingClass,
	pArguments->nExpectingTypeTag,
	pArguments->nIndex,
	pArguments->nObjIds,
	pArguments->pObjIds.int_vector_t_val,
	pArguments->pnTypeTags.u_int_vector_t_val );

  if ( Reply.bAnswered ) {
    __pRequest__	= NULL;
    return (RESULTTYPE) NULL;
  }

  pResult->nErrorLvl	= RPC_SERVER_ERRLVL();
  if ( pResult->nErrorLvl > 0 ) {
    pszErrorMsg		= RPC_SERVER_ERRMSG();
    if ( pszErrorMsg && *pszErrorMsg ) {
      pResult->pszErrorMsg	= strdup ( pszErrorMsg );
    }
  }
  if ( pResult->pszErrorMsg == NULL ) {
#ifdef MULTITHREAD
    pResult->pszErrorMsg	= strdup ( szEmpty );
#else
    pResult->pszErrorMsg	= (LPSTR) szEmpty;
#endif
  }
  __pRequest__	= NULL;
  return (RESULTTYPE) pResult;
} /* fnrpc_fnserverobjectwriteatindices_1 */




extern SHLOCK fnServerObjectWriteObjId
	(SHORTOBJID oShortObjIdHeap ,
	  SHORTOBJID oShortObjId ,
	  SHORTOBJID oExpectingClass ,
	  SHTYPETAG nExpectingTypeTag ,
	  int nIndex ,
	  SHORTOBJID oShortObjIdWrite);

#ifdef MULTITHREAD
bool_t
#else
fnServerObjectWriteObjId_rets *
#endif
	PASTE2(fnrpc_fnserverobjectwriteobjid_1,_SVCSUFFIX)
		( fnServerObjectWriteObjId_args * pArguments,
#ifdef MULTITHREAD
		  fnServerObjectWriteObjId_rets * pResult,
#endif
		  struct svc_req * pRequest )
{
  static const char	__procedure__[]	= "server:fnrpc_fnserverobjectwriteobjid_1";
#ifdef MULTITHREAD
  typedef bool_t RESULTTYPE;
#else
  typedef fnServerObjectWriteObjId_rets * RESULTTYPE;
#endif
#ifndef MULTITHREAD
  static fnServerObjectWriteObjId_rets	Result;
  RESULTTYPE			pResult = &Result;
#endif
  LPCSTR	pszErrorMsg;

  __pRequest__	= pRequest;

  RPC_SERVER_ENTRY();

#ifndef MULTITHREAD
  if ( pResult->pszErrorMsg == szEmpty ) {
    pResult->pszErrorMsg	= NULL;
  }
  xdr_free ( (xdrproc_t) xdr_fnServerObjectWriteObjId_rets, (char *) pResult );
#endif
  pResult->nErrorLvl		= 0;

  Reply.bAnswered		= FALSE;
  Reply.pfnCalled		= (void(*)()) fnServerObjectWriteObjId;
  Reply.pfnXdrResult		= (bool_t(*)()) xdr_fnServerObjectWriteObjId_rets;
  Reply.pnErrorLvl		= &pResult->nErrorLvl;
  Reply.ppszErrorMsg		= (LPCSTR *) &pResult->pszErrorMsg;
  Reply.pResult		= pResult;
  Reply.pReturnValue		= &pResult->ReturnValue;
  Reply.nReturnValueSize	= sizeof ( pResult->ReturnValue );

  pResult->ReturnValue		=
  fnServerObjectWriteObjId (
	pArguments->oShortObjIdHeap,
	pArguments->oShortObjId,
	pArguments->oExpectingClass,
	pArguments->nExpectingTypeTag,
	pArguments->nIndex,
	pArguments->oShortObjIdWrite );

  if ( Reply.bAnswered ) {
    __pRequest__	= NULL;
    return (RESULTTYPE) NULL;
  }

  pResult->nErrorLvl	= RPC_SERVER_ERRLVL();
  if ( pResult->nErrorLvl > 0 ) {
    pszErrorMsg		= RPC_SERVER_ERRMSG();
    if ( pszErrorMsg && *pszErrorMsg ) {
      pResult->pszErrorMsg	= strdup ( pszErrorMsg );
    }
  }
  if ( pResult->pszErrorMsg == NULL ) {
#ifdef MULTITHREAD
    pResult->pszErrorMsg	= strdup ( szEmpty );
#else
    pResult->pszErrorMsg	= (LPSTR) szEmpty;
#endif
  }
  __pRequest__	= NULL;
  return (RESULTTYPE) pResult;
} /* fnrpc_fnserverobjectwriteobjid_1 */




extern int fnServerObjectWriteValues
	(SHORTOBJID oShortObjIdHeap ,
	  SHORTOBJID oShortObjId ,
	  SHORTOBJID oExpectingClass ,
	  SHTYPETAG nExpectingTypeTag ,
	  int nIndex ,
	  SHTYPETAG nElementTypeTag ,
	  int nSizeInElements ,
	  void * /* _vector_t<((( fnTypeTagSizeValue(1,&nElementTypeTag, &nSizeInElements ) )*( sizeof(int) )) )> */ pBuffer);

#ifdef MULTITHREAD
bool_t
#else
fnServerObjectWriteValues_rets *
#endif
	PASTE2(fnrpc_fnserverobjectwritevalues_1,_SVCSUFFIX)
		( fnServerObjectWriteValues_args * pArguments,
#ifdef MULTITHREAD
		  fnServerObjectWriteValues_rets * pResult,
#endif
		  struct svc_req * pRequest )
{
  static const char	__procedure__[]	= "server:fnrpc_fnserverobjectwritevalues_1";
#ifdef MULTITHREAD
  typedef bool_t RESULTTYPE;
#else
  typedef fnServerObjectWriteValues_rets * RESULTTYPE;
#endif
#ifndef MULTITHREAD
  static fnServerObjectWriteValues_rets	Result;
  RESULTTYPE			pResult = &Result;
#endif
  LPCSTR	pszErrorMsg;

  __pRequest__	= pRequest;

  RPC_SERVER_ENTRY();

#ifndef MULTITHREAD
  if ( pResult->pszErrorMsg == szEmpty ) {
    pResult->pszErrorMsg	= NULL;
  }
  xdr_free ( (xdrproc_t) xdr_fnServerObjectWriteValues_rets, (char *) pResult );
#endif
  pResult->nErrorLvl		= 0;

  Reply.bAnswered		= FALSE;
  Reply.pfnCalled		= (void(*)()) fnServerObjectWriteValues;
  Reply.pfnXdrResult		= (bool_t(*)()) xdr_fnServerObjectWriteValues_rets;
  Reply.pnErrorLvl		= &pResult->nErrorLvl;
  Reply.ppszErrorMsg		= (LPCSTR *) &pResult->pszErrorMsg;
  Reply.pResult		= pResult;
  Reply.pReturnValue		= &pResult->ReturnValue;
  Reply.nReturnValueSize	= sizeof ( pResult->ReturnValue );

  pResult->ReturnValue		=
  fnServerObjectWriteValues (
	pArguments->oShortObjIdHeap,
	pArguments->oShortObjId,
	pArguments->oExpectingClass,
	pArguments->nExpectingTypeTag,
	pArguments->nIndex,
	pArguments->nElementTypeTag,
	pArguments->nSizeInElements,
	pArguments->pBuffer.void_vector_t_val );

  if ( Reply.bAnswered ) {
    __pRequest__	= NULL;
    return (RESULTTYPE) NULL;
  }

  pResult->nErrorLvl	= RPC_SERVER_ERRLVL();
  if ( pResult->nErrorLvl > 0 ) {
    pszErrorMsg		= RPC_SERVER_ERRMSG();
    if ( pszErrorMsg && *pszErrorMsg ) {
      pResult->pszErrorMsg	= strdup ( pszErrorMsg );
    }
  }
  if ( pResult->pszErrorMsg == NULL ) {
#ifdef MULTITHREAD
    pResult->pszErrorMsg	= strdup ( szEmpty );
#else
    pResult->pszErrorMsg	= (LPSTR) szEmpty;
#endif
  }
  __pRequest__	= NULL;
  return (RESULTTYPE) pResult;
} /* fnrpc_fnserverobjectwritevalues_1 */




extern DEPENDENTMODE fnShortMakeDependent
	(SHORTOBJID oShortObjIdHeap ,
	  SHORTOBJID oShortSelf ,
	  DEPENDENTMODE nDependentMode);

#ifdef MULTITHREAD
bool_t
#else
fnShortMakeDependent_rets *
#endif
	PASTE2(fnrpc_fnshortmakedependent_1,_SVCSUFFIX)
		( fnShortMakeDependent_args * pArguments,
#ifdef MULTITHREAD
		  fnShortMakeDependent_rets * pResult,
#endif
		  struct svc_req * pRequest )
{
  static const char	__procedure__[]	= "server:fnrpc_fnshortmakedependent_1";
#ifdef MULTITHREAD
  typedef bool_t RESULTTYPE;
#else
  typedef fnShortMakeDependent_rets * RESULTTYPE;
#endif
#ifndef MULTITHREAD
  static fnShortMakeDependent_rets	Result;
  RESULTTYPE			pResult = &Result;
#endif
  LPCSTR	pszErrorMsg;

  __pRequest__	= pRequest;

  RPC_SERVER_ENTRY();

#ifndef MULTITHREAD
  if ( pResult->pszErrorMsg == szEmpty ) {
    pResult->pszErrorMsg	= NULL;
  }
  xdr_free ( (xdrproc_t) xdr_fnShortMakeDependent_rets, (char *) pResult );
#endif
  pResult->nErrorLvl		= 0;

  Reply.bAnswered		= FALSE;
  Reply.pfnCalled		= (void(*)()) fnShortMakeDependent;
  Reply.pfnXdrResult		= (bool_t(*)()) xdr_fnShortMakeDependent_rets;
  Reply.pnErrorLvl		= &pResult->nErrorLvl;
  Reply.ppszErrorMsg		= (LPCSTR *) &pResult->pszErrorMsg;
  Reply.pResult		= pResult;
  Reply.pReturnValue		= &pResult->ReturnValue;
  Reply.nReturnValueSize	= sizeof ( pResult->ReturnValue );

  pResult->ReturnValue		=
  fnShortMakeDependent (
	pArguments->oShortObjIdHeap,
	pArguments->oShortSelf,
	pArguments->nDependentMode );

  if ( Reply.bAnswered ) {
    __pRequest__	= NULL;
    return (RESULTTYPE) NULL;
  }

  pResult->nErrorLvl	= RPC_SERVER_ERRLVL();
  if ( pResult->nErrorLvl > 0 ) {
    pszErrorMsg		= RPC_SERVER_ERRMSG();
    if ( pszErrorMsg && *pszErrorMsg ) {
      pResult->pszErrorMsg	= strdup ( pszErrorMsg );
    }
  }
  if ( pResult->pszErrorMsg == NULL ) {
#ifdef MULTITHREAD
    pResult->pszErrorMsg	= strdup ( szEmpty );
#else
    pResult->pszErrorMsg	= (LPSTR) szEmpty;
#endif
  }
  __pRequest__	= NULL;
  return (RESULTTYPE) pResult;
} /* fnrpc_fnshortmakedependent_1 */




extern SHLOCK fnServerObjectPeekSlots
	(SHORTOBJID oShortObjIdHeap ,
	  int hPeek ,
	  int nWords ,
	  u_int * /* _vector_t<nWords> */  pBuffer);

#ifdef MULTITHREAD
bool_t
#else
fnServerObjectPeekSlots_rets *
#endif
	PASTE2(fnrpc_fnserverobjectpeekslots_1,_SVCSUFFIX)
		( fnServerObjectPeekSlots_args * pArguments,
#ifdef MULTITHREAD
		  fnServerObjectPeekSlots_rets * pResult,
#endif
		  struct svc_req * pRequest )
{
  static const char	__procedure__[]	= "server:fnrpc_fnserverobjectpeekslots_1";
#ifdef MULTITHREAD
  typedef bool_t RESULTTYPE;
#else
  typedef fnServerObjectPeekSlots_rets * RESULTTYPE;
#endif
#ifndef MULTITHREAD
  static fnServerObjectPeekSlots_rets	Result;
  RESULTTYPE			pResult = &Result;
#endif
  LPCSTR	pszErrorMsg;

  __pRequest__	= pRequest;

  RPC_SERVER_ENTRY();

#ifndef MULTITHREAD
  if ( pResult->pszErrorMsg == szEmpty ) {
    pResult->pszErrorMsg	= NULL;
  }
  xdr_free ( (xdrproc_t) xdr_fnServerObjectPeekSlots_rets, (char *) pResult );
#endif
  pResult->nErrorLvl		= 0;

  pResult->pBuffer.u_int_vector_t_len	= pArguments->pBufferSize;
  if ( pArguments->pBufferSize == 0 ) {
    pResult->pBuffer.u_int_vector_t_val	= NULL;
  } else {
    pResult->pBuffer.u_int_vector_t_val	=
      (u_int*) malloc ( pArguments->pBufferSize *
               SIZEOF ( *(pResult->pBuffer.u_int_vector_t_val) ) );
    if ( pResult->pBuffer.u_int_vector_t_val == NULL ) {
      char	szError [ 256 ];
      sprintf ( szError, szFormatMallocFailed,
                __procedure__, pArguments->pBufferSize,
                "pBuffer" );
      RPC_SERVER_ERROR ( szError );
      return (RESULTTYPE) NULL;
    }
  }
  Reply.bAnswered		= FALSE;
  Reply.pfnCalled		= (void(*)()) fnServerObjectPeekSlots;
  Reply.pfnXdrResult		= (bool_t(*)()) xdr_fnServerObjectPeekSlots_rets;
  Reply.pnErrorLvl		= &pResult->nErrorLvl;
  Reply.ppszErrorMsg		= (LPCSTR *) &pResult->pszErrorMsg;
  Reply.pResult		= pResult;
  Reply.pReturnValue		= &pResult->ReturnValue;
  Reply.nReturnValueSize	= sizeof ( pResult->ReturnValue );

  pResult->ReturnValue		=
  fnServerObjectPeekSlots (
	pArguments->oShortObjIdHeap,
	pArguments->hPeek,
	pArguments->nWords,
	pResult->pBuffer.u_int_vector_t_val );

  if ( Reply.bAnswered ) {
    __pRequest__	= NULL;
    return (RESULTTYPE) NULL;
  }

  pResult->nErrorLvl	= RPC_SERVER_ERRLVL();
  if ( pResult->nErrorLvl > 0 ) {
    pszErrorMsg		= RPC_SERVER_ERRMSG();
    if ( pszErrorMsg && *pszErrorMsg ) {
      pResult->pszErrorMsg	= strdup ( pszErrorMsg );
    }
  }
  if ( pResult->pszErrorMsg == NULL ) {
#ifdef MULTITHREAD
    pResult->pszErrorMsg	= strdup ( szEmpty );
#else
    pResult->pszErrorMsg	= (LPSTR) szEmpty;
#endif
  }
  __pRequest__	= NULL;
  return (RESULTTYPE) pResult;
} /* fnrpc_fnserverobjectpeekslots_1 */




extern SHLOCK fnServerObjectPeekValues
	(SHORTOBJID oShortObjIdHeap ,
	  int hPeek ,
	  int nObjects ,
	  u_int * /* _vector_t<nObjects> */ pnElementTypeTagsIn ,
	  u_int * /* _vector_t<nObjects> */ pnSizesInElementsIn ,
	  u_int * /* _vector_t<nObjects> */  pnElementTypeTagsOut ,
	  u_int * /* _vector_t<nObjects> */  pnSizesInElementsOut ,
	  void * /* _vector_t<((( fnTypeTagSizeValue ( nObjects,pnElementTypeTagsIn, pnSizesInElementsIn ) )*( sizeof(int) )) )> */  pBuffer);

#ifdef MULTITHREAD
bool_t
#else
fnServerObjectPeekValues_rets *
#endif
	PASTE2(fnrpc_fnserverobjectpeekvalues_1,_SVCSUFFIX)
		( fnServerObjectPeekValues_args * pArguments,
#ifdef MULTITHREAD
		  fnServerObjectPeekValues_rets * pResult,
#endif
		  struct svc_req * pRequest )
{
  static const char	__procedure__[]	= "server:fnrpc_fnserverobjectpeekvalues_1";
#ifdef MULTITHREAD
  typedef bool_t RESULTTYPE;
#else
  typedef fnServerObjectPeekValues_rets * RESULTTYPE;
#endif
#ifndef MULTITHREAD
  static fnServerObjectPeekValues_rets	Result;
  RESULTTYPE			pResult = &Result;
#endif
  LPCSTR	pszErrorMsg;

  __pRequest__	= pRequest;

  RPC_SERVER_ENTRY();

#ifndef MULTITHREAD
  if ( pResult->pszErrorMsg == szEmpty ) {
    pResult->pszErrorMsg	= NULL;
  }
  xdr_free ( (xdrproc_t) xdr_fnServerObjectPeekValues_rets, (char *) pResult );
#endif
  pResult->nErrorLvl		= 0;

  pResult->pnElementTypeTagsOut.u_int_vector_t_len	= pArguments->pnElementTypeTagsOutSize;
  if ( pArguments->pnElementTypeTagsOutSize == 0 ) {
    pResult->pnElementTypeTagsOut.u_int_vector_t_val	= NULL;
  } else {
    pResult->pnElementTypeTagsOut.u_int_vector_t_val	=
      (u_int*) malloc ( pArguments->pnElementTypeTagsOutSize *
               SIZEOF ( *(pResult->pnElementTypeTagsOut.u_int_vector_t_val) ) );
    if ( pResult->pnElementTypeTagsOut.u_int_vector_t_val == NULL ) {
      char	szError [ 256 ];
      sprintf ( szError, szFormatMallocFailed,
                __procedure__, pArguments->pnElementTypeTagsOutSize,
                "pnElementTypeTagsOut" );
      RPC_SERVER_ERROR ( szError );
      return (RESULTTYPE) NULL;
    }
  }
  pResult->pnSizesInElementsOut.u_int_vector_t_len	= pArguments->pnSizesInElementsOutSize;
  if ( pArguments->pnSizesInElementsOutSize == 0 ) {
    pResult->pnSizesInElementsOut.u_int_vector_t_val	= NULL;
  } else {
    pResult->pnSizesInElementsOut.u_int_vector_t_val	=
      (u_int*) malloc ( pArguments->pnSizesInElementsOutSize *
               SIZEOF ( *(pResult->pnSizesInElementsOut.u_int_vector_t_val) ) );
    if ( pResult->pnSizesInElementsOut.u_int_vector_t_val == NULL ) {
      char	szError [ 256 ];
      sprintf ( szError, szFormatMallocFailed,
                __procedure__, pArguments->pnSizesInElementsOutSize,
                "pnSizesInElementsOut" );
      RPC_SERVER_ERROR ( szError );
      return (RESULTTYPE) NULL;
    }
  }
  pResult->pBuffer.void_vector_t_len	= pArguments->pBufferSize;
  if ( pArguments->pBufferSize == 0 ) {
    pResult->pBuffer.void_vector_t_val	= NULL;
  } else {
    pResult->pBuffer.void_vector_t_val	=
      (char*) malloc ( pArguments->pBufferSize *
               SIZEOF ( *(pResult->pBuffer.void_vector_t_val) ) );
    if ( pResult->pBuffer.void_vector_t_val == NULL ) {
      char	szError [ 256 ];
      sprintf ( szError, szFormatMallocFailed,
                __procedure__, pArguments->pBufferSize,
                "pBuffer" );
      RPC_SERVER_ERROR ( szError );
      return (RESULTTYPE) NULL;
    }
  }
  Reply.bAnswered		= FALSE;
  Reply.pfnCalled		= (void(*)()) fnServerObjectPeekValues;
  Reply.pfnXdrResult		= (bool_t(*)()) xdr_fnServerObjectPeekValues_rets;
  Reply.pnErrorLvl		= &pResult->nErrorLvl;
  Reply.ppszErrorMsg		= (LPCSTR *) &pResult->pszErrorMsg;
  Reply.pResult		= pResult;
  Reply.pReturnValue		= &pResult->ReturnValue;
  Reply.nReturnValueSize	= sizeof ( pResult->ReturnValue );

  pResult->ReturnValue		=
  fnServerObjectPeekValues (
	pArguments->oShortObjIdHeap,
	pArguments->hPeek,
	pArguments->nObjects,
	pArguments->pnElementTypeTagsIn.u_int_vector_t_val,
	pArguments->pnSizesInElementsIn.u_int_vector_t_val,
	pResult->pnElementTypeTagsOut.u_int_vector_t_val,
	pResult->pnSizesInElementsOut.u_int_vector_t_val,
	pResult->pBuffer.void_vector_t_val );

  if ( Reply.bAnswered ) {
    __pRequest__	= NULL;
    return (RESULTTYPE) NULL;
  }

  pResult->nErrorLvl	= RPC_SERVER_ERRLVL();
  if ( pResult->nErrorLvl > 0 ) {
    pszErrorMsg		= RPC_SERVER_ERRMSG();
    if ( pszErrorMsg && *pszErrorMsg ) {
      pResult->pszErrorMsg	= strdup ( pszErrorMsg );
    }
  }
  if ( pResult->pszErrorMsg == NULL ) {
#ifdef MULTITHREAD
    pResult->pszErrorMsg	= strdup ( szEmpty );
#else
    pResult->pszErrorMsg	= (LPSTR) szEmpty;
#endif
  }
  __pRequest__	= NULL;
  return (RESULTTYPE) pResult;
} /* fnrpc_fnserverobjectpeekvalues_1 */




extern void fnServerObjectPoke
	(SHORTOBJID oShortObjIdHeap ,
	  SHORTOBJID oShortObjId ,
	  int nSlots ,
	  u_int * /* _vector_t<nSlots> */ pSlots ,
	  SHTYPETAG nElementTypeTag ,
	  int nSizeInElements ,
	  void * /* _vector_t<((( fnTypeTagSizeValue(1,&nElementTypeTag, &nSizeInElements ) )*( sizeof(int) )) )> */ pValues);

#ifdef MULTITHREAD
bool_t
#else
void *
#endif
	PASTE2(fnrpc_fnserverobjectpoke_batch_1,_SVCSUFFIX)
		( fnServerObjectPoke_args * pArguments,
#ifdef MULTITHREAD
		  void * pResult,
#endif
		  struct svc_req * pRequest )
{
  static const char	__procedure__[]	= "server:fnrpc_fnserverobjectpoke_batch_1";
#ifdef MULTITHREAD
  typedef bool_t RESULTTYPE;
#else
  typedef void * RESULTTYPE;
#endif

  __pRequest__	= pRequest;

  RPC_SERVER_ENTRY();

  Reply.bAnswered		= TRUE;
  Reply.pfnCalled		= (void(*)()) fnServerObjectPoke;
  Reply.pfnXdrResult		= (bool_t(*)()) xdr_void;
  Reply.pnErrorLvl		= NULL;
  Reply.ppszErrorMsg		= NULL;
  Reply.pResult			= NULL;
  Reply.pReturnValue		= NULL;
  Reply.nReturnValueSize	= 0;
  fnServerObjectPoke (
	pArguments->oShortObjIdHeap,
	pArguments->oShortObjId,
	pArguments->nSlots,
	pArguments->pSlots.u_int_vector_t_val,
	pArguments->nElementTypeTag,
	pArguments->nSizeInElements,
	pArguments->pValues.void_vector_t_val );
  __pRequest__	= NULL;
  return (RESULTTYPE) NULL;
} /* fnrpc_fnserverobjectpoke_batch_1 */




extern FLUSHMODE fnFlushMode
	(SHORTOBJID oShortObjIdHeap ,
	  FLUSHMODE nMode);

#ifdef MULTITHREAD
bool_t
#else
fnFlushMode_rets *
#endif
	PASTE2(fnrpc_fnflushmode_1,_SVCSUFFIX)
		( fnFlushMode_args * pArguments,
#ifdef MULTITHREAD
		  fnFlushMode_rets * pResult,
#endif
		  struct svc_req * pRequest )
{
  static const char	__procedure__[]	= "server:fnrpc_fnflushmode_1";
#ifdef MULTITHREAD
  typedef bool_t RESULTTYPE;
#else
  typedef fnFlushMode_rets * RESULTTYPE;
#endif
#ifndef MULTITHREAD
  static fnFlushMode_rets	Result;
  RESULTTYPE			pResult = &Result;
#endif
  LPCSTR	pszErrorMsg;

  __pRequest__	= pRequest;

  RPC_SERVER_ENTRY();

#ifndef MULTITHREAD
  if ( pResult->pszErrorMsg == szEmpty ) {
    pResult->pszErrorMsg	= NULL;
  }
  xdr_free ( (xdrproc_t) xdr_fnFlushMode_rets, (char *) pResult );
#endif
  pResult->nErrorLvl		= 0;

  Reply.bAnswered		= FALSE;
  Reply.pfnCalled		= (void(*)()) fnFlushMode;
  Reply.pfnXdrResult		= (bool_t(*)()) xdr_fnFlushMode_rets;
  Reply.pnErrorLvl		= &pResult->nErrorLvl;
  Reply.ppszErrorMsg		= (LPCSTR *) &pResult->pszErrorMsg;
  Reply.pResult		= pResult;
  Reply.pReturnValue		= &pResult->ReturnValue;
  Reply.nReturnValueSize	= sizeof ( pResult->ReturnValue );

  pResult->ReturnValue		=
  fnFlushMode (
	pArguments->oShortObjIdHeap,
	pArguments->nMode );

  if ( Reply.bAnswered ) {
    __pRequest__	= NULL;
    return (RESULTTYPE) NULL;
  }

  pResult->nErrorLvl	= RPC_SERVER_ERRLVL();
  if ( pResult->nErrorLvl > 0 ) {
    pszErrorMsg		= RPC_SERVER_ERRMSG();
    if ( pszErrorMsg && *pszErrorMsg ) {
      pResult->pszErrorMsg	= strdup ( pszErrorMsg );
    }
  }
  if ( pResult->pszErrorMsg == NULL ) {
#ifdef MULTITHREAD
    pResult->pszErrorMsg	= strdup ( szEmpty );
#else
    pResult->pszErrorMsg	= (LPSTR) szEmpty;
#endif
  }
  __pRequest__	= NULL;
  return (RESULTTYPE) pResult;
} /* fnrpc_fnflushmode_1 */




extern int fnFlagWord
	(FLAGMODE nGetOrSet ,
	  int nFlagWord);

#ifdef MULTITHREAD
bool_t
#else
fnFlagWord_rets *
#endif
	PASTE2(fnrpc_fnflagword_1,_SVCSUFFIX)
		( fnFlagWord_args * pArguments,
#ifdef MULTITHREAD
		  fnFlagWord_rets * pResult,
#endif
		  struct svc_req * pRequest )
{
  static const char	__procedure__[]	= "server:fnrpc_fnflagword_1";
#ifdef MULTITHREAD
  typedef bool_t RESULTTYPE;
#else
  typedef fnFlagWord_rets * RESULTTYPE;
#endif
#ifndef MULTITHREAD
  static fnFlagWord_rets	Result;
  RESULTTYPE			pResult = &Result;
#endif
  LPCSTR	pszErrorMsg;

  __pRequest__	= pRequest;

  RPC_SERVER_ENTRY();

#ifndef MULTITHREAD
  if ( pResult->pszErrorMsg == szEmpty ) {
    pResult->pszErrorMsg	= NULL;
  }
  xdr_free ( (xdrproc_t) xdr_fnFlagWord_rets, (char *) pResult );
#endif
  pResult->nErrorLvl		= 0;

  Reply.bAnswered		= FALSE;
  Reply.pfnCalled		= (void(*)()) fnFlagWord;
  Reply.pfnXdrResult		= (bool_t(*)()) xdr_fnFlagWord_rets;
  Reply.pnErrorLvl		= &pResult->nErrorLvl;
  Reply.ppszErrorMsg		= (LPCSTR *) &pResult->pszErrorMsg;
  Reply.pResult		= pResult;
  Reply.pReturnValue		= &pResult->ReturnValue;
  Reply.nReturnValueSize	= sizeof ( pResult->ReturnValue );

  pResult->ReturnValue		=
  fnFlagWord (
	pArguments->nGetOrSet,
	pArguments->nFlagWord );

  if ( Reply.bAnswered ) {
    __pRequest__	= NULL;
    return (RESULTTYPE) NULL;
  }

  pResult->nErrorLvl	= RPC_SERVER_ERRLVL();
  if ( pResult->nErrorLvl > 0 ) {
    pszErrorMsg		= RPC_SERVER_ERRMSG();
    if ( pszErrorMsg && *pszErrorMsg ) {
      pResult->pszErrorMsg	= strdup ( pszErrorMsg );
    }
  }
  if ( pResult->pszErrorMsg == NULL ) {
#ifdef MULTITHREAD
    pResult->pszErrorMsg	= strdup ( szEmpty );
#else
    pResult->pszErrorMsg	= (LPSTR) szEmpty;
#endif
  }
  __pRequest__	= NULL;
  return (RESULTTYPE) pResult;
} /* fnrpc_fnflagword_1 */




extern SHORTOBJID fnShortMakeIVector
	(SHORTOBJID oShortObjIdHeap ,
	  SHTYPETAG nTypeTag ,
	  int nElements);

#ifdef MULTITHREAD
bool_t
#else
fnShortMakeIVector_rets *
#endif
	PASTE2(fnrpc_fnshortmakeivector_1,_SVCSUFFIX)
		( fnShortMakeIVector_args * pArguments,
#ifdef MULTITHREAD
		  fnShortMakeIVector_rets * pResult,
#endif
		  struct svc_req * pRequest )
{
  static const char	__procedure__[]	= "server:fnrpc_fnshortmakeivector_1";
#ifdef MULTITHREAD
  typedef bool_t RESULTTYPE;
#else
  typedef fnShortMakeIVector_rets * RESULTTYPE;
#endif
#ifndef MULTITHREAD
  static fnShortMakeIVector_rets	Result;
  RESULTTYPE			pResult = &Result;
#endif
  LPCSTR	pszErrorMsg;

  __pRequest__	= pRequest;

  RPC_SERVER_ENTRY();

#ifndef MULTITHREAD
  if ( pResult->pszErrorMsg == szEmpty ) {
    pResult->pszErrorMsg	= NULL;
  }
  xdr_free ( (xdrproc_t) xdr_fnShortMakeIVector_rets, (char *) pResult );
#endif
  pResult->nErrorLvl		= 0;

  Reply.bAnswered		= FALSE;
  Reply.pfnCalled		= (void(*)()) fnShortMakeIVector;
  Reply.pfnXdrResult		= (bool_t(*)()) xdr_fnShortMakeIVector_rets;
  Reply.pnErrorLvl		= &pResult->nErrorLvl;
  Reply.ppszErrorMsg		= (LPCSTR *) &pResult->pszErrorMsg;
  Reply.pResult		= pResult;
  Reply.pReturnValue		= &pResult->ReturnValue;
  Reply.nReturnValueSize	= sizeof ( pResult->ReturnValue );

  pResult->ReturnValue		=
  fnShortMakeIVector (
	pArguments->oShortObjIdHeap,
	pArguments->nTypeTag,
	pArguments->nElements );

  if ( Reply.bAnswered ) {
    __pRequest__	= NULL;
    return (RESULTTYPE) NULL;
  }

  pResult->nErrorLvl	= RPC_SERVER_ERRLVL();
  if ( pResult->nErrorLvl > 0 ) {
    pszErrorMsg		= RPC_SERVER_ERRMSG();
    if ( pszErrorMsg && *pszErrorMsg ) {
      pResult->pszErrorMsg	= strdup ( pszErrorMsg );
    }
  }
  if ( pResult->pszErrorMsg == NULL ) {
#ifdef MULTITHREAD
    pResult->pszErrorMsg	= strdup ( szEmpty );
#else
    pResult->pszErrorMsg	= (LPSTR) szEmpty;
#endif
  }
  __pRequest__	= NULL;
  return (RESULTTYPE) pResult;
} /* fnrpc_fnshortmakeivector_1 */




extern SHORTOBJID fnShortMakeString
	(SHORTOBJID oShortObjIdHeap ,
	  string_t /* string_t<@conststring@> */ lpszFrom);

#ifdef MULTITHREAD
bool_t
#else
fnShortMakeString_rets *
#endif
	PASTE2(fnrpc_fnshortmakestring_1,_SVCSUFFIX)
		( fnShortMakeString_args * pArguments,
#ifdef MULTITHREAD
		  fnShortMakeString_rets * pResult,
#endif
		  struct svc_req * pRequest )
{
  static const char	__procedure__[]	= "server:fnrpc_fnshortmakestring_1";
#ifdef MULTITHREAD
  typedef bool_t RESULTTYPE;
#else
  typedef fnShortMakeString_rets * RESULTTYPE;
#endif
#ifndef MULTITHREAD
  static fnShortMakeString_rets	Result;
  RESULTTYPE			pResult = &Result;
#endif
  LPCSTR	pszErrorMsg;

  __pRequest__	= pRequest;

  RPC_SERVER_ENTRY();

#ifndef MULTITHREAD
  if ( pResult->pszErrorMsg == szEmpty ) {
    pResult->pszErrorMsg	= NULL;
  }
  xdr_free ( (xdrproc_t) xdr_fnShortMakeString_rets, (char *) pResult );
#endif
  pResult->nErrorLvl		= 0;

  Reply.bAnswered		= FALSE;
  Reply.pfnCalled		= (void(*)()) fnShortMakeString;
  Reply.pfnXdrResult		= (bool_t(*)()) xdr_fnShortMakeString_rets;
  Reply.pnErrorLvl		= &pResult->nErrorLvl;
  Reply.ppszErrorMsg		= (LPCSTR *) &pResult->pszErrorMsg;
  Reply.pResult		= pResult;
  Reply.pReturnValue		= &pResult->ReturnValue;
  Reply.nReturnValueSize	= sizeof ( pResult->ReturnValue );

  pResult->ReturnValue		=
  fnShortMakeString (
	pArguments->oShortObjIdHeap,
	pArguments->lpszFrom );

  if ( Reply.bAnswered ) {
    __pRequest__	= NULL;
    return (RESULTTYPE) NULL;
  }

  pResult->nErrorLvl	= RPC_SERVER_ERRLVL();
  if ( pResult->nErrorLvl > 0 ) {
    pszErrorMsg		= RPC_SERVER_ERRMSG();
    if ( pszErrorMsg && *pszErrorMsg ) {
      pResult->pszErrorMsg	= strdup ( pszErrorMsg );
    }
  }
  if ( pResult->pszErrorMsg == NULL ) {
#ifdef MULTITHREAD
    pResult->pszErrorMsg	= strdup ( szEmpty );
#else
    pResult->pszErrorMsg	= (LPSTR) szEmpty;
#endif
  }
  __pRequest__	= NULL;
  return (RESULTTYPE) pResult;
} /* fnrpc_fnshortmakestring_1 */




extern int fnServerDbCreateStructures
	(SHORTOBJID oShortObjIdHeap ,
	  SHORTOBJID oShortObjIdStructDescr ,
	  int nObjIds ,
	  u_int * /* _vector_t<nObjIds> */  pObjIds ,
	  u_int * pnSlots);

#ifdef MULTITHREAD
bool_t
#else
fnServerDbCreateStructures_rets *
#endif
	PASTE2(fnrpc_fnserverdbcreatestructures_1,_SVCSUFFIX)
		( fnServerDbCreateStructures_args * pArguments,
#ifdef MULTITHREAD
		  fnServerDbCreateStructures_rets * pResult,
#endif
		  struct svc_req * pRequest )
{
  static const char	__procedure__[]	= "server:fnrpc_fnserverdbcreatestructures_1";
#ifdef MULTITHREAD
  typedef bool_t RESULTTYPE;
#else
  typedef fnServerDbCreateStructures_rets * RESULTTYPE;
#endif
#ifndef MULTITHREAD
  static fnServerDbCreateStructures_rets	Result;
  RESULTTYPE			pResult = &Result;
#endif
  LPCSTR	pszErrorMsg;

  __pRequest__	= pRequest;

  RPC_SERVER_ENTRY();

#ifndef MULTITHREAD
  if ( pResult->pszErrorMsg == szEmpty ) {
    pResult->pszErrorMsg	= NULL;
  }
  xdr_free ( (xdrproc_t) xdr_fnServerDbCreateStructures_rets, (char *) pResult );
#endif
  pResult->nErrorLvl		= 0;

  pResult->pObjIds.u_int_vector_t_len	= pArguments->pObjIdsSize;
  if ( pArguments->pObjIdsSize == 0 ) {
    pResult->pObjIds.u_int_vector_t_val	= NULL;
  } else {
    pResult->pObjIds.u_int_vector_t_val	=
      (u_int*) malloc ( pArguments->pObjIdsSize *
               SIZEOF ( *(pResult->pObjIds.u_int_vector_t_val) ) );
    if ( pResult->pObjIds.u_int_vector_t_val == NULL ) {
      char	szError [ 256 ];
      sprintf ( szError, szFormatMallocFailed,
                __procedure__, pArguments->pObjIdsSize,
                "pObjIds" );
      RPC_SERVER_ERROR ( szError );
      return (RESULTTYPE) NULL;
    }
  }
  Reply.bAnswered		= FALSE;
  Reply.pfnCalled		= (void(*)()) fnServerDbCreateStructures;
  Reply.pfnXdrResult		= (bool_t(*)()) xdr_fnServerDbCreateStructures_rets;
  Reply.pnErrorLvl		= &pResult->nErrorLvl;
  Reply.ppszErrorMsg		= (LPCSTR *) &pResult->pszErrorMsg;
  Reply.pResult		= pResult;
  Reply.pReturnValue		= &pResult->ReturnValue;
  Reply.nReturnValueSize	= sizeof ( pResult->ReturnValue );

  pResult->ReturnValue		=
  fnServerDbCreateStructures (
	pArguments->oShortObjIdHeap,
	pArguments->oShortObjIdStructDescr,
	pArguments->nObjIds,
	pResult->pObjIds.u_int_vector_t_val,
	&pResult->pnSlots );

  if ( Reply.bAnswered ) {
    __pRequest__	= NULL;
    return (RESULTTYPE) NULL;
  }

  pResult->nErrorLvl	= RPC_SERVER_ERRLVL();
  if ( pResult->nErrorLvl > 0 ) {
    pszErrorMsg		= RPC_SERVER_ERRMSG();
    if ( pszErrorMsg && *pszErrorMsg ) {
      pResult->pszErrorMsg	= strdup ( pszErrorMsg );
    }
  }
  if ( pResult->pszErrorMsg == NULL ) {
#ifdef MULTITHREAD
    pResult->pszErrorMsg	= strdup ( szEmpty );
#else
    pResult->pszErrorMsg	= (LPSTR) szEmpty;
#endif
  }
  __pRequest__	= NULL;
  return (RESULTTYPE) pResult;
} /* fnrpc_fnserverdbcreatestructures_1 */




extern int fnServerDbCreateInstances
	(SHORTOBJID oShortObjIdHeap ,
	  SHORTOBJID oShortObjIdClassDescr ,
	  int nObjIds ,
	  u_int * /* _vector_t<nObjIds> */  pObjIds ,
	  u_int * pnSlots ,
	  u_int * /* _vector_t<nObjIds> */  pDatas);

#ifdef MULTITHREAD
bool_t
#else
fnServerDbCreateInstances_rets *
#endif
	PASTE2(fnrpc_fnserverdbcreateinstances_1,_SVCSUFFIX)
		( fnServerDbCreateInstances_args * pArguments,
#ifdef MULTITHREAD
		  fnServerDbCreateInstances_rets * pResult,
#endif
		  struct svc_req * pRequest )
{
  static const char	__procedure__[]	= "server:fnrpc_fnserverdbcreateinstances_1";
#ifdef MULTITHREAD
  typedef bool_t RESULTTYPE;
#else
  typedef fnServerDbCreateInstances_rets * RESULTTYPE;
#endif
#ifndef MULTITHREAD
  static fnServerDbCreateInstances_rets	Result;
  RESULTTYPE			pResult = &Result;
#endif
  LPCSTR	pszErrorMsg;

  __pRequest__	= pRequest;

  RPC_SERVER_ENTRY();

#ifndef MULTITHREAD
  if ( pResult->pszErrorMsg == szEmpty ) {
    pResult->pszErrorMsg	= NULL;
  }
  xdr_free ( (xdrproc_t) xdr_fnServerDbCreateInstances_rets, (char *) pResult );
#endif
  pResult->nErrorLvl		= 0;

  pResult->pObjIds.u_int_vector_t_len	= pArguments->pObjIdsSize;
  if ( pArguments->pObjIdsSize == 0 ) {
    pResult->pObjIds.u_int_vector_t_val	= NULL;
  } else {
    pResult->pObjIds.u_int_vector_t_val	=
      (u_int*) malloc ( pArguments->pObjIdsSize *
               SIZEOF ( *(pResult->pObjIds.u_int_vector_t_val) ) );
    if ( pResult->pObjIds.u_int_vector_t_val == NULL ) {
      char	szError [ 256 ];
      sprintf ( szError, szFormatMallocFailed,
                __procedure__, pArguments->pObjIdsSize,
                "pObjIds" );
      RPC_SERVER_ERROR ( szError );
      return (RESULTTYPE) NULL;
    }
  }
  pResult->pDatas.u_int_vector_t_len	= pArguments->pDatasSize;
  if ( pArguments->pDatasSize == 0 ) {
    pResult->pDatas.u_int_vector_t_val	= NULL;
  } else {
    pResult->pDatas.u_int_vector_t_val	=
      (u_int*) malloc ( pArguments->pDatasSize *
               SIZEOF ( *(pResult->pDatas.u_int_vector_t_val) ) );
    if ( pResult->pDatas.u_int_vector_t_val == NULL ) {
      char	szError [ 256 ];
      sprintf ( szError, szFormatMallocFailed,
                __procedure__, pArguments->pDatasSize,
                "pDatas" );
      RPC_SERVER_ERROR ( szError );
      return (RESULTTYPE) NULL;
    }
  }
  Reply.bAnswered		= FALSE;
  Reply.pfnCalled		= (void(*)()) fnServerDbCreateInstances;
  Reply.pfnXdrResult		= (bool_t(*)()) xdr_fnServerDbCreateInstances_rets;
  Reply.pnErrorLvl		= &pResult->nErrorLvl;
  Reply.ppszErrorMsg		= (LPCSTR *) &pResult->pszErrorMsg;
  Reply.pResult		= pResult;
  Reply.pReturnValue		= &pResult->ReturnValue;
  Reply.nReturnValueSize	= sizeof ( pResult->ReturnValue );

  pResult->ReturnValue		=
  fnServerDbCreateInstances (
	pArguments->oShortObjIdHeap,
	pArguments->oShortObjIdClassDescr,
	pArguments->nObjIds,
	pResult->pObjIds.u_int_vector_t_val,
	&pResult->pnSlots,
	pResult->pDatas.u_int_vector_t_val );

  if ( Reply.bAnswered ) {
    __pRequest__	= NULL;
    return (RESULTTYPE) NULL;
  }

  pResult->nErrorLvl	= RPC_SERVER_ERRLVL();
  if ( pResult->nErrorLvl > 0 ) {
    pszErrorMsg		= RPC_SERVER_ERRMSG();
    if ( pszErrorMsg && *pszErrorMsg ) {
      pResult->pszErrorMsg	= strdup ( pszErrorMsg );
    }
  }
  if ( pResult->pszErrorMsg == NULL ) {
#ifdef MULTITHREAD
    pResult->pszErrorMsg	= strdup ( szEmpty );
#else
    pResult->pszErrorMsg	= (LPSTR) szEmpty;
#endif
  }
  __pRequest__	= NULL;
  return (RESULTTYPE) pResult;
} /* fnrpc_fnserverdbcreateinstances_1 */




extern SHLOCK fnServerInstanceWriteWrapper
	(SHORTOBJID oShortObjIdHeap ,
	  SHORTOBJID oShortObjIdInstance ,
	  SHORTOBJID oShortObjIdClassDescr);

#ifdef MULTITHREAD
bool_t
#else
fnServerInstanceWriteWrapper_rets *
#endif
	PASTE2(fnrpc_fnserverinstancewritewrapper_1,_SVCSUFFIX)
		( fnServerInstanceWriteWrapper_args * pArguments,
#ifdef MULTITHREAD
		  fnServerInstanceWriteWrapper_rets * pResult,
#endif
		  struct svc_req * pRequest )
{
  static const char	__procedure__[]	= "server:fnrpc_fnserverinstancewritewrapper_1";
#ifdef MULTITHREAD
  typedef bool_t RESULTTYPE;
#else
  typedef fnServerInstanceWriteWrapper_rets * RESULTTYPE;
#endif
#ifndef MULTITHREAD
  static fnServerInstanceWriteWrapper_rets	Result;
  RESULTTYPE			pResult = &Result;
#endif
  LPCSTR	pszErrorMsg;

  __pRequest__	= pRequest;

  RPC_SERVER_ENTRY();

#ifndef MULTITHREAD
  if ( pResult->pszErrorMsg == szEmpty ) {
    pResult->pszErrorMsg	= NULL;
  }
  xdr_free ( (xdrproc_t) xdr_fnServerInstanceWriteWrapper_rets, (char *) pResult );
#endif
  pResult->nErrorLvl		= 0;

  Reply.bAnswered		= FALSE;
  Reply.pfnCalled		= (void(*)()) fnServerInstanceWriteWrapper;
  Reply.pfnXdrResult		= (bool_t(*)()) xdr_fnServerInstanceWriteWrapper_rets;
  Reply.pnErrorLvl		= &pResult->nErrorLvl;
  Reply.ppszErrorMsg		= (LPCSTR *) &pResult->pszErrorMsg;
  Reply.pResult		= pResult;
  Reply.pReturnValue		= &pResult->ReturnValue;
  Reply.nReturnValueSize	= sizeof ( pResult->ReturnValue );

  pResult->ReturnValue		=
  fnServerInstanceWriteWrapper (
	pArguments->oShortObjIdHeap,
	pArguments->oShortObjIdInstance,
	pArguments->oShortObjIdClassDescr );

  if ( Reply.bAnswered ) {
    __pRequest__	= NULL;
    return (RESULTTYPE) NULL;
  }

  pResult->nErrorLvl	= RPC_SERVER_ERRLVL();
  if ( pResult->nErrorLvl > 0 ) {
    pszErrorMsg		= RPC_SERVER_ERRMSG();
    if ( pszErrorMsg && *pszErrorMsg ) {
      pResult->pszErrorMsg	= strdup ( pszErrorMsg );
    }
  }
  if ( pResult->pszErrorMsg == NULL ) {
#ifdef MULTITHREAD
    pResult->pszErrorMsg	= strdup ( szEmpty );
#else
    pResult->pszErrorMsg	= (LPSTR) szEmpty;
#endif
  }
  __pRequest__	= NULL;
  return (RESULTTYPE) pResult;
} /* fnrpc_fnserverinstancewritewrapper_1 */




extern SHLOCK fnServerInstanceWriteData
	(SHORTOBJID oShortObjIdHeap ,
	  SHORTOBJID oShortObjIdInstance ,
	  SHORTOBJID oShortObjIdData);

#ifdef MULTITHREAD
bool_t
#else
fnServerInstanceWriteData_rets *
#endif
	PASTE2(fnrpc_fnserverinstancewritedata_1,_SVCSUFFIX)
		( fnServerInstanceWriteData_args * pArguments,
#ifdef MULTITHREAD
		  fnServerInstanceWriteData_rets * pResult,
#endif
		  struct svc_req * pRequest )
{
  static const char	__procedure__[]	= "server:fnrpc_fnserverinstancewritedata_1";
#ifdef MULTITHREAD
  typedef bool_t RESULTTYPE;
#else
  typedef fnServerInstanceWriteData_rets * RESULTTYPE;
#endif
#ifndef MULTITHREAD
  static fnServerInstanceWriteData_rets	Result;
  RESULTTYPE			pResult = &Result;
#endif
  LPCSTR	pszErrorMsg;

  __pRequest__	= pRequest;

  RPC_SERVER_ENTRY();

#ifndef MULTITHREAD
  if ( pResult->pszErrorMsg == szEmpty ) {
    pResult->pszErrorMsg	= NULL;
  }
  xdr_free ( (xdrproc_t) xdr_fnServerInstanceWriteData_rets, (char *) pResult );
#endif
  pResult->nErrorLvl		= 0;

  Reply.bAnswered		= FALSE;
  Reply.pfnCalled		= (void(*)()) fnServerInstanceWriteData;
  Reply.pfnXdrResult		= (bool_t(*)()) xdr_fnServerInstanceWriteData_rets;
  Reply.pnErrorLvl		= &pResult->nErrorLvl;
  Reply.ppszErrorMsg		= (LPCSTR *) &pResult->pszErrorMsg;
  Reply.pResult		= pResult;
  Reply.pReturnValue		= &pResult->ReturnValue;
  Reply.nReturnValueSize	= sizeof ( pResult->ReturnValue );

  pResult->ReturnValue		=
  fnServerInstanceWriteData (
	pArguments->oShortObjIdHeap,
	pArguments->oShortObjIdInstance,
	pArguments->oShortObjIdData );

  if ( Reply.bAnswered ) {
    __pRequest__	= NULL;
    return (RESULTTYPE) NULL;
  }

  pResult->nErrorLvl	= RPC_SERVER_ERRLVL();
  if ( pResult->nErrorLvl > 0 ) {
    pszErrorMsg		= RPC_SERVER_ERRMSG();
    if ( pszErrorMsg && *pszErrorMsg ) {
      pResult->pszErrorMsg	= strdup ( pszErrorMsg );
    }
  }
  if ( pResult->pszErrorMsg == NULL ) {
#ifdef MULTITHREAD
    pResult->pszErrorMsg	= strdup ( szEmpty );
#else
    pResult->pszErrorMsg	= (LPSTR) szEmpty;
#endif
  }
  __pRequest__	= NULL;
  return (RESULTTYPE) pResult;
} /* fnrpc_fnserverinstancewritedata_1 */




extern string_t fnServerDbTypeTagName
	(SHTYPETAG nTypeTag);

#ifdef MULTITHREAD
bool_t
#else
fnServerDbTypeTagName_rets *
#endif
	PASTE2(fnrpc_fnserverdbtypetagname_1,_SVCSUFFIX)
		( SHTYPETAG * pArguments,
#ifdef MULTITHREAD
		  fnServerDbTypeTagName_rets * pResult,
#endif
		  struct svc_req * pRequest )
{
  static const char	__procedure__[]	= "server:fnrpc_fnserverdbtypetagname_1";
#ifdef MULTITHREAD
  typedef bool_t RESULTTYPE;
#else
  typedef fnServerDbTypeTagName_rets * RESULTTYPE;
#endif
#ifndef MULTITHREAD
  static fnServerDbTypeTagName_rets	Result;
  RESULTTYPE			pResult = &Result;
#endif
  LPCSTR	pszErrorMsg;

  __pRequest__	= pRequest;

  RPC_SERVER_ENTRY();

#ifndef MULTITHREAD
  if ( pResult->pszErrorMsg == szEmpty ) {
    pResult->pszErrorMsg	= NULL;
  }
  xdr_free ( (xdrproc_t) xdr_fnServerDbTypeTagName_rets, (char *) pResult );
#endif
  pResult->nErrorLvl		= 0;

  Reply.bAnswered		= FALSE;
  Reply.pfnCalled		= (void(*)()) fnServerDbTypeTagName;
  Reply.pfnXdrResult		= (bool_t(*)()) xdr_fnServerDbTypeTagName_rets;
  Reply.pnErrorLvl		= &pResult->nErrorLvl;
  Reply.ppszErrorMsg		= (LPCSTR *) &pResult->pszErrorMsg;
  Reply.pResult		= pResult;
  Reply.pReturnValue		= &pResult->ReturnValue;
  Reply.nReturnValueSize	= sizeof ( pResult->ReturnValue );

  pResult->ReturnValue		=
  fnServerDbTypeTagName (
	(*pArguments) );

  if ( Reply.bAnswered ) {
    __pRequest__	= NULL;
    return (RESULTTYPE) NULL;
  }

  pResult->nErrorLvl	= RPC_SERVER_ERRLVL();
  if ( pResult->nErrorLvl > 0 ) {
    pszErrorMsg		= RPC_SERVER_ERRMSG();
    if ( pszErrorMsg && *pszErrorMsg ) {
      pResult->pszErrorMsg	= strdup ( pszErrorMsg );
    }
  }
  if ( pResult->pszErrorMsg == NULL ) {
#ifdef MULTITHREAD
    pResult->pszErrorMsg	= strdup ( szEmpty );
#else
    pResult->pszErrorMsg	= (LPSTR) szEmpty;
#endif
  }
  __pRequest__	= NULL;
  return (RESULTTYPE) pResult;
} /* fnrpc_fnserverdbtypetagname_1 */




extern int fnServerObjectPrettyPrint
	(SHORTOBJID oShortObjIdHeap ,
	  SHORTOBJID oShortObjId ,
	  SHTYPETAG nTypeTag ,
	  string_t /* string_t<nBuffer> */  lpszBuffer ,
	  int nBuffer);

#ifdef MULTITHREAD
bool_t
#else
fnServerObjectPrettyPrint_rets *
#endif
	PASTE2(fnrpc_fnserverobjectprettyprint_1,_SVCSUFFIX)
		( fnServerObjectPrettyPrint_args * pArguments,
#ifdef MULTITHREAD
		  fnServerObjectPrettyPrint_rets * pResult,
#endif
		  struct svc_req * pRequest )
{
  static const char	__procedure__[]	= "server:fnrpc_fnserverobjectprettyprint_1";
#ifdef MULTITHREAD
  typedef bool_t RESULTTYPE;
#else
  typedef fnServerObjectPrettyPrint_rets * RESULTTYPE;
#endif
#ifndef MULTITHREAD
  static fnServerObjectPrettyPrint_rets	Result;
  RESULTTYPE			pResult = &Result;
#endif
  LPCSTR	pszErrorMsg;

  __pRequest__	= pRequest;

  RPC_SERVER_ENTRY();

#ifndef MULTITHREAD
  if ( pResult->pszErrorMsg == szEmpty ) {
    pResult->pszErrorMsg	= NULL;
  }
  xdr_free ( (xdrproc_t) xdr_fnServerObjectPrettyPrint_rets, (char *) pResult );
#endif
  pResult->nErrorLvl		= 0;

  if ( pArguments->lpszBufferSize == 0 ) {
    pResult->lpszBuffer	= NULL;
  } else {
    pResult->lpszBuffer	=
    (string_t) malloc ( pArguments->lpszBufferSize );
    if ( pResult->lpszBuffer == NULL ) {
      char	szError [ 256 ];
      sprintf ( szError, szFormatMallocFailed,
                __procedure__, pArguments->lpszBufferSize );
      RPC_SERVER_ERROR ( szError );
      return (RESULTTYPE) NULL;
    }
  }
  Reply.bAnswered		= FALSE;
  Reply.pfnCalled		= (void(*)()) fnServerObjectPrettyPrint;
  Reply.pfnXdrResult		= (bool_t(*)()) xdr_fnServerObjectPrettyPrint_rets;
  Reply.pnErrorLvl		= &pResult->nErrorLvl;
  Reply.ppszErrorMsg		= (LPCSTR *) &pResult->pszErrorMsg;
  Reply.pResult		= pResult;
  Reply.pReturnValue		= &pResult->ReturnValue;
  Reply.nReturnValueSize	= sizeof ( pResult->ReturnValue );

  pResult->ReturnValue		=
  fnServerObjectPrettyPrint (
	pArguments->oShortObjIdHeap,
	pArguments->oShortObjId,
	pArguments->nTypeTag,
	pResult->lpszBuffer,
	pArguments->nBuffer );

  if ( Reply.bAnswered ) {
    __pRequest__	= NULL;
    return (RESULTTYPE) NULL;
  }

  pResult->nErrorLvl	= RPC_SERVER_ERRLVL();
  if ( pResult->nErrorLvl > 0 ) {
    pszErrorMsg		= RPC_SERVER_ERRMSG();
    if ( pszErrorMsg && *pszErrorMsg ) {
      pResult->pszErrorMsg	= strdup ( pszErrorMsg );
    }
  }
  if ( pResult->pszErrorMsg == NULL ) {
#ifdef MULTITHREAD
    pResult->pszErrorMsg	= strdup ( szEmpty );
#else
    pResult->pszErrorMsg	= (LPSTR) szEmpty;
#endif
  }
  __pRequest__	= NULL;
  return (RESULTTYPE) pResult;
} /* fnrpc_fnserverobjectprettyprint_1 */




extern int fnShortPrintSymbol
	(SHORTOBJID oShortObjIdHeap ,
	  SHORTOBJID oShortSymbol ,
	  string_t /* string_t<nBuffer> */  lpszBuffer ,
	  int nBuffer);

#ifdef MULTITHREAD
bool_t
#else
fnShortPrintSymbol_rets *
#endif
	PASTE2(fnrpc_fnshortprintsymbol_1,_SVCSUFFIX)
		( fnShortPrintSymbol_args * pArguments,
#ifdef MULTITHREAD
		  fnShortPrintSymbol_rets * pResult,
#endif
		  struct svc_req * pRequest )
{
  static const char	__procedure__[]	= "server:fnrpc_fnshortprintsymbol_1";
#ifdef MULTITHREAD
  typedef bool_t RESULTTYPE;
#else
  typedef fnShortPrintSymbol_rets * RESULTTYPE;
#endif
#ifndef MULTITHREAD
  static fnShortPrintSymbol_rets	Result;
  RESULTTYPE			pResult = &Result;
#endif
  LPCSTR	pszErrorMsg;

  __pRequest__	= pRequest;

  RPC_SERVER_ENTRY();

#ifndef MULTITHREAD
  if ( pResult->pszErrorMsg == szEmpty ) {
    pResult->pszErrorMsg	= NULL;
  }
  xdr_free ( (xdrproc_t) xdr_fnShortPrintSymbol_rets, (char *) pResult );
#endif
  pResult->nErrorLvl		= 0;

  if ( pArguments->lpszBufferSize == 0 ) {
    pResult->lpszBuffer	= NULL;
  } else {
    pResult->lpszBuffer	=
    (string_t) malloc ( pArguments->lpszBufferSize );
    if ( pResult->lpszBuffer == NULL ) {
      char	szError [ 256 ];
      sprintf ( szError, szFormatMallocFailed,
                __procedure__, pArguments->lpszBufferSize );
      RPC_SERVER_ERROR ( szError );
      return (RESULTTYPE) NULL;
    }
  }
  Reply.bAnswered		= FALSE;
  Reply.pfnCalled		= (void(*)()) fnShortPrintSymbol;
  Reply.pfnXdrResult		= (bool_t(*)()) xdr_fnShortPrintSymbol_rets;
  Reply.pnErrorLvl		= &pResult->nErrorLvl;
  Reply.ppszErrorMsg		= (LPCSTR *) &pResult->pszErrorMsg;
  Reply.pResult		= pResult;
  Reply.pReturnValue		= &pResult->ReturnValue;
  Reply.nReturnValueSize	= sizeof ( pResult->ReturnValue );

  pResult->ReturnValue		=
  fnShortPrintSymbol (
	pArguments->oShortObjIdHeap,
	pArguments->oShortSymbol,
	pResult->lpszBuffer,
	pArguments->nBuffer );

  if ( Reply.bAnswered ) {
    __pRequest__	= NULL;
    return (RESULTTYPE) NULL;
  }

  pResult->nErrorLvl	= RPC_SERVER_ERRLVL();
  if ( pResult->nErrorLvl > 0 ) {
    pszErrorMsg		= RPC_SERVER_ERRMSG();
    if ( pszErrorMsg && *pszErrorMsg ) {
      pResult->pszErrorMsg	= strdup ( pszErrorMsg );
    }
  }
  if ( pResult->pszErrorMsg == NULL ) {
#ifdef MULTITHREAD
    pResult->pszErrorMsg	= strdup ( szEmpty );
#else
    pResult->pszErrorMsg	= (LPSTR) szEmpty;
#endif
  }
  __pRequest__	= NULL;
  return (RESULTTYPE) pResult;
} /* fnrpc_fnshortprintsymbol_1 */




extern SHORTOBJID fnShortMakeSingleFloat
	(SHORTOBJID oShortObjIdHeap ,
	  float fFrom);

#ifdef MULTITHREAD
bool_t
#else
fnShortMakeSingleFloat_rets *
#endif
	PASTE2(fnrpc_fnshortmakesinglefloat_1,_SVCSUFFIX)
		( fnShortMakeSingleFloat_args * pArguments,
#ifdef MULTITHREAD
		  fnShortMakeSingleFloat_rets * pResult,
#endif
		  struct svc_req * pRequest )
{
  static const char	__procedure__[]	= "server:fnrpc_fnshortmakesinglefloat_1";
#ifdef MULTITHREAD
  typedef bool_t RESULTTYPE;
#else
  typedef fnShortMakeSingleFloat_rets * RESULTTYPE;
#endif
#ifndef MULTITHREAD
  static fnShortMakeSingleFloat_rets	Result;
  RESULTTYPE			pResult = &Result;
#endif
  LPCSTR	pszErrorMsg;

  __pRequest__	= pRequest;

  RPC_SERVER_ENTRY();

#ifndef MULTITHREAD
  if ( pResult->pszErrorMsg == szEmpty ) {
    pResult->pszErrorMsg	= NULL;
  }
  xdr_free ( (xdrproc_t) xdr_fnShortMakeSingleFloat_rets, (char *) pResult );
#endif
  pResult->nErrorLvl		= 0;

  Reply.bAnswered		= FALSE;
  Reply.pfnCalled		= (void(*)()) fnShortMakeSingleFloat;
  Reply.pfnXdrResult		= (bool_t(*)()) xdr_fnShortMakeSingleFloat_rets;
  Reply.pnErrorLvl		= &pResult->nErrorLvl;
  Reply.ppszErrorMsg		= (LPCSTR *) &pResult->pszErrorMsg;
  Reply.pResult		= pResult;
  Reply.pReturnValue		= &pResult->ReturnValue;
  Reply.nReturnValueSize	= sizeof ( pResult->ReturnValue );

  pResult->ReturnValue		=
  fnShortMakeSingleFloat (
	pArguments->oShortObjIdHeap,
	pArguments->fFrom );

  if ( Reply.bAnswered ) {
    __pRequest__	= NULL;
    return (RESULTTYPE) NULL;
  }

  pResult->nErrorLvl	= RPC_SERVER_ERRLVL();
  if ( pResult->nErrorLvl > 0 ) {
    pszErrorMsg		= RPC_SERVER_ERRMSG();
    if ( pszErrorMsg && *pszErrorMsg ) {
      pResult->pszErrorMsg	= strdup ( pszErrorMsg );
    }
  }
  if ( pResult->pszErrorMsg == NULL ) {
#ifdef MULTITHREAD
    pResult->pszErrorMsg	= strdup ( szEmpty );
#else
    pResult->pszErrorMsg	= (LPSTR) szEmpty;
#endif
  }
  __pRequest__	= NULL;
  return (RESULTTYPE) pResult;
} /* fnrpc_fnshortmakesinglefloat_1 */




extern SHORTOBJID fnShortMakeDoubleFloat
	(SHORTOBJID oShortObjIdHeap ,
	  double fFrom);

#ifdef MULTITHREAD
bool_t
#else
fnShortMakeDoubleFloat_rets *
#endif
	PASTE2(fnrpc_fnshortmakedoublefloat_1,_SVCSUFFIX)
		( fnShortMakeDoubleFloat_args * pArguments,
#ifdef MULTITHREAD
		  fnShortMakeDoubleFloat_rets * pResult,
#endif
		  struct svc_req * pRequest )
{
  static const char	__procedure__[]	= "server:fnrpc_fnshortmakedoublefloat_1";
#ifdef MULTITHREAD
  typedef bool_t RESULTTYPE;
#else
  typedef fnShortMakeDoubleFloat_rets * RESULTTYPE;
#endif
#ifndef MULTITHREAD
  static fnShortMakeDoubleFloat_rets	Result;
  RESULTTYPE			pResult = &Result;
#endif
  LPCSTR	pszErrorMsg;

  __pRequest__	= pRequest;

  RPC_SERVER_ENTRY();

#ifndef MULTITHREAD
  if ( pResult->pszErrorMsg == szEmpty ) {
    pResult->pszErrorMsg	= NULL;
  }
  xdr_free ( (xdrproc_t) xdr_fnShortMakeDoubleFloat_rets, (char *) pResult );
#endif
  pResult->nErrorLvl		= 0;

  Reply.bAnswered		= FALSE;
  Reply.pfnCalled		= (void(*)()) fnShortMakeDoubleFloat;
  Reply.pfnXdrResult		= (bool_t(*)()) xdr_fnShortMakeDoubleFloat_rets;
  Reply.pnErrorLvl		= &pResult->nErrorLvl;
  Reply.ppszErrorMsg		= (LPCSTR *) &pResult->pszErrorMsg;
  Reply.pResult		= pResult;
  Reply.pReturnValue		= &pResult->ReturnValue;
  Reply.nReturnValueSize	= sizeof ( pResult->ReturnValue );

  pResult->ReturnValue		=
  fnShortMakeDoubleFloat (
	pArguments->oShortObjIdHeap,
	pArguments->fFrom );

  if ( Reply.bAnswered ) {
    __pRequest__	= NULL;
    return (RESULTTYPE) NULL;
  }

  pResult->nErrorLvl	= RPC_SERVER_ERRLVL();
  if ( pResult->nErrorLvl > 0 ) {
    pszErrorMsg		= RPC_SERVER_ERRMSG();
    if ( pszErrorMsg && *pszErrorMsg ) {
      pResult->pszErrorMsg	= strdup ( pszErrorMsg );
    }
  }
  if ( pResult->pszErrorMsg == NULL ) {
#ifdef MULTITHREAD
    pResult->pszErrorMsg	= strdup ( szEmpty );
#else
    pResult->pszErrorMsg	= (LPSTR) szEmpty;
#endif
  }
  __pRequest__	= NULL;
  return (RESULTTYPE) pResult;
} /* fnrpc_fnshortmakedoublefloat_1 */




extern SHORTOBJID fnServerDbMakeBignum
	(SHORTOBJID oShortObjIdHeap ,
	  SHORTOBJID oShortObjIdFormat ,
	  int nSizeInBits ,
	  as_is * /* _vector_t<((( AlignBitsToWords ( ABS ( nSizeInBits ) ) )*( sizeof(int) )) )> */ pnBignum);

#ifdef MULTITHREAD
bool_t
#else
fnServerDbMakeBignum_rets *
#endif
	PASTE2(fnrpc_fnserverdbmakebignum_1,_SVCSUFFIX)
		( fnServerDbMakeBignum_args * pArguments,
#ifdef MULTITHREAD
		  fnServerDbMakeBignum_rets * pResult,
#endif
		  struct svc_req * pRequest )
{
  static const char	__procedure__[]	= "server:fnrpc_fnserverdbmakebignum_1";
#ifdef MULTITHREAD
  typedef bool_t RESULTTYPE;
#else
  typedef fnServerDbMakeBignum_rets * RESULTTYPE;
#endif
#ifndef MULTITHREAD
  static fnServerDbMakeBignum_rets	Result;
  RESULTTYPE			pResult = &Result;
#endif
  LPCSTR	pszErrorMsg;

  __pRequest__	= pRequest;

  RPC_SERVER_ENTRY();

#ifndef MULTITHREAD
  if ( pResult->pszErrorMsg == szEmpty ) {
    pResult->pszErrorMsg	= NULL;
  }
  xdr_free ( (xdrproc_t) xdr_fnServerDbMakeBignum_rets, (char *) pResult );
#endif
  pResult->nErrorLvl		= 0;

  Reply.bAnswered		= FALSE;
  Reply.pfnCalled		= (void(*)()) fnServerDbMakeBignum;
  Reply.pfnXdrResult		= (bool_t(*)()) xdr_fnServerDbMakeBignum_rets;
  Reply.pnErrorLvl		= &pResult->nErrorLvl;
  Reply.ppszErrorMsg		= (LPCSTR *) &pResult->pszErrorMsg;
  Reply.pResult		= pResult;
  Reply.pReturnValue		= &pResult->ReturnValue;
  Reply.nReturnValueSize	= sizeof ( pResult->ReturnValue );

  pResult->ReturnValue		=
  fnServerDbMakeBignum (
	pArguments->oShortObjIdHeap,
	pArguments->oShortObjIdFormat,
	pArguments->nSizeInBits,
	pArguments->pnBignum.as_is_vector_t_val );

  if ( Reply.bAnswered ) {
    __pRequest__	= NULL;
    return (RESULTTYPE) NULL;
  }

  pResult->nErrorLvl	= RPC_SERVER_ERRLVL();
  if ( pResult->nErrorLvl > 0 ) {
    pszErrorMsg		= RPC_SERVER_ERRMSG();
    if ( pszErrorMsg && *pszErrorMsg ) {
      pResult->pszErrorMsg	= strdup ( pszErrorMsg );
    }
  }
  if ( pResult->pszErrorMsg == NULL ) {
#ifdef MULTITHREAD
    pResult->pszErrorMsg	= strdup ( szEmpty );
#else
    pResult->pszErrorMsg	= (LPSTR) szEmpty;
#endif
  }
  __pRequest__	= NULL;
  return (RESULTTYPE) pResult;
} /* fnrpc_fnserverdbmakebignum_1 */




extern SHLOCK fnServerObjectReadBignum
	(SHORTOBJID oShortObjIdHeap ,
	  SHORTOBJID oShortObjIdFormat ,
	  SHORTOBJID oShortObjId ,
	  int nSizeInBits ,
	  as_is * /* _vector_t<((( AlignBitsToWords ( ABS ( nSizeInBits ) ) )*( sizeof(int) )) )> */  pnBignum);

#ifdef MULTITHREAD
bool_t
#else
fnServerObjectReadBignum_rets *
#endif
	PASTE2(fnrpc_fnserverobjectreadbignum_1,_SVCSUFFIX)
		( fnServerObjectReadBignum_args * pArguments,
#ifdef MULTITHREAD
		  fnServerObjectReadBignum_rets * pResult,
#endif
		  struct svc_req * pRequest )
{
  static const char	__procedure__[]	= "server:fnrpc_fnserverobjectreadbignum_1";
#ifdef MULTITHREAD
  typedef bool_t RESULTTYPE;
#else
  typedef fnServerObjectReadBignum_rets * RESULTTYPE;
#endif
#ifndef MULTITHREAD
  static fnServerObjectReadBignum_rets	Result;
  RESULTTYPE			pResult = &Result;
#endif
  LPCSTR	pszErrorMsg;

  __pRequest__	= pRequest;

  RPC_SERVER_ENTRY();

#ifndef MULTITHREAD
  if ( pResult->pszErrorMsg == szEmpty ) {
    pResult->pszErrorMsg	= NULL;
  }
  xdr_free ( (xdrproc_t) xdr_fnServerObjectReadBignum_rets, (char *) pResult );
#endif
  pResult->nErrorLvl		= 0;

  pResult->pnBignum.as_is_vector_t_len	= pArguments->pnBignumSize;
  if ( pArguments->pnBignumSize == 0 ) {
    pResult->pnBignum.as_is_vector_t_val	= NULL;
  } else {
    pResult->pnBignum.as_is_vector_t_val	=
      (char*) malloc ( pArguments->pnBignumSize *
               SIZEOF ( *(pResult->pnBignum.as_is_vector_t_val) ) );
    if ( pResult->pnBignum.as_is_vector_t_val == NULL ) {
      char	szError [ 256 ];
      sprintf ( szError, szFormatMallocFailed,
                __procedure__, pArguments->pnBignumSize,
                "pnBignum" );
      RPC_SERVER_ERROR ( szError );
      return (RESULTTYPE) NULL;
    }
  }
  Reply.bAnswered		= FALSE;
  Reply.pfnCalled		= (void(*)()) fnServerObjectReadBignum;
  Reply.pfnXdrResult		= (bool_t(*)()) xdr_fnServerObjectReadBignum_rets;
  Reply.pnErrorLvl		= &pResult->nErrorLvl;
  Reply.ppszErrorMsg		= (LPCSTR *) &pResult->pszErrorMsg;
  Reply.pResult		= pResult;
  Reply.pReturnValue		= &pResult->ReturnValue;
  Reply.nReturnValueSize	= sizeof ( pResult->ReturnValue );

  pResult->ReturnValue		=
  fnServerObjectReadBignum (
	pArguments->oShortObjIdHeap,
	pArguments->oShortObjIdFormat,
	pArguments->oShortObjId,
	pArguments->nSizeInBits,
	pResult->pnBignum.as_is_vector_t_val );

  if ( Reply.bAnswered ) {
    __pRequest__	= NULL;
    return (RESULTTYPE) NULL;
  }

  pResult->nErrorLvl	= RPC_SERVER_ERRLVL();
  if ( pResult->nErrorLvl > 0 ) {
    pszErrorMsg		= RPC_SERVER_ERRMSG();
    if ( pszErrorMsg && *pszErrorMsg ) {
      pResult->pszErrorMsg	= strdup ( pszErrorMsg );
    }
  }
  if ( pResult->pszErrorMsg == NULL ) {
#ifdef MULTITHREAD
    pResult->pszErrorMsg	= strdup ( szEmpty );
#else
    pResult->pszErrorMsg	= (LPSTR) szEmpty;
#endif
  }
  __pRequest__	= NULL;
  return (RESULTTYPE) pResult;
} /* fnrpc_fnserverobjectreadbignum_1 */




extern SHLOCK fnServerObjectReadDoubleFloat
	(SHORTOBJID oShortObjIdHeap ,
	  SHORTOBJID oShortObjId ,
	  double * pfDoubleFloat);

#ifdef MULTITHREAD
bool_t
#else
fnServerObjectReadDoubleFloat_rets *
#endif
	PASTE2(fnrpc_fnserverobjectreaddoublefloat_1,_SVCSUFFIX)
		( fnServerObjectReadDoubleFloat_args * pArguments,
#ifdef MULTITHREAD
		  fnServerObjectReadDoubleFloat_rets * pResult,
#endif
		  struct svc_req * pRequest )
{
  static const char	__procedure__[]	= "server:fnrpc_fnserverobjectreaddoublefloat_1";
#ifdef MULTITHREAD
  typedef bool_t RESULTTYPE;
#else
  typedef fnServerObjectReadDoubleFloat_rets * RESULTTYPE;
#endif
#ifndef MULTITHREAD
  static fnServerObjectReadDoubleFloat_rets	Result;
  RESULTTYPE			pResult = &Result;
#endif
  LPCSTR	pszErrorMsg;

  __pRequest__	= pRequest;

  RPC_SERVER_ENTRY();

#ifndef MULTITHREAD
  if ( pResult->pszErrorMsg == szEmpty ) {
    pResult->pszErrorMsg	= NULL;
  }
  xdr_free ( (xdrproc_t) xdr_fnServerObjectReadDoubleFloat_rets, (char *) pResult );
#endif
  pResult->nErrorLvl		= 0;

  Reply.bAnswered		= FALSE;
  Reply.pfnCalled		= (void(*)()) fnServerObjectReadDoubleFloat;
  Reply.pfnXdrResult		= (bool_t(*)()) xdr_fnServerObjectReadDoubleFloat_rets;
  Reply.pnErrorLvl		= &pResult->nErrorLvl;
  Reply.ppszErrorMsg		= (LPCSTR *) &pResult->pszErrorMsg;
  Reply.pResult		= pResult;
  Reply.pReturnValue		= &pResult->ReturnValue;
  Reply.nReturnValueSize	= sizeof ( pResult->ReturnValue );

  pResult->ReturnValue		=
  fnServerObjectReadDoubleFloat (
	pArguments->oShortObjIdHeap,
	pArguments->oShortObjId,
	&pResult->pfDoubleFloat );

  if ( Reply.bAnswered ) {
    __pRequest__	= NULL;
    return (RESULTTYPE) NULL;
  }

  pResult->nErrorLvl	= RPC_SERVER_ERRLVL();
  if ( pResult->nErrorLvl > 0 ) {
    pszErrorMsg		= RPC_SERVER_ERRMSG();
    if ( pszErrorMsg && *pszErrorMsg ) {
      pResult->pszErrorMsg	= strdup ( pszErrorMsg );
    }
  }
  if ( pResult->pszErrorMsg == NULL ) {
#ifdef MULTITHREAD
    pResult->pszErrorMsg	= strdup ( szEmpty );
#else
    pResult->pszErrorMsg	= (LPSTR) szEmpty;
#endif
  }
  __pRequest__	= NULL;
  return (RESULTTYPE) pResult;
} /* fnrpc_fnserverobjectreaddoublefloat_1 */




extern SHLOCK fnServerObjectReadFixnum
	(SHORTOBJID oShortObjIdHeap ,
	  SHORTOBJID oShortObjId ,
	  SHORTOBJID oExpectingClass ,
	  SHTYPETAG nExpectingTypeTag ,
	  int nIndex ,
	  int * pnFixnum);

#ifdef MULTITHREAD
bool_t
#else
fnServerObjectReadFixnum_rets *
#endif
	PASTE2(fnrpc_fnserverobjectreadfixnum_1,_SVCSUFFIX)
		( fnServerObjectReadFixnum_args * pArguments,
#ifdef MULTITHREAD
		  fnServerObjectReadFixnum_rets * pResult,
#endif
		  struct svc_req * pRequest )
{
  static const char	__procedure__[]	= "server:fnrpc_fnserverobjectreadfixnum_1";
#ifdef MULTITHREAD
  typedef bool_t RESULTTYPE;
#else
  typedef fnServerObjectReadFixnum_rets * RESULTTYPE;
#endif
#ifndef MULTITHREAD
  static fnServerObjectReadFixnum_rets	Result;
  RESULTTYPE			pResult = &Result;
#endif
  LPCSTR	pszErrorMsg;

  __pRequest__	= pRequest;

  RPC_SERVER_ENTRY();

#ifndef MULTITHREAD
  if ( pResult->pszErrorMsg == szEmpty ) {
    pResult->pszErrorMsg	= NULL;
  }
  xdr_free ( (xdrproc_t) xdr_fnServerObjectReadFixnum_rets, (char *) pResult );
#endif
  pResult->nErrorLvl		= 0;

  Reply.bAnswered		= FALSE;
  Reply.pfnCalled		= (void(*)()) fnServerObjectReadFixnum;
  Reply.pfnXdrResult		= (bool_t(*)()) xdr_fnServerObjectReadFixnum_rets;
  Reply.pnErrorLvl		= &pResult->nErrorLvl;
  Reply.ppszErrorMsg		= (LPCSTR *) &pResult->pszErrorMsg;
  Reply.pResult		= pResult;
  Reply.pReturnValue		= &pResult->ReturnValue;
  Reply.nReturnValueSize	= sizeof ( pResult->ReturnValue );

  pResult->ReturnValue		=
  fnServerObjectReadFixnum (
	pArguments->oShortObjIdHeap,
	pArguments->oShortObjId,
	pArguments->oExpectingClass,
	pArguments->nExpectingTypeTag,
	pArguments->nIndex,
	&pResult->pnFixnum );

  if ( Reply.bAnswered ) {
    __pRequest__	= NULL;
    return (RESULTTYPE) NULL;
  }

  pResult->nErrorLvl	= RPC_SERVER_ERRLVL();
  if ( pResult->nErrorLvl > 0 ) {
    pszErrorMsg		= RPC_SERVER_ERRMSG();
    if ( pszErrorMsg && *pszErrorMsg ) {
      pResult->pszErrorMsg	= strdup ( pszErrorMsg );
    }
  }
  if ( pResult->pszErrorMsg == NULL ) {
#ifdef MULTITHREAD
    pResult->pszErrorMsg	= strdup ( szEmpty );
#else
    pResult->pszErrorMsg	= (LPSTR) szEmpty;
#endif
  }
  __pRequest__	= NULL;
  return (RESULTTYPE) pResult;
} /* fnrpc_fnserverobjectreadfixnum_1 */




extern SHLOCK fnServerObjectReadSingleFloat
	(SHORTOBJID oShortObjIdHeap ,
	  SHORTOBJID oShortObjId ,
	  float * pfSingleFloat);

#ifdef MULTITHREAD
bool_t
#else
fnServerObjectReadSingleFloat_rets *
#endif
	PASTE2(fnrpc_fnserverobjectreadsinglefloat_1,_SVCSUFFIX)
		( fnServerObjectReadSingleFloat_args * pArguments,
#ifdef MULTITHREAD
		  fnServerObjectReadSingleFloat_rets * pResult,
#endif
		  struct svc_req * pRequest )
{
  static const char	__procedure__[]	= "server:fnrpc_fnserverobjectreadsinglefloat_1";
#ifdef MULTITHREAD
  typedef bool_t RESULTTYPE;
#else
  typedef fnServerObjectReadSingleFloat_rets * RESULTTYPE;
#endif
#ifndef MULTITHREAD
  static fnServerObjectReadSingleFloat_rets	Result;
  RESULTTYPE			pResult = &Result;
#endif
  LPCSTR	pszErrorMsg;

  __pRequest__	= pRequest;

  RPC_SERVER_ENTRY();

#ifndef MULTITHREAD
  if ( pResult->pszErrorMsg == szEmpty ) {
    pResult->pszErrorMsg	= NULL;
  }
  xdr_free ( (xdrproc_t) xdr_fnServerObjectReadSingleFloat_rets, (char *) pResult );
#endif
  pResult->nErrorLvl		= 0;

  Reply.bAnswered		= FALSE;
  Reply.pfnCalled		= (void(*)()) fnServerObjectReadSingleFloat;
  Reply.pfnXdrResult		= (bool_t(*)()) xdr_fnServerObjectReadSingleFloat_rets;
  Reply.pnErrorLvl		= &pResult->nErrorLvl;
  Reply.ppszErrorMsg		= (LPCSTR *) &pResult->pszErrorMsg;
  Reply.pResult		= pResult;
  Reply.pReturnValue		= &pResult->ReturnValue;
  Reply.nReturnValueSize	= sizeof ( pResult->ReturnValue );

  pResult->ReturnValue		=
  fnServerObjectReadSingleFloat (
	pArguments->oShortObjIdHeap,
	pArguments->oShortObjId,
	&pResult->pfSingleFloat );

  if ( Reply.bAnswered ) {
    __pRequest__	= NULL;
    return (RESULTTYPE) NULL;
  }

  pResult->nErrorLvl	= RPC_SERVER_ERRLVL();
  if ( pResult->nErrorLvl > 0 ) {
    pszErrorMsg		= RPC_SERVER_ERRMSG();
    if ( pszErrorMsg && *pszErrorMsg ) {
      pResult->pszErrorMsg	= strdup ( pszErrorMsg );
    }
  }
  if ( pResult->pszErrorMsg == NULL ) {
#ifdef MULTITHREAD
    pResult->pszErrorMsg	= strdup ( szEmpty );
#else
    pResult->pszErrorMsg	= (LPSTR) szEmpty;
#endif
  }
  __pRequest__	= NULL;
  return (RESULTTYPE) pResult;
} /* fnrpc_fnserverobjectreadsinglefloat_1 */




extern SHLOCK fnServerObjectWriteBignum
	(SHORTOBJID oShortObjIdHeap ,
	  SHORTOBJID oShortObjIdFormat ,
	  SHORTOBJID oShortObjId ,
	  int nSizeInBits ,
	  as_is * /* _vector_t<((( AlignBitsToWords ( ABS ( nSizeInBits ) ) )*( sizeof(int) )) )> */ pnBignum);

#ifdef MULTITHREAD
bool_t
#else
fnServerObjectWriteBignum_rets *
#endif
	PASTE2(fnrpc_fnserverobjectwritebignum_1,_SVCSUFFIX)
		( fnServerObjectWriteBignum_args * pArguments,
#ifdef MULTITHREAD
		  fnServerObjectWriteBignum_rets * pResult,
#endif
		  struct svc_req * pRequest )
{
  static const char	__procedure__[]	= "server:fnrpc_fnserverobjectwritebignum_1";
#ifdef MULTITHREAD
  typedef bool_t RESULTTYPE;
#else
  typedef fnServerObjectWriteBignum_rets * RESULTTYPE;
#endif
#ifndef MULTITHREAD
  static fnServerObjectWriteBignum_rets	Result;
  RESULTTYPE			pResult = &Result;
#endif
  LPCSTR	pszErrorMsg;

  __pRequest__	= pRequest;

  RPC_SERVER_ENTRY();

#ifndef MULTITHREAD
  if ( pResult->pszErrorMsg == szEmpty ) {
    pResult->pszErrorMsg	= NULL;
  }
  xdr_free ( (xdrproc_t) xdr_fnServerObjectWriteBignum_rets, (char *) pResult );
#endif
  pResult->nErrorLvl		= 0;

  Reply.bAnswered		= FALSE;
  Reply.pfnCalled		= (void(*)()) fnServerObjectWriteBignum;
  Reply.pfnXdrResult		= (bool_t(*)()) xdr_fnServerObjectWriteBignum_rets;
  Reply.pnErrorLvl		= &pResult->nErrorLvl;
  Reply.ppszErrorMsg		= (LPCSTR *) &pResult->pszErrorMsg;
  Reply.pResult		= pResult;
  Reply.pReturnValue		= &pResult->ReturnValue;
  Reply.nReturnValueSize	= sizeof ( pResult->ReturnValue );

  pResult->ReturnValue		=
  fnServerObjectWriteBignum (
	pArguments->oShortObjIdHeap,
	pArguments->oShortObjIdFormat,
	pArguments->oShortObjId,
	pArguments->nSizeInBits,
	pArguments->pnBignum.as_is_vector_t_val );

  if ( Reply.bAnswered ) {
    __pRequest__	= NULL;
    return (RESULTTYPE) NULL;
  }

  pResult->nErrorLvl	= RPC_SERVER_ERRLVL();
  if ( pResult->nErrorLvl > 0 ) {
    pszErrorMsg		= RPC_SERVER_ERRMSG();
    if ( pszErrorMsg && *pszErrorMsg ) {
      pResult->pszErrorMsg	= strdup ( pszErrorMsg );
    }
  }
  if ( pResult->pszErrorMsg == NULL ) {
#ifdef MULTITHREAD
    pResult->pszErrorMsg	= strdup ( szEmpty );
#else
    pResult->pszErrorMsg	= (LPSTR) szEmpty;
#endif
  }
  __pRequest__	= NULL;
  return (RESULTTYPE) pResult;
} /* fnrpc_fnserverobjectwritebignum_1 */




extern SHLOCK fnServerObjectWriteDoubleFloat
	(SHORTOBJID oShortObjIdHeap ,
	  SHORTOBJID oShortObjId ,
	  double fDoubleFloat);

#ifdef MULTITHREAD
bool_t
#else
fnServerObjectWriteDoubleFloat_rets *
#endif
	PASTE2(fnrpc_fnserverobjectwritedoublefloat_1,_SVCSUFFIX)
		( fnServerObjectWriteDoubleFloat_args * pArguments,
#ifdef MULTITHREAD
		  fnServerObjectWriteDoubleFloat_rets * pResult,
#endif
		  struct svc_req * pRequest )
{
  static const char	__procedure__[]	= "server:fnrpc_fnserverobjectwritedoublefloat_1";
#ifdef MULTITHREAD
  typedef bool_t RESULTTYPE;
#else
  typedef fnServerObjectWriteDoubleFloat_rets * RESULTTYPE;
#endif
#ifndef MULTITHREAD
  static fnServerObjectWriteDoubleFloat_rets	Result;
  RESULTTYPE			pResult = &Result;
#endif
  LPCSTR	pszErrorMsg;

  __pRequest__	= pRequest;

  RPC_SERVER_ENTRY();

#ifndef MULTITHREAD
  if ( pResult->pszErrorMsg == szEmpty ) {
    pResult->pszErrorMsg	= NULL;
  }
  xdr_free ( (xdrproc_t) xdr_fnServerObjectWriteDoubleFloat_rets, (char *) pResult );
#endif
  pResult->nErrorLvl		= 0;

  Reply.bAnswered		= FALSE;
  Reply.pfnCalled		= (void(*)()) fnServerObjectWriteDoubleFloat;
  Reply.pfnXdrResult		= (bool_t(*)()) xdr_fnServerObjectWriteDoubleFloat_rets;
  Reply.pnErrorLvl		= &pResult->nErrorLvl;
  Reply.ppszErrorMsg		= (LPCSTR *) &pResult->pszErrorMsg;
  Reply.pResult		= pResult;
  Reply.pReturnValue		= &pResult->ReturnValue;
  Reply.nReturnValueSize	= sizeof ( pResult->ReturnValue );

  pResult->ReturnValue		=
  fnServerObjectWriteDoubleFloat (
	pArguments->oShortObjIdHeap,
	pArguments->oShortObjId,
	pArguments->fDoubleFloat );

  if ( Reply.bAnswered ) {
    __pRequest__	= NULL;
    return (RESULTTYPE) NULL;
  }

  pResult->nErrorLvl	= RPC_SERVER_ERRLVL();
  if ( pResult->nErrorLvl > 0 ) {
    pszErrorMsg		= RPC_SERVER_ERRMSG();
    if ( pszErrorMsg && *pszErrorMsg ) {
      pResult->pszErrorMsg	= strdup ( pszErrorMsg );
    }
  }
  if ( pResult->pszErrorMsg == NULL ) {
#ifdef MULTITHREAD
    pResult->pszErrorMsg	= strdup ( szEmpty );
#else
    pResult->pszErrorMsg	= (LPSTR) szEmpty;
#endif
  }
  __pRequest__	= NULL;
  return (RESULTTYPE) pResult;
} /* fnrpc_fnserverobjectwritedoublefloat_1 */




extern SHLOCK fnServerObjectWriteFixnum
	(SHORTOBJID oShortObjIdHeap ,
	  SHORTOBJID oShortObjId ,
	  SHORTOBJID oExpectingClass ,
	  SHTYPETAG nExpectingTypeTag ,
	  int nIndex ,
	  int nFixnumWrite);

#ifdef MULTITHREAD
bool_t
#else
fnServerObjectWriteFixnum_rets *
#endif
	PASTE2(fnrpc_fnserverobjectwritefixnum_1,_SVCSUFFIX)
		( fnServerObjectWriteFixnum_args * pArguments,
#ifdef MULTITHREAD
		  fnServerObjectWriteFixnum_rets * pResult,
#endif
		  struct svc_req * pRequest )
{
  static const char	__procedure__[]	= "server:fnrpc_fnserverobjectwritefixnum_1";
#ifdef MULTITHREAD
  typedef bool_t RESULTTYPE;
#else
  typedef fnServerObjectWriteFixnum_rets * RESULTTYPE;
#endif
#ifndef MULTITHREAD
  static fnServerObjectWriteFixnum_rets	Result;
  RESULTTYPE			pResult = &Result;
#endif
  LPCSTR	pszErrorMsg;

  __pRequest__	= pRequest;

  RPC_SERVER_ENTRY();

#ifndef MULTITHREAD
  if ( pResult->pszErrorMsg == szEmpty ) {
    pResult->pszErrorMsg	= NULL;
  }
  xdr_free ( (xdrproc_t) xdr_fnServerObjectWriteFixnum_rets, (char *) pResult );
#endif
  pResult->nErrorLvl		= 0;

  Reply.bAnswered		= FALSE;
  Reply.pfnCalled		= (void(*)()) fnServerObjectWriteFixnum;
  Reply.pfnXdrResult		= (bool_t(*)()) xdr_fnServerObjectWriteFixnum_rets;
  Reply.pnErrorLvl		= &pResult->nErrorLvl;
  Reply.ppszErrorMsg		= (LPCSTR *) &pResult->pszErrorMsg;
  Reply.pResult		= pResult;
  Reply.pReturnValue		= &pResult->ReturnValue;
  Reply.nReturnValueSize	= sizeof ( pResult->ReturnValue );

  pResult->ReturnValue		=
  fnServerObjectWriteFixnum (
	pArguments->oShortObjIdHeap,
	pArguments->oShortObjId,
	pArguments->oExpectingClass,
	pArguments->nExpectingTypeTag,
	pArguments->nIndex,
	pArguments->nFixnumWrite );

  if ( Reply.bAnswered ) {
    __pRequest__	= NULL;
    return (RESULTTYPE) NULL;
  }

  pResult->nErrorLvl	= RPC_SERVER_ERRLVL();
  if ( pResult->nErrorLvl > 0 ) {
    pszErrorMsg		= RPC_SERVER_ERRMSG();
    if ( pszErrorMsg && *pszErrorMsg ) {
      pResult->pszErrorMsg	= strdup ( pszErrorMsg );
    }
  }
  if ( pResult->pszErrorMsg == NULL ) {
#ifdef MULTITHREAD
    pResult->pszErrorMsg	= strdup ( szEmpty );
#else
    pResult->pszErrorMsg	= (LPSTR) szEmpty;
#endif
  }
  __pRequest__	= NULL;
  return (RESULTTYPE) pResult;
} /* fnrpc_fnserverobjectwritefixnum_1 */




extern SHLOCK fnServerObjectWriteSingleFloat
	(SHORTOBJID oShortObjIdHeap ,
	  SHORTOBJID oShortObjId ,
	  float fSingleFloat);

#ifdef MULTITHREAD
bool_t
#else
fnServerObjectWriteSingleFloat_rets *
#endif
	PASTE2(fnrpc_fnserverobjectwritesinglefloat_1,_SVCSUFFIX)
		( fnServerObjectWriteSingleFloat_args * pArguments,
#ifdef MULTITHREAD
		  fnServerObjectWriteSingleFloat_rets * pResult,
#endif
		  struct svc_req * pRequest )
{
  static const char	__procedure__[]	= "server:fnrpc_fnserverobjectwritesinglefloat_1";
#ifdef MULTITHREAD
  typedef bool_t RESULTTYPE;
#else
  typedef fnServerObjectWriteSingleFloat_rets * RESULTTYPE;
#endif
#ifndef MULTITHREAD
  static fnServerObjectWriteSingleFloat_rets	Result;
  RESULTTYPE			pResult = &Result;
#endif
  LPCSTR	pszErrorMsg;

  __pRequest__	= pRequest;

  RPC_SERVER_ENTRY();

#ifndef MULTITHREAD
  if ( pResult->pszErrorMsg == szEmpty ) {
    pResult->pszErrorMsg	= NULL;
  }
  xdr_free ( (xdrproc_t) xdr_fnServerObjectWriteSingleFloat_rets, (char *) pResult );
#endif
  pResult->nErrorLvl		= 0;

  Reply.bAnswered		= FALSE;
  Reply.pfnCalled		= (void(*)()) fnServerObjectWriteSingleFloat;
  Reply.pfnXdrResult		= (bool_t(*)()) xdr_fnServerObjectWriteSingleFloat_rets;
  Reply.pnErrorLvl		= &pResult->nErrorLvl;
  Reply.ppszErrorMsg		= (LPCSTR *) &pResult->pszErrorMsg;
  Reply.pResult		= pResult;
  Reply.pReturnValue		= &pResult->ReturnValue;
  Reply.nReturnValueSize	= sizeof ( pResult->ReturnValue );

  pResult->ReturnValue		=
  fnServerObjectWriteSingleFloat (
	pArguments->oShortObjIdHeap,
	pArguments->oShortObjId,
	pArguments->fSingleFloat );

  if ( Reply.bAnswered ) {
    __pRequest__	= NULL;
    return (RESULTTYPE) NULL;
  }

  pResult->nErrorLvl	= RPC_SERVER_ERRLVL();
  if ( pResult->nErrorLvl > 0 ) {
    pszErrorMsg		= RPC_SERVER_ERRMSG();
    if ( pszErrorMsg && *pszErrorMsg ) {
      pResult->pszErrorMsg	= strdup ( pszErrorMsg );
    }
  }
  if ( pResult->pszErrorMsg == NULL ) {
#ifdef MULTITHREAD
    pResult->pszErrorMsg	= strdup ( szEmpty );
#else
    pResult->pszErrorMsg	= (LPSTR) szEmpty;
#endif
  }
  __pRequest__	= NULL;
  return (RESULTTYPE) pResult;
} /* fnrpc_fnserverobjectwritesinglefloat_1 */




extern int fnClientLockPrint
	(SHORTOBJID oShortObjIdHeap ,
	  SHORTOBJID oShortSelf ,
	  SHLOCK nLevel ,
	  NUMERICSTDSTREAM nStdStream);

#ifdef MULTITHREAD
bool_t
#else
fnClientLockPrint_rets *
#endif
	PASTE2(fnrpc_fnclientlockprint_1,_SVCSUFFIX)
		( fnClientLockPrint_args * pArguments,
#ifdef MULTITHREAD
		  fnClientLockPrint_rets * pResult,
#endif
		  struct svc_req * pRequest )
{
  static const char	__procedure__[]	= "server:fnrpc_fnclientlockprint_1";
#ifdef MULTITHREAD
  typedef bool_t RESULTTYPE;
#else
  typedef fnClientLockPrint_rets * RESULTTYPE;
#endif
#ifndef MULTITHREAD
  static fnClientLockPrint_rets	Result;
  RESULTTYPE			pResult = &Result;
#endif
  LPCSTR	pszErrorMsg;

  __pRequest__	= pRequest;

  RPC_SERVER_ENTRY();

#ifndef MULTITHREAD
  if ( pResult->pszErrorMsg == szEmpty ) {
    pResult->pszErrorMsg	= NULL;
  }
  xdr_free ( (xdrproc_t) xdr_fnClientLockPrint_rets, (char *) pResult );
#endif
  pResult->nErrorLvl		= 0;

  Reply.bAnswered		= FALSE;
  Reply.pfnCalled		= (void(*)()) fnClientLockPrint;
  Reply.pfnXdrResult		= (bool_t(*)()) xdr_fnClientLockPrint_rets;
  Reply.pnErrorLvl		= &pResult->nErrorLvl;
  Reply.ppszErrorMsg		= (LPCSTR *) &pResult->pszErrorMsg;
  Reply.pResult		= pResult;
  Reply.pReturnValue		= &pResult->ReturnValue;
  Reply.nReturnValueSize	= sizeof ( pResult->ReturnValue );

  pResult->ReturnValue		=
  fnClientLockPrint (
	pArguments->oShortObjIdHeap,
	pArguments->oShortSelf,
	pArguments->nLevel,
	pArguments->nStdStream );

  if ( Reply.bAnswered ) {
    __pRequest__	= NULL;
    return (RESULTTYPE) NULL;
  }

  pResult->nErrorLvl	= RPC_SERVER_ERRLVL();
  if ( pResult->nErrorLvl > 0 ) {
    pszErrorMsg		= RPC_SERVER_ERRMSG();
    if ( pszErrorMsg && *pszErrorMsg ) {
      pResult->pszErrorMsg	= strdup ( pszErrorMsg );
    }
  }
  if ( pResult->pszErrorMsg == NULL ) {
#ifdef MULTITHREAD
    pResult->pszErrorMsg	= strdup ( szEmpty );
#else
    pResult->pszErrorMsg	= (LPSTR) szEmpty;
#endif
  }
  __pRequest__	= NULL;
  return (RESULTTYPE) pResult;
} /* fnrpc_fnclientlockprint_1 */




extern SHLOCK fnClientTransactionLockGet
	(SHORTOBJID oShortObjIdHeap ,
	  SHORTOBJID oShortObjIdLockedByP ,
	  SHLOCK nLevelP ,
	  SHORTOBJID oShortLockedP ,
	  SHTYPETAG nTypeTagLockedP ,
	  int nIndexP);

#ifdef MULTITHREAD
bool_t
#else
fnClientTransactionLockGet_rets *
#endif
	PASTE2(fnrpc_fnclienttransactionlockget_1,_SVCSUFFIX)
		( fnClientTransactionLockGet_args * pArguments,
#ifdef MULTITHREAD
		  fnClientTransactionLockGet_rets * pResult,
#endif
		  struct svc_req * pRequest )
{
  static const char	__procedure__[]	= "server:fnrpc_fnclienttransactionlockget_1";
#ifdef MULTITHREAD
  typedef bool_t RESULTTYPE;
#else
  typedef fnClientTransactionLockGet_rets * RESULTTYPE;
#endif
#ifndef MULTITHREAD
  static fnClientTransactionLockGet_rets	Result;
  RESULTTYPE			pResult = &Result;
#endif
  LPCSTR	pszErrorMsg;

  __pRequest__	= pRequest;

  RPC_SERVER_ENTRY();

#ifndef MULTITHREAD
  if ( pResult->pszErrorMsg == szEmpty ) {
    pResult->pszErrorMsg	= NULL;
  }
  xdr_free ( (xdrproc_t) xdr_fnClientTransactionLockGet_rets, (char *) pResult );
#endif
  pResult->nErrorLvl		= 0;

  Reply.bAnswered		= FALSE;
  Reply.pfnCalled		= (void(*)()) fnClientTransactionLockGet;
  Reply.pfnXdrResult		= (bool_t(*)()) xdr_fnClientTransactionLockGet_rets;
  Reply.pnErrorLvl		= &pResult->nErrorLvl;
  Reply.ppszErrorMsg		= (LPCSTR *) &pResult->pszErrorMsg;
  Reply.pResult		= pResult;
  Reply.pReturnValue		= &pResult->ReturnValue;
  Reply.nReturnValueSize	= sizeof ( pResult->ReturnValue );

  pResult->ReturnValue		=
  fnClientTransactionLockGet (
	pArguments->oShortObjIdHeap,
	pArguments->oShortObjIdLockedByP,
	pArguments->nLevelP,
	pArguments->oShortLockedP,
	pArguments->nTypeTagLockedP,
	pArguments->nIndexP );

  if ( Reply.bAnswered ) {
    __pRequest__	= NULL;
    return (RESULTTYPE) NULL;
  }

  pResult->nErrorLvl	= RPC_SERVER_ERRLVL();
  if ( pResult->nErrorLvl > 0 ) {
    pszErrorMsg		= RPC_SERVER_ERRMSG();
    if ( pszErrorMsg && *pszErrorMsg ) {
      pResult->pszErrorMsg	= strdup ( pszErrorMsg );
    }
  }
  if ( pResult->pszErrorMsg == NULL ) {
#ifdef MULTITHREAD
    pResult->pszErrorMsg	= strdup ( szEmpty );
#else
    pResult->pszErrorMsg	= (LPSTR) szEmpty;
#endif
  }
  __pRequest__	= NULL;
  return (RESULTTYPE) pResult;
} /* fnrpc_fnclienttransactionlockget_1 */




extern SHLOCK fnServerTransactionLockInsert
	(SHORTOBJID oShortObjIdHeap ,
	  SHORTOBJID oShortObjIdLockBy ,
	  SHLOCK nLock ,
	  SHORTOBJID oShortToLock ,
	  SHTYPETAG nTypeTagToLock ,
	  int nIndex ,
	  int * phPeek ,
	  int * pnObjIdWords);

#ifdef MULTITHREAD
bool_t
#else
fnServerTransactionLockInsert_rets *
#endif
	PASTE2(fnrpc_fnservertransactionlockinsert_1,_SVCSUFFIX)
		( fnServerTransactionLockInsert_args * pArguments,
#ifdef MULTITHREAD
		  fnServerTransactionLockInsert_rets * pResult,
#endif
		  struct svc_req * pRequest )
{
  static const char	__procedure__[]	= "server:fnrpc_fnservertransactionlockinsert_1";
#ifdef MULTITHREAD
  typedef bool_t RESULTTYPE;
#else
  typedef fnServerTransactionLockInsert_rets * RESULTTYPE;
#endif
#ifndef MULTITHREAD
  static fnServerTransactionLockInsert_rets	Result;
  RESULTTYPE			pResult = &Result;
#endif
  LPCSTR	pszErrorMsg;

  __pRequest__	= pRequest;

  RPC_SERVER_ENTRY();

#ifndef MULTITHREAD
  if ( pResult->pszErrorMsg == szEmpty ) {
    pResult->pszErrorMsg	= NULL;
  }
  xdr_free ( (xdrproc_t) xdr_fnServerTransactionLockInsert_rets, (char *) pResult );
#endif
  pResult->nErrorLvl		= 0;

  Reply.bAnswered		= FALSE;
  Reply.pfnCalled		= (void(*)()) fnServerTransactionLockInsert;
  Reply.pfnXdrResult		= (bool_t(*)()) xdr_fnServerTransactionLockInsert_rets;
  Reply.pnErrorLvl		= &pResult->nErrorLvl;
  Reply.ppszErrorMsg		= (LPCSTR *) &pResult->pszErrorMsg;
  Reply.pResult		= pResult;
  Reply.pReturnValue		= &pResult->ReturnValue;
  Reply.nReturnValueSize	= sizeof ( pResult->ReturnValue );

  pResult->ReturnValue		=
  fnServerTransactionLockInsert (
	pArguments->oShortObjIdHeap,
	pArguments->oShortObjIdLockBy,
	pArguments->nLock,
	pArguments->oShortToLock,
	pArguments->nTypeTagToLock,
	pArguments->nIndex,
	&pResult->phPeek,
	&pResult->pnObjIdWords );

  if ( Reply.bAnswered ) {
    __pRequest__	= NULL;
    return (RESULTTYPE) NULL;
  }

  pResult->nErrorLvl	= RPC_SERVER_ERRLVL();
  if ( pResult->nErrorLvl > 0 ) {
    pszErrorMsg		= RPC_SERVER_ERRMSG();
    if ( pszErrorMsg && *pszErrorMsg ) {
      pResult->pszErrorMsg	= strdup ( pszErrorMsg );
    }
  }
  if ( pResult->pszErrorMsg == NULL ) {
#ifdef MULTITHREAD
    pResult->pszErrorMsg	= strdup ( szEmpty );
#else
    pResult->pszErrorMsg	= (LPSTR) szEmpty;
#endif
  }
  __pRequest__	= NULL;
  return (RESULTTYPE) pResult;
} /* fnrpc_fnservertransactionlockinsert_1 */




extern SHLOCK fnServerTransactionLockSet
	(SHORTOBJID oShortObjIdHeap ,
	  SHORTOBJID oShortObjIdLockBy ,
	  SHLOCK nLock ,
	  SHORTOBJID oShortToLock ,
	  SHTYPETAG nTypeTagToLock ,
	  int nIndex ,
	  int * phPeek ,
	  int * pnObjIdWords);

#ifdef MULTITHREAD
bool_t
#else
fnServerTransactionLockSet_rets *
#endif
	PASTE2(fnrpc_fnservertransactionlockset_1,_SVCSUFFIX)
		( fnServerTransactionLockSet_args * pArguments,
#ifdef MULTITHREAD
		  fnServerTransactionLockSet_rets * pResult,
#endif
		  struct svc_req * pRequest )
{
  static const char	__procedure__[]	= "server:fnrpc_fnservertransactionlockset_1";
#ifdef MULTITHREAD
  typedef bool_t RESULTTYPE;
#else
  typedef fnServerTransactionLockSet_rets * RESULTTYPE;
#endif
#ifndef MULTITHREAD
  static fnServerTransactionLockSet_rets	Result;
  RESULTTYPE			pResult = &Result;
#endif
  LPCSTR	pszErrorMsg;

  __pRequest__	= pRequest;

  RPC_SERVER_ENTRY();

#ifndef MULTITHREAD
  if ( pResult->pszErrorMsg == szEmpty ) {
    pResult->pszErrorMsg	= NULL;
  }
  xdr_free ( (xdrproc_t) xdr_fnServerTransactionLockSet_rets, (char *) pResult );
#endif
  pResult->nErrorLvl		= 0;

  Reply.bAnswered		= FALSE;
  Reply.pfnCalled		= (void(*)()) fnServerTransactionLockSet;
  Reply.pfnXdrResult		= (bool_t(*)()) xdr_fnServerTransactionLockSet_rets;
  Reply.pnErrorLvl		= &pResult->nErrorLvl;
  Reply.ppszErrorMsg		= (LPCSTR *) &pResult->pszErrorMsg;
  Reply.pResult		= pResult;
  Reply.pReturnValue		= &pResult->ReturnValue;
  Reply.nReturnValueSize	= sizeof ( pResult->ReturnValue );

  pResult->ReturnValue		=
  fnServerTransactionLockSet (
	pArguments->oShortObjIdHeap,
	pArguments->oShortObjIdLockBy,
	pArguments->nLock,
	pArguments->oShortToLock,
	pArguments->nTypeTagToLock,
	pArguments->nIndex,
	&pResult->phPeek,
	&pResult->pnObjIdWords );

  if ( Reply.bAnswered ) {
    __pRequest__	= NULL;
    return (RESULTTYPE) NULL;
  }

  pResult->nErrorLvl	= RPC_SERVER_ERRLVL();
  if ( pResult->nErrorLvl > 0 ) {
    pszErrorMsg		= RPC_SERVER_ERRMSG();
    if ( pszErrorMsg && *pszErrorMsg ) {
      pResult->pszErrorMsg	= strdup ( pszErrorMsg );
    }
  }
  if ( pResult->pszErrorMsg == NULL ) {
#ifdef MULTITHREAD
    pResult->pszErrorMsg	= strdup ( szEmpty );
#else
    pResult->pszErrorMsg	= (LPSTR) szEmpty;
#endif
  }
  __pRequest__	= NULL;
  return (RESULTTYPE) pResult;
} /* fnrpc_fnservertransactionlockset_1 */




extern SHLOCK fnServerTransactionUnlock
	(SHORTOBJID oShortObjIdHeap ,
	  SHORTOBJID oShortObjIdLockedBy ,
	  SHLOCK nLock ,
	  SHORTOBJID oShortToUnlock ,
	  int nIndex ,
	  SHLOCK * pnVectorLockNow);

#ifdef MULTITHREAD
bool_t
#else
fnServerTransactionUnlock_rets *
#endif
	PASTE2(fnrpc_fnservertransactionunlock_1,_SVCSUFFIX)
		( fnServerTransactionUnlock_args * pArguments,
#ifdef MULTITHREAD
		  fnServerTransactionUnlock_rets * pResult,
#endif
		  struct svc_req * pRequest )
{
  static const char	__procedure__[]	= "server:fnrpc_fnservertransactionunlock_1";
#ifdef MULTITHREAD
  typedef bool_t RESULTTYPE;
#else
  typedef fnServerTransactionUnlock_rets * RESULTTYPE;
#endif
#ifndef MULTITHREAD
  static fnServerTransactionUnlock_rets	Result;
  RESULTTYPE			pResult = &Result;
#endif
  LPCSTR	pszErrorMsg;

  __pRequest__	= pRequest;

  RPC_SERVER_ENTRY();

#ifndef MULTITHREAD
  if ( pResult->pszErrorMsg == szEmpty ) {
    pResult->pszErrorMsg	= NULL;
  }
  xdr_free ( (xdrproc_t) xdr_fnServerTransactionUnlock_rets, (char *) pResult );
#endif
  pResult->nErrorLvl		= 0;

  Reply.bAnswered		= FALSE;
  Reply.pfnCalled		= (void(*)()) fnServerTransactionUnlock;
  Reply.pfnXdrResult		= (bool_t(*)()) xdr_fnServerTransactionUnlock_rets;
  Reply.pnErrorLvl		= &pResult->nErrorLvl;
  Reply.ppszErrorMsg		= (LPCSTR *) &pResult->pszErrorMsg;
  Reply.pResult		= pResult;
  Reply.pReturnValue		= &pResult->ReturnValue;
  Reply.nReturnValueSize	= sizeof ( pResult->ReturnValue );

  pResult->ReturnValue		=
  fnServerTransactionUnlock (
	pArguments->oShortObjIdHeap,
	pArguments->oShortObjIdLockedBy,
	pArguments->nLock,
	pArguments->oShortToUnlock,
	pArguments->nIndex,
	&pResult->pnVectorLockNow );

  if ( Reply.bAnswered ) {
    __pRequest__	= NULL;
    return (RESULTTYPE) NULL;
  }

  pResult->nErrorLvl	= RPC_SERVER_ERRLVL();
  if ( pResult->nErrorLvl > 0 ) {
    pszErrorMsg		= RPC_SERVER_ERRMSG();
    if ( pszErrorMsg && *pszErrorMsg ) {
      pResult->pszErrorMsg	= strdup ( pszErrorMsg );
    }
  }
  if ( pResult->pszErrorMsg == NULL ) {
#ifdef MULTITHREAD
    pResult->pszErrorMsg	= strdup ( szEmpty );
#else
    pResult->pszErrorMsg	= (LPSTR) szEmpty;
#endif
  }
  __pRequest__	= NULL;
  return (RESULTTYPE) pResult;
} /* fnrpc_fnservertransactionunlock_1 */




extern int fnServerTransactionUnlockAll
	(SHORTOBJID oShortObjIdHeap ,
	  SHORTOBJID oShortObjIdLockedBy ,
	  SHORTOBJID oShortToUnlock);

#ifdef MULTITHREAD
bool_t
#else
fnServerTransactionUnlockAll_rets *
#endif
	PASTE2(fnrpc_fnservertransactionunlockall_1,_SVCSUFFIX)
		( fnServerTransactionUnlockAll_args * pArguments,
#ifdef MULTITHREAD
		  fnServerTransactionUnlockAll_rets * pResult,
#endif
		  struct svc_req * pRequest )
{
  static const char	__procedure__[]	= "server:fnrpc_fnservertransactionunlockall_1";
#ifdef MULTITHREAD
  typedef bool_t RESULTTYPE;
#else
  typedef fnServerTransactionUnlockAll_rets * RESULTTYPE;
#endif
#ifndef MULTITHREAD
  static fnServerTransactionUnlockAll_rets	Result;
  RESULTTYPE			pResult = &Result;
#endif
  LPCSTR	pszErrorMsg;

  __pRequest__	= pRequest;

  RPC_SERVER_ENTRY();

#ifndef MULTITHREAD
  if ( pResult->pszErrorMsg == szEmpty ) {
    pResult->pszErrorMsg	= NULL;
  }
  xdr_free ( (xdrproc_t) xdr_fnServerTransactionUnlockAll_rets, (char *) pResult );
#endif
  pResult->nErrorLvl		= 0;

  Reply.bAnswered		= FALSE;
  Reply.pfnCalled		= (void(*)()) fnServerTransactionUnlockAll;
  Reply.pfnXdrResult		= (bool_t(*)()) xdr_fnServerTransactionUnlockAll_rets;
  Reply.pnErrorLvl		= &pResult->nErrorLvl;
  Reply.ppszErrorMsg		= (LPCSTR *) &pResult->pszErrorMsg;
  Reply.pResult		= pResult;
  Reply.pReturnValue		= &pResult->ReturnValue;
  Reply.nReturnValueSize	= sizeof ( pResult->ReturnValue );

  pResult->ReturnValue		=
  fnServerTransactionUnlockAll (
	pArguments->oShortObjIdHeap,
	pArguments->oShortObjIdLockedBy,
	pArguments->oShortToUnlock );

  if ( Reply.bAnswered ) {
    __pRequest__	= NULL;
    return (RESULTTYPE) NULL;
  }

  pResult->nErrorLvl	= RPC_SERVER_ERRLVL();
  if ( pResult->nErrorLvl > 0 ) {
    pszErrorMsg		= RPC_SERVER_ERRMSG();
    if ( pszErrorMsg && *pszErrorMsg ) {
      pResult->pszErrorMsg	= strdup ( pszErrorMsg );
    }
  }
  if ( pResult->pszErrorMsg == NULL ) {
#ifdef MULTITHREAD
    pResult->pszErrorMsg	= strdup ( szEmpty );
#else
    pResult->pszErrorMsg	= (LPSTR) szEmpty;
#endif
  }
  __pRequest__	= NULL;
  return (RESULTTYPE) pResult;
} /* fnrpc_fnservertransactionunlockall_1 */




extern int fnServerTransactionUnlockAllAll
	(SHORTOBJID oShortObjIdHeap ,
	  SHORTOBJID oShortObjIdLockedBy);

#ifdef MULTITHREAD
bool_t
#else
fnServerTransactionUnlockAllAll_rets *
#endif
	PASTE2(fnrpc_fnservertransactionunlockallall_1,_SVCSUFFIX)
		( fnServerTransactionUnlockAllAll_args * pArguments,
#ifdef MULTITHREAD
		  fnServerTransactionUnlockAllAll_rets * pResult,
#endif
		  struct svc_req * pRequest )
{
  static const char	__procedure__[]	= "server:fnrpc_fnservertransactionunlockallall_1";
#ifdef MULTITHREAD
  typedef bool_t RESULTTYPE;
#else
  typedef fnServerTransactionUnlockAllAll_rets * RESULTTYPE;
#endif
#ifndef MULTITHREAD
  static fnServerTransactionUnlockAllAll_rets	Result;
  RESULTTYPE			pResult = &Result;
#endif
  LPCSTR	pszErrorMsg;

  __pRequest__	= pRequest;

  RPC_SERVER_ENTRY();

#ifndef MULTITHREAD
  if ( pResult->pszErrorMsg == szEmpty ) {
    pResult->pszErrorMsg	= NULL;
  }
  xdr_free ( (xdrproc_t) xdr_fnServerTransactionUnlockAllAll_rets, (char *) pResult );
#endif
  pResult->nErrorLvl		= 0;

  Reply.bAnswered		= FALSE;
  Reply.pfnCalled		= (void(*)()) fnServerTransactionUnlockAllAll;
  Reply.pfnXdrResult		= (bool_t(*)()) xdr_fnServerTransactionUnlockAllAll_rets;
  Reply.pnErrorLvl		= &pResult->nErrorLvl;
  Reply.ppszErrorMsg		= (LPCSTR *) &pResult->pszErrorMsg;
  Reply.pResult		= pResult;
  Reply.pReturnValue		= &pResult->ReturnValue;
  Reply.nReturnValueSize	= sizeof ( pResult->ReturnValue );

  pResult->ReturnValue		=
  fnServerTransactionUnlockAllAll (
	pArguments->oShortObjIdHeap,
	pArguments->oShortObjIdLockedBy );

  if ( Reply.bAnswered ) {
    __pRequest__	= NULL;
    return (RESULTTYPE) NULL;
  }

  pResult->nErrorLvl	= RPC_SERVER_ERRLVL();
  if ( pResult->nErrorLvl > 0 ) {
    pszErrorMsg		= RPC_SERVER_ERRMSG();
    if ( pszErrorMsg && *pszErrorMsg ) {
      pResult->pszErrorMsg	= strdup ( pszErrorMsg );
    }
  }
  if ( pResult->pszErrorMsg == NULL ) {
#ifdef MULTITHREAD
    pResult->pszErrorMsg	= strdup ( szEmpty );
#else
    pResult->pszErrorMsg	= (LPSTR) szEmpty;
#endif
  }
  __pRequest__	= NULL;
  return (RESULTTYPE) pResult;
} /* fnrpc_fnservertransactionunlockallall_1 */




extern bool_t fnShortMakeReadOnly
	(SHORTOBJID oShortObjIdHeap ,
	  SHORTOBJID oShortSelf ,
	  READONLYMODE nReadOnlyP);

#ifdef MULTITHREAD
bool_t
#else
fnShortMakeReadOnly_rets *
#endif
	PASTE2(fnrpc_fnshortmakereadonly_1,_SVCSUFFIX)
		( fnShortMakeReadOnly_args * pArguments,
#ifdef MULTITHREAD
		  fnShortMakeReadOnly_rets * pResult,
#endif
		  struct svc_req * pRequest )
{
  static const char	__procedure__[]	= "server:fnrpc_fnshortmakereadonly_1";
#ifdef MULTITHREAD
  typedef bool_t RESULTTYPE;
#else
  typedef fnShortMakeReadOnly_rets * RESULTTYPE;
#endif
#ifndef MULTITHREAD
  static fnShortMakeReadOnly_rets	Result;
  RESULTTYPE			pResult = &Result;
#endif
  LPCSTR	pszErrorMsg;

  __pRequest__	= pRequest;

  RPC_SERVER_ENTRY();

#ifndef MULTITHREAD
  if ( pResult->pszErrorMsg == szEmpty ) {
    pResult->pszErrorMsg	= NULL;
  }
  xdr_free ( (xdrproc_t) xdr_fnShortMakeReadOnly_rets, (char *) pResult );
#endif
  pResult->nErrorLvl		= 0;

  Reply.bAnswered		= FALSE;
  Reply.pfnCalled		= (void(*)()) fnShortMakeReadOnly;
  Reply.pfnXdrResult		= (bool_t(*)()) xdr_fnShortMakeReadOnly_rets;
  Reply.pnErrorLvl		= &pResult->nErrorLvl;
  Reply.ppszErrorMsg		= (LPCSTR *) &pResult->pszErrorMsg;
  Reply.pResult		= pResult;
  Reply.pReturnValue		= &pResult->ReturnValue;
  Reply.nReturnValueSize	= sizeof ( pResult->ReturnValue );

  pResult->ReturnValue		=
  fnShortMakeReadOnly (
	pArguments->oShortObjIdHeap,
	pArguments->oShortSelf,
	pArguments->nReadOnlyP );

  if ( Reply.bAnswered ) {
    __pRequest__	= NULL;
    return (RESULTTYPE) NULL;
  }

  pResult->nErrorLvl	= RPC_SERVER_ERRLVL();
  if ( pResult->nErrorLvl > 0 ) {
    pszErrorMsg		= RPC_SERVER_ERRMSG();
    if ( pszErrorMsg && *pszErrorMsg ) {
      pResult->pszErrorMsg	= strdup ( pszErrorMsg );
    }
  }
  if ( pResult->pszErrorMsg == NULL ) {
#ifdef MULTITHREAD
    pResult->pszErrorMsg	= strdup ( szEmpty );
#else
    pResult->pszErrorMsg	= (LPSTR) szEmpty;
#endif
  }
  __pRequest__	= NULL;
  return (RESULTTYPE) pResult;
} /* fnrpc_fnshortmakereadonly_1 */




extern TRACTID fnServerTransactionBegin
	(SHORTOBJID oShortObjIdHeap ,
	  bool_t bIgnoreError);

#ifdef MULTITHREAD
bool_t
#else
fnServerTransactionBegin_rets *
#endif
	PASTE2(fnrpc_fnservertransactionbegin_1,_SVCSUFFIX)
		( fnServerTransactionBegin_args * pArguments,
#ifdef MULTITHREAD
		  fnServerTransactionBegin_rets * pResult,
#endif
		  struct svc_req * pRequest )
{
  static const char	__procedure__[]	= "server:fnrpc_fnservertransactionbegin_1";
#ifdef MULTITHREAD
  typedef bool_t RESULTTYPE;
#else
  typedef fnServerTransactionBegin_rets * RESULTTYPE;
#endif
#ifndef MULTITHREAD
  static fnServerTransactionBegin_rets	Result;
  RESULTTYPE			pResult = &Result;
#endif
  LPCSTR	pszErrorMsg;

  __pRequest__	= pRequest;

  RPC_SERVER_ENTRY();

#ifndef MULTITHREAD
  if ( pResult->pszErrorMsg == szEmpty ) {
    pResult->pszErrorMsg	= NULL;
  }
  xdr_free ( (xdrproc_t) xdr_fnServerTransactionBegin_rets, (char *) pResult );
#endif
  pResult->nErrorLvl		= 0;

  Reply.bAnswered		= FALSE;
  Reply.pfnCalled		= (void(*)()) fnServerTransactionBegin;
  Reply.pfnXdrResult		= (bool_t(*)()) xdr_fnServerTransactionBegin_rets;
  Reply.pnErrorLvl		= &pResult->nErrorLvl;
  Reply.ppszErrorMsg		= (LPCSTR *) &pResult->pszErrorMsg;
  Reply.pResult		= pResult;
  Reply.pReturnValue		= &pResult->ReturnValue;
  Reply.nReturnValueSize	= sizeof ( pResult->ReturnValue );

  pResult->ReturnValue		=
  fnServerTransactionBegin (
	pArguments->oShortObjIdHeap,
	pArguments->bIgnoreError );

  if ( Reply.bAnswered ) {
    __pRequest__	= NULL;
    return (RESULTTYPE) NULL;
  }

  pResult->nErrorLvl	= RPC_SERVER_ERRLVL();
  if ( pResult->nErrorLvl > 0 ) {
    pszErrorMsg		= RPC_SERVER_ERRMSG();
    if ( pszErrorMsg && *pszErrorMsg ) {
      pResult->pszErrorMsg	= strdup ( pszErrorMsg );
    }
  }
  if ( pResult->pszErrorMsg == NULL ) {
#ifdef MULTITHREAD
    pResult->pszErrorMsg	= strdup ( szEmpty );
#else
    pResult->pszErrorMsg	= (LPSTR) szEmpty;
#endif
  }
  __pRequest__	= NULL;
  return (RESULTTYPE) pResult;
} /* fnrpc_fnservertransactionbegin_1 */




extern TRACTID fnServerTransactionCancel
	(SHORTOBJID oShortObjIdHeap ,
	  bool_t bIgnoreError);

#ifdef MULTITHREAD
bool_t
#else
fnServerTransactionCancel_rets *
#endif
	PASTE2(fnrpc_fnservertransactioncancel_1,_SVCSUFFIX)
		( fnServerTransactionCancel_args * pArguments,
#ifdef MULTITHREAD
		  fnServerTransactionCancel_rets * pResult,
#endif
		  struct svc_req * pRequest )
{
  static const char	__procedure__[]	= "server:fnrpc_fnservertransactioncancel_1";
#ifdef MULTITHREAD
  typedef bool_t RESULTTYPE;
#else
  typedef fnServerTransactionCancel_rets * RESULTTYPE;
#endif
#ifndef MULTITHREAD
  static fnServerTransactionCancel_rets	Result;
  RESULTTYPE			pResult = &Result;
#endif
  LPCSTR	pszErrorMsg;

  __pRequest__	= pRequest;

  RPC_SERVER_ENTRY();

#ifndef MULTITHREAD
  if ( pResult->pszErrorMsg == szEmpty ) {
    pResult->pszErrorMsg	= NULL;
  }
  xdr_free ( (xdrproc_t) xdr_fnServerTransactionCancel_rets, (char *) pResult );
#endif
  pResult->nErrorLvl		= 0;

  Reply.bAnswered		= FALSE;
  Reply.pfnCalled		= (void(*)()) fnServerTransactionCancel;
  Reply.pfnXdrResult		= (bool_t(*)()) xdr_fnServerTransactionCancel_rets;
  Reply.pnErrorLvl		= &pResult->nErrorLvl;
  Reply.ppszErrorMsg		= (LPCSTR *) &pResult->pszErrorMsg;
  Reply.pResult		= pResult;
  Reply.pReturnValue		= &pResult->ReturnValue;
  Reply.nReturnValueSize	= sizeof ( pResult->ReturnValue );

  pResult->ReturnValue		=
  fnServerTransactionCancel (
	pArguments->oShortObjIdHeap,
	pArguments->bIgnoreError );

  if ( Reply.bAnswered ) {
    __pRequest__	= NULL;
    return (RESULTTYPE) NULL;
  }

  pResult->nErrorLvl	= RPC_SERVER_ERRLVL();
  if ( pResult->nErrorLvl > 0 ) {
    pszErrorMsg		= RPC_SERVER_ERRMSG();
    if ( pszErrorMsg && *pszErrorMsg ) {
      pResult->pszErrorMsg	= strdup ( pszErrorMsg );
    }
  }
  if ( pResult->pszErrorMsg == NULL ) {
#ifdef MULTITHREAD
    pResult->pszErrorMsg	= strdup ( szEmpty );
#else
    pResult->pszErrorMsg	= (LPSTR) szEmpty;
#endif
  }
  __pRequest__	= NULL;
  return (RESULTTYPE) pResult;
} /* fnrpc_fnservertransactioncancel_1 */




extern TRACTID fnServerTransactionEnd
	(SHORTOBJID oShortObjIdHeap ,
	  bool_t bIgnoreError);

#ifdef MULTITHREAD
bool_t
#else
fnServerTransactionEnd_rets *
#endif
	PASTE2(fnrpc_fnservertransactionend_1,_SVCSUFFIX)
		( fnServerTransactionEnd_args * pArguments,
#ifdef MULTITHREAD
		  fnServerTransactionEnd_rets * pResult,
#endif
		  struct svc_req * pRequest )
{
  static const char	__procedure__[]	= "server:fnrpc_fnservertransactionend_1";
#ifdef MULTITHREAD
  typedef bool_t RESULTTYPE;
#else
  typedef fnServerTransactionEnd_rets * RESULTTYPE;
#endif
#ifndef MULTITHREAD
  static fnServerTransactionEnd_rets	Result;
  RESULTTYPE			pResult = &Result;
#endif
  LPCSTR	pszErrorMsg;

  __pRequest__	= pRequest;

  RPC_SERVER_ENTRY();

#ifndef MULTITHREAD
  if ( pResult->pszErrorMsg == szEmpty ) {
    pResult->pszErrorMsg	= NULL;
  }
  xdr_free ( (xdrproc_t) xdr_fnServerTransactionEnd_rets, (char *) pResult );
#endif
  pResult->nErrorLvl		= 0;

  Reply.bAnswered		= FALSE;
  Reply.pfnCalled		= (void(*)()) fnServerTransactionEnd;
  Reply.pfnXdrResult		= (bool_t(*)()) xdr_fnServerTransactionEnd_rets;
  Reply.pnErrorLvl		= &pResult->nErrorLvl;
  Reply.ppszErrorMsg		= (LPCSTR *) &pResult->pszErrorMsg;
  Reply.pResult		= pResult;
  Reply.pReturnValue		= &pResult->ReturnValue;
  Reply.nReturnValueSize	= sizeof ( pResult->ReturnValue );

  pResult->ReturnValue		=
  fnServerTransactionEnd (
	pArguments->oShortObjIdHeap,
	pArguments->bIgnoreError );

  if ( Reply.bAnswered ) {
    __pRequest__	= NULL;
    return (RESULTTYPE) NULL;
  }

  pResult->nErrorLvl	= RPC_SERVER_ERRLVL();
  if ( pResult->nErrorLvl > 0 ) {
    pszErrorMsg		= RPC_SERVER_ERRMSG();
    if ( pszErrorMsg && *pszErrorMsg ) {
      pResult->pszErrorMsg	= strdup ( pszErrorMsg );
    }
  }
  if ( pResult->pszErrorMsg == NULL ) {
#ifdef MULTITHREAD
    pResult->pszErrorMsg	= strdup ( szEmpty );
#else
    pResult->pszErrorMsg	= (LPSTR) szEmpty;
#endif
  }
  __pRequest__	= NULL;
  return (RESULTTYPE) pResult;
} /* fnrpc_fnservertransactionend_1 */




extern void fnServerTransactionFlush
	(SHORTOBJID oShortObjIdHeap);

#ifdef MULTITHREAD
bool_t
#else
void *
#endif
	PASTE2(fnrpc_fnservertransactionflush_batch_1,_SVCSUFFIX)
		( SHORTOBJID * pArguments,
#ifdef MULTITHREAD
		  void * pResult,
#endif
		  struct svc_req * pRequest )
{
  static const char	__procedure__[]	= "server:fnrpc_fnservertransactionflush_batch_1";
#ifdef MULTITHREAD
  typedef bool_t RESULTTYPE;
#else
  typedef void * RESULTTYPE;
#endif

  __pRequest__	= pRequest;

  RPC_SERVER_ENTRY();

  Reply.bAnswered		= TRUE;
  Reply.pfnCalled		= (void(*)()) fnServerTransactionFlush;
  Reply.pfnXdrResult		= (bool_t(*)()) xdr_void;
  Reply.pnErrorLvl		= NULL;
  Reply.ppszErrorMsg		= NULL;
  Reply.pResult			= NULL;
  Reply.pReturnValue		= NULL;
  Reply.nReturnValueSize	= 0;
  fnServerTransactionFlush (
	(*pArguments) );
  __pRequest__	= NULL;
  return (RESULTTYPE) NULL;
} /* fnrpc_fnservertransactionflush_batch_1 */




extern TRACTID fnServerDbTransactionP
	(SHORTOBJID oShortObjIdHeap ,
	  TRACTID nTractId);

#ifdef MULTITHREAD
bool_t
#else
fnServerDbTransactionP_rets *
#endif
	PASTE2(fnrpc_fnserverdbtransactionp_1,_SVCSUFFIX)
		( fnServerDbTransactionP_args * pArguments,
#ifdef MULTITHREAD
		  fnServerDbTransactionP_rets * pResult,
#endif
		  struct svc_req * pRequest )
{
  static const char	__procedure__[]	= "server:fnrpc_fnserverdbtransactionp_1";
#ifdef MULTITHREAD
  typedef bool_t RESULTTYPE;
#else
  typedef fnServerDbTransactionP_rets * RESULTTYPE;
#endif
#ifndef MULTITHREAD
  static fnServerDbTransactionP_rets	Result;
  RESULTTYPE			pResult = &Result;
#endif
  LPCSTR	pszErrorMsg;

  __pRequest__	= pRequest;

  RPC_SERVER_ENTRY();

#ifndef MULTITHREAD
  if ( pResult->pszErrorMsg == szEmpty ) {
    pResult->pszErrorMsg	= NULL;
  }
  xdr_free ( (xdrproc_t) xdr_fnServerDbTransactionP_rets, (char *) pResult );
#endif
  pResult->nErrorLvl		= 0;

  Reply.bAnswered		= FALSE;
  Reply.pfnCalled		= (void(*)()) fnServerDbTransactionP;
  Reply.pfnXdrResult		= (bool_t(*)()) xdr_fnServerDbTransactionP_rets;
  Reply.pnErrorLvl		= &pResult->nErrorLvl;
  Reply.ppszErrorMsg		= (LPCSTR *) &pResult->pszErrorMsg;
  Reply.pResult		= pResult;
  Reply.pReturnValue		= &pResult->ReturnValue;
  Reply.nReturnValueSize	= sizeof ( pResult->ReturnValue );

  pResult->ReturnValue		=
  fnServerDbTransactionP (
	pArguments->oShortObjIdHeap,
	pArguments->nTractId );

  if ( Reply.bAnswered ) {
    __pRequest__	= NULL;
    return (RESULTTYPE) NULL;
  }

  pResult->nErrorLvl	= RPC_SERVER_ERRLVL();
  if ( pResult->nErrorLvl > 0 ) {
    pszErrorMsg		= RPC_SERVER_ERRMSG();
    if ( pszErrorMsg && *pszErrorMsg ) {
      pResult->pszErrorMsg	= strdup ( pszErrorMsg );
    }
  }
  if ( pResult->pszErrorMsg == NULL ) {
#ifdef MULTITHREAD
    pResult->pszErrorMsg	= strdup ( szEmpty );
#else
    pResult->pszErrorMsg	= (LPSTR) szEmpty;
#endif
  }
  __pRequest__	= NULL;
  return (RESULTTYPE) pResult;
} /* fnrpc_fnserverdbtransactionp_1 */




extern BTREERESULT fnClientBtreeClear
	(SHORTOBJID oShortObjIdHeap ,
	  SHORTOBJID oShortObjIdBTree);

#ifdef MULTITHREAD
bool_t
#else
fnClientBtreeClear_rets *
#endif
	PASTE2(fnrpc_fnclientbtreeclear_1,_SVCSUFFIX)
		( fnClientBtreeClear_args * pArguments,
#ifdef MULTITHREAD
		  fnClientBtreeClear_rets * pResult,
#endif
		  struct svc_req * pRequest )
{
  static const char	__procedure__[]	= "server:fnrpc_fnclientbtreeclear_1";
#ifdef MULTITHREAD
  typedef bool_t RESULTTYPE;
#else
  typedef fnClientBtreeClear_rets * RESULTTYPE;
#endif
#ifndef MULTITHREAD
  static fnClientBtreeClear_rets	Result;
  RESULTTYPE			pResult = &Result;
#endif
  LPCSTR	pszErrorMsg;

  __pRequest__	= pRequest;

  RPC_SERVER_ENTRY();

#ifndef MULTITHREAD
  if ( pResult->pszErrorMsg == szEmpty ) {
    pResult->pszErrorMsg	= NULL;
  }
  xdr_free ( (xdrproc_t) xdr_fnClientBtreeClear_rets, (char *) pResult );
#endif
  pResult->nErrorLvl		= 0;

  Reply.bAnswered		= FALSE;
  Reply.pfnCalled		= (void(*)()) fnClientBtreeClear;
  Reply.pfnXdrResult		= (bool_t(*)()) xdr_fnClientBtreeClear_rets;
  Reply.pnErrorLvl		= &pResult->nErrorLvl;
  Reply.ppszErrorMsg		= (LPCSTR *) &pResult->pszErrorMsg;
  Reply.pResult		= pResult;
  Reply.pReturnValue		= &pResult->ReturnValue;
  Reply.nReturnValueSize	= sizeof ( pResult->ReturnValue );

  pResult->ReturnValue		=
  fnClientBtreeClear (
	pArguments->oShortObjIdHeap,
	pArguments->oShortObjIdBTree );

  if ( Reply.bAnswered ) {
    __pRequest__	= NULL;
    return (RESULTTYPE) NULL;
  }

  pResult->nErrorLvl	= RPC_SERVER_ERRLVL();
  if ( pResult->nErrorLvl > 0 ) {
    pszErrorMsg		= RPC_SERVER_ERRMSG();
    if ( pszErrorMsg && *pszErrorMsg ) {
      pResult->pszErrorMsg	= strdup ( pszErrorMsg );
    }
  }
  if ( pResult->pszErrorMsg == NULL ) {
#ifdef MULTITHREAD
    pResult->pszErrorMsg	= strdup ( szEmpty );
#else
    pResult->pszErrorMsg	= (LPSTR) szEmpty;
#endif
  }
  __pRequest__	= NULL;
  return (RESULTTYPE) pResult;
} /* fnrpc_fnclientbtreeclear_1 */




extern int fnClientBtreeCount
	(SHORTOBJID oShortObjIdHeap ,
	  SHORTOBJID oShortObjIdBTree);

#ifdef MULTITHREAD
bool_t
#else
fnClientBtreeCount_rets *
#endif
	PASTE2(fnrpc_fnclientbtreecount_1,_SVCSUFFIX)
		( fnClientBtreeCount_args * pArguments,
#ifdef MULTITHREAD
		  fnClientBtreeCount_rets * pResult,
#endif
		  struct svc_req * pRequest )
{
  static const char	__procedure__[]	= "server:fnrpc_fnclientbtreecount_1";
#ifdef MULTITHREAD
  typedef bool_t RESULTTYPE;
#else
  typedef fnClientBtreeCount_rets * RESULTTYPE;
#endif
#ifndef MULTITHREAD
  static fnClientBtreeCount_rets	Result;
  RESULTTYPE			pResult = &Result;
#endif
  LPCSTR	pszErrorMsg;

  __pRequest__	= pRequest;

  RPC_SERVER_ENTRY();

#ifndef MULTITHREAD
  if ( pResult->pszErrorMsg == szEmpty ) {
    pResult->pszErrorMsg	= NULL;
  }
  xdr_free ( (xdrproc_t) xdr_fnClientBtreeCount_rets, (char *) pResult );
#endif
  pResult->nErrorLvl		= 0;

  Reply.bAnswered		= FALSE;
  Reply.pfnCalled		= (void(*)()) fnClientBtreeCount;
  Reply.pfnXdrResult		= (bool_t(*)()) xdr_fnClientBtreeCount_rets;
  Reply.pnErrorLvl		= &pResult->nErrorLvl;
  Reply.ppszErrorMsg		= (LPCSTR *) &pResult->pszErrorMsg;
  Reply.pResult		= pResult;
  Reply.pReturnValue		= &pResult->ReturnValue;
  Reply.nReturnValueSize	= sizeof ( pResult->ReturnValue );

  pResult->ReturnValue		=
  fnClientBtreeCount (
	pArguments->oShortObjIdHeap,
	pArguments->oShortObjIdBTree );

  if ( Reply.bAnswered ) {
    __pRequest__	= NULL;
    return (RESULTTYPE) NULL;
  }

  pResult->nErrorLvl	= RPC_SERVER_ERRLVL();
  if ( pResult->nErrorLvl > 0 ) {
    pszErrorMsg		= RPC_SERVER_ERRMSG();
    if ( pszErrorMsg && *pszErrorMsg ) {
      pResult->pszErrorMsg	= strdup ( pszErrorMsg );
    }
  }
  if ( pResult->pszErrorMsg == NULL ) {
#ifdef MULTITHREAD
    pResult->pszErrorMsg	= strdup ( szEmpty );
#else
    pResult->pszErrorMsg	= (LPSTR) szEmpty;
#endif
  }
  __pRequest__	= NULL;
  return (RESULTTYPE) pResult;
} /* fnrpc_fnclientbtreecount_1 */




extern BTREERESULT fnServerBtreeDelete
	(SHORTOBJID oShortObjIdHeap ,
	  SHORTOBJID oShortObjIdBTree ,
	  int nValueKey ,
	  SHTYPETAG nTypeTagKey);

#ifdef MULTITHREAD
bool_t
#else
fnServerBtreeDelete_rets *
#endif
	PASTE2(fnrpc_fnserverbtreedelete_1,_SVCSUFFIX)
		( fnServerBtreeDelete_args * pArguments,
#ifdef MULTITHREAD
		  fnServerBtreeDelete_rets * pResult,
#endif
		  struct svc_req * pRequest )
{
  static const char	__procedure__[]	= "server:fnrpc_fnserverbtreedelete_1";
#ifdef MULTITHREAD
  typedef bool_t RESULTTYPE;
#else
  typedef fnServerBtreeDelete_rets * RESULTTYPE;
#endif
#ifndef MULTITHREAD
  static fnServerBtreeDelete_rets	Result;
  RESULTTYPE			pResult = &Result;
#endif
  LPCSTR	pszErrorMsg;

  __pRequest__	= pRequest;

  RPC_SERVER_ENTRY();

#ifndef MULTITHREAD
  if ( pResult->pszErrorMsg == szEmpty ) {
    pResult->pszErrorMsg	= NULL;
  }
  xdr_free ( (xdrproc_t) xdr_fnServerBtreeDelete_rets, (char *) pResult );
#endif
  pResult->nErrorLvl		= 0;

  Reply.bAnswered		= FALSE;
  Reply.pfnCalled		= (void(*)()) fnServerBtreeDelete;
  Reply.pfnXdrResult		= (bool_t(*)()) xdr_fnServerBtreeDelete_rets;
  Reply.pnErrorLvl		= &pResult->nErrorLvl;
  Reply.ppszErrorMsg		= (LPCSTR *) &pResult->pszErrorMsg;
  Reply.pResult		= pResult;
  Reply.pReturnValue		= &pResult->ReturnValue;
  Reply.nReturnValueSize	= sizeof ( pResult->ReturnValue );

  pResult->ReturnValue		=
  fnServerBtreeDelete (
	pArguments->oShortObjIdHeap,
	pArguments->oShortObjIdBTree,
	pArguments->nValueKey,
	pArguments->nTypeTagKey );

  if ( Reply.bAnswered ) {
    __pRequest__	= NULL;
    return (RESULTTYPE) NULL;
  }

  pResult->nErrorLvl	= RPC_SERVER_ERRLVL();
  if ( pResult->nErrorLvl > 0 ) {
    pszErrorMsg		= RPC_SERVER_ERRMSG();
    if ( pszErrorMsg && *pszErrorMsg ) {
      pResult->pszErrorMsg	= strdup ( pszErrorMsg );
    }
  }
  if ( pResult->pszErrorMsg == NULL ) {
#ifdef MULTITHREAD
    pResult->pszErrorMsg	= strdup ( szEmpty );
#else
    pResult->pszErrorMsg	= (LPSTR) szEmpty;
#endif
  }
  __pRequest__	= NULL;
  return (RESULTTYPE) pResult;
} /* fnrpc_fnserverbtreedelete_1 */




extern BTREERESULT fnServerBtreeDeleteByFloat
	(SHORTOBJID oShortObjIdHeap ,
	  SHORTOBJID oShortObjIdBTree ,
	  float fKey);

#ifdef MULTITHREAD
bool_t
#else
fnServerBtreeDeleteByFloat_rets *
#endif
	PASTE2(fnrpc_fnserverbtreedeletebyfloat_1,_SVCSUFFIX)
		( fnServerBtreeDeleteByFloat_args * pArguments,
#ifdef MULTITHREAD
		  fnServerBtreeDeleteByFloat_rets * pResult,
#endif
		  struct svc_req * pRequest )
{
  static const char	__procedure__[]	= "server:fnrpc_fnserverbtreedeletebyfloat_1";
#ifdef MULTITHREAD
  typedef bool_t RESULTTYPE;
#else
  typedef fnServerBtreeDeleteByFloat_rets * RESULTTYPE;
#endif
#ifndef MULTITHREAD
  static fnServerBtreeDeleteByFloat_rets	Result;
  RESULTTYPE			pResult = &Result;
#endif
  LPCSTR	pszErrorMsg;

  __pRequest__	= pRequest;

  RPC_SERVER_ENTRY();

#ifndef MULTITHREAD
  if ( pResult->pszErrorMsg == szEmpty ) {
    pResult->pszErrorMsg	= NULL;
  }
  xdr_free ( (xdrproc_t) xdr_fnServerBtreeDeleteByFloat_rets, (char *) pResult );
#endif
  pResult->nErrorLvl		= 0;

  Reply.bAnswered		= FALSE;
  Reply.pfnCalled		= (void(*)()) fnServerBtreeDeleteByFloat;
  Reply.pfnXdrResult		= (bool_t(*)()) xdr_fnServerBtreeDeleteByFloat_rets;
  Reply.pnErrorLvl		= &pResult->nErrorLvl;
  Reply.ppszErrorMsg		= (LPCSTR *) &pResult->pszErrorMsg;
  Reply.pResult		= pResult;
  Reply.pReturnValue		= &pResult->ReturnValue;
  Reply.nReturnValueSize	= sizeof ( pResult->ReturnValue );

  pResult->ReturnValue		=
  fnServerBtreeDeleteByFloat (
	pArguments->oShortObjIdHeap,
	pArguments->oShortObjIdBTree,
	pArguments->fKey );

  if ( Reply.bAnswered ) {
    __pRequest__	= NULL;
    return (RESULTTYPE) NULL;
  }

  pResult->nErrorLvl	= RPC_SERVER_ERRLVL();
  if ( pResult->nErrorLvl > 0 ) {
    pszErrorMsg		= RPC_SERVER_ERRMSG();
    if ( pszErrorMsg && *pszErrorMsg ) {
      pResult->pszErrorMsg	= strdup ( pszErrorMsg );
    }
  }
  if ( pResult->pszErrorMsg == NULL ) {
#ifdef MULTITHREAD
    pResult->pszErrorMsg	= strdup ( szEmpty );
#else
    pResult->pszErrorMsg	= (LPSTR) szEmpty;
#endif
  }
  __pRequest__	= NULL;
  return (RESULTTYPE) pResult;
} /* fnrpc_fnserverbtreedeletebyfloat_1 */




extern BTREERESULT fnServerBtreeDeleteByDouble
	(SHORTOBJID oShortObjIdHeap ,
	  SHORTOBJID oShortObjIdBTree ,
	  double fKey);

#ifdef MULTITHREAD
bool_t
#else
fnServerBtreeDeleteByDouble_rets *
#endif
	PASTE2(fnrpc_fnserverbtreedeletebydouble_1,_SVCSUFFIX)
		( fnServerBtreeDeleteByDouble_args * pArguments,
#ifdef MULTITHREAD
		  fnServerBtreeDeleteByDouble_rets * pResult,
#endif
		  struct svc_req * pRequest )
{
  static const char	__procedure__[]	= "server:fnrpc_fnserverbtreedeletebydouble_1";
#ifdef MULTITHREAD
  typedef bool_t RESULTTYPE;
#else
  typedef fnServerBtreeDeleteByDouble_rets * RESULTTYPE;
#endif
#ifndef MULTITHREAD
  static fnServerBtreeDeleteByDouble_rets	Result;
  RESULTTYPE			pResult = &Result;
#endif
  LPCSTR	pszErrorMsg;

  __pRequest__	= pRequest;

  RPC_SERVER_ENTRY();

#ifndef MULTITHREAD
  if ( pResult->pszErrorMsg == szEmpty ) {
    pResult->pszErrorMsg	= NULL;
  }
  xdr_free ( (xdrproc_t) xdr_fnServerBtreeDeleteByDouble_rets, (char *) pResult );
#endif
  pResult->nErrorLvl		= 0;

  Reply.bAnswered		= FALSE;
  Reply.pfnCalled		= (void(*)()) fnServerBtreeDeleteByDouble;
  Reply.pfnXdrResult		= (bool_t(*)()) xdr_fnServerBtreeDeleteByDouble_rets;
  Reply.pnErrorLvl		= &pResult->nErrorLvl;
  Reply.ppszErrorMsg		= (LPCSTR *) &pResult->pszErrorMsg;
  Reply.pResult		= pResult;
  Reply.pReturnValue		= &pResult->ReturnValue;
  Reply.nReturnValueSize	= sizeof ( pResult->ReturnValue );

  pResult->ReturnValue		=
  fnServerBtreeDeleteByDouble (
	pArguments->oShortObjIdHeap,
	pArguments->oShortObjIdBTree,
	pArguments->fKey );

  if ( Reply.bAnswered ) {
    __pRequest__	= NULL;
    return (RESULTTYPE) NULL;
  }

  pResult->nErrorLvl	= RPC_SERVER_ERRLVL();
  if ( pResult->nErrorLvl > 0 ) {
    pszErrorMsg		= RPC_SERVER_ERRMSG();
    if ( pszErrorMsg && *pszErrorMsg ) {
      pResult->pszErrorMsg	= strdup ( pszErrorMsg );
    }
  }
  if ( pResult->pszErrorMsg == NULL ) {
#ifdef MULTITHREAD
    pResult->pszErrorMsg	= strdup ( szEmpty );
#else
    pResult->pszErrorMsg	= (LPSTR) szEmpty;
#endif
  }
  __pRequest__	= NULL;
  return (RESULTTYPE) pResult;
} /* fnrpc_fnserverbtreedeletebydouble_1 */




extern BTREERESULT fnServerBtreeDeleteByString
	(SHORTOBJID oShortObjIdHeap ,
	  SHORTOBJID oShortObjIdBTree ,
	  string_t /* string_t<@conststring@> */ szKey);

#ifdef MULTITHREAD
bool_t
#else
fnServerBtreeDeleteByString_rets *
#endif
	PASTE2(fnrpc_fnserverbtreedeletebystring_1,_SVCSUFFIX)
		( fnServerBtreeDeleteByString_args * pArguments,
#ifdef MULTITHREAD
		  fnServerBtreeDeleteByString_rets * pResult,
#endif
		  struct svc_req * pRequest )
{
  static const char	__procedure__[]	= "server:fnrpc_fnserverbtreedeletebystring_1";
#ifdef MULTITHREAD
  typedef bool_t RESULTTYPE;
#else
  typedef fnServerBtreeDeleteByString_rets * RESULTTYPE;
#endif
#ifndef MULTITHREAD
  static fnServerBtreeDeleteByString_rets	Result;
  RESULTTYPE			pResult = &Result;
#endif
  LPCSTR	pszErrorMsg;

  __pRequest__	= pRequest;

  RPC_SERVER_ENTRY();

#ifndef MULTITHREAD
  if ( pResult->pszErrorMsg == szEmpty ) {
    pResult->pszErrorMsg	= NULL;
  }
  xdr_free ( (xdrproc_t) xdr_fnServerBtreeDeleteByString_rets, (char *) pResult );
#endif
  pResult->nErrorLvl		= 0;

  Reply.bAnswered		= FALSE;
  Reply.pfnCalled		= (void(*)()) fnServerBtreeDeleteByString;
  Reply.pfnXdrResult		= (bool_t(*)()) xdr_fnServerBtreeDeleteByString_rets;
  Reply.pnErrorLvl		= &pResult->nErrorLvl;
  Reply.ppszErrorMsg		= (LPCSTR *) &pResult->pszErrorMsg;
  Reply.pResult		= pResult;
  Reply.pReturnValue		= &pResult->ReturnValue;
  Reply.nReturnValueSize	= sizeof ( pResult->ReturnValue );

  pResult->ReturnValue		=
  fnServerBtreeDeleteByString (
	pArguments->oShortObjIdHeap,
	pArguments->oShortObjIdBTree,
	pArguments->szKey );

  if ( Reply.bAnswered ) {
    __pRequest__	= NULL;
    return (RESULTTYPE) NULL;
  }

  pResult->nErrorLvl	= RPC_SERVER_ERRLVL();
  if ( pResult->nErrorLvl > 0 ) {
    pszErrorMsg		= RPC_SERVER_ERRMSG();
    if ( pszErrorMsg && *pszErrorMsg ) {
      pResult->pszErrorMsg	= strdup ( pszErrorMsg );
    }
  }
  if ( pResult->pszErrorMsg == NULL ) {
#ifdef MULTITHREAD
    pResult->pszErrorMsg	= strdup ( szEmpty );
#else
    pResult->pszErrorMsg	= (LPSTR) szEmpty;
#endif
  }
  __pRequest__	= NULL;
  return (RESULTTYPE) pResult;
} /* fnrpc_fnserverbtreedeletebystring_1 */




extern BTREERESULT fnServerBtreeInsert
	(SHORTOBJID oShortObjIdHeap ,
	  SHORTOBJID oShortObjIdBTree ,
	  int nValueKey ,
	  SHTYPETAG nTypeTagKey ,
	  int nValueData ,
	  SHTYPETAG nTypeTagData);

#ifdef MULTITHREAD
bool_t
#else
fnServerBtreeInsert_rets *
#endif
	PASTE2(fnrpc_fnserverbtreeinsert_1,_SVCSUFFIX)
		( fnServerBtreeInsert_args * pArguments,
#ifdef MULTITHREAD
		  fnServerBtreeInsert_rets * pResult,
#endif
		  struct svc_req * pRequest )
{
  static const char	__procedure__[]	= "server:fnrpc_fnserverbtreeinsert_1";
#ifdef MULTITHREAD
  typedef bool_t RESULTTYPE;
#else
  typedef fnServerBtreeInsert_rets * RESULTTYPE;
#endif
#ifndef MULTITHREAD
  static fnServerBtreeInsert_rets	Result;
  RESULTTYPE			pResult = &Result;
#endif
  LPCSTR	pszErrorMsg;

  __pRequest__	= pRequest;

  RPC_SERVER_ENTRY();

#ifndef MULTITHREAD
  if ( pResult->pszErrorMsg == szEmpty ) {
    pResult->pszErrorMsg	= NULL;
  }
  xdr_free ( (xdrproc_t) xdr_fnServerBtreeInsert_rets, (char *) pResult );
#endif
  pResult->nErrorLvl		= 0;

  Reply.bAnswered		= FALSE;
  Reply.pfnCalled		= (void(*)()) fnServerBtreeInsert;
  Reply.pfnXdrResult		= (bool_t(*)()) xdr_fnServerBtreeInsert_rets;
  Reply.pnErrorLvl		= &pResult->nErrorLvl;
  Reply.ppszErrorMsg		= (LPCSTR *) &pResult->pszErrorMsg;
  Reply.pResult		= pResult;
  Reply.pReturnValue		= &pResult->ReturnValue;
  Reply.nReturnValueSize	= sizeof ( pResult->ReturnValue );

  pResult->ReturnValue		=
  fnServerBtreeInsert (
	pArguments->oShortObjIdHeap,
	pArguments->oShortObjIdBTree,
	pArguments->nValueKey,
	pArguments->nTypeTagKey,
	pArguments->nValueData,
	pArguments->nTypeTagData );

  if ( Reply.bAnswered ) {
    __pRequest__	= NULL;
    return (RESULTTYPE) NULL;
  }

  pResult->nErrorLvl	= RPC_SERVER_ERRLVL();
  if ( pResult->nErrorLvl > 0 ) {
    pszErrorMsg		= RPC_SERVER_ERRMSG();
    if ( pszErrorMsg && *pszErrorMsg ) {
      pResult->pszErrorMsg	= strdup ( pszErrorMsg );
    }
  }
  if ( pResult->pszErrorMsg == NULL ) {
#ifdef MULTITHREAD
    pResult->pszErrorMsg	= strdup ( szEmpty );
#else
    pResult->pszErrorMsg	= (LPSTR) szEmpty;
#endif
  }
  __pRequest__	= NULL;
  return (RESULTTYPE) pResult;
} /* fnrpc_fnserverbtreeinsert_1 */




extern BTREERESULT fnServerBtreeInsertByFloat
	(SHORTOBJID oShortObjIdHeap ,
	  SHORTOBJID oShortObjIdBTree ,
	  float fKey ,
	  int nValueData ,
	  SHTYPETAG nTypeTagData);

#ifdef MULTITHREAD
bool_t
#else
fnServerBtreeInsertByFloat_rets *
#endif
	PASTE2(fnrpc_fnserverbtreeinsertbyfloat_1,_SVCSUFFIX)
		( fnServerBtreeInsertByFloat_args * pArguments,
#ifdef MULTITHREAD
		  fnServerBtreeInsertByFloat_rets * pResult,
#endif
		  struct svc_req * pRequest )
{
  static const char	__procedure__[]	= "server:fnrpc_fnserverbtreeinsertbyfloat_1";
#ifdef MULTITHREAD
  typedef bool_t RESULTTYPE;
#else
  typedef fnServerBtreeInsertByFloat_rets * RESULTTYPE;
#endif
#ifndef MULTITHREAD
  static fnServerBtreeInsertByFloat_rets	Result;
  RESULTTYPE			pResult = &Result;
#endif
  LPCSTR	pszErrorMsg;

  __pRequest__	= pRequest;

  RPC_SERVER_ENTRY();

#ifndef MULTITHREAD
  if ( pResult->pszErrorMsg == szEmpty ) {
    pResult->pszErrorMsg	= NULL;
  }
  xdr_free ( (xdrproc_t) xdr_fnServerBtreeInsertByFloat_rets, (char *) pResult );
#endif
  pResult->nErrorLvl		= 0;

  Reply.bAnswered		= FALSE;
  Reply.pfnCalled		= (void(*)()) fnServerBtreeInsertByFloat;
  Reply.pfnXdrResult		= (bool_t(*)()) xdr_fnServerBtreeInsertByFloat_rets;
  Reply.pnErrorLvl		= &pResult->nErrorLvl;
  Reply.ppszErrorMsg		= (LPCSTR *) &pResult->pszErrorMsg;
  Reply.pResult		= pResult;
  Reply.pReturnValue		= &pResult->ReturnValue;
  Reply.nReturnValueSize	= sizeof ( pResult->ReturnValue );

  pResult->ReturnValue		=
  fnServerBtreeInsertByFloat (
	pArguments->oShortObjIdHeap,
	pArguments->oShortObjIdBTree,
	pArguments->fKey,
	pArguments->nValueData,
	pArguments->nTypeTagData );

  if ( Reply.bAnswered ) {
    __pRequest__	= NULL;
    return (RESULTTYPE) NULL;
  }

  pResult->nErrorLvl	= RPC_SERVER_ERRLVL();
  if ( pResult->nErrorLvl > 0 ) {
    pszErrorMsg		= RPC_SERVER_ERRMSG();
    if ( pszErrorMsg && *pszErrorMsg ) {
      pResult->pszErrorMsg	= strdup ( pszErrorMsg );
    }
  }
  if ( pResult->pszErrorMsg == NULL ) {
#ifdef MULTITHREAD
    pResult->pszErrorMsg	= strdup ( szEmpty );
#else
    pResult->pszErrorMsg	= (LPSTR) szEmpty;
#endif
  }
  __pRequest__	= NULL;
  return (RESULTTYPE) pResult;
} /* fnrpc_fnserverbtreeinsertbyfloat_1 */




extern BTREERESULT fnServerBtreeInsertByDouble
	(SHORTOBJID oShortObjIdHeap ,
	  SHORTOBJID oShortObjIdBTree ,
	  double fKey ,
	  int nValueData ,
	  SHTYPETAG nTypeTagData);

#ifdef MULTITHREAD
bool_t
#else
fnServerBtreeInsertByDouble_rets *
#endif
	PASTE2(fnrpc_fnserverbtreeinsertbydouble_1,_SVCSUFFIX)
		( fnServerBtreeInsertByDouble_args * pArguments,
#ifdef MULTITHREAD
		  fnServerBtreeInsertByDouble_rets * pResult,
#endif
		  struct svc_req * pRequest )
{
  static const char	__procedure__[]	= "server:fnrpc_fnserverbtreeinsertbydouble_1";
#ifdef MULTITHREAD
  typedef bool_t RESULTTYPE;
#else
  typedef fnServerBtreeInsertByDouble_rets * RESULTTYPE;
#endif
#ifndef MULTITHREAD
  static fnServerBtreeInsertByDouble_rets	Result;
  RESULTTYPE			pResult = &Result;
#endif
  LPCSTR	pszErrorMsg;

  __pRequest__	= pRequest;

  RPC_SERVER_ENTRY();

#ifndef MULTITHREAD
  if ( pResult->pszErrorMsg == szEmpty ) {
    pResult->pszErrorMsg	= NULL;
  }
  xdr_free ( (xdrproc_t) xdr_fnServerBtreeInsertByDouble_rets, (char *) pResult );
#endif
  pResult->nErrorLvl		= 0;

  Reply.bAnswered		= FALSE;
  Reply.pfnCalled		= (void(*)()) fnServerBtreeInsertByDouble;
  Reply.pfnXdrResult		= (bool_t(*)()) xdr_fnServerBtreeInsertByDouble_rets;
  Reply.pnErrorLvl		= &pResult->nErrorLvl;
  Reply.ppszErrorMsg		= (LPCSTR *) &pResult->pszErrorMsg;
  Reply.pResult		= pResult;
  Reply.pReturnValue		= &pResult->ReturnValue;
  Reply.nReturnValueSize	= sizeof ( pResult->ReturnValue );

  pResult->ReturnValue		=
  fnServerBtreeInsertByDouble (
	pArguments->oShortObjIdHeap,
	pArguments->oShortObjIdBTree,
	pArguments->fKey,
	pArguments->nValueData,
	pArguments->nTypeTagData );

  if ( Reply.bAnswered ) {
    __pRequest__	= NULL;
    return (RESULTTYPE) NULL;
  }

  pResult->nErrorLvl	= RPC_SERVER_ERRLVL();
  if ( pResult->nErrorLvl > 0 ) {
    pszErrorMsg		= RPC_SERVER_ERRMSG();
    if ( pszErrorMsg && *pszErrorMsg ) {
      pResult->pszErrorMsg	= strdup ( pszErrorMsg );
    }
  }
  if ( pResult->pszErrorMsg == NULL ) {
#ifdef MULTITHREAD
    pResult->pszErrorMsg	= strdup ( szEmpty );
#else
    pResult->pszErrorMsg	= (LPSTR) szEmpty;
#endif
  }
  __pRequest__	= NULL;
  return (RESULTTYPE) pResult;
} /* fnrpc_fnserverbtreeinsertbydouble_1 */




extern BTREERESULT fnServerBtreeInsertByString
	(SHORTOBJID oShortObjIdHeap ,
	  SHORTOBJID oShortObjIdBTree ,
	  string_t /* string_t<@conststring@> */ szKey ,
	  int nValueData ,
	  SHTYPETAG nTypeTagData);

#ifdef MULTITHREAD
bool_t
#else
fnServerBtreeInsertByString_rets *
#endif
	PASTE2(fnrpc_fnserverbtreeinsertbystring_1,_SVCSUFFIX)
		( fnServerBtreeInsertByString_args * pArguments,
#ifdef MULTITHREAD
		  fnServerBtreeInsertByString_rets * pResult,
#endif
		  struct svc_req * pRequest )
{
  static const char	__procedure__[]	= "server:fnrpc_fnserverbtreeinsertbystring_1";
#ifdef MULTITHREAD
  typedef bool_t RESULTTYPE;
#else
  typedef fnServerBtreeInsertByString_rets * RESULTTYPE;
#endif
#ifndef MULTITHREAD
  static fnServerBtreeInsertByString_rets	Result;
  RESULTTYPE			pResult = &Result;
#endif
  LPCSTR	pszErrorMsg;

  __pRequest__	= pRequest;

  RPC_SERVER_ENTRY();

#ifndef MULTITHREAD
  if ( pResult->pszErrorMsg == szEmpty ) {
    pResult->pszErrorMsg	= NULL;
  }
  xdr_free ( (xdrproc_t) xdr_fnServerBtreeInsertByString_rets, (char *) pResult );
#endif
  pResult->nErrorLvl		= 0;

  Reply.bAnswered		= FALSE;
  Reply.pfnCalled		= (void(*)()) fnServerBtreeInsertByString;
  Reply.pfnXdrResult		= (bool_t(*)()) xdr_fnServerBtreeInsertByString_rets;
  Reply.pnErrorLvl		= &pResult->nErrorLvl;
  Reply.ppszErrorMsg		= (LPCSTR *) &pResult->pszErrorMsg;
  Reply.pResult		= pResult;
  Reply.pReturnValue		= &pResult->ReturnValue;
  Reply.nReturnValueSize	= sizeof ( pResult->ReturnValue );

  pResult->ReturnValue		=
  fnServerBtreeInsertByString (
	pArguments->oShortObjIdHeap,
	pArguments->oShortObjIdBTree,
	pArguments->szKey,
	pArguments->nValueData,
	pArguments->nTypeTagData );

  if ( Reply.bAnswered ) {
    __pRequest__	= NULL;
    return (RESULTTYPE) NULL;
  }

  pResult->nErrorLvl	= RPC_SERVER_ERRLVL();
  if ( pResult->nErrorLvl > 0 ) {
    pszErrorMsg		= RPC_SERVER_ERRMSG();
    if ( pszErrorMsg && *pszErrorMsg ) {
      pResult->pszErrorMsg	= strdup ( pszErrorMsg );
    }
  }
  if ( pResult->pszErrorMsg == NULL ) {
#ifdef MULTITHREAD
    pResult->pszErrorMsg	= strdup ( szEmpty );
#else
    pResult->pszErrorMsg	= (LPSTR) szEmpty;
#endif
  }
  __pRequest__	= NULL;
  return (RESULTTYPE) pResult;
} /* fnrpc_fnserverbtreeinsertbystring_1 */




extern int fnServerBtreemapSearch
	(SHORTOBJID oShortObjIdMapper ,
	  SHORTOBJID oShortObjIdHeap ,
	  SHORTOBJID oShortObjIdBTree ,
	  int nValueKeyLower ,
	  SHTYPETAG nTypeTagKeyLower ,
	  COMPARETAG eCompareLower ,
	  int nValueKeyUpper ,
	  SHTYPETAG nTypeTagKeyUpper ,
	  COMPARETAG eCompareUpper ,
	  bool_t bDescending);

#ifdef MULTITHREAD
bool_t
#else
fnServerBtreemapSearch_rets *
#endif
	PASTE2(fnrpc_fnserverbtreemapsearch_1,_SVCSUFFIX)
		( fnServerBtreemapSearch_args * pArguments,
#ifdef MULTITHREAD
		  fnServerBtreemapSearch_rets * pResult,
#endif
		  struct svc_req * pRequest )
{
  static const char	__procedure__[]	= "server:fnrpc_fnserverbtreemapsearch_1";
#ifdef MULTITHREAD
  typedef bool_t RESULTTYPE;
#else
  typedef fnServerBtreemapSearch_rets * RESULTTYPE;
#endif
#ifndef MULTITHREAD
  static fnServerBtreemapSearch_rets	Result;
  RESULTTYPE			pResult = &Result;
#endif
  LPCSTR	pszErrorMsg;

  __pRequest__	= pRequest;

  RPC_SERVER_ENTRY();

#ifndef MULTITHREAD
  if ( pResult->pszErrorMsg == szEmpty ) {
    pResult->pszErrorMsg	= NULL;
  }
  xdr_free ( (xdrproc_t) xdr_fnServerBtreemapSearch_rets, (char *) pResult );
#endif
  pResult->nErrorLvl		= 0;

  Reply.bAnswered		= FALSE;
  Reply.pfnCalled		= (void(*)()) fnServerBtreemapSearch;
  Reply.pfnXdrResult		= (bool_t(*)()) xdr_fnServerBtreemapSearch_rets;
  Reply.pnErrorLvl		= &pResult->nErrorLvl;
  Reply.ppszErrorMsg		= (LPCSTR *) &pResult->pszErrorMsg;
  Reply.pResult		= pResult;
  Reply.pReturnValue		= &pResult->ReturnValue;
  Reply.nReturnValueSize	= sizeof ( pResult->ReturnValue );

  pResult->ReturnValue		=
  fnServerBtreemapSearch (
	pArguments->oShortObjIdMapper,
	pArguments->oShortObjIdHeap,
	pArguments->oShortObjIdBTree,
	pArguments->nValueKeyLower,
	pArguments->nTypeTagKeyLower,
	pArguments->eCompareLower,
	pArguments->nValueKeyUpper,
	pArguments->nTypeTagKeyUpper,
	pArguments->eCompareUpper,
	pArguments->bDescending );

  if ( Reply.bAnswered ) {
    __pRequest__	= NULL;
    return (RESULTTYPE) NULL;
  }

  pResult->nErrorLvl	= RPC_SERVER_ERRLVL();
  if ( pResult->nErrorLvl > 0 ) {
    pszErrorMsg		= RPC_SERVER_ERRMSG();
    if ( pszErrorMsg && *pszErrorMsg ) {
      pResult->pszErrorMsg	= strdup ( pszErrorMsg );
    }
  }
  if ( pResult->pszErrorMsg == NULL ) {
#ifdef MULTITHREAD
    pResult->pszErrorMsg	= strdup ( szEmpty );
#else
    pResult->pszErrorMsg	= (LPSTR) szEmpty;
#endif
  }
  __pRequest__	= NULL;
  return (RESULTTYPE) pResult;
} /* fnrpc_fnserverbtreemapsearch_1 */




extern int fnServerBtreemapSearchByFloat
	(SHORTOBJID oShortObjIdMapper ,
	  SHORTOBJID oShortObjIdHeap ,
	  SHORTOBJID oShortObjIdBTree ,
	  float fKeyLower ,
	  SHTYPETAG nTypeTagKeyLower ,
	  COMPARETAG eCompareLower ,
	  float fKeyUpper ,
	  SHTYPETAG nTypeTagKeyUpper ,
	  COMPARETAG eCompareUpper ,
	  bool_t bDescending);

#ifdef MULTITHREAD
bool_t
#else
fnServerBtreemapSearchByFloat_rets *
#endif
	PASTE2(fnrpc_fnserverbtreemapsearchbyfloat_1,_SVCSUFFIX)
		( fnServerBtreemapSearchByFloat_args * pArguments,
#ifdef MULTITHREAD
		  fnServerBtreemapSearchByFloat_rets * pResult,
#endif
		  struct svc_req * pRequest )
{
  static const char	__procedure__[]	= "server:fnrpc_fnserverbtreemapsearchbyfloat_1";
#ifdef MULTITHREAD
  typedef bool_t RESULTTYPE;
#else
  typedef fnServerBtreemapSearchByFloat_rets * RESULTTYPE;
#endif
#ifndef MULTITHREAD
  static fnServerBtreemapSearchByFloat_rets	Result;
  RESULTTYPE			pResult = &Result;
#endif
  LPCSTR	pszErrorMsg;

  __pRequest__	= pRequest;

  RPC_SERVER_ENTRY();

#ifndef MULTITHREAD
  if ( pResult->pszErrorMsg == szEmpty ) {
    pResult->pszErrorMsg	= NULL;
  }
  xdr_free ( (xdrproc_t) xdr_fnServerBtreemapSearchByFloat_rets, (char *) pResult );
#endif
  pResult->nErrorLvl		= 0;

  Reply.bAnswered		= FALSE;
  Reply.pfnCalled		= (void(*)()) fnServerBtreemapSearchByFloat;
  Reply.pfnXdrResult		= (bool_t(*)()) xdr_fnServerBtreemapSearchByFloat_rets;
  Reply.pnErrorLvl		= &pResult->nErrorLvl;
  Reply.ppszErrorMsg		= (LPCSTR *) &pResult->pszErrorMsg;
  Reply.pResult		= pResult;
  Reply.pReturnValue		= &pResult->ReturnValue;
  Reply.nReturnValueSize	= sizeof ( pResult->ReturnValue );

  pResult->ReturnValue		=
  fnServerBtreemapSearchByFloat (
	pArguments->oShortObjIdMapper,
	pArguments->oShortObjIdHeap,
	pArguments->oShortObjIdBTree,
	pArguments->fKeyLower,
	pArguments->nTypeTagKeyLower,
	pArguments->eCompareLower,
	pArguments->fKeyUpper,
	pArguments->nTypeTagKeyUpper,
	pArguments->eCompareUpper,
	pArguments->bDescending );

  if ( Reply.bAnswered ) {
    __pRequest__	= NULL;
    return (RESULTTYPE) NULL;
  }

  pResult->nErrorLvl	= RPC_SERVER_ERRLVL();
  if ( pResult->nErrorLvl > 0 ) {
    pszErrorMsg		= RPC_SERVER_ERRMSG();
    if ( pszErrorMsg && *pszErrorMsg ) {
      pResult->pszErrorMsg	= strdup ( pszErrorMsg );
    }
  }
  if ( pResult->pszErrorMsg == NULL ) {
#ifdef MULTITHREAD
    pResult->pszErrorMsg	= strdup ( szEmpty );
#else
    pResult->pszErrorMsg	= (LPSTR) szEmpty;
#endif
  }
  __pRequest__	= NULL;
  return (RESULTTYPE) pResult;
} /* fnrpc_fnserverbtreemapsearchbyfloat_1 */




extern int fnServerBtreemapSearchByDouble
	(SHORTOBJID oShortObjIdMapper ,
	  SHORTOBJID oShortObjIdHeap ,
	  SHORTOBJID oShortObjIdBTree ,
	  double fKeyLower ,
	  COMPARETAG eCompareLower ,
	  SHTYPETAG nTypeTagKeyLower ,
	  double fKeyUpper ,
	  SHTYPETAG nTypeTagKeyUpper ,
	  COMPARETAG eCompareUpper ,
	  bool_t bDescending);

#ifdef MULTITHREAD
bool_t
#else
fnServerBtreemapSearchByDouble_rets *
#endif
	PASTE2(fnrpc_fnserverbtreemapsearchbydouble_1,_SVCSUFFIX)
		( fnServerBtreemapSearchByDouble_args * pArguments,
#ifdef MULTITHREAD
		  fnServerBtreemapSearchByDouble_rets * pResult,
#endif
		  struct svc_req * pRequest )
{
  static const char	__procedure__[]	= "server:fnrpc_fnserverbtreemapsearchbydouble_1";
#ifdef MULTITHREAD
  typedef bool_t RESULTTYPE;
#else
  typedef fnServerBtreemapSearchByDouble_rets * RESULTTYPE;
#endif
#ifndef MULTITHREAD
  static fnServerBtreemapSearchByDouble_rets	Result;
  RESULTTYPE			pResult = &Result;
#endif
  LPCSTR	pszErrorMsg;

  __pRequest__	= pRequest;

  RPC_SERVER_ENTRY();

#ifndef MULTITHREAD
  if ( pResult->pszErrorMsg == szEmpty ) {
    pResult->pszErrorMsg	= NULL;
  }
  xdr_free ( (xdrproc_t) xdr_fnServerBtreemapSearchByDouble_rets, (char *) pResult );
#endif
  pResult->nErrorLvl		= 0;

  Reply.bAnswered		= FALSE;
  Reply.pfnCalled		= (void(*)()) fnServerBtreemapSearchByDouble;
  Reply.pfnXdrResult		= (bool_t(*)()) xdr_fnServerBtreemapSearchByDouble_rets;
  Reply.pnErrorLvl		= &pResult->nErrorLvl;
  Reply.ppszErrorMsg		= (LPCSTR *) &pResult->pszErrorMsg;
  Reply.pResult		= pResult;
  Reply.pReturnValue		= &pResult->ReturnValue;
  Reply.nReturnValueSize	= sizeof ( pResult->ReturnValue );

  pResult->ReturnValue		=
  fnServerBtreemapSearchByDouble (
	pArguments->oShortObjIdMapper,
	pArguments->oShortObjIdHeap,
	pArguments->oShortObjIdBTree,
	pArguments->fKeyLower,
	pArguments->eCompareLower,
	pArguments->nTypeTagKeyLower,
	pArguments->fKeyUpper,
	pArguments->nTypeTagKeyUpper,
	pArguments->eCompareUpper,
	pArguments->bDescending );

  if ( Reply.bAnswered ) {
    __pRequest__	= NULL;
    return (RESULTTYPE) NULL;
  }

  pResult->nErrorLvl	= RPC_SERVER_ERRLVL();
  if ( pResult->nErrorLvl > 0 ) {
    pszErrorMsg		= RPC_SERVER_ERRMSG();
    if ( pszErrorMsg && *pszErrorMsg ) {
      pResult->pszErrorMsg	= strdup ( pszErrorMsg );
    }
  }
  if ( pResult->pszErrorMsg == NULL ) {
#ifdef MULTITHREAD
    pResult->pszErrorMsg	= strdup ( szEmpty );
#else
    pResult->pszErrorMsg	= (LPSTR) szEmpty;
#endif
  }
  __pRequest__	= NULL;
  return (RESULTTYPE) pResult;
} /* fnrpc_fnserverbtreemapsearchbydouble_1 */




extern int fnServerBtreemapSearchByString
	(SHORTOBJID oShortObjIdMapper ,
	  SHORTOBJID oShortObjIdHeap ,
	  SHORTOBJID oShortObjIdBTree ,
	  string_t /* string_t<@conststring@> */ szKeyLower ,
	  SHTYPETAG nTypeTagKeyLower ,
	  COMPARETAG eCompareLower ,
	  string_t /* string_t<@conststring@> */ szKeyUpper ,
	  SHTYPETAG nTypeTagKeyUpper ,
	  COMPARETAG eCompareUpper ,
	  bool_t bDescending);

#ifdef MULTITHREAD
bool_t
#else
fnServerBtreemapSearchByString_rets *
#endif
	PASTE2(fnrpc_fnserverbtreemapsearchbystring_1,_SVCSUFFIX)
		( fnServerBtreemapSearchByString_args * pArguments,
#ifdef MULTITHREAD
		  fnServerBtreemapSearchByString_rets * pResult,
#endif
		  struct svc_req * pRequest )
{
  static const char	__procedure__[]	= "server:fnrpc_fnserverbtreemapsearchbystring_1";
#ifdef MULTITHREAD
  typedef bool_t RESULTTYPE;
#else
  typedef fnServerBtreemapSearchByString_rets * RESULTTYPE;
#endif
#ifndef MULTITHREAD
  static fnServerBtreemapSearchByString_rets	Result;
  RESULTTYPE			pResult = &Result;
#endif
  LPCSTR	pszErrorMsg;

  __pRequest__	= pRequest;

  RPC_SERVER_ENTRY();

#ifndef MULTITHREAD
  if ( pResult->pszErrorMsg == szEmpty ) {
    pResult->pszErrorMsg	= NULL;
  }
  xdr_free ( (xdrproc_t) xdr_fnServerBtreemapSearchByString_rets, (char *) pResult );
#endif
  pResult->nErrorLvl		= 0;

  Reply.bAnswered		= FALSE;
  Reply.pfnCalled		= (void(*)()) fnServerBtreemapSearchByString;
  Reply.pfnXdrResult		= (bool_t(*)()) xdr_fnServerBtreemapSearchByString_rets;
  Reply.pnErrorLvl		= &pResult->nErrorLvl;
  Reply.ppszErrorMsg		= (LPCSTR *) &pResult->pszErrorMsg;
  Reply.pResult		= pResult;
  Reply.pReturnValue		= &pResult->ReturnValue;
  Reply.nReturnValueSize	= sizeof ( pResult->ReturnValue );

  pResult->ReturnValue		=
  fnServerBtreemapSearchByString (
	pArguments->oShortObjIdMapper,
	pArguments->oShortObjIdHeap,
	pArguments->oShortObjIdBTree,
	pArguments->szKeyLower,
	pArguments->nTypeTagKeyLower,
	pArguments->eCompareLower,
	pArguments->szKeyUpper,
	pArguments->nTypeTagKeyUpper,
	pArguments->eCompareUpper,
	pArguments->bDescending );

  if ( Reply.bAnswered ) {
    __pRequest__	= NULL;
    return (RESULTTYPE) NULL;
  }

  pResult->nErrorLvl	= RPC_SERVER_ERRLVL();
  if ( pResult->nErrorLvl > 0 ) {
    pszErrorMsg		= RPC_SERVER_ERRMSG();
    if ( pszErrorMsg && *pszErrorMsg ) {
      pResult->pszErrorMsg	= strdup ( pszErrorMsg );
    }
  }
  if ( pResult->pszErrorMsg == NULL ) {
#ifdef MULTITHREAD
    pResult->pszErrorMsg	= strdup ( szEmpty );
#else
    pResult->pszErrorMsg	= (LPSTR) szEmpty;
#endif
  }
  __pRequest__	= NULL;
  return (RESULTTYPE) pResult;
} /* fnrpc_fnserverbtreemapsearchbystring_1 */




extern int fnServerBtreemapSeek
	(SHORTOBJID oShortObjIdHeap ,
	  SHORTOBJID oShortObjIdMapper ,
	  int nIncrement ,
	  SEEK eOrigin ,
	  int * pnValueKey ,
	  SHTYPETAG * pnTypeTagKey ,
	  int * pnValueData ,
	  SHTYPETAG * pnTypeTagData);

#ifdef MULTITHREAD
bool_t
#else
fnServerBtreemapSeek_rets *
#endif
	PASTE2(fnrpc_fnserverbtreemapseek_1,_SVCSUFFIX)
		( fnServerBtreemapSeek_args * pArguments,
#ifdef MULTITHREAD
		  fnServerBtreemapSeek_rets * pResult,
#endif
		  struct svc_req * pRequest )
{
  static const char	__procedure__[]	= "server:fnrpc_fnserverbtreemapseek_1";
#ifdef MULTITHREAD
  typedef bool_t RESULTTYPE;
#else
  typedef fnServerBtreemapSeek_rets * RESULTTYPE;
#endif
#ifndef MULTITHREAD
  static fnServerBtreemapSeek_rets	Result;
  RESULTTYPE			pResult = &Result;
#endif
  LPCSTR	pszErrorMsg;

  __pRequest__	= pRequest;

  RPC_SERVER_ENTRY();

#ifndef MULTITHREAD
  if ( pResult->pszErrorMsg == szEmpty ) {
    pResult->pszErrorMsg	= NULL;
  }
  xdr_free ( (xdrproc_t) xdr_fnServerBtreemapSeek_rets, (char *) pResult );
#endif
  pResult->nErrorLvl		= 0;

  Reply.bAnswered		= FALSE;
  Reply.pfnCalled		= (void(*)()) fnServerBtreemapSeek;
  Reply.pfnXdrResult		= (bool_t(*)()) xdr_fnServerBtreemapSeek_rets;
  Reply.pnErrorLvl		= &pResult->nErrorLvl;
  Reply.ppszErrorMsg		= (LPCSTR *) &pResult->pszErrorMsg;
  Reply.pResult		= pResult;
  Reply.pReturnValue		= &pResult->ReturnValue;
  Reply.nReturnValueSize	= sizeof ( pResult->ReturnValue );

  pResult->ReturnValue		=
  fnServerBtreemapSeek (
	pArguments->oShortObjIdHeap,
	pArguments->oShortObjIdMapper,
	pArguments->nIncrement,
	pArguments->eOrigin,
	&pResult->pnValueKey,
	&pResult->pnTypeTagKey,
	&pResult->pnValueData,
	&pResult->pnTypeTagData );

  if ( Reply.bAnswered ) {
    __pRequest__	= NULL;
    return (RESULTTYPE) NULL;
  }

  pResult->nErrorLvl	= RPC_SERVER_ERRLVL();
  if ( pResult->nErrorLvl > 0 ) {
    pszErrorMsg		= RPC_SERVER_ERRMSG();
    if ( pszErrorMsg && *pszErrorMsg ) {
      pResult->pszErrorMsg	= strdup ( pszErrorMsg );
    }
  }
  if ( pResult->pszErrorMsg == NULL ) {
#ifdef MULTITHREAD
    pResult->pszErrorMsg	= strdup ( szEmpty );
#else
    pResult->pszErrorMsg	= (LPSTR) szEmpty;
#endif
  }
  __pRequest__	= NULL;
  return (RESULTTYPE) pResult;
} /* fnrpc_fnserverbtreemapseek_1 */




extern int fnServerBtreemapSeekSet
	(SHORTOBJID oShortObjIdHeap ,
	  SHORTOBJID oShortObjIdMapper ,
	  int nIncrement ,
	  SEEK eOrigin ,
	  int nValueData ,
	  SHTYPETAG nTypeTagData);

#ifdef MULTITHREAD
bool_t
#else
fnServerBtreemapSeekSet_rets *
#endif
	PASTE2(fnrpc_fnserverbtreemapseekset_1,_SVCSUFFIX)
		( fnServerBtreemapSeekSet_args * pArguments,
#ifdef MULTITHREAD
		  fnServerBtreemapSeekSet_rets * pResult,
#endif
		  struct svc_req * pRequest )
{
  static const char	__procedure__[]	= "server:fnrpc_fnserverbtreemapseekset_1";
#ifdef MULTITHREAD
  typedef bool_t RESULTTYPE;
#else
  typedef fnServerBtreemapSeekSet_rets * RESULTTYPE;
#endif
#ifndef MULTITHREAD
  static fnServerBtreemapSeekSet_rets	Result;
  RESULTTYPE			pResult = &Result;
#endif
  LPCSTR	pszErrorMsg;

  __pRequest__	= pRequest;

  RPC_SERVER_ENTRY();

#ifndef MULTITHREAD
  if ( pResult->pszErrorMsg == szEmpty ) {
    pResult->pszErrorMsg	= NULL;
  }
  xdr_free ( (xdrproc_t) xdr_fnServerBtreemapSeekSet_rets, (char *) pResult );
#endif
  pResult->nErrorLvl		= 0;

  Reply.bAnswered		= FALSE;
  Reply.pfnCalled		= (void(*)()) fnServerBtreemapSeekSet;
  Reply.pfnXdrResult		= (bool_t(*)()) xdr_fnServerBtreemapSeekSet_rets;
  Reply.pnErrorLvl		= &pResult->nErrorLvl;
  Reply.ppszErrorMsg		= (LPCSTR *) &pResult->pszErrorMsg;
  Reply.pResult		= pResult;
  Reply.pReturnValue		= &pResult->ReturnValue;
  Reply.nReturnValueSize	= sizeof ( pResult->ReturnValue );

  pResult->ReturnValue		=
  fnServerBtreemapSeekSet (
	pArguments->oShortObjIdHeap,
	pArguments->oShortObjIdMapper,
	pArguments->nIncrement,
	pArguments->eOrigin,
	pArguments->nValueData,
	pArguments->nTypeTagData );

  if ( Reply.bAnswered ) {
    __pRequest__	= NULL;
    return (RESULTTYPE) NULL;
  }

  pResult->nErrorLvl	= RPC_SERVER_ERRLVL();
  if ( pResult->nErrorLvl > 0 ) {
    pszErrorMsg		= RPC_SERVER_ERRMSG();
    if ( pszErrorMsg && *pszErrorMsg ) {
      pResult->pszErrorMsg	= strdup ( pszErrorMsg );
    }
  }
  if ( pResult->pszErrorMsg == NULL ) {
#ifdef MULTITHREAD
    pResult->pszErrorMsg	= strdup ( szEmpty );
#else
    pResult->pszErrorMsg	= (LPSTR) szEmpty;
#endif
  }
  __pRequest__	= NULL;
  return (RESULTTYPE) pResult;
} /* fnrpc_fnserverbtreemapseekset_1 */




extern int fnServerBtreemapFirst
	(SHORTOBJID * lpoShortObjIdMapper ,
	  SHORTOBJID oShortObjIdHeap ,
	  SHORTOBJID oShortObjIdBTree ,
	  int nValueKeyLower ,
	  SHTYPETAG nTypeTagKeyLower ,
	  COMPARETAG eCompareLower ,
	  int nValueKeyUpper ,
	  SHTYPETAG nTypeTagKeyUpper ,
	  COMPARETAG eCompareUpper ,
	  bool_t bDescending ,
	  int nMap ,
	  int * /* _vector_t<nMap> */  pnValueKey ,
	  u_int * /* _vector_t<nMap> */  pnTypeTagKey ,
	  int * /* _vector_t<nMap> */  pnValueData ,
	  u_int * /* _vector_t<nMap> */  pnTypeTagData);

#ifdef MULTITHREAD
bool_t
#else
fnServerBtreemapFirst_rets *
#endif
	PASTE2(fnrpc_fnserverbtreemapfirst_1,_SVCSUFFIX)
		( fnServerBtreemapFirst_args * pArguments,
#ifdef MULTITHREAD
		  fnServerBtreemapFirst_rets * pResult,
#endif
		  struct svc_req * pRequest )
{
  static const char	__procedure__[]	= "server:fnrpc_fnserverbtreemapfirst_1";
#ifdef MULTITHREAD
  typedef bool_t RESULTTYPE;
#else
  typedef fnServerBtreemapFirst_rets * RESULTTYPE;
#endif
#ifndef MULTITHREAD
  static fnServerBtreemapFirst_rets	Result;
  RESULTTYPE			pResult = &Result;
#endif
  LPCSTR	pszErrorMsg;

  __pRequest__	= pRequest;

  RPC_SERVER_ENTRY();

#ifndef MULTITHREAD
  if ( pResult->pszErrorMsg == szEmpty ) {
    pResult->pszErrorMsg	= NULL;
  }
  xdr_free ( (xdrproc_t) xdr_fnServerBtreemapFirst_rets, (char *) pResult );
#endif
  pResult->nErrorLvl		= 0;

  pResult->pnValueKey.int_vector_t_len	= pArguments->pnValueKeySize;
  if ( pArguments->pnValueKeySize == 0 ) {
    pResult->pnValueKey.int_vector_t_val	= NULL;
  } else {
    pResult->pnValueKey.int_vector_t_val	=
      (int*) malloc ( pArguments->pnValueKeySize *
               SIZEOF ( *(pResult->pnValueKey.int_vector_t_val) ) );
    if ( pResult->pnValueKey.int_vector_t_val == NULL ) {
      char	szError [ 256 ];
      sprintf ( szError, szFormatMallocFailed,
                __procedure__, pArguments->pnValueKeySize,
                "pnValueKey" );
      RPC_SERVER_ERROR ( szError );
      return (RESULTTYPE) NULL;
    }
  }
  pResult->pnTypeTagKey.u_int_vector_t_len	= pArguments->pnTypeTagKeySize;
  if ( pArguments->pnTypeTagKeySize == 0 ) {
    pResult->pnTypeTagKey.u_int_vector_t_val	= NULL;
  } else {
    pResult->pnTypeTagKey.u_int_vector_t_val	=
      (u_int*) malloc ( pArguments->pnTypeTagKeySize *
               SIZEOF ( *(pResult->pnTypeTagKey.u_int_vector_t_val) ) );
    if ( pResult->pnTypeTagKey.u_int_vector_t_val == NULL ) {
      char	szError [ 256 ];
      sprintf ( szError, szFormatMallocFailed,
                __procedure__, pArguments->pnTypeTagKeySize,
                "pnTypeTagKey" );
      RPC_SERVER_ERROR ( szError );
      return (RESULTTYPE) NULL;
    }
  }
  pResult->pnValueData.int_vector_t_len	= pArguments->pnValueDataSize;
  if ( pArguments->pnValueDataSize == 0 ) {
    pResult->pnValueData.int_vector_t_val	= NULL;
  } else {
    pResult->pnValueData.int_vector_t_val	=
      (int*) malloc ( pArguments->pnValueDataSize *
               SIZEOF ( *(pResult->pnValueData.int_vector_t_val) ) );
    if ( pResult->pnValueData.int_vector_t_val == NULL ) {
      char	szError [ 256 ];
      sprintf ( szError, szFormatMallocFailed,
                __procedure__, pArguments->pnValueDataSize,
                "pnValueData" );
      RPC_SERVER_ERROR ( szError );
      return (RESULTTYPE) NULL;
    }
  }
  pResult->pnTypeTagData.u_int_vector_t_len	= pArguments->pnTypeTagDataSize;
  if ( pArguments->pnTypeTagDataSize == 0 ) {
    pResult->pnTypeTagData.u_int_vector_t_val	= NULL;
  } else {
    pResult->pnTypeTagData.u_int_vector_t_val	=
      (u_int*) malloc ( pArguments->pnTypeTagDataSize *
               SIZEOF ( *(pResult->pnTypeTagData.u_int_vector_t_val) ) );
    if ( pResult->pnTypeTagData.u_int_vector_t_val == NULL ) {
      char	szError [ 256 ];
      sprintf ( szError, szFormatMallocFailed,
                __procedure__, pArguments->pnTypeTagDataSize,
                "pnTypeTagData" );
      RPC_SERVER_ERROR ( szError );
      return (RESULTTYPE) NULL;
    }
  }
  Reply.bAnswered		= FALSE;
  Reply.pfnCalled		= (void(*)()) fnServerBtreemapFirst;
  Reply.pfnXdrResult		= (bool_t(*)()) xdr_fnServerBtreemapFirst_rets;
  Reply.pnErrorLvl		= &pResult->nErrorLvl;
  Reply.ppszErrorMsg		= (LPCSTR *) &pResult->pszErrorMsg;
  Reply.pResult		= pResult;
  Reply.pReturnValue		= &pResult->ReturnValue;
  Reply.nReturnValueSize	= sizeof ( pResult->ReturnValue );

  pResult->ReturnValue		=
  fnServerBtreemapFirst (
	&pResult->lpoShortObjIdMapper,
	pArguments->oShortObjIdHeap,
	pArguments->oShortObjIdBTree,
	pArguments->nValueKeyLower,
	pArguments->nTypeTagKeyLower,
	pArguments->eCompareLower,
	pArguments->nValueKeyUpper,
	pArguments->nTypeTagKeyUpper,
	pArguments->eCompareUpper,
	pArguments->bDescending,
	pArguments->nMap,
	pResult->pnValueKey.int_vector_t_val,
	pResult->pnTypeTagKey.u_int_vector_t_val,
	pResult->pnValueData.int_vector_t_val,
	pResult->pnTypeTagData.u_int_vector_t_val );

  if ( Reply.bAnswered ) {
    __pRequest__	= NULL;
    return (RESULTTYPE) NULL;
  }

  pResult->nErrorLvl	= RPC_SERVER_ERRLVL();
  if ( pResult->nErrorLvl > 0 ) {
    pszErrorMsg		= RPC_SERVER_ERRMSG();
    if ( pszErrorMsg && *pszErrorMsg ) {
      pResult->pszErrorMsg	= strdup ( pszErrorMsg );
    }
  }
  if ( pResult->pszErrorMsg == NULL ) {
#ifdef MULTITHREAD
    pResult->pszErrorMsg	= strdup ( szEmpty );
#else
    pResult->pszErrorMsg	= (LPSTR) szEmpty;
#endif
  }
  __pRequest__	= NULL;
  return (RESULTTYPE) pResult;
} /* fnrpc_fnserverbtreemapfirst_1 */




extern int fnServerBtreemapFirstByFloat
	(SHORTOBJID * lpoShortObjIdMapper ,
	  SHORTOBJID oShortObjIdHeap ,
	  SHORTOBJID oShortObjIdBTree ,
	  float fKeyLower ,
	  SHTYPETAG nTypeTagKeyLower ,
	  COMPARETAG eCompareLower ,
	  float fKeyUpper ,
	  SHTYPETAG nTypeTagKeyUpper ,
	  COMPARETAG eCompareUpper ,
	  bool_t bDescending ,
	  int nMap ,
	  int * /* _vector_t<nMap> */  pnValueKey ,
	  u_int * /* _vector_t<nMap> */  pnTypeTagKey ,
	  int * /* _vector_t<nMap> */  pnValueData ,
	  u_int * /* _vector_t<nMap> */  pnTypeTagData);

#ifdef MULTITHREAD
bool_t
#else
fnServerBtreemapFirstByFloat_rets *
#endif
	PASTE2(fnrpc_fnserverbtreemapfirstbyfloat_1,_SVCSUFFIX)
		( fnServerBtreemapFirstByFloat_args * pArguments,
#ifdef MULTITHREAD
		  fnServerBtreemapFirstByFloat_rets * pResult,
#endif
		  struct svc_req * pRequest )
{
  static const char	__procedure__[]	= "server:fnrpc_fnserverbtreemapfirstbyfloat_1";
#ifdef MULTITHREAD
  typedef bool_t RESULTTYPE;
#else
  typedef fnServerBtreemapFirstByFloat_rets * RESULTTYPE;
#endif
#ifndef MULTITHREAD
  static fnServerBtreemapFirstByFloat_rets	Result;
  RESULTTYPE			pResult = &Result;
#endif
  LPCSTR	pszErrorMsg;

  __pRequest__	= pRequest;

  RPC_SERVER_ENTRY();

#ifndef MULTITHREAD
  if ( pResult->pszErrorMsg == szEmpty ) {
    pResult->pszErrorMsg	= NULL;
  }
  xdr_free ( (xdrproc_t) xdr_fnServerBtreemapFirstByFloat_rets, (char *) pResult );
#endif
  pResult->nErrorLvl		= 0;

  pResult->pnValueKey.int_vector_t_len	= pArguments->pnValueKeySize;
  if ( pArguments->pnValueKeySize == 0 ) {
    pResult->pnValueKey.int_vector_t_val	= NULL;
  } else {
    pResult->pnValueKey.int_vector_t_val	=
      (int*) malloc ( pArguments->pnValueKeySize *
               SIZEOF ( *(pResult->pnValueKey.int_vector_t_val) ) );
    if ( pResult->pnValueKey.int_vector_t_val == NULL ) {
      char	szError [ 256 ];
      sprintf ( szError, szFormatMallocFailed,
                __procedure__, pArguments->pnValueKeySize,
                "pnValueKey" );
      RPC_SERVER_ERROR ( szError );
      return (RESULTTYPE) NULL;
    }
  }
  pResult->pnTypeTagKey.u_int_vector_t_len	= pArguments->pnTypeTagKeySize;
  if ( pArguments->pnTypeTagKeySize == 0 ) {
    pResult->pnTypeTagKey.u_int_vector_t_val	= NULL;
  } else {
    pResult->pnTypeTagKey.u_int_vector_t_val	=
      (u_int*) malloc ( pArguments->pnTypeTagKeySize *
               SIZEOF ( *(pResult->pnTypeTagKey.u_int_vector_t_val) ) );
    if ( pResult->pnTypeTagKey.u_int_vector_t_val == NULL ) {
      char	szError [ 256 ];
      sprintf ( szError, szFormatMallocFailed,
                __procedure__, pArguments->pnTypeTagKeySize,
                "pnTypeTagKey" );
      RPC_SERVER_ERROR ( szError );
      return (RESULTTYPE) NULL;
    }
  }
  pResult->pnValueData.int_vector_t_len	= pArguments->pnValueDataSize;
  if ( pArguments->pnValueDataSize == 0 ) {
    pResult->pnValueData.int_vector_t_val	= NULL;
  } else {
    pResult->pnValueData.int_vector_t_val	=
      (int*) malloc ( pArguments->pnValueDataSize *
               SIZEOF ( *(pResult->pnValueData.int_vector_t_val) ) );
    if ( pResult->pnValueData.int_vector_t_val == NULL ) {
      char	szError [ 256 ];
      sprintf ( szError, szFormatMallocFailed,
                __procedure__, pArguments->pnValueDataSize,
                "pnValueData" );
      RPC_SERVER_ERROR ( szError );
      return (RESULTTYPE) NULL;
    }
  }
  pResult->pnTypeTagData.u_int_vector_t_len	= pArguments->pnTypeTagDataSize;
  if ( pArguments->pnTypeTagDataSize == 0 ) {
    pResult->pnTypeTagData.u_int_vector_t_val	= NULL;
  } else {
    pResult->pnTypeTagData.u_int_vector_t_val	=
      (u_int*) malloc ( pArguments->pnTypeTagDataSize *
               SIZEOF ( *(pResult->pnTypeTagData.u_int_vector_t_val) ) );
    if ( pResult->pnTypeTagData.u_int_vector_t_val == NULL ) {
      char	szError [ 256 ];
      sprintf ( szError, szFormatMallocFailed,
                __procedure__, pArguments->pnTypeTagDataSize,
                "pnTypeTagData" );
      RPC_SERVER_ERROR ( szError );
      return (RESULTTYPE) NULL;
    }
  }
  Reply.bAnswered		= FALSE;
  Reply.pfnCalled		= (void(*)()) fnServerBtreemapFirstByFloat;
  Reply.pfnXdrResult		= (bool_t(*)()) xdr_fnServerBtreemapFirstByFloat_rets;
  Reply.pnErrorLvl		= &pResult->nErrorLvl;
  Reply.ppszErrorMsg		= (LPCSTR *) &pResult->pszErrorMsg;
  Reply.pResult		= pResult;
  Reply.pReturnValue		= &pResult->ReturnValue;
  Reply.nReturnValueSize	= sizeof ( pResult->ReturnValue );

  pResult->ReturnValue		=
  fnServerBtreemapFirstByFloat (
	&pResult->lpoShortObjIdMapper,
	pArguments->oShortObjIdHeap,
	pArguments->oShortObjIdBTree,
	pArguments->fKeyLower,
	pArguments->nTypeTagKeyLower,
	pArguments->eCompareLower,
	pArguments->fKeyUpper,
	pArguments->nTypeTagKeyUpper,
	pArguments->eCompareUpper,
	pArguments->bDescending,
	pArguments->nMap,
	pResult->pnValueKey.int_vector_t_val,
	pResult->pnTypeTagKey.u_int_vector_t_val,
	pResult->pnValueData.int_vector_t_val,
	pResult->pnTypeTagData.u_int_vector_t_val );

  if ( Reply.bAnswered ) {
    __pRequest__	= NULL;
    return (RESULTTYPE) NULL;
  }

  pResult->nErrorLvl	= RPC_SERVER_ERRLVL();
  if ( pResult->nErrorLvl > 0 ) {
    pszErrorMsg		= RPC_SERVER_ERRMSG();
    if ( pszErrorMsg && *pszErrorMsg ) {
      pResult->pszErrorMsg	= strdup ( pszErrorMsg );
    }
  }
  if ( pResult->pszErrorMsg == NULL ) {
#ifdef MULTITHREAD
    pResult->pszErrorMsg	= strdup ( szEmpty );
#else
    pResult->pszErrorMsg	= (LPSTR) szEmpty;
#endif
  }
  __pRequest__	= NULL;
  return (RESULTTYPE) pResult;
} /* fnrpc_fnserverbtreemapfirstbyfloat_1 */




extern int fnServerBtreemapFirstByDouble
	(SHORTOBJID * lpoShortObjIdMapper ,
	  SHORTOBJID oShortObjIdHeap ,
	  SHORTOBJID oShortObjIdBTree ,
	  double fKeyLower ,
	  COMPARETAG eCompareLower ,
	  SHTYPETAG nTypeTagKeyLower ,
	  double fKeyUpper ,
	  SHTYPETAG nTypeTagKeyUpper ,
	  COMPARETAG eCompareUpper ,
	  bool_t bDescending ,
	  int nMap ,
	  int * /* _vector_t<nMap> */  pnValueKey ,
	  u_int * /* _vector_t<nMap> */  pnTypeTagKey ,
	  int * /* _vector_t<nMap> */  pnValueData ,
	  u_int * /* _vector_t<nMap> */  pnTypeTagData);

#ifdef MULTITHREAD
bool_t
#else
fnServerBtreemapFirstByDouble_rets *
#endif
	PASTE2(fnrpc_fnserverbtreemapfirstbydouble_1,_SVCSUFFIX)
		( fnServerBtreemapFirstByDouble_args * pArguments,
#ifdef MULTITHREAD
		  fnServerBtreemapFirstByDouble_rets * pResult,
#endif
		  struct svc_req * pRequest )
{
  static const char	__procedure__[]	= "server:fnrpc_fnserverbtreemapfirstbydouble_1";
#ifdef MULTITHREAD
  typedef bool_t RESULTTYPE;
#else
  typedef fnServerBtreemapFirstByDouble_rets * RESULTTYPE;
#endif
#ifndef MULTITHREAD
  static fnServerBtreemapFirstByDouble_rets	Result;
  RESULTTYPE			pResult = &Result;
#endif
  LPCSTR	pszErrorMsg;

  __pRequest__	= pRequest;

  RPC_SERVER_ENTRY();

#ifndef MULTITHREAD
  if ( pResult->pszErrorMsg == szEmpty ) {
    pResult->pszErrorMsg	= NULL;
  }
  xdr_free ( (xdrproc_t) xdr_fnServerBtreemapFirstByDouble_rets, (char *) pResult );
#endif
  pResult->nErrorLvl		= 0;

  pResult->pnValueKey.int_vector_t_len	= pArguments->pnValueKeySize;
  if ( pArguments->pnValueKeySize == 0 ) {
    pResult->pnValueKey.int_vector_t_val	= NULL;
  } else {
    pResult->pnValueKey.int_vector_t_val	=
      (int*) malloc ( pArguments->pnValueKeySize *
               SIZEOF ( *(pResult->pnValueKey.int_vector_t_val) ) );
    if ( pResult->pnValueKey.int_vector_t_val == NULL ) {
      char	szError [ 256 ];
      sprintf ( szError, szFormatMallocFailed,
                __procedure__, pArguments->pnValueKeySize,
                "pnValueKey" );
      RPC_SERVER_ERROR ( szError );
      return (RESULTTYPE) NULL;
    }
  }
  pResult->pnTypeTagKey.u_int_vector_t_len	= pArguments->pnTypeTagKeySize;
  if ( pArguments->pnTypeTagKeySize == 0 ) {
    pResult->pnTypeTagKey.u_int_vector_t_val	= NULL;
  } else {
    pResult->pnTypeTagKey.u_int_vector_t_val	=
      (u_int*) malloc ( pArguments->pnTypeTagKeySize *
               SIZEOF ( *(pResult->pnTypeTagKey.u_int_vector_t_val) ) );
    if ( pResult->pnTypeTagKey.u_int_vector_t_val == NULL ) {
      char	szError [ 256 ];
      sprintf ( szError, szFormatMallocFailed,
                __procedure__, pArguments->pnTypeTagKeySize,
                "pnTypeTagKey" );
      RPC_SERVER_ERROR ( szError );
      return (RESULTTYPE) NULL;
    }
  }
  pResult->pnValueData.int_vector_t_len	= pArguments->pnValueDataSize;
  if ( pArguments->pnValueDataSize == 0 ) {
    pResult->pnValueData.int_vector_t_val	= NULL;
  } else {
    pResult->pnValueData.int_vector_t_val	=
      (int*) malloc ( pArguments->pnValueDataSize *
               SIZEOF ( *(pResult->pnValueData.int_vector_t_val) ) );
    if ( pResult->pnValueData.int_vector_t_val == NULL ) {
      char	szError [ 256 ];
      sprintf ( szError, szFormatMallocFailed,
                __procedure__, pArguments->pnValueDataSize,
                "pnValueData" );
      RPC_SERVER_ERROR ( szError );
      return (RESULTTYPE) NULL;
    }
  }
  pResult->pnTypeTagData.u_int_vector_t_len	= pArguments->pnTypeTagDataSize;
  if ( pArguments->pnTypeTagDataSize == 0 ) {
    pResult->pnTypeTagData.u_int_vector_t_val	= NULL;
  } else {
    pResult->pnTypeTagData.u_int_vector_t_val	=
      (u_int*) malloc ( pArguments->pnTypeTagDataSize *
               SIZEOF ( *(pResult->pnTypeTagData.u_int_vector_t_val) ) );
    if ( pResult->pnTypeTagData.u_int_vector_t_val == NULL ) {
      char	szError [ 256 ];
      sprintf ( szError, szFormatMallocFailed,
                __procedure__, pArguments->pnTypeTagDataSize,
                "pnTypeTagData" );
      RPC_SERVER_ERROR ( szError );
      return (RESULTTYPE) NULL;
    }
  }
  Reply.bAnswered		= FALSE;
  Reply.pfnCalled		= (void(*)()) fnServerBtreemapFirstByDouble;
  Reply.pfnXdrResult		= (bool_t(*)()) xdr_fnServerBtreemapFirstByDouble_rets;
  Reply.pnErrorLvl		= &pResult->nErrorLvl;
  Reply.ppszErrorMsg		= (LPCSTR *) &pResult->pszErrorMsg;
  Reply.pResult		= pResult;
  Reply.pReturnValue		= &pResult->ReturnValue;
  Reply.nReturnValueSize	= sizeof ( pResult->ReturnValue );

  pResult->ReturnValue		=
  fnServerBtreemapFirstByDouble (
	&pResult->lpoShortObjIdMapper,
	pArguments->oShortObjIdHeap,
	pArguments->oShortObjIdBTree,
	pArguments->fKeyLower,
	pArguments->eCompareLower,
	pArguments->nTypeTagKeyLower,
	pArguments->fKeyUpper,
	pArguments->nTypeTagKeyUpper,
	pArguments->eCompareUpper,
	pArguments->bDescending,
	pArguments->nMap,
	pResult->pnValueKey.int_vector_t_val,
	pResult->pnTypeTagKey.u_int_vector_t_val,
	pResult->pnValueData.int_vector_t_val,
	pResult->pnTypeTagData.u_int_vector_t_val );

  if ( Reply.bAnswered ) {
    __pRequest__	= NULL;
    return (RESULTTYPE) NULL;
  }

  pResult->nErrorLvl	= RPC_SERVER_ERRLVL();
  if ( pResult->nErrorLvl > 0 ) {
    pszErrorMsg		= RPC_SERVER_ERRMSG();
    if ( pszErrorMsg && *pszErrorMsg ) {
      pResult->pszErrorMsg	= strdup ( pszErrorMsg );
    }
  }
  if ( pResult->pszErrorMsg == NULL ) {
#ifdef MULTITHREAD
    pResult->pszErrorMsg	= strdup ( szEmpty );
#else
    pResult->pszErrorMsg	= (LPSTR) szEmpty;
#endif
  }
  __pRequest__	= NULL;
  return (RESULTTYPE) pResult;
} /* fnrpc_fnserverbtreemapfirstbydouble_1 */




extern int fnServerBtreemapFirstByString
	(SHORTOBJID * lpoShortObjIdMapper ,
	  SHORTOBJID oShortObjIdHeap ,
	  SHORTOBJID oShortObjIdBTree ,
	  string_t /* string_t<@conststring@> */ szKeyLower ,
	  SHTYPETAG nTypeTagKeyLower ,
	  COMPARETAG eCompareLower ,
	  string_t /* string_t<@conststring@> */ szKeyUpper ,
	  SHTYPETAG nTypeTagKeyUpper ,
	  COMPARETAG eCompareUpper ,
	  bool_t bDescending ,
	  int nMap ,
	  int * /* _vector_t<nMap> */  pnValueKey ,
	  u_int * /* _vector_t<nMap> */  pnTypeTagKey ,
	  int * /* _vector_t<nMap> */  pnValueData ,
	  u_int * /* _vector_t<nMap> */  pnTypeTagData);

#ifdef MULTITHREAD
bool_t
#else
fnServerBtreemapFirstByString_rets *
#endif
	PASTE2(fnrpc_fnserverbtreemapfirstbystring_1,_SVCSUFFIX)
		( fnServerBtreemapFirstByString_args * pArguments,
#ifdef MULTITHREAD
		  fnServerBtreemapFirstByString_rets * pResult,
#endif
		  struct svc_req * pRequest )
{
  static const char	__procedure__[]	= "server:fnrpc_fnserverbtreemapfirstbystring_1";
#ifdef MULTITHREAD
  typedef bool_t RESULTTYPE;
#else
  typedef fnServerBtreemapFirstByString_rets * RESULTTYPE;
#endif
#ifndef MULTITHREAD
  static fnServerBtreemapFirstByString_rets	Result;
  RESULTTYPE			pResult = &Result;
#endif
  LPCSTR	pszErrorMsg;

  __pRequest__	= pRequest;

  RPC_SERVER_ENTRY();

#ifndef MULTITHREAD
  if ( pResult->pszErrorMsg == szEmpty ) {
    pResult->pszErrorMsg	= NULL;
  }
  xdr_free ( (xdrproc_t) xdr_fnServerBtreemapFirstByString_rets, (char *) pResult );
#endif
  pResult->nErrorLvl		= 0;

  pResult->pnValueKey.int_vector_t_len	= pArguments->pnValueKeySize;
  if ( pArguments->pnValueKeySize == 0 ) {
    pResult->pnValueKey.int_vector_t_val	= NULL;
  } else {
    pResult->pnValueKey.int_vector_t_val	=
      (int*) malloc ( pArguments->pnValueKeySize *
               SIZEOF ( *(pResult->pnValueKey.int_vector_t_val) ) );
    if ( pResult->pnValueKey.int_vector_t_val == NULL ) {
      char	szError [ 256 ];
      sprintf ( szError, szFormatMallocFailed,
                __procedure__, pArguments->pnValueKeySize,
                "pnValueKey" );
      RPC_SERVER_ERROR ( szError );
      return (RESULTTYPE) NULL;
    }
  }
  pResult->pnTypeTagKey.u_int_vector_t_len	= pArguments->pnTypeTagKeySize;
  if ( pArguments->pnTypeTagKeySize == 0 ) {
    pResult->pnTypeTagKey.u_int_vector_t_val	= NULL;
  } else {
    pResult->pnTypeTagKey.u_int_vector_t_val	=
      (u_int*) malloc ( pArguments->pnTypeTagKeySize *
               SIZEOF ( *(pResult->pnTypeTagKey.u_int_vector_t_val) ) );
    if ( pResult->pnTypeTagKey.u_int_vector_t_val == NULL ) {
      char	szError [ 256 ];
      sprintf ( szError, szFormatMallocFailed,
                __procedure__, pArguments->pnTypeTagKeySize,
                "pnTypeTagKey" );
      RPC_SERVER_ERROR ( szError );
      return (RESULTTYPE) NULL;
    }
  }
  pResult->pnValueData.int_vector_t_len	= pArguments->pnValueDataSize;
  if ( pArguments->pnValueDataSize == 0 ) {
    pResult->pnValueData.int_vector_t_val	= NULL;
  } else {
    pResult->pnValueData.int_vector_t_val	=
      (int*) malloc ( pArguments->pnValueDataSize *
               SIZEOF ( *(pResult->pnValueData.int_vector_t_val) ) );
    if ( pResult->pnValueData.int_vector_t_val == NULL ) {
      char	szError [ 256 ];
      sprintf ( szError, szFormatMallocFailed,
                __procedure__, pArguments->pnValueDataSize,
                "pnValueData" );
      RPC_SERVER_ERROR ( szError );
      return (RESULTTYPE) NULL;
    }
  }
  pResult->pnTypeTagData.u_int_vector_t_len	= pArguments->pnTypeTagDataSize;
  if ( pArguments->pnTypeTagDataSize == 0 ) {
    pResult->pnTypeTagData.u_int_vector_t_val	= NULL;
  } else {
    pResult->pnTypeTagData.u_int_vector_t_val	=
      (u_int*) malloc ( pArguments->pnTypeTagDataSize *
               SIZEOF ( *(pResult->pnTypeTagData.u_int_vector_t_val) ) );
    if ( pResult->pnTypeTagData.u_int_vector_t_val == NULL ) {
      char	szError [ 256 ];
      sprintf ( szError, szFormatMallocFailed,
                __procedure__, pArguments->pnTypeTagDataSize,
                "pnTypeTagData" );
      RPC_SERVER_ERROR ( szError );
      return (RESULTTYPE) NULL;
    }
  }
  Reply.bAnswered		= FALSE;
  Reply.pfnCalled		= (void(*)()) fnServerBtreemapFirstByString;
  Reply.pfnXdrResult		= (bool_t(*)()) xdr_fnServerBtreemapFirstByString_rets;
  Reply.pnErrorLvl		= &pResult->nErrorLvl;
  Reply.ppszErrorMsg		= (LPCSTR *) &pResult->pszErrorMsg;
  Reply.pResult		= pResult;
  Reply.pReturnValue		= &pResult->ReturnValue;
  Reply.nReturnValueSize	= sizeof ( pResult->ReturnValue );

  pResult->ReturnValue		=
  fnServerBtreemapFirstByString (
	&pResult->lpoShortObjIdMapper,
	pArguments->oShortObjIdHeap,
	pArguments->oShortObjIdBTree,
	pArguments->szKeyLower,
	pArguments->nTypeTagKeyLower,
	pArguments->eCompareLower,
	pArguments->szKeyUpper,
	pArguments->nTypeTagKeyUpper,
	pArguments->eCompareUpper,
	pArguments->bDescending,
	pArguments->nMap,
	pResult->pnValueKey.int_vector_t_val,
	pResult->pnTypeTagKey.u_int_vector_t_val,
	pResult->pnValueData.int_vector_t_val,
	pResult->pnTypeTagData.u_int_vector_t_val );

  if ( Reply.bAnswered ) {
    __pRequest__	= NULL;
    return (RESULTTYPE) NULL;
  }

  pResult->nErrorLvl	= RPC_SERVER_ERRLVL();
  if ( pResult->nErrorLvl > 0 ) {
    pszErrorMsg		= RPC_SERVER_ERRMSG();
    if ( pszErrorMsg && *pszErrorMsg ) {
      pResult->pszErrorMsg	= strdup ( pszErrorMsg );
    }
  }
  if ( pResult->pszErrorMsg == NULL ) {
#ifdef MULTITHREAD
    pResult->pszErrorMsg	= strdup ( szEmpty );
#else
    pResult->pszErrorMsg	= (LPSTR) szEmpty;
#endif
  }
  __pRequest__	= NULL;
  return (RESULTTYPE) pResult;
} /* fnrpc_fnserverbtreemapfirstbystring_1 */




extern int fnClientBtreemapNext
	(SHORTOBJID oShortObjIdMapper ,
	  SHORTOBJID oShortObjIdHeap ,
	  int nMap ,
	  int * /* _vector_t<nMap> */  pnValueKey ,
	  u_int * /* _vector_t<nMap> */  pnTypeTagKey ,
	  int * /* _vector_t<nMap> */  pnValueData ,
	  u_int * /* _vector_t<nMap> */  pnTypeTagData);

#ifdef MULTITHREAD
bool_t
#else
fnClientBtreemapNext_rets *
#endif
	PASTE2(fnrpc_fnclientbtreemapnext_1,_SVCSUFFIX)
		( fnClientBtreemapNext_args * pArguments,
#ifdef MULTITHREAD
		  fnClientBtreemapNext_rets * pResult,
#endif
		  struct svc_req * pRequest )
{
  static const char	__procedure__[]	= "server:fnrpc_fnclientbtreemapnext_1";
#ifdef MULTITHREAD
  typedef bool_t RESULTTYPE;
#else
  typedef fnClientBtreemapNext_rets * RESULTTYPE;
#endif
#ifndef MULTITHREAD
  static fnClientBtreemapNext_rets	Result;
  RESULTTYPE			pResult = &Result;
#endif
  LPCSTR	pszErrorMsg;

  __pRequest__	= pRequest;

  RPC_SERVER_ENTRY();

#ifndef MULTITHREAD
  if ( pResult->pszErrorMsg == szEmpty ) {
    pResult->pszErrorMsg	= NULL;
  }
  xdr_free ( (xdrproc_t) xdr_fnClientBtreemapNext_rets, (char *) pResult );
#endif
  pResult->nErrorLvl		= 0;

  pResult->pnValueKey.int_vector_t_len	= pArguments->pnValueKeySize;
  if ( pArguments->pnValueKeySize == 0 ) {
    pResult->pnValueKey.int_vector_t_val	= NULL;
  } else {
    pResult->pnValueKey.int_vector_t_val	=
      (int*) malloc ( pArguments->pnValueKeySize *
               SIZEOF ( *(pResult->pnValueKey.int_vector_t_val) ) );
    if ( pResult->pnValueKey.int_vector_t_val == NULL ) {
      char	szError [ 256 ];
      sprintf ( szError, szFormatMallocFailed,
                __procedure__, pArguments->pnValueKeySize,
                "pnValueKey" );
      RPC_SERVER_ERROR ( szError );
      return (RESULTTYPE) NULL;
    }
  }
  pResult->pnTypeTagKey.u_int_vector_t_len	= pArguments->pnTypeTagKeySize;
  if ( pArguments->pnTypeTagKeySize == 0 ) {
    pResult->pnTypeTagKey.u_int_vector_t_val	= NULL;
  } else {
    pResult->pnTypeTagKey.u_int_vector_t_val	=
      (u_int*) malloc ( pArguments->pnTypeTagKeySize *
               SIZEOF ( *(pResult->pnTypeTagKey.u_int_vector_t_val) ) );
    if ( pResult->pnTypeTagKey.u_int_vector_t_val == NULL ) {
      char	szError [ 256 ];
      sprintf ( szError, szFormatMallocFailed,
                __procedure__, pArguments->pnTypeTagKeySize,
                "pnTypeTagKey" );
      RPC_SERVER_ERROR ( szError );
      return (RESULTTYPE) NULL;
    }
  }
  pResult->pnValueData.int_vector_t_len	= pArguments->pnValueDataSize;
  if ( pArguments->pnValueDataSize == 0 ) {
    pResult->pnValueData.int_vector_t_val	= NULL;
  } else {
    pResult->pnValueData.int_vector_t_val	=
      (int*) malloc ( pArguments->pnValueDataSize *
               SIZEOF ( *(pResult->pnValueData.int_vector_t_val) ) );
    if ( pResult->pnValueData.int_vector_t_val == NULL ) {
      char	szError [ 256 ];
      sprintf ( szError, szFormatMallocFailed,
                __procedure__, pArguments->pnValueDataSize,
                "pnValueData" );
      RPC_SERVER_ERROR ( szError );
      return (RESULTTYPE) NULL;
    }
  }
  pResult->pnTypeTagData.u_int_vector_t_len	= pArguments->pnTypeTagDataSize;
  if ( pArguments->pnTypeTagDataSize == 0 ) {
    pResult->pnTypeTagData.u_int_vector_t_val	= NULL;
  } else {
    pResult->pnTypeTagData.u_int_vector_t_val	=
      (u_int*) malloc ( pArguments->pnTypeTagDataSize *
               SIZEOF ( *(pResult->pnTypeTagData.u_int_vector_t_val) ) );
    if ( pResult->pnTypeTagData.u_int_vector_t_val == NULL ) {
      char	szError [ 256 ];
      sprintf ( szError, szFormatMallocFailed,
                __procedure__, pArguments->pnTypeTagDataSize,
                "pnTypeTagData" );
      RPC_SERVER_ERROR ( szError );
      return (RESULTTYPE) NULL;
    }
  }
  Reply.bAnswered		= FALSE;
  Reply.pfnCalled		= (void(*)()) fnClientBtreemapNext;
  Reply.pfnXdrResult		= (bool_t(*)()) xdr_fnClientBtreemapNext_rets;
  Reply.pnErrorLvl		= &pResult->nErrorLvl;
  Reply.ppszErrorMsg		= (LPCSTR *) &pResult->pszErrorMsg;
  Reply.pResult		= pResult;
  Reply.pReturnValue		= &pResult->ReturnValue;
  Reply.nReturnValueSize	= sizeof ( pResult->ReturnValue );

  pResult->ReturnValue		=
  fnClientBtreemapNext (
	pArguments->oShortObjIdMapper,
	pArguments->oShortObjIdHeap,
	pArguments->nMap,
	pResult->pnValueKey.int_vector_t_val,
	pResult->pnTypeTagKey.u_int_vector_t_val,
	pResult->pnValueData.int_vector_t_val,
	pResult->pnTypeTagData.u_int_vector_t_val );

  if ( Reply.bAnswered ) {
    __pRequest__	= NULL;
    return (RESULTTYPE) NULL;
  }

  pResult->nErrorLvl	= RPC_SERVER_ERRLVL();
  if ( pResult->nErrorLvl > 0 ) {
    pszErrorMsg		= RPC_SERVER_ERRMSG();
    if ( pszErrorMsg && *pszErrorMsg ) {
      pResult->pszErrorMsg	= strdup ( pszErrorMsg );
    }
  }
  if ( pResult->pszErrorMsg == NULL ) {
#ifdef MULTITHREAD
    pResult->pszErrorMsg	= strdup ( szEmpty );
#else
    pResult->pszErrorMsg	= (LPSTR) szEmpty;
#endif
  }
  __pRequest__	= NULL;
  return (RESULTTYPE) pResult;
} /* fnrpc_fnclientbtreemapnext_1 */




extern SHORTOBJID fnClientBtreemapLast
	(SHORTOBJID oShortObjIdMapper ,
	  SHORTOBJID oShortObjIdHeap);

#ifdef MULTITHREAD
bool_t
#else
fnClientBtreemapLast_rets *
#endif
	PASTE2(fnrpc_fnclientbtreemaplast_1,_SVCSUFFIX)
		( fnClientBtreemapLast_args * pArguments,
#ifdef MULTITHREAD
		  fnClientBtreemapLast_rets * pResult,
#endif
		  struct svc_req * pRequest )
{
  static const char	__procedure__[]	= "server:fnrpc_fnclientbtreemaplast_1";
#ifdef MULTITHREAD
  typedef bool_t RESULTTYPE;
#else
  typedef fnClientBtreemapLast_rets * RESULTTYPE;
#endif
#ifndef MULTITHREAD
  static fnClientBtreemapLast_rets	Result;
  RESULTTYPE			pResult = &Result;
#endif
  LPCSTR	pszErrorMsg;

  __pRequest__	= pRequest;

  RPC_SERVER_ENTRY();

#ifndef MULTITHREAD
  if ( pResult->pszErrorMsg == szEmpty ) {
    pResult->pszErrorMsg	= NULL;
  }
  xdr_free ( (xdrproc_t) xdr_fnClientBtreemapLast_rets, (char *) pResult );
#endif
  pResult->nErrorLvl		= 0;

  Reply.bAnswered		= FALSE;
  Reply.pfnCalled		= (void(*)()) fnClientBtreemapLast;
  Reply.pfnXdrResult		= (bool_t(*)()) xdr_fnClientBtreemapLast_rets;
  Reply.pnErrorLvl		= &pResult->nErrorLvl;
  Reply.ppszErrorMsg		= (LPCSTR *) &pResult->pszErrorMsg;
  Reply.pResult		= pResult;
  Reply.pReturnValue		= &pResult->ReturnValue;
  Reply.nReturnValueSize	= sizeof ( pResult->ReturnValue );

  pResult->ReturnValue		=
  fnClientBtreemapLast (
	pArguments->oShortObjIdMapper,
	pArguments->oShortObjIdHeap );

  if ( Reply.bAnswered ) {
    __pRequest__	= NULL;
    return (RESULTTYPE) NULL;
  }

  pResult->nErrorLvl	= RPC_SERVER_ERRLVL();
  if ( pResult->nErrorLvl > 0 ) {
    pszErrorMsg		= RPC_SERVER_ERRMSG();
    if ( pszErrorMsg && *pszErrorMsg ) {
      pResult->pszErrorMsg	= strdup ( pszErrorMsg );
    }
  }
  if ( pResult->pszErrorMsg == NULL ) {
#ifdef MULTITHREAD
    pResult->pszErrorMsg	= strdup ( szEmpty );
#else
    pResult->pszErrorMsg	= (LPSTR) szEmpty;
#endif
  }
  __pRequest__	= NULL;
  return (RESULTTYPE) pResult;
} /* fnrpc_fnclientbtreemaplast_1 */




extern int fnClientBtreePrint
	(SHORTOBJID oShortObjIdHeap ,
	  SHORTOBJID oShortObjIdBTree ,
	  NUMERICSTDSTREAM nStdStream);

#ifdef MULTITHREAD
bool_t
#else
fnClientBtreePrint_rets *
#endif
	PASTE2(fnrpc_fnclientbtreeprint_1,_SVCSUFFIX)
		( fnClientBtreePrint_args * pArguments,
#ifdef MULTITHREAD
		  fnClientBtreePrint_rets * pResult,
#endif
		  struct svc_req * pRequest )
{
  static const char	__procedure__[]	= "server:fnrpc_fnclientbtreeprint_1";
#ifdef MULTITHREAD
  typedef bool_t RESULTTYPE;
#else
  typedef fnClientBtreePrint_rets * RESULTTYPE;
#endif
#ifndef MULTITHREAD
  static fnClientBtreePrint_rets	Result;
  RESULTTYPE			pResult = &Result;
#endif
  LPCSTR	pszErrorMsg;

  __pRequest__	= pRequest;

  RPC_SERVER_ENTRY();

#ifndef MULTITHREAD
  if ( pResult->pszErrorMsg == szEmpty ) {
    pResult->pszErrorMsg	= NULL;
  }
  xdr_free ( (xdrproc_t) xdr_fnClientBtreePrint_rets, (char *) pResult );
#endif
  pResult->nErrorLvl		= 0;

  Reply.bAnswered		= FALSE;
  Reply.pfnCalled		= (void(*)()) fnClientBtreePrint;
  Reply.pfnXdrResult		= (bool_t(*)()) xdr_fnClientBtreePrint_rets;
  Reply.pnErrorLvl		= &pResult->nErrorLvl;
  Reply.ppszErrorMsg		= (LPCSTR *) &pResult->pszErrorMsg;
  Reply.pResult		= pResult;
  Reply.pReturnValue		= &pResult->ReturnValue;
  Reply.nReturnValueSize	= sizeof ( pResult->ReturnValue );

  pResult->ReturnValue		=
  fnClientBtreePrint (
	pArguments->oShortObjIdHeap,
	pArguments->oShortObjIdBTree,
	pArguments->nStdStream );

  if ( Reply.bAnswered ) {
    __pRequest__	= NULL;
    return (RESULTTYPE) NULL;
  }

  pResult->nErrorLvl	= RPC_SERVER_ERRLVL();
  if ( pResult->nErrorLvl > 0 ) {
    pszErrorMsg		= RPC_SERVER_ERRMSG();
    if ( pszErrorMsg && *pszErrorMsg ) {
      pResult->pszErrorMsg	= strdup ( pszErrorMsg );
    }
  }
  if ( pResult->pszErrorMsg == NULL ) {
#ifdef MULTITHREAD
    pResult->pszErrorMsg	= strdup ( szEmpty );
#else
    pResult->pszErrorMsg	= (LPSTR) szEmpty;
#endif
  }
  __pRequest__	= NULL;
  return (RESULTTYPE) pResult;
} /* fnrpc_fnclientbtreeprint_1 */




extern BTREERESULT fnServerBtreeSearch
	(SHORTOBJID oShortObjIdHeap ,
	  SHORTOBJID oShortObjIdBTree ,
	  int nValueKey ,
	  SHTYPETAG nTypeTagKey ,
	  int * pnValueKey ,
	  SHTYPETAG * pnTypeTagKey ,
	  int * pnValueData ,
	  SHTYPETAG * pnTypeTagData);

#ifdef MULTITHREAD
bool_t
#else
fnServerBtreeSearch_rets *
#endif
	PASTE2(fnrpc_fnserverbtreesearch_1,_SVCSUFFIX)
		( fnServerBtreeSearch_args * pArguments,
#ifdef MULTITHREAD
		  fnServerBtreeSearch_rets * pResult,
#endif
		  struct svc_req * pRequest )
{
  static const char	__procedure__[]	= "server:fnrpc_fnserverbtreesearch_1";
#ifdef MULTITHREAD
  typedef bool_t RESULTTYPE;
#else
  typedef fnServerBtreeSearch_rets * RESULTTYPE;
#endif
#ifndef MULTITHREAD
  static fnServerBtreeSearch_rets	Result;
  RESULTTYPE			pResult = &Result;
#endif
  LPCSTR	pszErrorMsg;

  __pRequest__	= pRequest;

  RPC_SERVER_ENTRY();

#ifndef MULTITHREAD
  if ( pResult->pszErrorMsg == szEmpty ) {
    pResult->pszErrorMsg	= NULL;
  }
  xdr_free ( (xdrproc_t) xdr_fnServerBtreeSearch_rets, (char *) pResult );
#endif
  pResult->nErrorLvl		= 0;

  Reply.bAnswered		= FALSE;
  Reply.pfnCalled		= (void(*)()) fnServerBtreeSearch;
  Reply.pfnXdrResult		= (bool_t(*)()) xdr_fnServerBtreeSearch_rets;
  Reply.pnErrorLvl		= &pResult->nErrorLvl;
  Reply.ppszErrorMsg		= (LPCSTR *) &pResult->pszErrorMsg;
  Reply.pResult		= pResult;
  Reply.pReturnValue		= &pResult->ReturnValue;
  Reply.nReturnValueSize	= sizeof ( pResult->ReturnValue );

  pResult->ReturnValue		=
  fnServerBtreeSearch (
	pArguments->oShortObjIdHeap,
	pArguments->oShortObjIdBTree,
	pArguments->nValueKey,
	pArguments->nTypeTagKey,
	&pResult->pnValueKey,
	&pResult->pnTypeTagKey,
	&pResult->pnValueData,
	&pResult->pnTypeTagData );

  if ( Reply.bAnswered ) {
    __pRequest__	= NULL;
    return (RESULTTYPE) NULL;
  }

  pResult->nErrorLvl	= RPC_SERVER_ERRLVL();
  if ( pResult->nErrorLvl > 0 ) {
    pszErrorMsg		= RPC_SERVER_ERRMSG();
    if ( pszErrorMsg && *pszErrorMsg ) {
      pResult->pszErrorMsg	= strdup ( pszErrorMsg );
    }
  }
  if ( pResult->pszErrorMsg == NULL ) {
#ifdef MULTITHREAD
    pResult->pszErrorMsg	= strdup ( szEmpty );
#else
    pResult->pszErrorMsg	= (LPSTR) szEmpty;
#endif
  }
  __pRequest__	= NULL;
  return (RESULTTYPE) pResult;
} /* fnrpc_fnserverbtreesearch_1 */




extern BTREERESULT fnServerBtreeSearchByFloat
	(SHORTOBJID oShortObjIdHeap ,
	  SHORTOBJID oShortObjIdBTree ,
	  float fKey ,
	  SHTYPETAG nTypeTagKey ,
	  int * pnValueKey ,
	  SHTYPETAG * pnTypeTagKey ,
	  int * pnValueData ,
	  SHTYPETAG * pnTypeTagData);

#ifdef MULTITHREAD
bool_t
#else
fnServerBtreeSearchByFloat_rets *
#endif
	PASTE2(fnrpc_fnserverbtreesearchbyfloat_1,_SVCSUFFIX)
		( fnServerBtreeSearchByFloat_args * pArguments,
#ifdef MULTITHREAD
		  fnServerBtreeSearchByFloat_rets * pResult,
#endif
		  struct svc_req * pRequest )
{
  static const char	__procedure__[]	= "server:fnrpc_fnserverbtreesearchbyfloat_1";
#ifdef MULTITHREAD
  typedef bool_t RESULTTYPE;
#else
  typedef fnServerBtreeSearchByFloat_rets * RESULTTYPE;
#endif
#ifndef MULTITHREAD
  static fnServerBtreeSearchByFloat_rets	Result;
  RESULTTYPE			pResult = &Result;
#endif
  LPCSTR	pszErrorMsg;

  __pRequest__	= pRequest;

  RPC_SERVER_ENTRY();

#ifndef MULTITHREAD
  if ( pResult->pszErrorMsg == szEmpty ) {
    pResult->pszErrorMsg	= NULL;
  }
  xdr_free ( (xdrproc_t) xdr_fnServerBtreeSearchByFloat_rets, (char *) pResult );
#endif
  pResult->nErrorLvl		= 0;

  Reply.bAnswered		= FALSE;
  Reply.pfnCalled		= (void(*)()) fnServerBtreeSearchByFloat;
  Reply.pfnXdrResult		= (bool_t(*)()) xdr_fnServerBtreeSearchByFloat_rets;
  Reply.pnErrorLvl		= &pResult->nErrorLvl;
  Reply.ppszErrorMsg		= (LPCSTR *) &pResult->pszErrorMsg;
  Reply.pResult		= pResult;
  Reply.pReturnValue		= &pResult->ReturnValue;
  Reply.nReturnValueSize	= sizeof ( pResult->ReturnValue );

  pResult->ReturnValue		=
  fnServerBtreeSearchByFloat (
	pArguments->oShortObjIdHeap,
	pArguments->oShortObjIdBTree,
	pArguments->fKey,
	pArguments->nTypeTagKey,
	&pResult->pnValueKey,
	&pResult->pnTypeTagKey,
	&pResult->pnValueData,
	&pResult->pnTypeTagData );

  if ( Reply.bAnswered ) {
    __pRequest__	= NULL;
    return (RESULTTYPE) NULL;
  }

  pResult->nErrorLvl	= RPC_SERVER_ERRLVL();
  if ( pResult->nErrorLvl > 0 ) {
    pszErrorMsg		= RPC_SERVER_ERRMSG();
    if ( pszErrorMsg && *pszErrorMsg ) {
      pResult->pszErrorMsg	= strdup ( pszErrorMsg );
    }
  }
  if ( pResult->pszErrorMsg == NULL ) {
#ifdef MULTITHREAD
    pResult->pszErrorMsg	= strdup ( szEmpty );
#else
    pResult->pszErrorMsg	= (LPSTR) szEmpty;
#endif
  }
  __pRequest__	= NULL;
  return (RESULTTYPE) pResult;
} /* fnrpc_fnserverbtreesearchbyfloat_1 */




extern BTREERESULT fnServerBtreeSearchByDouble
	(SHORTOBJID oShortObjIdHeap ,
	  SHORTOBJID oShortObjIdBTree ,
	  double fKey ,
	  SHTYPETAG nTypeTagKey ,
	  int * pnValueKey ,
	  SHTYPETAG * pnTypeTagKey ,
	  int * pnValueData ,
	  SHTYPETAG * pnTypeTagData);

#ifdef MULTITHREAD
bool_t
#else
fnServerBtreeSearchByDouble_rets *
#endif
	PASTE2(fnrpc_fnserverbtreesearchbydouble_1,_SVCSUFFIX)
		( fnServerBtreeSearchByDouble_args * pArguments,
#ifdef MULTITHREAD
		  fnServerBtreeSearchByDouble_rets * pResult,
#endif
		  struct svc_req * pRequest )
{
  static const char	__procedure__[]	= "server:fnrpc_fnserverbtreesearchbydouble_1";
#ifdef MULTITHREAD
  typedef bool_t RESULTTYPE;
#else
  typedef fnServerBtreeSearchByDouble_rets * RESULTTYPE;
#endif
#ifndef MULTITHREAD
  static fnServerBtreeSearchByDouble_rets	Result;
  RESULTTYPE			pResult = &Result;
#endif
  LPCSTR	pszErrorMsg;

  __pRequest__	= pRequest;

  RPC_SERVER_ENTRY();

#ifndef MULTITHREAD
  if ( pResult->pszErrorMsg == szEmpty ) {
    pResult->pszErrorMsg	= NULL;
  }
  xdr_free ( (xdrproc_t) xdr_fnServerBtreeSearchByDouble_rets, (char *) pResult );
#endif
  pResult->nErrorLvl		= 0;

  Reply.bAnswered		= FALSE;
  Reply.pfnCalled		= (void(*)()) fnServerBtreeSearchByDouble;
  Reply.pfnXdrResult		= (bool_t(*)()) xdr_fnServerBtreeSearchByDouble_rets;
  Reply.pnErrorLvl		= &pResult->nErrorLvl;
  Reply.ppszErrorMsg		= (LPCSTR *) &pResult->pszErrorMsg;
  Reply.pResult		= pResult;
  Reply.pReturnValue		= &pResult->ReturnValue;
  Reply.nReturnValueSize	= sizeof ( pResult->ReturnValue );

  pResult->ReturnValue		=
  fnServerBtreeSearchByDouble (
	pArguments->oShortObjIdHeap,
	pArguments->oShortObjIdBTree,
	pArguments->fKey,
	pArguments->nTypeTagKey,
	&pResult->pnValueKey,
	&pResult->pnTypeTagKey,
	&pResult->pnValueData,
	&pResult->pnTypeTagData );

  if ( Reply.bAnswered ) {
    __pRequest__	= NULL;
    return (RESULTTYPE) NULL;
  }

  pResult->nErrorLvl	= RPC_SERVER_ERRLVL();
  if ( pResult->nErrorLvl > 0 ) {
    pszErrorMsg		= RPC_SERVER_ERRMSG();
    if ( pszErrorMsg && *pszErrorMsg ) {
      pResult->pszErrorMsg	= strdup ( pszErrorMsg );
    }
  }
  if ( pResult->pszErrorMsg == NULL ) {
#ifdef MULTITHREAD
    pResult->pszErrorMsg	= strdup ( szEmpty );
#else
    pResult->pszErrorMsg	= (LPSTR) szEmpty;
#endif
  }
  __pRequest__	= NULL;
  return (RESULTTYPE) pResult;
} /* fnrpc_fnserverbtreesearchbydouble_1 */




extern BTREERESULT fnServerBtreeSearchByString
	(SHORTOBJID oShortObjIdHeap ,
	  SHORTOBJID oShortObjIdBTree ,
	  string_t /* string_t<@conststring@> */ szKey ,
	  SHTYPETAG nTypeTagKey ,
	  int * pnValueKey ,
	  SHTYPETAG * pnTypeTagKey ,
	  int * pnValueData ,
	  SHTYPETAG * pnTypeTagData);

#ifdef MULTITHREAD
bool_t
#else
fnServerBtreeSearchByString_rets *
#endif
	PASTE2(fnrpc_fnserverbtreesearchbystring_1,_SVCSUFFIX)
		( fnServerBtreeSearchByString_args * pArguments,
#ifdef MULTITHREAD
		  fnServerBtreeSearchByString_rets * pResult,
#endif
		  struct svc_req * pRequest )
{
  static const char	__procedure__[]	= "server:fnrpc_fnserverbtreesearchbystring_1";
#ifdef MULTITHREAD
  typedef bool_t RESULTTYPE;
#else
  typedef fnServerBtreeSearchByString_rets * RESULTTYPE;
#endif
#ifndef MULTITHREAD
  static fnServerBtreeSearchByString_rets	Result;
  RESULTTYPE			pResult = &Result;
#endif
  LPCSTR	pszErrorMsg;

  __pRequest__	= pRequest;

  RPC_SERVER_ENTRY();

#ifndef MULTITHREAD
  if ( pResult->pszErrorMsg == szEmpty ) {
    pResult->pszErrorMsg	= NULL;
  }
  xdr_free ( (xdrproc_t) xdr_fnServerBtreeSearchByString_rets, (char *) pResult );
#endif
  pResult->nErrorLvl		= 0;

  Reply.bAnswered		= FALSE;
  Reply.pfnCalled		= (void(*)()) fnServerBtreeSearchByString;
  Reply.pfnXdrResult		= (bool_t(*)()) xdr_fnServerBtreeSearchByString_rets;
  Reply.pnErrorLvl		= &pResult->nErrorLvl;
  Reply.ppszErrorMsg		= (LPCSTR *) &pResult->pszErrorMsg;
  Reply.pResult		= pResult;
  Reply.pReturnValue		= &pResult->ReturnValue;
  Reply.nReturnValueSize	= sizeof ( pResult->ReturnValue );

  pResult->ReturnValue		=
  fnServerBtreeSearchByString (
	pArguments->oShortObjIdHeap,
	pArguments->oShortObjIdBTree,
	pArguments->szKey,
	pArguments->nTypeTagKey,
	&pResult->pnValueKey,
	&pResult->pnTypeTagKey,
	&pResult->pnValueData,
	&pResult->pnTypeTagData );

  if ( Reply.bAnswered ) {
    __pRequest__	= NULL;
    return (RESULTTYPE) NULL;
  }

  pResult->nErrorLvl	= RPC_SERVER_ERRLVL();
  if ( pResult->nErrorLvl > 0 ) {
    pszErrorMsg		= RPC_SERVER_ERRMSG();
    if ( pszErrorMsg && *pszErrorMsg ) {
      pResult->pszErrorMsg	= strdup ( pszErrorMsg );
    }
  }
  if ( pResult->pszErrorMsg == NULL ) {
#ifdef MULTITHREAD
    pResult->pszErrorMsg	= strdup ( szEmpty );
#else
    pResult->pszErrorMsg	= (LPSTR) szEmpty;
#endif
  }
  __pRequest__	= NULL;
  return (RESULTTYPE) pResult;
} /* fnrpc_fnserverbtreesearchbystring_1 */




extern SHORTOBJID fnClientBtreeRoot
	(SHORTOBJID oShortObjIdHeap ,
	  SHORTOBJID oShortObjIdBTree);

#ifdef MULTITHREAD
bool_t
#else
fnClientBtreeRoot_rets *
#endif
	PASTE2(fnrpc_fnclientbtreeroot_1,_SVCSUFFIX)
		( fnClientBtreeRoot_args * pArguments,
#ifdef MULTITHREAD
		  fnClientBtreeRoot_rets * pResult,
#endif
		  struct svc_req * pRequest )
{
  static const char	__procedure__[]	= "server:fnrpc_fnclientbtreeroot_1";
#ifdef MULTITHREAD
  typedef bool_t RESULTTYPE;
#else
  typedef fnClientBtreeRoot_rets * RESULTTYPE;
#endif
#ifndef MULTITHREAD
  static fnClientBtreeRoot_rets	Result;
  RESULTTYPE			pResult = &Result;
#endif
  LPCSTR	pszErrorMsg;

  __pRequest__	= pRequest;

  RPC_SERVER_ENTRY();

#ifndef MULTITHREAD
  if ( pResult->pszErrorMsg == szEmpty ) {
    pResult->pszErrorMsg	= NULL;
  }
  xdr_free ( (xdrproc_t) xdr_fnClientBtreeRoot_rets, (char *) pResult );
#endif
  pResult->nErrorLvl		= 0;

  Reply.bAnswered		= FALSE;
  Reply.pfnCalled		= (void(*)()) fnClientBtreeRoot;
  Reply.pfnXdrResult		= (bool_t(*)()) xdr_fnClientBtreeRoot_rets;
  Reply.pnErrorLvl		= &pResult->nErrorLvl;
  Reply.ppszErrorMsg		= (LPCSTR *) &pResult->pszErrorMsg;
  Reply.pResult		= pResult;
  Reply.pReturnValue		= &pResult->ReturnValue;
  Reply.nReturnValueSize	= sizeof ( pResult->ReturnValue );

  pResult->ReturnValue		=
  fnClientBtreeRoot (
	pArguments->oShortObjIdHeap,
	pArguments->oShortObjIdBTree );

  if ( Reply.bAnswered ) {
    __pRequest__	= NULL;
    return (RESULTTYPE) NULL;
  }

  pResult->nErrorLvl	= RPC_SERVER_ERRLVL();
  if ( pResult->nErrorLvl > 0 ) {
    pszErrorMsg		= RPC_SERVER_ERRMSG();
    if ( pszErrorMsg && *pszErrorMsg ) {
      pResult->pszErrorMsg	= strdup ( pszErrorMsg );
    }
  }
  if ( pResult->pszErrorMsg == NULL ) {
#ifdef MULTITHREAD
    pResult->pszErrorMsg	= strdup ( szEmpty );
#else
    pResult->pszErrorMsg	= (LPSTR) szEmpty;
#endif
  }
  __pRequest__	= NULL;
  return (RESULTTYPE) pResult;
} /* fnrpc_fnclientbtreeroot_1 */




extern int fnClientBtreeSize
	(SHORTOBJID oShortObjIdHeap ,
	  SHORTOBJID oShortObjIdBTree);

#ifdef MULTITHREAD
bool_t
#else
fnClientBtreeSize_rets *
#endif
	PASTE2(fnrpc_fnclientbtreesize_1,_SVCSUFFIX)
		( fnClientBtreeSize_args * pArguments,
#ifdef MULTITHREAD
		  fnClientBtreeSize_rets * pResult,
#endif
		  struct svc_req * pRequest )
{
  static const char	__procedure__[]	= "server:fnrpc_fnclientbtreesize_1";
#ifdef MULTITHREAD
  typedef bool_t RESULTTYPE;
#else
  typedef fnClientBtreeSize_rets * RESULTTYPE;
#endif
#ifndef MULTITHREAD
  static fnClientBtreeSize_rets	Result;
  RESULTTYPE			pResult = &Result;
#endif
  LPCSTR	pszErrorMsg;

  __pRequest__	= pRequest;

  RPC_SERVER_ENTRY();

#ifndef MULTITHREAD
  if ( pResult->pszErrorMsg == szEmpty ) {
    pResult->pszErrorMsg	= NULL;
  }
  xdr_free ( (xdrproc_t) xdr_fnClientBtreeSize_rets, (char *) pResult );
#endif
  pResult->nErrorLvl		= 0;

  Reply.bAnswered		= FALSE;
  Reply.pfnCalled		= (void(*)()) fnClientBtreeSize;
  Reply.pfnXdrResult		= (bool_t(*)()) xdr_fnClientBtreeSize_rets;
  Reply.pnErrorLvl		= &pResult->nErrorLvl;
  Reply.ppszErrorMsg		= (LPCSTR *) &pResult->pszErrorMsg;
  Reply.pResult		= pResult;
  Reply.pReturnValue		= &pResult->ReturnValue;
  Reply.nReturnValueSize	= sizeof ( pResult->ReturnValue );

  pResult->ReturnValue		=
  fnClientBtreeSize (
	pArguments->oShortObjIdHeap,
	pArguments->oShortObjIdBTree );

  if ( Reply.bAnswered ) {
    __pRequest__	= NULL;
    return (RESULTTYPE) NULL;
  }

  pResult->nErrorLvl	= RPC_SERVER_ERRLVL();
  if ( pResult->nErrorLvl > 0 ) {
    pszErrorMsg		= RPC_SERVER_ERRMSG();
    if ( pszErrorMsg && *pszErrorMsg ) {
      pResult->pszErrorMsg	= strdup ( pszErrorMsg );
    }
  }
  if ( pResult->pszErrorMsg == NULL ) {
#ifdef MULTITHREAD
    pResult->pszErrorMsg	= strdup ( szEmpty );
#else
    pResult->pszErrorMsg	= (LPSTR) szEmpty;
#endif
  }
  __pRequest__	= NULL;
  return (RESULTTYPE) pResult;
} /* fnrpc_fnclientbtreesize_1 */




extern COMPARETAG fnClientBtreeTestMode
	(SHORTOBJID oShortObjIdHeap ,
	  SHORTOBJID oShortObjIdBTree ,
	  COMPARETAG nNewTestMode);

#ifdef MULTITHREAD
bool_t
#else
fnClientBtreeTestMode_rets *
#endif
	PASTE2(fnrpc_fnclientbtreetestmode_1,_SVCSUFFIX)
		( fnClientBtreeTestMode_args * pArguments,
#ifdef MULTITHREAD
		  fnClientBtreeTestMode_rets * pResult,
#endif
		  struct svc_req * pRequest )
{
  static const char	__procedure__[]	= "server:fnrpc_fnclientbtreetestmode_1";
#ifdef MULTITHREAD
  typedef bool_t RESULTTYPE;
#else
  typedef fnClientBtreeTestMode_rets * RESULTTYPE;
#endif
#ifndef MULTITHREAD
  static fnClientBtreeTestMode_rets	Result;
  RESULTTYPE			pResult = &Result;
#endif
  LPCSTR	pszErrorMsg;

  __pRequest__	= pRequest;

  RPC_SERVER_ENTRY();

#ifndef MULTITHREAD
  if ( pResult->pszErrorMsg == szEmpty ) {
    pResult->pszErrorMsg	= NULL;
  }
  xdr_free ( (xdrproc_t) xdr_fnClientBtreeTestMode_rets, (char *) pResult );
#endif
  pResult->nErrorLvl		= 0;

  Reply.bAnswered		= FALSE;
  Reply.pfnCalled		= (void(*)()) fnClientBtreeTestMode;
  Reply.pfnXdrResult		= (bool_t(*)()) xdr_fnClientBtreeTestMode_rets;
  Reply.pnErrorLvl		= &pResult->nErrorLvl;
  Reply.ppszErrorMsg		= (LPCSTR *) &pResult->pszErrorMsg;
  Reply.pResult		= pResult;
  Reply.pReturnValue		= &pResult->ReturnValue;
  Reply.nReturnValueSize	= sizeof ( pResult->ReturnValue );

  pResult->ReturnValue		=
  fnClientBtreeTestMode (
	pArguments->oShortObjIdHeap,
	pArguments->oShortObjIdBTree,
	pArguments->nNewTestMode );

  if ( Reply.bAnswered ) {
    __pRequest__	= NULL;
    return (RESULTTYPE) NULL;
  }

  pResult->nErrorLvl	= RPC_SERVER_ERRLVL();
  if ( pResult->nErrorLvl > 0 ) {
    pszErrorMsg		= RPC_SERVER_ERRMSG();
    if ( pszErrorMsg && *pszErrorMsg ) {
      pResult->pszErrorMsg	= strdup ( pszErrorMsg );
    }
  }
  if ( pResult->pszErrorMsg == NULL ) {
#ifdef MULTITHREAD
    pResult->pszErrorMsg	= strdup ( szEmpty );
#else
    pResult->pszErrorMsg	= (LPSTR) szEmpty;
#endif
  }
  __pRequest__	= NULL;
  return (RESULTTYPE) pResult;
} /* fnrpc_fnclientbtreetestmode_1 */




extern int fnClientBtreePageSize
	(SHORTOBJID oShortObjIdHeap ,
	  SHORTOBJID oShortObjIdBTree ,
	  int nNewPageSize);

#ifdef MULTITHREAD
bool_t
#else
fnClientBtreePageSize_rets *
#endif
	PASTE2(fnrpc_fnclientbtreepagesize_1,_SVCSUFFIX)
		( fnClientBtreePageSize_args * pArguments,
#ifdef MULTITHREAD
		  fnClientBtreePageSize_rets * pResult,
#endif
		  struct svc_req * pRequest )
{
  static const char	__procedure__[]	= "server:fnrpc_fnclientbtreepagesize_1";
#ifdef MULTITHREAD
  typedef bool_t RESULTTYPE;
#else
  typedef fnClientBtreePageSize_rets * RESULTTYPE;
#endif
#ifndef MULTITHREAD
  static fnClientBtreePageSize_rets	Result;
  RESULTTYPE			pResult = &Result;
#endif
  LPCSTR	pszErrorMsg;

  __pRequest__	= pRequest;

  RPC_SERVER_ENTRY();

#ifndef MULTITHREAD
  if ( pResult->pszErrorMsg == szEmpty ) {
    pResult->pszErrorMsg	= NULL;
  }
  xdr_free ( (xdrproc_t) xdr_fnClientBtreePageSize_rets, (char *) pResult );
#endif
  pResult->nErrorLvl		= 0;

  Reply.bAnswered		= FALSE;
  Reply.pfnCalled		= (void(*)()) fnClientBtreePageSize;
  Reply.pfnXdrResult		= (bool_t(*)()) xdr_fnClientBtreePageSize_rets;
  Reply.pnErrorLvl		= &pResult->nErrorLvl;
  Reply.ppszErrorMsg		= (LPCSTR *) &pResult->pszErrorMsg;
  Reply.pResult		= pResult;
  Reply.pReturnValue		= &pResult->ReturnValue;
  Reply.nReturnValueSize	= sizeof ( pResult->ReturnValue );

  pResult->ReturnValue		=
  fnClientBtreePageSize (
	pArguments->oShortObjIdHeap,
	pArguments->oShortObjIdBTree,
	pArguments->nNewPageSize );

  if ( Reply.bAnswered ) {
    __pRequest__	= NULL;
    return (RESULTTYPE) NULL;
  }

  pResult->nErrorLvl	= RPC_SERVER_ERRLVL();
  if ( pResult->nErrorLvl > 0 ) {
    pszErrorMsg		= RPC_SERVER_ERRMSG();
    if ( pszErrorMsg && *pszErrorMsg ) {
      pResult->pszErrorMsg	= strdup ( pszErrorMsg );
    }
  }
  if ( pResult->pszErrorMsg == NULL ) {
#ifdef MULTITHREAD
    pResult->pszErrorMsg	= strdup ( szEmpty );
#else
    pResult->pszErrorMsg	= (LPSTR) szEmpty;
#endif
  }
  __pRequest__	= NULL;
  return (RESULTTYPE) pResult;
} /* fnrpc_fnclientbtreepagesize_1 */




extern OBJID fnClientBtreepageParent
	(SHORTOBJID oShortObjIdHeap ,
	  SHORTOBJID oShortObjIdBTreePage);

#ifdef MULTITHREAD
bool_t
#else
fnClientBtreepageParent_rets *
#endif
	PASTE2(fnrpc_fnclientbtreepageparent_1,_SVCSUFFIX)
		( fnClientBtreepageParent_args * pArguments,
#ifdef MULTITHREAD
		  fnClientBtreepageParent_rets * pResult,
#endif
		  struct svc_req * pRequest )
{
  static const char	__procedure__[]	= "server:fnrpc_fnclientbtreepageparent_1";
#ifdef MULTITHREAD
  typedef bool_t RESULTTYPE;
#else
  typedef fnClientBtreepageParent_rets * RESULTTYPE;
#endif
#ifndef MULTITHREAD
  static fnClientBtreepageParent_rets	Result;
  RESULTTYPE			pResult = &Result;
#endif
  LPCSTR	pszErrorMsg;

  __pRequest__	= pRequest;

  RPC_SERVER_ENTRY();

#ifndef MULTITHREAD
  if ( pResult->pszErrorMsg == szEmpty ) {
    pResult->pszErrorMsg	= NULL;
  }
  xdr_free ( (xdrproc_t) xdr_fnClientBtreepageParent_rets, (char *) pResult );
#endif
  pResult->nErrorLvl		= 0;

  Reply.bAnswered		= FALSE;
  Reply.pfnCalled		= (void(*)()) fnClientBtreepageParent;
  Reply.pfnXdrResult		= (bool_t(*)()) xdr_fnClientBtreepageParent_rets;
  Reply.pnErrorLvl		= &pResult->nErrorLvl;
  Reply.ppszErrorMsg		= (LPCSTR *) &pResult->pszErrorMsg;
  Reply.pResult		= pResult;
  Reply.pReturnValue		= &pResult->ReturnValue;
  Reply.nReturnValueSize	= sizeof ( pResult->ReturnValue );

  pResult->ReturnValue		=
  fnClientBtreepageParent (
	pArguments->oShortObjIdHeap,
	pArguments->oShortObjIdBTreePage );

  if ( Reply.bAnswered ) {
    __pRequest__	= NULL;
    return (RESULTTYPE) NULL;
  }

  pResult->nErrorLvl	= RPC_SERVER_ERRLVL();
  if ( pResult->nErrorLvl > 0 ) {
    pszErrorMsg		= RPC_SERVER_ERRMSG();
    if ( pszErrorMsg && *pszErrorMsg ) {
      pResult->pszErrorMsg	= strdup ( pszErrorMsg );
    }
  }
  if ( pResult->pszErrorMsg == NULL ) {
#ifdef MULTITHREAD
    pResult->pszErrorMsg	= strdup ( szEmpty );
#else
    pResult->pszErrorMsg	= (LPSTR) szEmpty;
#endif
  }
  __pRequest__	= NULL;
  return (RESULTTYPE) pResult;
} /* fnrpc_fnclientbtreepageparent_1 */




extern int fnClientBtreepageCount
	(SHORTOBJID oShortObjIdHeap ,
	  SHORTOBJID oShortObjIdBTreePage);

#ifdef MULTITHREAD
bool_t
#else
fnClientBtreepageCount_rets *
#endif
	PASTE2(fnrpc_fnclientbtreepagecount_1,_SVCSUFFIX)
		( fnClientBtreepageCount_args * pArguments,
#ifdef MULTITHREAD
		  fnClientBtreepageCount_rets * pResult,
#endif
		  struct svc_req * pRequest )
{
  static const char	__procedure__[]	= "server:fnrpc_fnclientbtreepagecount_1";
#ifdef MULTITHREAD
  typedef bool_t RESULTTYPE;
#else
  typedef fnClientBtreepageCount_rets * RESULTTYPE;
#endif
#ifndef MULTITHREAD
  static fnClientBtreepageCount_rets	Result;
  RESULTTYPE			pResult = &Result;
#endif
  LPCSTR	pszErrorMsg;

  __pRequest__	= pRequest;

  RPC_SERVER_ENTRY();

#ifndef MULTITHREAD
  if ( pResult->pszErrorMsg == szEmpty ) {
    pResult->pszErrorMsg	= NULL;
  }
  xdr_free ( (xdrproc_t) xdr_fnClientBtreepageCount_rets, (char *) pResult );
#endif
  pResult->nErrorLvl		= 0;

  Reply.bAnswered		= FALSE;
  Reply.pfnCalled		= (void(*)()) fnClientBtreepageCount;
  Reply.pfnXdrResult		= (bool_t(*)()) xdr_fnClientBtreepageCount_rets;
  Reply.pnErrorLvl		= &pResult->nErrorLvl;
  Reply.ppszErrorMsg		= (LPCSTR *) &pResult->pszErrorMsg;
  Reply.pResult		= pResult;
  Reply.pReturnValue		= &pResult->ReturnValue;
  Reply.nReturnValueSize	= sizeof ( pResult->ReturnValue );

  pResult->ReturnValue		=
  fnClientBtreepageCount (
	pArguments->oShortObjIdHeap,
	pArguments->oShortObjIdBTreePage );

  if ( Reply.bAnswered ) {
    __pRequest__	= NULL;
    return (RESULTTYPE) NULL;
  }

  pResult->nErrorLvl	= RPC_SERVER_ERRLVL();
  if ( pResult->nErrorLvl > 0 ) {
    pszErrorMsg		= RPC_SERVER_ERRMSG();
    if ( pszErrorMsg && *pszErrorMsg ) {
      pResult->pszErrorMsg	= strdup ( pszErrorMsg );
    }
  }
  if ( pResult->pszErrorMsg == NULL ) {
#ifdef MULTITHREAD
    pResult->pszErrorMsg	= strdup ( szEmpty );
#else
    pResult->pszErrorMsg	= (LPSTR) szEmpty;
#endif
  }
  __pRequest__	= NULL;
  return (RESULTTYPE) pResult;
} /* fnrpc_fnclientbtreepagecount_1 */




extern int fnClientBtreepageGetSize
	(SHORTOBJID oShortObjIdHeap ,
	  SHORTOBJID oShortObjIdBTreePage);

#ifdef MULTITHREAD
bool_t
#else
fnClientBtreepageGetSize_rets *
#endif
	PASTE2(fnrpc_fnclientbtreepagegetsize_1,_SVCSUFFIX)
		( fnClientBtreepageGetSize_args * pArguments,
#ifdef MULTITHREAD
		  fnClientBtreepageGetSize_rets * pResult,
#endif
		  struct svc_req * pRequest )
{
  static const char	__procedure__[]	= "server:fnrpc_fnclientbtreepagegetsize_1";
#ifdef MULTITHREAD
  typedef bool_t RESULTTYPE;
#else
  typedef fnClientBtreepageGetSize_rets * RESULTTYPE;
#endif
#ifndef MULTITHREAD
  static fnClientBtreepageGetSize_rets	Result;
  RESULTTYPE			pResult = &Result;
#endif
  LPCSTR	pszErrorMsg;

  __pRequest__	= pRequest;

  RPC_SERVER_ENTRY();

#ifndef MULTITHREAD
  if ( pResult->pszErrorMsg == szEmpty ) {
    pResult->pszErrorMsg	= NULL;
  }
  xdr_free ( (xdrproc_t) xdr_fnClientBtreepageGetSize_rets, (char *) pResult );
#endif
  pResult->nErrorLvl		= 0;

  Reply.bAnswered		= FALSE;
  Reply.pfnCalled		= (void(*)()) fnClientBtreepageGetSize;
  Reply.pfnXdrResult		= (bool_t(*)()) xdr_fnClientBtreepageGetSize_rets;
  Reply.pnErrorLvl		= &pResult->nErrorLvl;
  Reply.ppszErrorMsg		= (LPCSTR *) &pResult->pszErrorMsg;
  Reply.pResult		= pResult;
  Reply.pReturnValue		= &pResult->ReturnValue;
  Reply.nReturnValueSize	= sizeof ( pResult->ReturnValue );

  pResult->ReturnValue		=
  fnClientBtreepageGetSize (
	pArguments->oShortObjIdHeap,
	pArguments->oShortObjIdBTreePage );

  if ( Reply.bAnswered ) {
    __pRequest__	= NULL;
    return (RESULTTYPE) NULL;
  }

  pResult->nErrorLvl	= RPC_SERVER_ERRLVL();
  if ( pResult->nErrorLvl > 0 ) {
    pszErrorMsg		= RPC_SERVER_ERRMSG();
    if ( pszErrorMsg && *pszErrorMsg ) {
      pResult->pszErrorMsg	= strdup ( pszErrorMsg );
    }
  }
  if ( pResult->pszErrorMsg == NULL ) {
#ifdef MULTITHREAD
    pResult->pszErrorMsg	= strdup ( szEmpty );
#else
    pResult->pszErrorMsg	= (LPSTR) szEmpty;
#endif
  }
  __pRequest__	= NULL;
  return (RESULTTYPE) pResult;
} /* fnrpc_fnclientbtreepagegetsize_1 */




extern int fnClientBtreepageItem
	(SHORTOBJID oShortObjIdHeap ,
	  SHORTOBJID oShortObjIdBTreePage ,
	  int nIndex ,
	  int nItems ,
	  int * /* _vector_t<nItems> */  pnValueKey ,
	  u_int * /* _vector_t<nItems> */  pnTypeTagKey ,
	  int * /* _vector_t<nItems> */  pnValueData ,
	  u_int * /* _vector_t<nItems> */  pnTypeTagData ,
	  u_int * /* _vector_t<nItems> */  poNext);

#ifdef MULTITHREAD
bool_t
#else
fnClientBtreepageItem_rets *
#endif
	PASTE2(fnrpc_fnclientbtreepageitem_1,_SVCSUFFIX)
		( fnClientBtreepageItem_args * pArguments,
#ifdef MULTITHREAD
		  fnClientBtreepageItem_rets * pResult,
#endif
		  struct svc_req * pRequest )
{
  static const char	__procedure__[]	= "server:fnrpc_fnclientbtreepageitem_1";
#ifdef MULTITHREAD
  typedef bool_t RESULTTYPE;
#else
  typedef fnClientBtreepageItem_rets * RESULTTYPE;
#endif
#ifndef MULTITHREAD
  static fnClientBtreepageItem_rets	Result;
  RESULTTYPE			pResult = &Result;
#endif
  LPCSTR	pszErrorMsg;

  __pRequest__	= pRequest;

  RPC_SERVER_ENTRY();

#ifndef MULTITHREAD
  if ( pResult->pszErrorMsg == szEmpty ) {
    pResult->pszErrorMsg	= NULL;
  }
  xdr_free ( (xdrproc_t) xdr_fnClientBtreepageItem_rets, (char *) pResult );
#endif
  pResult->nErrorLvl		= 0;

  pResult->pnValueKey.int_vector_t_len	= pArguments->pnValueKeySize;
  if ( pArguments->pnValueKeySize == 0 ) {
    pResult->pnValueKey.int_vector_t_val	= NULL;
  } else {
    pResult->pnValueKey.int_vector_t_val	=
      (int*) malloc ( pArguments->pnValueKeySize *
               SIZEOF ( *(pResult->pnValueKey.int_vector_t_val) ) );
    if ( pResult->pnValueKey.int_vector_t_val == NULL ) {
      char	szError [ 256 ];
      sprintf ( szError, szFormatMallocFailed,
                __procedure__, pArguments->pnValueKeySize,
                "pnValueKey" );
      RPC_SERVER_ERROR ( szError );
      return (RESULTTYPE) NULL;
    }
  }
  pResult->pnTypeTagKey.u_int_vector_t_len	= pArguments->pnTypeTagKeySize;
  if ( pArguments->pnTypeTagKeySize == 0 ) {
    pResult->pnTypeTagKey.u_int_vector_t_val	= NULL;
  } else {
    pResult->pnTypeTagKey.u_int_vector_t_val	=
      (u_int*) malloc ( pArguments->pnTypeTagKeySize *
               SIZEOF ( *(pResult->pnTypeTagKey.u_int_vector_t_val) ) );
    if ( pResult->pnTypeTagKey.u_int_vector_t_val == NULL ) {
      char	szError [ 256 ];
      sprintf ( szError, szFormatMallocFailed,
                __procedure__, pArguments->pnTypeTagKeySize,
                "pnTypeTagKey" );
      RPC_SERVER_ERROR ( szError );
      return (RESULTTYPE) NULL;
    }
  }
  pResult->pnValueData.int_vector_t_len	= pArguments->pnValueDataSize;
  if ( pArguments->pnValueDataSize == 0 ) {
    pResult->pnValueData.int_vector_t_val	= NULL;
  } else {
    pResult->pnValueData.int_vector_t_val	=
      (int*) malloc ( pArguments->pnValueDataSize *
               SIZEOF ( *(pResult->pnValueData.int_vector_t_val) ) );
    if ( pResult->pnValueData.int_vector_t_val == NULL ) {
      char	szError [ 256 ];
      sprintf ( szError, szFormatMallocFailed,
                __procedure__, pArguments->pnValueDataSize,
                "pnValueData" );
      RPC_SERVER_ERROR ( szError );
      return (RESULTTYPE) NULL;
    }
  }
  pResult->pnTypeTagData.u_int_vector_t_len	= pArguments->pnTypeTagDataSize;
  if ( pArguments->pnTypeTagDataSize == 0 ) {
    pResult->pnTypeTagData.u_int_vector_t_val	= NULL;
  } else {
    pResult->pnTypeTagData.u_int_vector_t_val	=
      (u_int*) malloc ( pArguments->pnTypeTagDataSize *
               SIZEOF ( *(pResult->pnTypeTagData.u_int_vector_t_val) ) );
    if ( pResult->pnTypeTagData.u_int_vector_t_val == NULL ) {
      char	szError [ 256 ];
      sprintf ( szError, szFormatMallocFailed,
                __procedure__, pArguments->pnTypeTagDataSize,
                "pnTypeTagData" );
      RPC_SERVER_ERROR ( szError );
      return (RESULTTYPE) NULL;
    }
  }
  pResult->poNext.u_int_vector_t_len	= pArguments->poNextSize;
  if ( pArguments->poNextSize == 0 ) {
    pResult->poNext.u_int_vector_t_val	= NULL;
  } else {
    pResult->poNext.u_int_vector_t_val	=
      (u_int*) malloc ( pArguments->poNextSize *
               SIZEOF ( *(pResult->poNext.u_int_vector_t_val) ) );
    if ( pResult->poNext.u_int_vector_t_val == NULL ) {
      char	szError [ 256 ];
      sprintf ( szError, szFormatMallocFailed,
                __procedure__, pArguments->poNextSize,
                "poNext" );
      RPC_SERVER_ERROR ( szError );
      return (RESULTTYPE) NULL;
    }
  }
  Reply.bAnswered		= FALSE;
  Reply.pfnCalled		= (void(*)()) fnClientBtreepageItem;
  Reply.pfnXdrResult		= (bool_t(*)()) xdr_fnClientBtreepageItem_rets;
  Reply.pnErrorLvl		= &pResult->nErrorLvl;
  Reply.ppszErrorMsg		= (LPCSTR *) &pResult->pszErrorMsg;
  Reply.pResult		= pResult;
  Reply.pReturnValue		= &pResult->ReturnValue;
  Reply.nReturnValueSize	= sizeof ( pResult->ReturnValue );

  pResult->ReturnValue		=
  fnClientBtreepageItem (
	pArguments->oShortObjIdHeap,
	pArguments->oShortObjIdBTreePage,
	pArguments->nIndex,
	pArguments->nItems,
	pResult->pnValueKey.int_vector_t_val,
	pResult->pnTypeTagKey.u_int_vector_t_val,
	pResult->pnValueData.int_vector_t_val,
	pResult->pnTypeTagData.u_int_vector_t_val,
	pResult->poNext.u_int_vector_t_val );

  if ( Reply.bAnswered ) {
    __pRequest__	= NULL;
    return (RESULTTYPE) NULL;
  }

  pResult->nErrorLvl	= RPC_SERVER_ERRLVL();
  if ( pResult->nErrorLvl > 0 ) {
    pszErrorMsg		= RPC_SERVER_ERRMSG();
    if ( pszErrorMsg && *pszErrorMsg ) {
      pResult->pszErrorMsg	= strdup ( pszErrorMsg );
    }
  }
  if ( pResult->pszErrorMsg == NULL ) {
#ifdef MULTITHREAD
    pResult->pszErrorMsg	= strdup ( szEmpty );
#else
    pResult->pszErrorMsg	= (LPSTR) szEmpty;
#endif
  }
  __pRequest__	= NULL;
  return (RESULTTYPE) pResult;
} /* fnrpc_fnclientbtreepageitem_1 */


int fnMain ();
int main (int argc, char * argv [] )
{
  static const char	__procedure__[]	 = "main";

  RPC_SERVER_INITIALIZE ( argc, argv );

  fnMain ();

  return 0;
} /* main */
#define main fnMain

/* ------------------------------------------------------------------------
| End of plobd.x
 ----------------------------------------------------------------------- */

static void plobd_1();

main()
{
	SVCXPRT *transp;

#ifdef WIN32
	rpc_nt_init();
#endif

	(void)pmap_unset(PLOBD, PLOBDVERS);

	transp = svcudp_create(RPC_ANYSOCK);
	if (transp == NULL) {
		(void)fprintf(stderr, "cannot create udp service.\n");
#ifdef WIN32
		rpc_nt_exit();
#endif
		exit(1);
	}
	if (!svc_register(transp, PLOBD, PLOBDVERS, plobd_1, IPPROTO_UDP)) {
		(void)fprintf(stderr, "unable to register (PLOBD, PLOBDVERS, udp).\n");
#ifdef WIN32
		rpc_nt_exit();
#endif
		exit(1);
	}

	transp = svctcp_create(RPC_ANYSOCK, 0, 0);
	if (transp == NULL) {
		(void)fprintf(stderr, "cannot create tcp service.\n");
#ifdef WIN32
		rpc_nt_exit();
#endif
		exit(1);
	}
	if (!svc_register(transp, PLOBD, PLOBDVERS, plobd_1, IPPROTO_TCP)) {
		(void)fprintf(stderr, "unable to register (PLOBD, PLOBDVERS, tcp).\n");
#ifdef WIN32
		rpc_nt_exit();
#endif
		exit(1);
	}
	svc_run();
	(void)fprintf(stderr, "svc_run returned\n");
#ifdef WIN32
	rpc_nt_exit();
#endif
	exit(1);
}

#ifdef MULTITHREAD
struct call_params {
	struct svc_req *rqstp;
	SVCXPRT *transp;
	void *arg;
	char *(*local)();
	bool_t (*xdr_argument)(), (*xdr_result)();
};
static void plobd_1_a ();
#endif

static void
plobd_1(rqstp, transp)
	struct svc_req *rqstp;
	SVCXPRT *transp;
{
	union {
		SHORTOBJID fnrpc_fnclientdbreadroot_1_arg;
		fnServerDbWriteRoot_args fnrpc_fnserverdbwriteroot_1_arg;
		SHORTOBJID fnrpc_fnclientdbsessions_1_arg;
		fnServerGetVersion_args fnrpc_fnservergetversion_1_arg;
		fnClientDbCreateMachine_args fnrpc_fnclientdbcreatemachine_1_arg;
		fnClientMachineLoginP_args fnrpc_fnclientmachineloginp_1_arg;
		fnClientMachineAddr_args fnrpc_fnclientmachineaddr_1_arg;
		fnClientDbMachineSearch_args fnrpc_fnclientdbmachinesearch_1_arg;
		fnClientDbMachineDelete_args fnrpc_fnclientdbmachinedelete_1_arg;
		fnClientDbMachineInsert_args fnrpc_fnclientdbmachineinsert_1_arg;
		SHORTOBJID fnrpc_fnclientdbmachines_1_arg;
		fnServerGetPortByDirectory_args fnrpc_fnservergetportbydirectory_1_arg;
		fnServerGetDirectory_args fnrpc_fnservergetdirectory_1_arg;
		fnServerExit_args fnrpc_fnserverexit_1_arg;
		fnServerDbReset_args fnrpc_fnserverdbreset_1_arg;
		fnServerRestart_args fnrpc_fnserverrestart_1_arg;
		fnClientObjectCanModify_args fnrpc_fnclientobjectcanmodify_1_arg;
		fnServerDbClose_args fnrpc_fnserverdbclose_batch_1_arg;
		SHORTOBJID fnrpc_fnclientdbconfiguration_1_arg;
		fnServerDbCreateObject_args fnrpc_fnserverdbcreateobject_1_arg;
		fnServerDbCreateObjects_args fnrpc_fnserverdbcreateobjects_1_arg;
		fnServerObjectDestroy_args fnrpc_fnserverobjectdestroy_batch_1_arg;
		fnServerObjectObjIdSize_args fnrpc_fnserverobjectobjidsize_1_arg;
		fnServerDbOpen_args fnrpc_fnserverdbopen_1_arg;
		fnServerObjectFlush_args fnrpc_fnserverobjectflush_1_arg;
		fnServerObjectReadAtIndex_args fnrpc_fnserverobjectreadatindex_1_arg;
		fnServerObjectReadAtIndices_args fnrpc_fnserverobjectreadatindices_1_arg;
		fnServerObjectReadObjId_args fnrpc_fnserverobjectreadobjid_1_arg;
		fnServerObjectReadValues_args fnrpc_fnserverobjectreadvalues_1_arg;
		SHORTOBJID fnrpc_fnclientdbstatistics_1_arg;
		SHORTOBJID fnrpc_fnserverdbstabilise_batch_1_arg;
		fnServerObjectTypeTag_args fnrpc_fnserverobjecttypetag_1_arg;
		fnServerObjectValueSize_args fnrpc_fnserverobjectvaluesize_1_arg;
		fnServerObjectWriteAtIndex_args fnrpc_fnserverobjectwriteatindex_1_arg;
		fnServerObjectWriteAtIndices_args fnrpc_fnserverobjectwriteatindices_1_arg;
		fnServerObjectWriteObjId_args fnrpc_fnserverobjectwriteobjid_1_arg;
		fnServerObjectWriteValues_args fnrpc_fnserverobjectwritevalues_1_arg;
		fnShortMakeDependent_args fnrpc_fnshortmakedependent_1_arg;
		fnServerObjectPeekSlots_args fnrpc_fnserverobjectpeekslots_1_arg;
		fnServerObjectPeekValues_args fnrpc_fnserverobjectpeekvalues_1_arg;
		fnServerObjectPoke_args fnrpc_fnserverobjectpoke_batch_1_arg;
		fnFlushMode_args fnrpc_fnflushmode_1_arg;
		fnFlagWord_args fnrpc_fnflagword_1_arg;
		fnShortMakeIVector_args fnrpc_fnshortmakeivector_1_arg;
		fnShortMakeString_args fnrpc_fnshortmakestring_1_arg;
		fnServerDbCreateStructures_args fnrpc_fnserverdbcreatestructures_1_arg;
		fnServerDbCreateInstances_args fnrpc_fnserverdbcreateinstances_1_arg;
		fnServerInstanceWriteWrapper_args fnrpc_fnserverinstancewritewrapper_1_arg;
		fnServerInstanceWriteData_args fnrpc_fnserverinstancewritedata_1_arg;
		SHTYPETAG fnrpc_fnserverdbtypetagname_1_arg;
		fnServerObjectPrettyPrint_args fnrpc_fnserverobjectprettyprint_1_arg;
		fnShortPrintSymbol_args fnrpc_fnshortprintsymbol_1_arg;
		fnShortMakeSingleFloat_args fnrpc_fnshortmakesinglefloat_1_arg;
		fnShortMakeDoubleFloat_args fnrpc_fnshortmakedoublefloat_1_arg;
		fnServerDbMakeBignum_args fnrpc_fnserverdbmakebignum_1_arg;
		fnServerObjectReadBignum_args fnrpc_fnserverobjectreadbignum_1_arg;
		fnServerObjectReadDoubleFloat_args fnrpc_fnserverobjectreaddoublefloat_1_arg;
		fnServerObjectReadFixnum_args fnrpc_fnserverobjectreadfixnum_1_arg;
		fnServerObjectReadSingleFloat_args fnrpc_fnserverobjectreadsinglefloat_1_arg;
		fnServerObjectWriteBignum_args fnrpc_fnserverobjectwritebignum_1_arg;
		fnServerObjectWriteDoubleFloat_args fnrpc_fnserverobjectwritedoublefloat_1_arg;
		fnServerObjectWriteFixnum_args fnrpc_fnserverobjectwritefixnum_1_arg;
		fnServerObjectWriteSingleFloat_args fnrpc_fnserverobjectwritesinglefloat_1_arg;
		fnClientLockPrint_args fnrpc_fnclientlockprint_1_arg;
		fnClientTransactionLockGet_args fnrpc_fnclienttransactionlockget_1_arg;
		fnServerTransactionLockInsert_args fnrpc_fnservertransactionlockinsert_1_arg;
		fnServerTransactionLockSet_args fnrpc_fnservertransactionlockset_1_arg;
		fnServerTransactionUnlock_args fnrpc_fnservertransactionunlock_1_arg;
		fnServerTransactionUnlockAll_args fnrpc_fnservertransactionunlockall_1_arg;
		fnServerTransactionUnlockAllAll_args fnrpc_fnservertransactionunlockallall_1_arg;
		fnShortMakeReadOnly_args fnrpc_fnshortmakereadonly_1_arg;
		fnServerTransactionBegin_args fnrpc_fnservertransactionbegin_1_arg;
		fnServerTransactionCancel_args fnrpc_fnservertransactioncancel_1_arg;
		fnServerTransactionEnd_args fnrpc_fnservertransactionend_1_arg;
		SHORTOBJID fnrpc_fnservertransactionflush_batch_1_arg;
		fnServerDbTransactionP_args fnrpc_fnserverdbtransactionp_1_arg;
		fnClientBtreeClear_args fnrpc_fnclientbtreeclear_1_arg;
		fnClientBtreeCount_args fnrpc_fnclientbtreecount_1_arg;
		fnServerBtreeDelete_args fnrpc_fnserverbtreedelete_1_arg;
		fnServerBtreeDeleteByFloat_args fnrpc_fnserverbtreedeletebyfloat_1_arg;
		fnServerBtreeDeleteByDouble_args fnrpc_fnserverbtreedeletebydouble_1_arg;
		fnServerBtreeDeleteByString_args fnrpc_fnserverbtreedeletebystring_1_arg;
		fnServerBtreeInsert_args fnrpc_fnserverbtreeinsert_1_arg;
		fnServerBtreeInsertByFloat_args fnrpc_fnserverbtreeinsertbyfloat_1_arg;
		fnServerBtreeInsertByDouble_args fnrpc_fnserverbtreeinsertbydouble_1_arg;
		fnServerBtreeInsertByString_args fnrpc_fnserverbtreeinsertbystring_1_arg;
		fnServerBtreemapSearch_args fnrpc_fnserverbtreemapsearch_1_arg;
		fnServerBtreemapSearchByFloat_args fnrpc_fnserverbtreemapsearchbyfloat_1_arg;
		fnServerBtreemapSearchByDouble_args fnrpc_fnserverbtreemapsearchbydouble_1_arg;
		fnServerBtreemapSearchByString_args fnrpc_fnserverbtreemapsearchbystring_1_arg;
		fnServerBtreemapSeek_args fnrpc_fnserverbtreemapseek_1_arg;
		fnServerBtreemapSeekSet_args fnrpc_fnserverbtreemapseekset_1_arg;
		fnServerBtreemapFirst_args fnrpc_fnserverbtreemapfirst_1_arg;
		fnServerBtreemapFirstByFloat_args fnrpc_fnserverbtreemapfirstbyfloat_1_arg;
		fnServerBtreemapFirstByDouble_args fnrpc_fnserverbtreemapfirstbydouble_1_arg;
		fnServerBtreemapFirstByString_args fnrpc_fnserverbtreemapfirstbystring_1_arg;
		fnClientBtreemapNext_args fnrpc_fnclientbtreemapnext_1_arg;
		fnClientBtreemapLast_args fnrpc_fnclientbtreemaplast_1_arg;
		fnClientBtreePrint_args fnrpc_fnclientbtreeprint_1_arg;
		fnServerBtreeSearch_args fnrpc_fnserverbtreesearch_1_arg;
		fnServerBtreeSearchByFloat_args fnrpc_fnserverbtreesearchbyfloat_1_arg;
		fnServerBtreeSearchByDouble_args fnrpc_fnserverbtreesearchbydouble_1_arg;
		fnServerBtreeSearchByString_args fnrpc_fnserverbtreesearchbystring_1_arg;
		fnClientBtreeRoot_args fnrpc_fnclientbtreeroot_1_arg;
		fnClientBtreeSize_args fnrpc_fnclientbtreesize_1_arg;
		fnClientBtreeTestMode_args fnrpc_fnclientbtreetestmode_1_arg;
		fnClientBtreePageSize_args fnrpc_fnclientbtreepagesize_1_arg;
		fnClientBtreepageParent_args fnrpc_fnclientbtreepageparent_1_arg;
		fnClientBtreepageCount_args fnrpc_fnclientbtreepagecount_1_arg;
		fnClientBtreepageGetSize_args fnrpc_fnclientbtreepagegetsize_1_arg;
		fnClientBtreepageItem_args fnrpc_fnclientbtreepageitem_1_arg;
	} argument;
	char *result;
	bool_t (*xdr_argument)(), (*xdr_result)();
	char *(*local)();


#ifdef MULTITHREAD
	DWORD TID = 0;
	HANDLE threadHandle = NULL;
	struct call_params	*params;
#endif
	switch (rqstp->rq_proc) {
	case NULLPROC:
		(void)svc_sendreply(transp, xdr_void, (char *)NULL);
		return;

	case fnRpc_fnClientDbReadRoot:
		xdr_argument = xdr_SHORTOBJID;
		xdr_result = xdr_fnClientDbReadRoot_rets;
		local = (char *(*)()) fnrpc_fnclientdbreadroot_1;
		break;

	case fnRpc_fnServerDbWriteRoot:
		xdr_argument = xdr_fnServerDbWriteRoot_args;
		xdr_result = xdr_fnServerDbWriteRoot_rets;
		local = (char *(*)()) fnrpc_fnserverdbwriteroot_1;
		break;

	case fnRpc_fnClientDbSessions:
		xdr_argument = xdr_SHORTOBJID;
		xdr_result = xdr_fnClientDbSessions_rets;
		local = (char *(*)()) fnrpc_fnclientdbsessions_1;
		break;

	case fnRpc_fnServerGetVersion:
		xdr_argument = xdr_fnServerGetVersion_args;
		xdr_result = xdr_fnServerGetVersion_rets;
		local = (char *(*)()) fnrpc_fnservergetversion_1;
		break;

	case fnRpc_fnClientDbCreateMachine:
		xdr_argument = xdr_fnClientDbCreateMachine_args;
		xdr_result = xdr_fnClientDbCreateMachine_rets;
		local = (char *(*)()) fnrpc_fnclientdbcreatemachine_1;
		break;

	case fnRpc_fnClientMachineLoginP:
		xdr_argument = xdr_fnClientMachineLoginP_args;
		xdr_result = xdr_fnClientMachineLoginP_rets;
		local = (char *(*)()) fnrpc_fnclientmachineloginp_1;
		break;

	case fnRpc_fnClientMachineAddr:
		xdr_argument = xdr_fnClientMachineAddr_args;
		xdr_result = xdr_fnClientMachineAddr_rets;
		local = (char *(*)()) fnrpc_fnclientmachineaddr_1;
		break;

	case fnRpc_fnClientDbMachineSearch:
		xdr_argument = xdr_fnClientDbMachineSearch_args;
		xdr_result = xdr_fnClientDbMachineSearch_rets;
		local = (char *(*)()) fnrpc_fnclientdbmachinesearch_1;
		break;

	case fnRpc_fnClientDbMachineDelete:
		xdr_argument = xdr_fnClientDbMachineDelete_args;
		xdr_result = xdr_fnClientDbMachineDelete_rets;
		local = (char *(*)()) fnrpc_fnclientdbmachinedelete_1;
		break;

	case fnRpc_fnClientDbMachineInsert:
		xdr_argument = xdr_fnClientDbMachineInsert_args;
		xdr_result = xdr_fnClientDbMachineInsert_rets;
		local = (char *(*)()) fnrpc_fnclientdbmachineinsert_1;
		break;

	case fnRpc_fnClientDbMachines:
		xdr_argument = xdr_SHORTOBJID;
		xdr_result = xdr_fnClientDbMachines_rets;
		local = (char *(*)()) fnrpc_fnclientdbmachines_1;
		break;

	case fnRpc_fnServerGetPortByDirectory:
		xdr_argument = xdr_fnServerGetPortByDirectory_args;
		xdr_result = xdr_fnServerGetPortByDirectory_rets;
		local = (char *(*)()) fnrpc_fnservergetportbydirectory_1;
		break;

	case fnRpc_fnServerGetPID:
		xdr_argument = xdr_void;
		xdr_result = xdr_fnServerGetPID_rets;
		local = (char *(*)()) fnrpc_fnservergetpid_1;
		break;

	case fnRpc_fnServerGetDirectory:
		xdr_argument = xdr_fnServerGetDirectory_args;
		xdr_result = xdr_fnServerGetDirectory_rets;
		local = (char *(*)()) fnrpc_fnservergetdirectory_1;
		break;

	case fnRpc_fnServerExit:
		xdr_argument = xdr_fnServerExit_args;
		xdr_result = xdr_fnServerExit_rets;
		local = (char *(*)()) fnrpc_fnserverexit_1;
		break;

	case fnRpc_fnServerDbReset:
		xdr_argument = xdr_fnServerDbReset_args;
		xdr_result = xdr_fnServerDbReset_rets;
		local = (char *(*)()) fnrpc_fnserverdbreset_1;
		break;

	case fnRpc_fnServerRestart:
		xdr_argument = xdr_fnServerRestart_args;
		xdr_result = xdr_fnServerRestart_rets;
		local = (char *(*)()) fnrpc_fnserverrestart_1;
		break;

	case fnRpc_fnClientObjectCanModify:
		xdr_argument = xdr_fnClientObjectCanModify_args;
		xdr_result = xdr_fnClientObjectCanModify_rets;
		local = (char *(*)()) fnrpc_fnclientobjectcanmodify_1;
		break;

	case fnRpc_fnServerDbClose_batch:
		xdr_argument = xdr_fnServerDbClose_args;
		xdr_result = xdr_void;
		local = (char *(*)()) fnrpc_fnserverdbclose_batch_1;
		break;

	case fnRpc_fnClientDbConfiguration:
		xdr_argument = xdr_SHORTOBJID;
		xdr_result = xdr_fnClientDbConfiguration_rets;
		local = (char *(*)()) fnrpc_fnclientdbconfiguration_1;
		break;

	case fnRpc_fnServerDbCreateObject:
		xdr_argument = xdr_fnServerDbCreateObject_args;
		xdr_result = xdr_fnServerDbCreateObject_rets;
		local = (char *(*)()) fnrpc_fnserverdbcreateobject_1;
		break;

	case fnRpc_fnServerDbCreateObjects:
		xdr_argument = xdr_fnServerDbCreateObjects_args;
		xdr_result = xdr_fnServerDbCreateObjects_rets;
		local = (char *(*)()) fnrpc_fnserverdbcreateobjects_1;
		break;

	case fnRpc_fnServerObjectDestroy_batch:
		xdr_argument = xdr_fnServerObjectDestroy_args;
		xdr_result = xdr_void;
		local = (char *(*)()) fnrpc_fnserverobjectdestroy_batch_1;
		break;

	case fnRpc_fnServerObjectObjIdSize:
		xdr_argument = xdr_fnServerObjectObjIdSize_args;
		xdr_result = xdr_fnServerObjectObjIdSize_rets;
		local = (char *(*)()) fnrpc_fnserverobjectobjidsize_1;
		break;

	case fnRpc_fnServerDbOpen:
		xdr_argument = xdr_fnServerDbOpen_args;
		xdr_result = xdr_fnServerDbOpen_rets;
		local = (char *(*)()) fnrpc_fnserverdbopen_1;
		break;

	case fnRpc_fnServerObjectFlush:
		xdr_argument = xdr_fnServerObjectFlush_args;
		xdr_result = xdr_fnServerObjectFlush_rets;
		local = (char *(*)()) fnrpc_fnserverobjectflush_1;
		break;

	case fnRpc_fnServerObjectReadAtIndex:
		xdr_argument = xdr_fnServerObjectReadAtIndex_args;
		xdr_result = xdr_fnServerObjectReadAtIndex_rets;
		local = (char *(*)()) fnrpc_fnserverobjectreadatindex_1;
		break;

	case fnRpc_fnServerObjectReadAtIndices:
		xdr_argument = xdr_fnServerObjectReadAtIndices_args;
		xdr_result = xdr_fnServerObjectReadAtIndices_rets;
		local = (char *(*)()) fnrpc_fnserverobjectreadatindices_1;
		break;

	case fnRpc_fnServerObjectReadObjId:
		xdr_argument = xdr_fnServerObjectReadObjId_args;
		xdr_result = xdr_fnServerObjectReadObjId_rets;
		local = (char *(*)()) fnrpc_fnserverobjectreadobjid_1;
		break;

	case fnRpc_fnServerObjectReadValues:
		xdr_argument = xdr_fnServerObjectReadValues_args;
		xdr_result = xdr_fnServerObjectReadValues_rets;
		local = (char *(*)()) fnrpc_fnserverobjectreadvalues_1;
		break;

	case fnRpc_fnClientDbStatistics:
		xdr_argument = xdr_SHORTOBJID;
		xdr_result = xdr_fnClientDbStatistics_rets;
		local = (char *(*)()) fnrpc_fnclientdbstatistics_1;
		break;

	case fnRpc_fnServerDbStabilise_batch:
		xdr_argument = xdr_SHORTOBJID;
		xdr_result = xdr_void;
		local = (char *(*)()) fnrpc_fnserverdbstabilise_batch_1;
		break;

	case fnRpc_fnServerObjectTypeTag:
		xdr_argument = xdr_fnServerObjectTypeTag_args;
		xdr_result = xdr_fnServerObjectTypeTag_rets;
		local = (char *(*)()) fnrpc_fnserverobjecttypetag_1;
		break;

	case fnRpc_fnServerObjectValueSize:
		xdr_argument = xdr_fnServerObjectValueSize_args;
		xdr_result = xdr_fnServerObjectValueSize_rets;
		local = (char *(*)()) fnrpc_fnserverobjectvaluesize_1;
		break;

	case fnRpc_fnServerObjectWriteAtIndex:
		xdr_argument = xdr_fnServerObjectWriteAtIndex_args;
		xdr_result = xdr_fnServerObjectWriteAtIndex_rets;
		local = (char *(*)()) fnrpc_fnserverobjectwriteatindex_1;
		break;

	case fnRpc_fnServerObjectWriteAtIndices:
		xdr_argument = xdr_fnServerObjectWriteAtIndices_args;
		xdr_result = xdr_fnServerObjectWriteAtIndices_rets;
		local = (char *(*)()) fnrpc_fnserverobjectwriteatindices_1;
		break;

	case fnRpc_fnServerObjectWriteObjId:
		xdr_argument = xdr_fnServerObjectWriteObjId_args;
		xdr_result = xdr_fnServerObjectWriteObjId_rets;
		local = (char *(*)()) fnrpc_fnserverobjectwriteobjid_1;
		break;

	case fnRpc_fnServerObjectWriteValues:
		xdr_argument = xdr_fnServerObjectWriteValues_args;
		xdr_result = xdr_fnServerObjectWriteValues_rets;
		local = (char *(*)()) fnrpc_fnserverobjectwritevalues_1;
		break;

	case fnRpc_fnShortMakeDependent:
		xdr_argument = xdr_fnShortMakeDependent_args;
		xdr_result = xdr_fnShortMakeDependent_rets;
		local = (char *(*)()) fnrpc_fnshortmakedependent_1;
		break;

	case fnRpc_fnServerObjectPeekSlots:
		xdr_argument = xdr_fnServerObjectPeekSlots_args;
		xdr_result = xdr_fnServerObjectPeekSlots_rets;
		local = (char *(*)()) fnrpc_fnserverobjectpeekslots_1;
		break;

	case fnRpc_fnServerObjectPeekValues:
		xdr_argument = xdr_fnServerObjectPeekValues_args;
		xdr_result = xdr_fnServerObjectPeekValues_rets;
		local = (char *(*)()) fnrpc_fnserverobjectpeekvalues_1;
		break;

	case fnRpc_fnServerObjectPoke_batch:
		xdr_argument = xdr_fnServerObjectPoke_args;
		xdr_result = xdr_void;
		local = (char *(*)()) fnrpc_fnserverobjectpoke_batch_1;
		break;

	case fnRpc_fnFlushMode:
		xdr_argument = xdr_fnFlushMode_args;
		xdr_result = xdr_fnFlushMode_rets;
		local = (char *(*)()) fnrpc_fnflushmode_1;
		break;

	case fnRpc_fnFlagWord:
		xdr_argument = xdr_fnFlagWord_args;
		xdr_result = xdr_fnFlagWord_rets;
		local = (char *(*)()) fnrpc_fnflagword_1;
		break;

	case fnRpc_fnShortMakeIVector:
		xdr_argument = xdr_fnShortMakeIVector_args;
		xdr_result = xdr_fnShortMakeIVector_rets;
		local = (char *(*)()) fnrpc_fnshortmakeivector_1;
		break;

	case fnRpc_fnShortMakeString:
		xdr_argument = xdr_fnShortMakeString_args;
		xdr_result = xdr_fnShortMakeString_rets;
		local = (char *(*)()) fnrpc_fnshortmakestring_1;
		break;

	case fnRpc_fnServerDbCreateStructures:
		xdr_argument = xdr_fnServerDbCreateStructures_args;
		xdr_result = xdr_fnServerDbCreateStructures_rets;
		local = (char *(*)()) fnrpc_fnserverdbcreatestructures_1;
		break;

	case fnRpc_fnServerDbCreateInstances:
		xdr_argument = xdr_fnServerDbCreateInstances_args;
		xdr_result = xdr_fnServerDbCreateInstances_rets;
		local = (char *(*)()) fnrpc_fnserverdbcreateinstances_1;
		break;

	case fnRpc_fnServerInstanceWriteWrapper:
		xdr_argument = xdr_fnServerInstanceWriteWrapper_args;
		xdr_result = xdr_fnServerInstanceWriteWrapper_rets;
		local = (char *(*)()) fnrpc_fnserverinstancewritewrapper_1;
		break;

	case fnRpc_fnServerInstanceWriteData:
		xdr_argument = xdr_fnServerInstanceWriteData_args;
		xdr_result = xdr_fnServerInstanceWriteData_rets;
		local = (char *(*)()) fnrpc_fnserverinstancewritedata_1;
		break;

	case fnRpc_fnServerDbTypeTagName:
		xdr_argument = xdr_SHTYPETAG;
		xdr_result = xdr_fnServerDbTypeTagName_rets;
		local = (char *(*)()) fnrpc_fnserverdbtypetagname_1;
		break;

	case fnRpc_fnServerObjectPrettyPrint:
		xdr_argument = xdr_fnServerObjectPrettyPrint_args;
		xdr_result = xdr_fnServerObjectPrettyPrint_rets;
		local = (char *(*)()) fnrpc_fnserverobjectprettyprint_1;
		break;

	case fnRpc_fnShortPrintSymbol:
		xdr_argument = xdr_fnShortPrintSymbol_args;
		xdr_result = xdr_fnShortPrintSymbol_rets;
		local = (char *(*)()) fnrpc_fnshortprintsymbol_1;
		break;

	case fnRpc_fnShortMakeSingleFloat:
		xdr_argument = xdr_fnShortMakeSingleFloat_args;
		xdr_result = xdr_fnShortMakeSingleFloat_rets;
		local = (char *(*)()) fnrpc_fnshortmakesinglefloat_1;
		break;

	case fnRpc_fnShortMakeDoubleFloat:
		xdr_argument = xdr_fnShortMakeDoubleFloat_args;
		xdr_result = xdr_fnShortMakeDoubleFloat_rets;
		local = (char *(*)()) fnrpc_fnshortmakedoublefloat_1;
		break;

	case fnRpc_fnServerDbMakeBignum:
		xdr_argument = xdr_fnServerDbMakeBignum_args;
		xdr_result = xdr_fnServerDbMakeBignum_rets;
		local = (char *(*)()) fnrpc_fnserverdbmakebignum_1;
		break;

	case fnRpc_fnServerObjectReadBignum:
		xdr_argument = xdr_fnServerObjectReadBignum_args;
		xdr_result = xdr_fnServerObjectReadBignum_rets;
		local = (char *(*)()) fnrpc_fnserverobjectreadbignum_1;
		break;

	case fnRpc_fnServerObjectReadDoubleFloat:
		xdr_argument = xdr_fnServerObjectReadDoubleFloat_args;
		xdr_result = xdr_fnServerObjectReadDoubleFloat_rets;
		local = (char *(*)()) fnrpc_fnserverobjectreaddoublefloat_1;
		break;

	case fnRpc_fnServerObjectReadFixnum:
		xdr_argument = xdr_fnServerObjectReadFixnum_args;
		xdr_result = xdr_fnServerObjectReadFixnum_rets;
		local = (char *(*)()) fnrpc_fnserverobjectreadfixnum_1;
		break;

	case fnRpc_fnServerObjectReadSingleFloat:
		xdr_argument = xdr_fnServerObjectReadSingleFloat_args;
		xdr_result = xdr_fnServerObjectReadSingleFloat_rets;
		local = (char *(*)()) fnrpc_fnserverobjectreadsinglefloat_1;
		break;

	case fnRpc_fnServerObjectWriteBignum:
		xdr_argument = xdr_fnServerObjectWriteBignum_args;
		xdr_result = xdr_fnServerObjectWriteBignum_rets;
		local = (char *(*)()) fnrpc_fnserverobjectwritebignum_1;
		break;

	case fnRpc_fnServerObjectWriteDoubleFloat:
		xdr_argument = xdr_fnServerObjectWriteDoubleFloat_args;
		xdr_result = xdr_fnServerObjectWriteDoubleFloat_rets;
		local = (char *(*)()) fnrpc_fnserverobjectwritedoublefloat_1;
		break;

	case fnRpc_fnServerObjectWriteFixnum:
		xdr_argument = xdr_fnServerObjectWriteFixnum_args;
		xdr_result = xdr_fnServerObjectWriteFixnum_rets;
		local = (char *(*)()) fnrpc_fnserverobjectwritefixnum_1;
		break;

	case fnRpc_fnServerObjectWriteSingleFloat:
		xdr_argument = xdr_fnServerObjectWriteSingleFloat_args;
		xdr_result = xdr_fnServerObjectWriteSingleFloat_rets;
		local = (char *(*)()) fnrpc_fnserverobjectwritesinglefloat_1;
		break;

	case fnRpc_fnClientLockPrint:
		xdr_argument = xdr_fnClientLockPrint_args;
		xdr_result = xdr_fnClientLockPrint_rets;
		local = (char *(*)()) fnrpc_fnclientlockprint_1;
		break;

	case fnRpc_fnClientTransactionLockGet:
		xdr_argument = xdr_fnClientTransactionLockGet_args;
		xdr_result = xdr_fnClientTransactionLockGet_rets;
		local = (char *(*)()) fnrpc_fnclienttransactionlockget_1;
		break;

	case fnRpc_fnServerTransactionLockInsert:
		xdr_argument = xdr_fnServerTransactionLockInsert_args;
		xdr_result = xdr_fnServerTransactionLockInsert_rets;
		local = (char *(*)()) fnrpc_fnservertransactionlockinsert_1;
		break;

	case fnRpc_fnServerTransactionLockSet:
		xdr_argument = xdr_fnServerTransactionLockSet_args;
		xdr_result = xdr_fnServerTransactionLockSet_rets;
		local = (char *(*)()) fnrpc_fnservertransactionlockset_1;
		break;

	case fnRpc_fnServerTransactionUnlock:
		xdr_argument = xdr_fnServerTransactionUnlock_args;
		xdr_result = xdr_fnServerTransactionUnlock_rets;
		local = (char *(*)()) fnrpc_fnservertransactionunlock_1;
		break;

	case fnRpc_fnServerTransactionUnlockAll:
		xdr_argument = xdr_fnServerTransactionUnlockAll_args;
		xdr_result = xdr_fnServerTransactionUnlockAll_rets;
		local = (char *(*)()) fnrpc_fnservertransactionunlockall_1;
		break;

	case fnRpc_fnServerTransactionUnlockAllAll:
		xdr_argument = xdr_fnServerTransactionUnlockAllAll_args;
		xdr_result = xdr_fnServerTransactionUnlockAllAll_rets;
		local = (char *(*)()) fnrpc_fnservertransactionunlockallall_1;
		break;

	case fnRpc_fnShortMakeReadOnly:
		xdr_argument = xdr_fnShortMakeReadOnly_args;
		xdr_result = xdr_fnShortMakeReadOnly_rets;
		local = (char *(*)()) fnrpc_fnshortmakereadonly_1;
		break;

	case fnRpc_fnServerTransactionBegin:
		xdr_argument = xdr_fnServerTransactionBegin_args;
		xdr_result = xdr_fnServerTransactionBegin_rets;
		local = (char *(*)()) fnrpc_fnservertransactionbegin_1;
		break;

	case fnRpc_fnServerTransactionCancel:
		xdr_argument = xdr_fnServerTransactionCancel_args;
		xdr_result = xdr_fnServerTransactionCancel_rets;
		local = (char *(*)()) fnrpc_fnservertransactioncancel_1;
		break;

	case fnRpc_fnServerTransactionEnd:
		xdr_argument = xdr_fnServerTransactionEnd_args;
		xdr_result = xdr_fnServerTransactionEnd_rets;
		local = (char *(*)()) fnrpc_fnservertransactionend_1;
		break;

	case fnRpc_fnServerTransactionFlush_batch:
		xdr_argument = xdr_SHORTOBJID;
		xdr_result = xdr_void;
		local = (char *(*)()) fnrpc_fnservertransactionflush_batch_1;
		break;

	case fnRpc_fnServerDbTransactionP:
		xdr_argument = xdr_fnServerDbTransactionP_args;
		xdr_result = xdr_fnServerDbTransactionP_rets;
		local = (char *(*)()) fnrpc_fnserverdbtransactionp_1;
		break;

	case fnRpc_fnClientBtreeClear:
		xdr_argument = xdr_fnClientBtreeClear_args;
		xdr_result = xdr_fnClientBtreeClear_rets;
		local = (char *(*)()) fnrpc_fnclientbtreeclear_1;
		break;

	case fnRpc_fnClientBtreeCount:
		xdr_argument = xdr_fnClientBtreeCount_args;
		xdr_result = xdr_fnClientBtreeCount_rets;
		local = (char *(*)()) fnrpc_fnclientbtreecount_1;
		break;

	case fnRpc_fnServerBtreeDelete:
		xdr_argument = xdr_fnServerBtreeDelete_args;
		xdr_result = xdr_fnServerBtreeDelete_rets;
		local = (char *(*)()) fnrpc_fnserverbtreedelete_1;
		break;

	case fnRpc_fnServerBtreeDeleteByFloat:
		xdr_argument = xdr_fnServerBtreeDeleteByFloat_args;
		xdr_result = xdr_fnServerBtreeDeleteByFloat_rets;
		local = (char *(*)()) fnrpc_fnserverbtreedeletebyfloat_1;
		break;

	case fnRpc_fnServerBtreeDeleteByDouble:
		xdr_argument = xdr_fnServerBtreeDeleteByDouble_args;
		xdr_result = xdr_fnServerBtreeDeleteByDouble_rets;
		local = (char *(*)()) fnrpc_fnserverbtreedeletebydouble_1;
		break;

	case fnRpc_fnServerBtreeDeleteByString:
		xdr_argument = xdr_fnServerBtreeDeleteByString_args;
		xdr_result = xdr_fnServerBtreeDeleteByString_rets;
		local = (char *(*)()) fnrpc_fnserverbtreedeletebystring_1;
		break;

	case fnRpc_fnServerBtreeInsert:
		xdr_argument = xdr_fnServerBtreeInsert_args;
		xdr_result = xdr_fnServerBtreeInsert_rets;
		local = (char *(*)()) fnrpc_fnserverbtreeinsert_1;
		break;

	case fnRpc_fnServerBtreeInsertByFloat:
		xdr_argument = xdr_fnServerBtreeInsertByFloat_args;
		xdr_result = xdr_fnServerBtreeInsertByFloat_rets;
		local = (char *(*)()) fnrpc_fnserverbtreeinsertbyfloat_1;
		break;

	case fnRpc_fnServerBtreeInsertByDouble:
		xdr_argument = xdr_fnServerBtreeInsertByDouble_args;
		xdr_result = xdr_fnServerBtreeInsertByDouble_rets;
		local = (char *(*)()) fnrpc_fnserverbtreeinsertbydouble_1;
		break;

	case fnRpc_fnServerBtreeInsertByString:
		xdr_argument = xdr_fnServerBtreeInsertByString_args;
		xdr_result = xdr_fnServerBtreeInsertByString_rets;
		local = (char *(*)()) fnrpc_fnserverbtreeinsertbystring_1;
		break;

	case fnRpc_fnServerBtreemapSearch:
		xdr_argument = xdr_fnServerBtreemapSearch_args;
		xdr_result = xdr_fnServerBtreemapSearch_rets;
		local = (char *(*)()) fnrpc_fnserverbtreemapsearch_1;
		break;

	case fnRpc_fnServerBtreemapSearchByFloat:
		xdr_argument = xdr_fnServerBtreemapSearchByFloat_args;
		xdr_result = xdr_fnServerBtreemapSearchByFloat_rets;
		local = (char *(*)()) fnrpc_fnserverbtreemapsearchbyfloat_1;
		break;

	case fnRpc_fnServerBtreemapSearchByDouble:
		xdr_argument = xdr_fnServerBtreemapSearchByDouble_args;
		xdr_result = xdr_fnServerBtreemapSearchByDouble_rets;
		local = (char *(*)()) fnrpc_fnserverbtreemapsearchbydouble_1;
		break;

	case fnRpc_fnServerBtreemapSearchByString:
		xdr_argument = xdr_fnServerBtreemapSearchByString_args;
		xdr_result = xdr_fnServerBtreemapSearchByString_rets;
		local = (char *(*)()) fnrpc_fnserverbtreemapsearchbystring_1;
		break;

	case fnRpc_fnServerBtreemapSeek:
		xdr_argument = xdr_fnServerBtreemapSeek_args;
		xdr_result = xdr_fnServerBtreemapSeek_rets;
		local = (char *(*)()) fnrpc_fnserverbtreemapseek_1;
		break;

	case fnRpc_fnServerBtreemapSeekSet:
		xdr_argument = xdr_fnServerBtreemapSeekSet_args;
		xdr_result = xdr_fnServerBtreemapSeekSet_rets;
		local = (char *(*)()) fnrpc_fnserverbtreemapseekset_1;
		break;

	case fnRpc_fnServerBtreemapFirst:
		xdr_argument = xdr_fnServerBtreemapFirst_args;
		xdr_result = xdr_fnServerBtreemapFirst_rets;
		local = (char *(*)()) fnrpc_fnserverbtreemapfirst_1;
		break;

	case fnRpc_fnServerBtreemapFirstByFloat:
		xdr_argument = xdr_fnServerBtreemapFirstByFloat_args;
		xdr_result = xdr_fnServerBtreemapFirstByFloat_rets;
		local = (char *(*)()) fnrpc_fnserverbtreemapfirstbyfloat_1;
		break;

	case fnRpc_fnServerBtreemapFirstByDouble:
		xdr_argument = xdr_fnServerBtreemapFirstByDouble_args;
		xdr_result = xdr_fnServerBtreemapFirstByDouble_rets;
		local = (char *(*)()) fnrpc_fnserverbtreemapfirstbydouble_1;
		break;

	case fnRpc_fnServerBtreemapFirstByString:
		xdr_argument = xdr_fnServerBtreemapFirstByString_args;
		xdr_result = xdr_fnServerBtreemapFirstByString_rets;
		local = (char *(*)()) fnrpc_fnserverbtreemapfirstbystring_1;
		break;

	case fnRpc_fnClientBtreemapNext:
		xdr_argument = xdr_fnClientBtreemapNext_args;
		xdr_result = xdr_fnClientBtreemapNext_rets;
		local = (char *(*)()) fnrpc_fnclientbtreemapnext_1;
		break;

	case fnRpc_fnClientBtreemapLast:
		xdr_argument = xdr_fnClientBtreemapLast_args;
		xdr_result = xdr_fnClientBtreemapLast_rets;
		local = (char *(*)()) fnrpc_fnclientbtreemaplast_1;
		break;

	case fnRpc_fnClientBtreePrint:
		xdr_argument = xdr_fnClientBtreePrint_args;
		xdr_result = xdr_fnClientBtreePrint_rets;
		local = (char *(*)()) fnrpc_fnclientbtreeprint_1;
		break;

	case fnRpc_fnServerBtreeSearch:
		xdr_argument = xdr_fnServerBtreeSearch_args;
		xdr_result = xdr_fnServerBtreeSearch_rets;
		local = (char *(*)()) fnrpc_fnserverbtreesearch_1;
		break;

	case fnRpc_fnServerBtreeSearchByFloat:
		xdr_argument = xdr_fnServerBtreeSearchByFloat_args;
		xdr_result = xdr_fnServerBtreeSearchByFloat_rets;
		local = (char *(*)()) fnrpc_fnserverbtreesearchbyfloat_1;
		break;

	case fnRpc_fnServerBtreeSearchByDouble:
		xdr_argument = xdr_fnServerBtreeSearchByDouble_args;
		xdr_result = xdr_fnServerBtreeSearchByDouble_rets;
		local = (char *(*)()) fnrpc_fnserverbtreesearchbydouble_1;
		break;

	case fnRpc_fnServerBtreeSearchByString:
		xdr_argument = xdr_fnServerBtreeSearchByString_args;
		xdr_result = xdr_fnServerBtreeSearchByString_rets;
		local = (char *(*)()) fnrpc_fnserverbtreesearchbystring_1;
		break;

	case fnRpc_fnClientBtreeRoot:
		xdr_argument = xdr_fnClientBtreeRoot_args;
		xdr_result = xdr_fnClientBtreeRoot_rets;
		local = (char *(*)()) fnrpc_fnclientbtreeroot_1;
		break;

	case fnRpc_fnClientBtreeSize:
		xdr_argument = xdr_fnClientBtreeSize_args;
		xdr_result = xdr_fnClientBtreeSize_rets;
		local = (char *(*)()) fnrpc_fnclientbtreesize_1;
		break;

	case fnRpc_fnClientBtreeTestMode:
		xdr_argument = xdr_fnClientBtreeTestMode_args;
		xdr_result = xdr_fnClientBtreeTestMode_rets;
		local = (char *(*)()) fnrpc_fnclientbtreetestmode_1;
		break;

	case fnRpc_fnClientBtreePageSize:
		xdr_argument = xdr_fnClientBtreePageSize_args;
		xdr_result = xdr_fnClientBtreePageSize_rets;
		local = (char *(*)()) fnrpc_fnclientbtreepagesize_1;
		break;

	case fnRpc_fnClientBtreepageParent:
		xdr_argument = xdr_fnClientBtreepageParent_args;
		xdr_result = xdr_fnClientBtreepageParent_rets;
		local = (char *(*)()) fnrpc_fnclientbtreepageparent_1;
		break;

	case fnRpc_fnClientBtreepageCount:
		xdr_argument = xdr_fnClientBtreepageCount_args;
		xdr_result = xdr_fnClientBtreepageCount_rets;
		local = (char *(*)()) fnrpc_fnclientbtreepagecount_1;
		break;

	case fnRpc_fnClientBtreepageGetSize:
		xdr_argument = xdr_fnClientBtreepageGetSize_args;
		xdr_result = xdr_fnClientBtreepageGetSize_rets;
		local = (char *(*)()) fnrpc_fnclientbtreepagegetsize_1;
		break;

	case fnRpc_fnClientBtreepageItem:
		xdr_argument = xdr_fnClientBtreepageItem_args;
		xdr_result = xdr_fnClientBtreepageItem_rets;
		local = (char *(*)()) fnrpc_fnclientbtreepageitem_1;
		break;

	default:
		svcerr_noproc(transp);
		return;
	}
	bzero((char *)&argument, sizeof(argument));
	if (!svc_getargs(transp, xdr_argument, &argument)) {
		svcerr_decode(transp);
		return;
	}

#ifdef MULTITHREAD
	params = (struct call_params*) malloc (sizeof(struct call_params));

	params->rqstp = (struct svc_req*) malloc (sizeof(struct svc_req));
	bcopy(rqstp, params->rqstp, sizeof(struct svc_req));

	params->transp = transp;

	params->arg = malloc (sizeof(argument));
	bcopy(&argument, params->arg, sizeof(argument));

	params->local = local;

	params->xdr_argument = xdr_argument;
	params->xdr_result = xdr_result;

	threadHandle = CreateThread(NULL, 0, (LPTHREAD_START_ROUTINE)plobd_1_a, params, 0, &TID);
	if (!threadHandle)
		plobd_1_a(&params);
}

static void
plobd_1_a(params)
struct call_params *params;
{
	struct svc_req *rqstp;
	SVCXPRT *transp;
	void *argument;
	void (*destroy_proc)();

	char *result;
	bool_t (*xdr_argument)(), (*xdr_result)();
	char *(*local)();


	argument = params->arg;
	rqstp = params->rqstp;
	transp = params->transp;
	xdr_argument = params->xdr_argument;
	xdr_result = params->xdr_result;
	local = params->local;
	destroy_proc = transp->xp_ops->xp_destroy;
	transp->xp_ops->xp_destroy = xprt_unregister;
#endif

	result = (*local)(&argument, rqstp);
	if (result != NULL && !svc_sendreply(transp, xdr_result, result)) {
		svcerr_systemerr(transp);
	}
#ifdef MULTITHREAD
	free(params->rqstp);
	free(params);
#endif
	if (!svc_freeargs(transp, xdr_argument, &argument)) {
		(void)fprintf(stderr, "unable to free arguments\n");
#ifdef WIN32
		rpc_nt_exit();
#endif
		exit(1);
	}
#ifdef MULTITHREAD
	free(argument);
	transp->xp_ops->xp_destroy = destroy_proc;
#endif
}

