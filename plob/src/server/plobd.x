%
%/* ------------------------------------------------------------------------
%| plobd.x generated by c2rpc on Tue Feb 13 10:40:22  2001
%| c2rpc (C) 1996/09/19 Heiko Kirschke kirschke@informatik.uni-hamburg.de
% ----------------------------------------------------------------------- */
%
%#if RPC_HDR
%#include <rpc/rpc.h>
%typedef CLIENT * PCLIENT;
%#include <global.h>
%#endif
%#if RPC_CLNT || RPC_SVC
%#include <string.h>
%#endif
%#ifndef as_is
%#define as_is void
%#endif
%#ifndef ABS
%#define ABS(x) (((x)<0)?-(x):(x))
%#endif
%#ifndef MIN
%#define MIN(x,y) (((x)<(y))?(x):(y))
%#endif
%#ifndef MAX
%#define MAX(x,y) (((x)>(y))?(x):(y))
%#endif
%#ifndef PASTE
%#define PASTE(token1,token2) token1##token2
%#endif
%#ifndef PASTE2
%#define PASTE2(token1,token2) PASTE(token1,token2)
%#endif
%#ifndef EMPTY
%#define EMPTY
%#endif
%#ifndef _SVCSUFFIX
%#if LINUX
%#define _SVCSUFFIX _svc
%#else
%#define _SVCSUFFIX EMPTY
%#endif
%#endif
%#if !defined(DLLEXPORT)
%#if WIN32
%#if (BUILDDLL+0)
%#define DLLEXPORT __attribute__(( dllexport )) __attribute__((__cdecl__))
%#else
%#define DLLEXPORT __attribute__(( dllimport )) __attribute__((__cdecl__))
%#endif
%#else
%#define DLLEXPORT
%#endif
%#endif
%#if !defined(DLLEXPORTVAR)
%#if WIN32
%#if (BUILDDLL+0)
%#define DLLEXPORTVAR __attribute__(( dllexport ))
%#else
%#define DLLEXPORTVAR __attribute__(( dllimport ))
%#endif
%#else
%#define DLLEXPORTVAR
%#endif
%#endif
%#if WIN32
%#define strdup _strdup
%#endif
%
%
%#if ! defined(AlignBitsToWords)
%#define AlignBitsToWords( nSizeInBits ) (int ) ( ( (nSizeInBits) + nSizeOfPostoreWord * nBitsPerByte -1 ) / ( nSizeOfPostoreWord * nBitsPerByte ) )
%#endif
%
%
%
%extern DLLEXPORTVAR int __bInitializePlob__ ;
%extern DLLEXPORTVAR int __bDeinitializePlob__ ;
%void fnServerInitializePlob ( int argc,char * argv [] );
%#if ! defined(INITIALIZEPLOB)
%void fnInitializePlob ( void );
%#define INITIALIZEPLOB ((__bInitializePlob__)? (fnInitializePlob(),TRUE):FALSE)
%#endif
%
%#if (RPC_SVC+0)
%
%extern DLLEXPORTVAR int nGlobalStored;
%extern DLLEXPORTVAR OBJID oGlobalSession;
%
%#if !defined(UNSTORESESSION)
%#define UNSTORESESSION() (__bJmpBufErrorValid__=FALSE,nGlobalStored=0,oGlobalSession=NULLOBJID)
%#endif
%#if !defined(UnstoreSession)
%#define UnstoreSession() ((--nGlobalStored==0)?(UNSTORESESSION(),TRUE):FALSE)
%#endif
%
%extern DLLEXPORTVAR LPCSTR __lpszErrorMessage__;
%extern DLLEXPORTVAR ERRLVL __nErrorLevel__;
%
%
%#define RPC_SERVER_INITIALIZE(argc,argv) fnServerInitializePlob(argc,argv)
%
%
%#define RPC_SERVER_ENTRY() { UNSTORESESSION (); __nErrorLevel__ = errLvl0; if ( __lpszErrorMessage__ != NULL ) { free ( (LPVOID) __lpszErrorMessage__ ); __lpszErrorMessage__ = (LPCSTR) NULL; } INITIALIZEPLOB;}
%#define RPC_SERVER_ERRLVL() ((__bDeinitializePlob__)?0:__nErrorLevel__)
%#define RPC_SERVER_ERRMSG() ((__bDeinitializePlob__)?(LPCSTR) NULL:__lpszErrorMessage__)
%
%#include <rpc/rpc.h>
%#include <rpc/svc.h>
%
%void fnInitializeAfterRegister ( void );
%static void fnSvcRun ( void )
%{
% INITIALIZEPLOB;
% fnInitializeAfterRegister ();
% svc_run();
%}
%
%#ifdef svc_run
%#undef svc_run
%#endif
%#define svc_run fnSvcRun
%
%#endif
%
%#if (RPC_CLNT+0)
%
%#define RPC_CLIENT_INITIALIZE() INITIALIZEPLOB
%
%extern PCLIENT fnClientCreate ( LPCSTR pszHost,
% LPCSTR pszTransport );
%#define RPC_CLIENT_CREATE(host,transport) fnClientCreate ( host,transport )
%
%extern PCLIENT fnClientDestroy ( PCLIENT pClient );
%#define RPC_CLIENT_DESTROY(pclient) fnClientDestroy ( pclient )
%
%#define RPC_CLIENT_ERROR(msg) ((__bDeinitializePlob__)? FALSE: (fnLISPerrorCallback(errLvlError,NULL,msg),TRUE))
%#define RPC_CLIENT_CERROR(cont,msg) ((__bDeinitializePlob__)? FALSE: (fnLISPerrorCallback(errLvlCError,cont,msg),TRUE))
%#define RPC_CLIENT_SERROR(lvl,proc,msg) ((__bDeinitializePlob__)? FALSE: (fnLISPserrorCallback(lvl,proc,msg),TRUE))
%
%#endif
%
%#if (RPC_SVC+0)||(RPC_CLNT+0)
%
%#define xdr_fnServerObjectReadValues_rets xdr_fnPatchedServerObjectReadValues_rets
%#define xdr_fnServerObjectWriteValues_args xdr_fnPatchedServerObjectWriteValues_args
%#define xdr_fnServerObjectPeekValues_rets xdr_fnPatchedServerObjectPeekValues_rets
%#define xdr_fnServerObjectPoke_args xdr_fnPatchedServerObjectPoke_args
%#include "plobpxdr.h"
%
%#endif
%
#if RPC_HDR || RPC_XDR
%
%#ifndef RPCNOTYPES
%
        const   eshRootTag  =   136  ;
        const   eshUserTag  =   256  ;
        const   eshMachTag  =   272  ;
        const   NULLOBJID  =   0 ;
        const   NULLTYPETAG  =   -1 ;
        const   nBitsPerByte  =   8  ;
        const   nBitsPerBigit  =   16 ;
        const   nSizeOfPostoreWord  =   4 ;
        const   nFixnumBits  =  30 ;
        const   nTagBits  =   3  ;
  const nTagMask =  0 ;
        const   MAX_URL  =   256 ;
        const   eshConsTag  =   8  ;
        const   eshVectorTag  =   64  ;
        const   eshIVectorTag  =   192  ;
        const   eshArrayTag  =   32  ;
        const   eshStringTag  =   40  ;
        const   eshBitVectorTag  =   48  ;
        const   eshStructureTag  =   56  ;
        const   eshInstanceTag  =   72  ;
        const   eshSingleFloatValueSize  =   1 ;
        const   eshDoubleFloatValueSize  =   2 ;
        const   eshSumLockTag  =   168  ;
        const   eshOneLockTag  =   176  ;
        const   eshQueueEntryTag  =   208  ;
        const   NULLTRACTID  =   0 ;
        const   eshHeapTag  =   144  ;
        const   eshBTreeTag  =   152  ;
        const   eshBTreePageTag  =   160  ;
        const   eshBTreeMapperTag  =   216  ;
        const   eshGetTestMode  =   -2 ;
        enum   GETVERSION   {  esvDatabase = 1,
	esvServerCode = 2,
	esvClientCcode = 3,
	esvClientLispCode = 4  };
        enum   MACHLOGINP   {  eshLoginIgnore = 0,
	eshLoginAllow = 1,
	eshLoginDeny = 2,
	eshLoginGet = 3 };
        enum   LISPROOTIDX   {  eshLispRootIdxVersion =  1,
	eshLispRootIdxLispFormat =  2,
	eshLispRootIdxTimeFormat =  3,
	eshLispRootIdxNamePkgTable =  4,
	eshLispRootIdxSymbolClassTable =  5,
	eshLispRootIdxStructDescr =  6,
	eshLispRootIdxStructSlotDescr =  7,
	eshLispRootIdxPkgDescr =  8,
	eshLispRootIdxPlobDescr =  9,
	eshLispRootIdxClassDescr =  10,
	eshLispRootIdxSlotDescr =  11,
	eshLispRootIdxDirSlotDescr =  12,
	eshLispRootIdxEffSlotDescr =  13,
	eshLispRootIdxMethodDescr =  14,
	eshLispRootIdxPFS =  15,
	eshLispRootSize =  16 };
        enum   SHSYMBOLIDX   {  eshSymbolIdxFunction = 0,
	eshSymbolIdxPackage = 1,
	eshSymbolIdxPList = 2,
	eshSymbolIdxName = 3,
	eshSymbolIdxValue = 4,
	eshSymbolObjIdSize = 5 };
        enum   SHFUNCTIONIDX   {  eshFunctionIdxName = 0,
	eshFunctionIdxLanguage = 1,
	eshFunctionIdxCode = 2,
	eshFunctionSize = 3 };
        enum   SHTLATTERIDX   {  eshTLatterIdxKey = 0,
	eshTLatterIdxData = 1,
	eshTLatterIdxNext = 2,
	eshTLatterObjIdSize = 3 };
        enum   SHTYPETAG   {      eshObjIdTag  =  			0,
	eshFixnumTag = 1,
	eshShortFloatTag = 2,
	eshCharacterTag = 3,
	eshMarkerTag = 4,
	eshUnboundTag =  260,
	eshSlotUnboundTag =  516,
	eshUnstorableTag =  772,
	eshEndTag =  1028,
	eshMinTag =  1284,
	eshMaxTag =  1540,
	eshTrueTag =  1796,
	eshIgnoreSlotTag =  2052,
	eshNilTag =  2308,
	eshAllowTag =  2564,
	eshDenyTag =  2820,
	eshEqTag =  3076,
	eshEqlTag =  3332,
	eshEqualTag =  3588,
	eshBitmaskTag = 6,
	eshBuiltInTag = 7,
	eshSymbolTag  =   		16,
	eshFunctionTag = 24,
	eshSingleFloatTag = 80,
	eshDoubleFloatTag = 88,
	eshBignumTag = 96,
	eshRatioTag = 104,
	eshComplexTag = 112,
	eshTLatterTag = 184,
	eshShortObjIdTag  =  		120,
	eshDynCStringPtrTag = 128,
	eshDynCFloatPtrTag = 200,
	eshDynCDoublePtrTag = 224,
	eshDynCQuadruplePtrTag =  232 };
        enum   ERRLVL   {  errLvl0 = 0,
	errLvlInfo = 1,
	errLvlWarn = 2,
	errLvlCError = 3,
	errLvlError = 4,
	errLvlFatal = 5 };
        enum   GETACTION   {  eGetPortPassive = 1,
	eGetPortActive = 2,
	eCreateDatabase = 4,
	eStartServer = 8 };
        enum   SHLOCK   {      eshKeyNotFound  =   -10,
	eshLockErrorFirst =  -9,
	eshLockErrorLast =  -1,
	eshLockDenied = -9,
	eshUnknownLockMode = -8,
	eshGeneralError = -7,
	eshUnlockFailed = -6,
	eshWriteFailed = -5,
	eshLockFailed = -4,
	eshLockConflictFirst =  -3,
	eshLockConflictLast =  -1,
	eshLockConflictElement =  -3,
	eshLockConflictVector =  -2,
	eshLockConflictStore =  -1,
	eshLockModeReadOnlyIntent  =  32,
	eshLockModeReadIntent =  64,
	eshLockModeWriteIntent =  128,
	eshLockLevelNothing  =  0,
	eshLockLevelMin =  1,
	eshLockLevelMax =  3,
	eshLockLevelElement =  1,
	eshLockLevelVector =  2,
	eshLockLevelStore =  3,
	eshLockModeNothing  =  0,
	eshLockModeReadOnly =  4,
	eshLockModeRead =  8,
	eshLockModeWrite =  16,
	eshUnlock  =   256,
	eshLockForce = 512,
	eshLockPeek = 1024,
	eshLockElementRead  =  9,
	eshLockVectorRead =  10,
	eshLockStoreRead =  11,
	eshLockElementWrite =  17,
	eshLockVectorWrite =  18,
	eshLockStoreWrite =  19,
	eshLockLevelMask  =  3,
	eshLockModeMask =  28,
	eshLockModeExcl =  16 };
        enum   DAYLIGHTSAVINGTIME   {  eDstNone = 0,
	eDstUsa = 1,
	eDstAust = 2,
	eDstWet = 3,
	eDstMet = 4,
	eDstEet = 5,
	eDstCan = 6,
	eDstGb = 7,
	eDstRum = 8,
	eDstTur = 9,
	eDstAustAlt = 10 };
        enum   DEPENDENTMODE   {  flagDependentGet =  -1,
	flagDependentNone =  0,
	flagDependentRead =  4,
	flagDependentWrite =  8,
	flagDependentReadWrite =  12 };
        enum   NUMERICSTDSTREAM   {  eshStdIn = 0,
	eshStdOut = 1,
	eshStdErr = 2 };
        enum   FLUSHMODE   {  flushGet = -1,
	flushNever = 0,
	flushSeldom = 1,
	flushSometimes = 2,
	flushOften = 3,
	flushAlways = 4,
	flushDefault = 0 };
        enum   FLAGMODE   {  flagGet = -1,
	flagSet = 0 };
        enum   SHCONSIDX   {  eshConsIdxCar = 0,
	eshConsIdxCdr = 1,
	eshConsObjIdSize = 2 };
        enum   SHVECTORIDX   {  eshVectorObjIdSize = 0 };
        enum   IVECTORTAG   {  eshSignedByte2Tag =  5892,
	eshSignedByte4Tag =  9988,
	eshSignedByte8Tag =  14084,
	eshSignedByte16Tag =  18180,
	eshSignedByte32Tag =  22276,
	eshUnsignedByte1Tag =  46852,
	eshUnsignedByte2Tag =  26372,
	eshUnsignedByte4Tag =  30468,
	eshUnsignedByte8Tag =  34564,
	eshUnsignedByte16Tag =  38660,
	eshUnsignedByte32Tag =  42756 };
        enum   IVECTORIDX   {  eshIVectorIdxType = 0,
	eshIVectorIdxLength = 1,
	eshIVectorObjIdSize = 2 };
        enum   SHARRAYIDX   {  eshArrayIdxDataVector = 0,
	eshArrayIdxFillPointer = 1,
	eshArrayIdxDisplacedOffset = 2,
	eshArrayIdxAdjustable = 3,
	eshArrayIdxRank = 4,
	eshArrayIdxFirstDimension = 5,
	eshArrayObjIdSize = 5 };
        enum   SHSTRINGIDX   {  eshStringIdxLength = 0,
	eshStringObjIdSize = 1 };
        enum   SHBITVECTORIDX   {  eshBitVectorIdxLength = 0,
	eshBitVectorObjIdSize = 1 };
        enum   SHSTRUCTIDX   {  eshStructIdxDesc = 0,
	eshStructObjIdSize = 0 };
        enum   SHSTRUCTDESCIDX   {  eshStructDescrIdxName =  1,
	eshStructDescrIdxVersion =  2,
	eshStructDescrIdxTimeStamp =  3,
	eshStructDescrIdxSchemaEvolution =  4,
	eshStructDescrIdxNextGen =  5,
	eshStructDescrIdxConstructor =  6,
	eshStructDescrIdxDependent =  7,
	eshStructDescrIdxPNSlots =  8,
	eshStructDescrIdxNSlots =  9,
	eshStructDescrIdxSlots =  10,
	eshStructDescSize =  11 };
        enum   SHSTRUCTSLOTDESCIDX   {  eshStructSlotDescrIdxName =  1,
	eshStructSlotDescrInitArg =  2,
	eshStructSlotDescrIdxReader =  3,
	eshStructSlotDescrIdxLocation =  4,
	eshStructSlotDescrIdxInit =  5,
	eshStructSlotDescrIdxType =  6,
	eshStructSlotDescrIdxExtent =  7,
	eshStructSlotDescrIdxDeferred =  8,
	eshStructSlotDescSize =  9 };
        enum   SHPACKAGEIDX   {  eshPackageIdxName =  1,
	eshPackageIdxInternals =  2,
	eshPackageIdxExternals =  3,
	eshPackageSize =  4 };
        enum   SHINSTIDX   {  eshInstIdxClassWrapper = 0,
	eshInstIdxDataVector = 1,
	eshInstObjIdSize = 2 };
        enum   SHPLOBDESCRIDX   {  eshPlobDescrSize = 0 };
        enum   SHCLASSDESCRIDX   {  eshClassDescrIdxName =  0,
	eshClassDescrIdxSuperclasses =  1,
	eshClassDescrIdxPrecedenceList =  2,
	eshClassDescrIdxMetaclass =  3,
	eshClassDescrIdxVersion =  4,
	eshClassDescrIdxTimeStamp =  5,
	eshClassDescrIdxSchemaEvolution =  6,
	eshClassDescrIdxNextGen =  7,
	eshClassDescrIdxDirMethods =  8,
	eshClassDescrIdxPNSlots =  9,
	eshClassDescrIdxNSlots =  10,
	eshClassDescrIdxDirSlots =  11,
	eshClassDescrIdxEffSlots =  12,
	eshClassDescrIdxConstructor =  13,
	eshClassDescrIdxDependent =  14,
	eshClassDescrIdxPList =  15,
	eshClassDescrIdxPrototype =  16,
	eshClassDescrSize = 17 };
        enum   SHCLASSLOTIDX   {  eshClassSlotDescrIdxName =  0,
	eshClassSlotDescrIdxInitArg =  1,
	eshClassSlotDescrIdxInitForm =  2,
	eshClassSlotDescrIdxInitFunc =  3,
	eshClassSlotDescrIdxType =  4,
	eshClassSlotDescrIdxAlloc =  5,
	eshClassSlotDescrIdxExtent =  6,
	eshClassSlotDescrIdxDeferred =  7,
	eshClassSlotDescrIdxIndex =  8,
	eshClassSlotDescrSize = 9 };
        enum   SHDIRCLASSLOTIDX   {  eshClassDirSlotDescrIdxReaders =  9,
	eshClassDirSlotDescrIdxWriters =  10,
	eshClassDirSlotDescrSize =  11 };
        enum   SHEFFCLASSLOTIDX   {  eshClassEffSlotDescrIdxLocation =  9,
	eshClassEffSlotDescrSize =  10 };
        enum   SHMETHODIDX   {  eshMethodIdxName =  0,
	eshMethodIdxFunction =  1,
	eshMethodIdxLambdaList =  2,
	eshMethodIdxSpecializers =  3,
	eshMethodIdxQualifiers =  4,
	eshMethodSize =  5 };
        enum   COMPARETAG   {  eshEqual = 4,
	eshEql = 0,
	eshEq = 3,
	eshNotEqual = 9,
	eshNotEql = 5,
	eshNotEq = 8,
	eshLessEqual = -2,
	eshLess = -1,
	eshGreater = 1,
	eshGreaterEqual = 2 };
        enum   TYPEFLAGS   {  typeNoFlags = 0,
	typeImmediateP = 1,
	typeNotAllocatableP = 2,
	typeTransientP = 4,
	typeVarSizeObjIdP = 8,
	typeVarSizeValueP = 16,
	typeRecycleP = 32,
	typeNotYetImplemented = 64,
	typeNotCachableP = 128  };
        enum   SHRATIOIDX   {  eshRatioIdxNumerator = 0,
	eshRatioIdxDenominator = 1,
	eshRatioObjIdSize = 2 };
        enum   SHCOMPLEXIDX   {  eshComplexIdxRealPart = 0,
	eshComplexIdxImagPart = 1,
	eshComplexObjIdSize = 2 };
        enum   SHBIGNUMIDX   {  eshBignumIdxFormat = 0,
	eshBignumIdxSize = 1,
	eshBignumObjIdSize = 2 };
        enum   READONLYMODE   {  eshReadOnlyP = -1,
	eshReadWrite = 0,
	eshReadOnly = 1 };
        enum   SHHEAPIDX   {  eshHeapIdxSelf = 0,
	eshHeapIdxTractId = 1,
	eshHeapIdxTractLogId = 2 };
        enum   BTREERESULT   {  btreeNotFound = 0,
	btreeFound = 1,
	btreeInserted = 2,
	btreeUpdated = 3,
	btreeDeleted = 4 };
        enum   SHBTREEIDX   {  eshBTreeIdxSelf = 0,
	eshBTreeIdxCompare = 1,
	eshBTreeIdxCount = 2,
	eshBTreeIdxCached = 3,
	eshBTreeIdxTimeStamp = 4 };
        enum   SEEK   {  seekSet = 0,
	seekCur = 1,
	seekEnd = 2 };
        typedef     int       psint  ;
        typedef     int       SHORTOBJID  ;
        typedef     psint      OBJID  ;
        typedef     int       TRACTID  ;
%
%#endif	/* ! RPCNOTYPES */
#endif	/* RPC_HDR || RPC_XDR */
%
        typedef   opaque    as_is_vector_t<>  ;
        typedef   opaque    void_vector_t<>  ;
        typedef   int    int_vector_t<>  ;
        typedef   unsigned int    u_int_vector_t<>  ;
        typedef   float    float_vector_t<>  ;
        typedef   double    double_vector_t<>  ;
        typedef   string    string_t<>  ;
struct fnClientDbReadRoot_rets {
  SHORTOBJID ReturnValue;
  int nErrorLvl ;
   string_t pszErrorMsg;
};
struct fnServerDbWriteRoot_rets {
  SHORTOBJID ReturnValue;
  int nErrorLvl ;
   string_t pszErrorMsg;
};
struct fnServerDbWriteRoot_args {
  SHORTOBJID oShortObjIdHeap;
SHORTOBJID oShortObjId ;

};
struct fnClientDbSessions_rets {
  SHORTOBJID ReturnValue;
  int nErrorLvl ;
   string_t pszErrorMsg;
};
struct fnServerGetVersion_rets {
  int ReturnValue;
  int nErrorLvl ;
   string_t pszErrorMsg;
};
struct fnServerGetVersion_args {
  SHORTOBJID oShortObjIdHeap;
GETVERSION eWhat ;

};
struct fnClientDbCreateMachine_rets {
  SHORTOBJID ReturnValue;
  int nErrorLvl ;
   string_t pszErrorMsg;
};
struct fnClientDbCreateMachine_args {
  SHORTOBJID oShortObjIdHeap;
int_vector_t /* <4> */ nAddr;
MACHLOGINP eLoginP ;

};
struct fnClientMachineLoginP_rets {
  MACHLOGINP ReturnValue;
  int nErrorLvl ;
   string_t pszErrorMsg;
};
struct fnClientMachineLoginP_args {
  SHORTOBJID oShortObjIdHeap;
SHORTOBJID oShortMachine;
MACHLOGINP eLoginP ;

};
struct fnClientMachineAddr_rets {
  bool_t ReturnValue;
  int_vector_t /* <4> */  pnAddr ;
   int nErrorLvl ;
   string_t pszErrorMsg;
};
struct fnClientMachineAddr_args {
  SHORTOBJID oShortObjIdHeap;
SHORTOBJID oShortMachine;

int pnAddrSize;
};
struct fnClientDbMachineSearch_rets {
  SHORTOBJID ReturnValue;
  int nErrorLvl ;
   string_t pszErrorMsg;
};
struct fnClientDbMachineSearch_args {
  SHORTOBJID oShortObjIdHeap;
int_vector_t /* <4> */ nAddr ;

};
struct fnClientDbMachineDelete_rets {
  SHORTOBJID ReturnValue;
  int nErrorLvl ;
   string_t pszErrorMsg;
};
struct fnClientDbMachineDelete_args {
  SHORTOBJID oShortObjIdHeap;
int_vector_t /* <4> */ nAddr ;

};
struct fnClientDbMachineInsert_rets {
  SHORTOBJID ReturnValue;
  int nErrorLvl ;
   string_t pszErrorMsg;
};
struct fnClientDbMachineInsert_args {
  SHORTOBJID oShortObjIdHeap;
SHORTOBJID oShortMachine ;

};
struct fnClientDbMachines_rets {
  SHORTOBJID ReturnValue;
  int nErrorLvl ;
   string_t pszErrorMsg;
};
struct fnServerGetPortByDirectory_rets {
  int ReturnValue;
  int nErrorLvl ;
   string_t pszErrorMsg;
};
struct fnServerGetPortByDirectory_args {
  string_t /* <@conststring@> */ szDirectory;
GETACTION eAction ;

};
struct fnServerGetPID_rets {
  int ReturnValue;
  int nErrorLvl ;
   string_t pszErrorMsg;
};
struct fnServerGetDirectory_rets {
  int ReturnValue;
  string_t /* <nDirectory> */  szDirectory ;
   int nErrorLvl ;
   string_t pszErrorMsg;
};
struct fnServerGetDirectory_args {
  int nDirectory;

int szDirectorySize;
};
struct fnServerExit_rets {
  bool_t ReturnValue;
  int nErrorLvl ;
   string_t pszErrorMsg;
};
struct fnServerExit_args {
  SHORTOBJID oShortObjIdHeap;
bool_t bForceExit ;

};
struct fnServerDbReset_rets {
  bool_t ReturnValue;
  int nErrorLvl ;
   string_t pszErrorMsg;
};
struct fnServerDbReset_args {
  SHORTOBJID oShortObjIdHeap;
bool_t bForceReset ;

};
struct fnServerRestart_rets {
  bool_t ReturnValue;
  int nErrorLvl ;
   string_t pszErrorMsg;
};
struct fnServerRestart_args {
  SHORTOBJID oShortObjIdHeap;
bool_t bForceRestart ;

};
struct fnClientObjectCanModify_rets {
  bool_t ReturnValue;
  int nErrorLvl ;
   string_t pszErrorMsg;
};
struct fnClientObjectCanModify_args {
  SHORTOBJID oShortObjIdHeap;
SHORTOBJID oShortObjId ;

};
struct fnServerDbClose_args {
  SHORTOBJID oShortObjIdHeap;
bool_t bWithGarbageCollection ;

};
struct fnClientDbConfiguration_rets {
  bool_t ReturnValue;
  int  pnFlags ;
   int  pnMinimumKey ;
   int  pnMaximumKey ;
   int  pnKeyAlignment ;
   int nErrorLvl ;
   string_t pszErrorMsg;
};
struct fnServerDbCreateObject_rets {
  SHORTOBJID ReturnValue;
  int nErrorLvl ;
   string_t pszErrorMsg;
};
struct fnServerDbCreateObject_args {
  SHORTOBJID oShortObjIdHeap;
SHTYPETAG nTypeTag;
int nExtraReferences;
SHTYPETAG eTypeTagValues;
int nExtraValues ;

};
struct fnServerDbCreateObjects_rets {
  int ReturnValue;
  u_int_vector_t /* <nObjIds> */  pObjIds ;
   int nErrorLvl ;
   string_t pszErrorMsg;
};
struct fnServerDbCreateObjects_args {
  SHORTOBJID oShortObjIdHeap;
SHTYPETAG nTypeTag;
int nExtraReferences;
SHTYPETAG eTypeTagValues;
int nExtraValues;
int nObjIds;

int pObjIdsSize;
};
struct fnServerObjectDestroy_args {
  SHORTOBJID oShortObjIdHeap;
SHORTOBJID oShortObjId ;

};
struct fnServerObjectObjIdSize_rets {
  int ReturnValue;
  int nErrorLvl ;
   string_t pszErrorMsg;
};
struct fnServerObjectObjIdSize_args {
  SHORTOBJID oShortObjIdHeap;
SHORTOBJID oShortObjId ;

};
struct fnServerDbOpen_rets {
  SHORTOBJID ReturnValue;
  OBJID  poObjIdMin ;
   OBJID  poObjIdMax ;
   int nErrorLvl ;
   string_t pszErrorMsg;
};
struct fnServerDbOpen_args {
  string_t /* <@conststring@> */ szDirectory;
string_t /* <@conststring@> */ szUserName;
string_t /* <@conststring@> */ szDescription;
int nMinAddrInK;

};
struct fnServerObjectFlush_rets {
  bool_t ReturnValue;
  int nErrorLvl ;
   string_t pszErrorMsg;
};
struct fnServerObjectFlush_args {
  SHORTOBJID oShortObjIdHeap;
SHORTOBJID oShortObjId ;

};
struct fnServerObjectReadAtIndex_rets {
  SHLOCK ReturnValue;
  int  pnValue ;
   SHTYPETAG  pnTypeTag ;
   int nErrorLvl ;
   string_t pszErrorMsg;
};
struct fnServerObjectReadAtIndex_args {
  SHORTOBJID oShortObjIdHeap;
SHORTOBJID oShortObjId;
SHORTOBJID oExpectingClass;
SHTYPETAG nExpectingTypeTag;
int nIndex;

};
struct fnServerObjectReadAtIndices_rets {
  int ReturnValue;
  int_vector_t /* <nObjIds> */  pObjIds ;
   u_int_vector_t /* <nObjIds> */  pnTypeTags ;
   int nErrorLvl ;
   string_t pszErrorMsg;
};
struct fnServerObjectReadAtIndices_args {
  SHORTOBJID oShortObjIdHeap;
SHORTOBJID oShortObjId;
SHORTOBJID oExpectingClass;
SHTYPETAG nExpectingTypeTag;
int nIndex;
int nObjIds;

int pObjIdsSize;
int pnTypeTagsSize;
};
struct fnServerObjectReadObjId_rets {
  SHLOCK ReturnValue;
  int  pnObjId ;
   int nErrorLvl ;
   string_t pszErrorMsg;
};
struct fnServerObjectReadObjId_args {
  SHORTOBJID oShortObjIdHeap;
SHORTOBJID oShortObjId;
SHORTOBJID oExpectingClass;
SHTYPETAG nExpectingTypeTag;
int nIndex;

};
struct fnServerObjectReadValues_rets {
  int ReturnValue;
  SHTYPETAG  pnElementTypeTagOut ;
   int  pnSizeInElementsOut ;
   void_vector_t /* <((( fnTypeTagSizeValue(1,&nElementTypeTagIn, &nSizeInElementsIn) )*( sizeof(int) )) )> */  pBuffer ;
   int nErrorLvl ;
   string_t pszErrorMsg;
};
struct fnServerObjectReadValues_args {
  SHORTOBJID oShortObjIdHeap;
SHORTOBJID oShortObjId;
SHORTOBJID oExpectingClass;
SHTYPETAG nExpectingTypeTag;
int nIndex;
SHTYPETAG nElementTypeTagIn;
int nSizeInElementsIn;

int pBufferSize;
};
struct fnClientDbStatistics_rets {
  bool_t ReturnValue;
  int  pnMaximumSpace ;
   int  pnAllocatedSpace ;
   int  pnUnallocatedSpace ;
   int  pnUnusedAllocatedSpace ;
   int  pnAllocatedManagementSpace ;
   int  pnNumberOfObjects ;
   int nErrorLvl ;
   string_t pszErrorMsg;
};
struct fnServerObjectTypeTag_rets {
  SHTYPETAG ReturnValue;
  int nErrorLvl ;
   string_t pszErrorMsg;
};
struct fnServerObjectTypeTag_args {
  SHORTOBJID oShortObjIdHeap;
SHORTOBJID oShortObjId ;

};
struct fnServerObjectValueSize_rets {
  int ReturnValue;
  int nErrorLvl ;
   string_t pszErrorMsg;
};
struct fnServerObjectValueSize_args {
  SHORTOBJID oShortObjIdHeap;
SHORTOBJID oShortObjId ;

};
struct fnServerObjectWriteAtIndex_rets {
  SHLOCK ReturnValue;
  int nErrorLvl ;
   string_t pszErrorMsg;
};
struct fnServerObjectWriteAtIndex_args {
  SHORTOBJID oShortObjIdHeap;
SHORTOBJID oShortObjId;
SHORTOBJID oExpectingClass;
SHTYPETAG nExpectingTypeTag;
int nIndex;
int nValue;
SHTYPETAG nTypeTagValue ;

};
struct fnServerObjectWriteAtIndices_rets {
  int ReturnValue;
  int nErrorLvl ;
   string_t pszErrorMsg;
};
struct fnServerObjectWriteAtIndices_args {
  SHORTOBJID oShortObjIdHeap;
SHORTOBJID oShortObjId;
SHORTOBJID oExpectingClass;
SHTYPETAG nExpectingTypeTag;
int nIndex;
int nObjIds;
int_vector_t /* <nObjIds> */ pObjIds;
u_int_vector_t /* <nObjIds> */ pnTypeTags ;

};
struct fnServerObjectWriteObjId_rets {
  SHLOCK ReturnValue;
  int nErrorLvl ;
   string_t pszErrorMsg;
};
struct fnServerObjectWriteObjId_args {
  SHORTOBJID oShortObjIdHeap;
SHORTOBJID oShortObjId;
SHORTOBJID oExpectingClass;
SHTYPETAG nExpectingTypeTag;
int nIndex;
SHORTOBJID oShortObjIdWrite ;

};
struct fnServerObjectWriteValues_rets {
  int ReturnValue;
  int nErrorLvl ;
   string_t pszErrorMsg;
};
struct fnServerObjectWriteValues_args {
  SHORTOBJID oShortObjIdHeap;
SHORTOBJID oShortObjId;
SHORTOBJID oExpectingClass;
SHTYPETAG nExpectingTypeTag;
int nIndex;
SHTYPETAG nElementTypeTag;
int nSizeInElements;
void_vector_t /* <((( fnTypeTagSizeValue(1,&nElementTypeTag, &nSizeInElements ) )*( sizeof(int) )) )> */ pBuffer ;

};
struct fnShortMakeDependent_rets {
  DEPENDENTMODE ReturnValue;
  int nErrorLvl ;
   string_t pszErrorMsg;
};
struct fnShortMakeDependent_args {
  SHORTOBJID oShortObjIdHeap;
SHORTOBJID oShortSelf;
DEPENDENTMODE nDependentMode ;

};
struct fnServerObjectPeekSlots_rets {
  SHLOCK ReturnValue;
  u_int_vector_t /* <nWords> */  pBuffer ;
   int nErrorLvl ;
   string_t pszErrorMsg;
};
struct fnServerObjectPeekSlots_args {
  SHORTOBJID oShortObjIdHeap;
int hPeek;
int nWords;

int pBufferSize;
};
struct fnServerObjectPeekValues_rets {
  SHLOCK ReturnValue;
  u_int_vector_t /* <nObjects> */  pnElementTypeTagsOut ;
   u_int_vector_t /* <nObjects> */  pnSizesInElementsOut ;
   void_vector_t /* <((( fnTypeTagSizeValue ( nObjects,pnElementTypeTagsIn, pnSizesInElementsIn ) )*( sizeof(int) )) )> */  pBuffer ;
   int nErrorLvl ;
   string_t pszErrorMsg;
};
struct fnServerObjectPeekValues_args {
  SHORTOBJID oShortObjIdHeap;
int hPeek;
int nObjects;
u_int_vector_t /* <nObjects> */ pnElementTypeTagsIn;
u_int_vector_t /* <nObjects> */ pnSizesInElementsIn;

int pnElementTypeTagsOutSize;
int pnSizesInElementsOutSize;
int pBufferSize;
};
struct fnServerObjectPoke_args {
  SHORTOBJID oShortObjIdHeap;
SHORTOBJID oShortObjId;
int nSlots;
u_int_vector_t /* <nSlots> */ pSlots;
SHTYPETAG nElementTypeTag;
int nSizeInElements;
void_vector_t /* <((( fnTypeTagSizeValue(1,&nElementTypeTag, &nSizeInElements ) )*( sizeof(int) )) )> */ pValues ;

};
struct fnFlushMode_rets {
  FLUSHMODE ReturnValue;
  int nErrorLvl ;
   string_t pszErrorMsg;
};
struct fnFlushMode_args {
  SHORTOBJID oShortObjIdHeap;
FLUSHMODE nMode ;

};
struct fnFlagWord_rets {
  int ReturnValue;
  int nErrorLvl ;
   string_t pszErrorMsg;
};
struct fnFlagWord_args {
  FLAGMODE nGetOrSet;
int nFlagWord ;

};
struct fnShortMakeIVector_rets {
  SHORTOBJID ReturnValue;
  int nErrorLvl ;
   string_t pszErrorMsg;
};
struct fnShortMakeIVector_args {
  SHORTOBJID oShortObjIdHeap;
SHTYPETAG nTypeTag;
int nElements ;

};
struct fnShortMakeString_rets {
  SHORTOBJID ReturnValue;
  int nErrorLvl ;
   string_t pszErrorMsg;
};
struct fnShortMakeString_args {
  SHORTOBJID oShortObjIdHeap;
string_t /* <@conststring@> */ lpszFrom ;

};
struct fnServerDbCreateStructures_rets {
  int ReturnValue;
  u_int_vector_t /* <nObjIds> */  pObjIds ;
   u_int  pnSlots ;
   int nErrorLvl ;
   string_t pszErrorMsg;
};
struct fnServerDbCreateStructures_args {
  SHORTOBJID oShortObjIdHeap;
SHORTOBJID oShortObjIdStructDescr;
int nObjIds;

int pObjIdsSize;
};
struct fnServerDbCreateInstances_rets {
  int ReturnValue;
  u_int_vector_t /* <nObjIds> */  pObjIds ;
   u_int  pnSlots ;
   u_int_vector_t /* <nObjIds> */  pDatas ;
   int nErrorLvl ;
   string_t pszErrorMsg;
};
struct fnServerDbCreateInstances_args {
  SHORTOBJID oShortObjIdHeap;
SHORTOBJID oShortObjIdClassDescr;
int nObjIds;

int pObjIdsSize;
int pDatasSize;
};
struct fnServerInstanceWriteWrapper_rets {
  SHLOCK ReturnValue;
  int nErrorLvl ;
   string_t pszErrorMsg;
};
struct fnServerInstanceWriteWrapper_args {
  SHORTOBJID oShortObjIdHeap;
SHORTOBJID oShortObjIdInstance;
SHORTOBJID oShortObjIdClassDescr ;

};
struct fnServerInstanceWriteData_rets {
  SHLOCK ReturnValue;
  int nErrorLvl ;
   string_t pszErrorMsg;
};
struct fnServerInstanceWriteData_args {
  SHORTOBJID oShortObjIdHeap;
SHORTOBJID oShortObjIdInstance;
SHORTOBJID oShortObjIdData ;

};
struct fnServerDbTypeTagName_rets {
  string_t /* <@conststring@> */ ReturnValue;
  int nErrorLvl ;
   string_t pszErrorMsg;
};
struct fnServerObjectPrettyPrint_rets {
  int ReturnValue;
  string_t /* <nBuffer> */  lpszBuffer ;
   int nErrorLvl ;
   string_t pszErrorMsg;
};
struct fnServerObjectPrettyPrint_args {
  SHORTOBJID oShortObjIdHeap;
SHORTOBJID oShortObjId;
SHTYPETAG nTypeTag;
int nBuffer ;

int lpszBufferSize;
};
struct fnShortPrintSymbol_rets {
  int ReturnValue;
  string_t /* <nBuffer> */  lpszBuffer ;
   int nErrorLvl ;
   string_t pszErrorMsg;
};
struct fnShortPrintSymbol_args {
  SHORTOBJID oShortObjIdHeap;
SHORTOBJID oShortSymbol;
int nBuffer ;

int lpszBufferSize;
};
struct fnShortMakeSingleFloat_rets {
  SHORTOBJID ReturnValue;
  int nErrorLvl ;
   string_t pszErrorMsg;
};
struct fnShortMakeSingleFloat_args {
  SHORTOBJID oShortObjIdHeap;
float fFrom ;

};
struct fnShortMakeDoubleFloat_rets {
  SHORTOBJID ReturnValue;
  int nErrorLvl ;
   string_t pszErrorMsg;
};
struct fnShortMakeDoubleFloat_args {
  SHORTOBJID oShortObjIdHeap;
double fFrom ;

};
struct fnServerDbMakeBignum_rets {
  SHORTOBJID ReturnValue;
  int nErrorLvl ;
   string_t pszErrorMsg;
};
struct fnServerDbMakeBignum_args {
  SHORTOBJID oShortObjIdHeap;
SHORTOBJID oShortObjIdFormat;
int nSizeInBits;
as_is_vector_t /* <((( AlignBitsToWords ( ABS ( nSizeInBits ) ) )*( sizeof(int) )) )> */ pnBignum ;

};
struct fnServerObjectReadBignum_rets {
  SHLOCK ReturnValue;
  as_is_vector_t /* <((( AlignBitsToWords ( ABS ( nSizeInBits ) ) )*( sizeof(int) )) )> */  pnBignum ;
   int nErrorLvl ;
   string_t pszErrorMsg;
};
struct fnServerObjectReadBignum_args {
  SHORTOBJID oShortObjIdHeap;
SHORTOBJID oShortObjIdFormat;
SHORTOBJID oShortObjId;
int nSizeInBits;

int pnBignumSize;
};
struct fnServerObjectReadDoubleFloat_rets {
  SHLOCK ReturnValue;
  double  pfDoubleFloat ;
   int nErrorLvl ;
   string_t pszErrorMsg;
};
struct fnServerObjectReadDoubleFloat_args {
  SHORTOBJID oShortObjIdHeap;
SHORTOBJID oShortObjId;

};
struct fnServerObjectReadFixnum_rets {
  SHLOCK ReturnValue;
  int  pnFixnum ;
   int nErrorLvl ;
   string_t pszErrorMsg;
};
struct fnServerObjectReadFixnum_args {
  SHORTOBJID oShortObjIdHeap;
SHORTOBJID oShortObjId;
SHORTOBJID oExpectingClass;
SHTYPETAG nExpectingTypeTag;
int nIndex;

};
struct fnServerObjectReadSingleFloat_rets {
  SHLOCK ReturnValue;
  float  pfSingleFloat ;
   int nErrorLvl ;
   string_t pszErrorMsg;
};
struct fnServerObjectReadSingleFloat_args {
  SHORTOBJID oShortObjIdHeap;
SHORTOBJID oShortObjId;

};
struct fnServerObjectWriteBignum_rets {
  SHLOCK ReturnValue;
  int nErrorLvl ;
   string_t pszErrorMsg;
};
struct fnServerObjectWriteBignum_args {
  SHORTOBJID oShortObjIdHeap;
SHORTOBJID oShortObjIdFormat;
SHORTOBJID oShortObjId;
int nSizeInBits;
as_is_vector_t /* <((( AlignBitsToWords ( ABS ( nSizeInBits ) ) )*( sizeof(int) )) )> */ pnBignum ;

};
struct fnServerObjectWriteDoubleFloat_rets {
  SHLOCK ReturnValue;
  int nErrorLvl ;
   string_t pszErrorMsg;
};
struct fnServerObjectWriteDoubleFloat_args {
  SHORTOBJID oShortObjIdHeap;
SHORTOBJID oShortObjId;
double fDoubleFloat ;

};
struct fnServerObjectWriteFixnum_rets {
  SHLOCK ReturnValue;
  int nErrorLvl ;
   string_t pszErrorMsg;
};
struct fnServerObjectWriteFixnum_args {
  SHORTOBJID oShortObjIdHeap;
SHORTOBJID oShortObjId;
SHORTOBJID oExpectingClass;
SHTYPETAG nExpectingTypeTag;
int nIndex;
int nFixnumWrite ;

};
struct fnServerObjectWriteSingleFloat_rets {
  SHLOCK ReturnValue;
  int nErrorLvl ;
   string_t pszErrorMsg;
};
struct fnServerObjectWriteSingleFloat_args {
  SHORTOBJID oShortObjIdHeap;
SHORTOBJID oShortObjId;
float fSingleFloat ;

};
struct fnClientLockPrint_rets {
  int ReturnValue;
  int nErrorLvl ;
   string_t pszErrorMsg;
};
struct fnClientLockPrint_args {
  SHORTOBJID oShortObjIdHeap;
SHORTOBJID oShortSelf;
SHLOCK nLevel;
NUMERICSTDSTREAM nStdStream ;

};
struct fnClientTransactionLockGet_rets {
  SHLOCK ReturnValue;
  int nErrorLvl ;
   string_t pszErrorMsg;
};
struct fnClientTransactionLockGet_args {
  SHORTOBJID oShortObjIdHeap;
SHORTOBJID oShortObjIdLockedByP;
SHLOCK nLevelP;
SHORTOBJID oShortLockedP;
SHTYPETAG nTypeTagLockedP;
int nIndexP ;

};
struct fnServerTransactionLockInsert_rets {
  SHLOCK ReturnValue;
  int  phPeek ;
   int  pnObjIdWords ;
   int nErrorLvl ;
   string_t pszErrorMsg;
};
struct fnServerTransactionLockInsert_args {
  SHORTOBJID oShortObjIdHeap;
SHORTOBJID oShortObjIdLockBy;
SHLOCK nLock;
SHORTOBJID oShortToLock;
SHTYPETAG nTypeTagToLock;
int nIndex;

};
struct fnServerTransactionLockSet_rets {
  SHLOCK ReturnValue;
  int  phPeek ;
   int  pnObjIdWords ;
   int nErrorLvl ;
   string_t pszErrorMsg;
};
struct fnServerTransactionLockSet_args {
  SHORTOBJID oShortObjIdHeap;
SHORTOBJID oShortObjIdLockBy;
SHLOCK nLock;
SHORTOBJID oShortToLock;
SHTYPETAG nTypeTagToLock;
int nIndex;

};
struct fnServerTransactionUnlock_rets {
  SHLOCK ReturnValue;
  SHLOCK  pnVectorLockNow ;
   int nErrorLvl ;
   string_t pszErrorMsg;
};
struct fnServerTransactionUnlock_args {
  SHORTOBJID oShortObjIdHeap;
SHORTOBJID oShortObjIdLockedBy;
SHLOCK nLock;
SHORTOBJID oShortToUnlock;
int nIndex;

};
struct fnServerTransactionUnlockAll_rets {
  int ReturnValue;
  int nErrorLvl ;
   string_t pszErrorMsg;
};
struct fnServerTransactionUnlockAll_args {
  SHORTOBJID oShortObjIdHeap;
SHORTOBJID oShortObjIdLockedBy;
SHORTOBJID oShortToUnlock ;

};
struct fnServerTransactionUnlockAllAll_rets {
  int ReturnValue;
  int nErrorLvl ;
   string_t pszErrorMsg;
};
struct fnServerTransactionUnlockAllAll_args {
  SHORTOBJID oShortObjIdHeap;
SHORTOBJID oShortObjIdLockedBy ;

};
struct fnShortMakeReadOnly_rets {
  bool_t ReturnValue;
  int nErrorLvl ;
   string_t pszErrorMsg;
};
struct fnShortMakeReadOnly_args {
  SHORTOBJID oShortObjIdHeap;
SHORTOBJID oShortSelf;
READONLYMODE nReadOnlyP ;

};
struct fnServerTransactionBegin_rets {
  TRACTID ReturnValue;
  int nErrorLvl ;
   string_t pszErrorMsg;
};
struct fnServerTransactionBegin_args {
  SHORTOBJID oShortObjIdHeap;
bool_t bIgnoreError ;

};
struct fnServerTransactionCancel_rets {
  TRACTID ReturnValue;
  int nErrorLvl ;
   string_t pszErrorMsg;
};
struct fnServerTransactionCancel_args {
  SHORTOBJID oShortObjIdHeap;
bool_t bIgnoreError ;

};
struct fnServerTransactionEnd_rets {
  TRACTID ReturnValue;
  int nErrorLvl ;
   string_t pszErrorMsg;
};
struct fnServerTransactionEnd_args {
  SHORTOBJID oShortObjIdHeap;
bool_t bIgnoreError ;

};
struct fnServerDbTransactionP_rets {
  TRACTID ReturnValue;
  int nErrorLvl ;
   string_t pszErrorMsg;
};
struct fnServerDbTransactionP_args {
  SHORTOBJID oShortObjIdHeap;
TRACTID nTractId ;

};
struct fnClientBtreeClear_rets {
  BTREERESULT ReturnValue;
  int nErrorLvl ;
   string_t pszErrorMsg;
};
struct fnClientBtreeClear_args {
  SHORTOBJID oShortObjIdHeap;
SHORTOBJID oShortObjIdBTree ;

};
struct fnClientBtreeCount_rets {
  int ReturnValue;
  int nErrorLvl ;
   string_t pszErrorMsg;
};
struct fnClientBtreeCount_args {
  SHORTOBJID oShortObjIdHeap;
SHORTOBJID oShortObjIdBTree ;

};
struct fnServerBtreeDelete_rets {
  BTREERESULT ReturnValue;
  int nErrorLvl ;
   string_t pszErrorMsg;
};
struct fnServerBtreeDelete_args {
  SHORTOBJID oShortObjIdHeap;
SHORTOBJID oShortObjIdBTree;
int nValueKey;
SHTYPETAG nTypeTagKey ;

};
struct fnServerBtreeDeleteByFloat_rets {
  BTREERESULT ReturnValue;
  int nErrorLvl ;
   string_t pszErrorMsg;
};
struct fnServerBtreeDeleteByFloat_args {
  SHORTOBJID oShortObjIdHeap;
SHORTOBJID oShortObjIdBTree;
float fKey ;

};
struct fnServerBtreeDeleteByDouble_rets {
  BTREERESULT ReturnValue;
  int nErrorLvl ;
   string_t pszErrorMsg;
};
struct fnServerBtreeDeleteByDouble_args {
  SHORTOBJID oShortObjIdHeap;
SHORTOBJID oShortObjIdBTree;
double fKey ;

};
struct fnServerBtreeDeleteByString_rets {
  BTREERESULT ReturnValue;
  int nErrorLvl ;
   string_t pszErrorMsg;
};
struct fnServerBtreeDeleteByString_args {
  SHORTOBJID oShortObjIdHeap;
SHORTOBJID oShortObjIdBTree;
string_t /* <@conststring@> */ szKey ;

};
struct fnServerBtreeInsert_rets {
  BTREERESULT ReturnValue;
  int nErrorLvl ;
   string_t pszErrorMsg;
};
struct fnServerBtreeInsert_args {
  SHORTOBJID oShortObjIdHeap;
SHORTOBJID oShortObjIdBTree;
int nValueKey;
SHTYPETAG nTypeTagKey;
int nValueData;
SHTYPETAG nTypeTagData ;

};
struct fnServerBtreeInsertByFloat_rets {
  BTREERESULT ReturnValue;
  int nErrorLvl ;
   string_t pszErrorMsg;
};
struct fnServerBtreeInsertByFloat_args {
  SHORTOBJID oShortObjIdHeap;
SHORTOBJID oShortObjIdBTree;
float fKey;
int nValueData;
SHTYPETAG nTypeTagData ;

};
struct fnServerBtreeInsertByDouble_rets {
  BTREERESULT ReturnValue;
  int nErrorLvl ;
   string_t pszErrorMsg;
};
struct fnServerBtreeInsertByDouble_args {
  SHORTOBJID oShortObjIdHeap;
SHORTOBJID oShortObjIdBTree;
double fKey;
int nValueData;
SHTYPETAG nTypeTagData ;

};
struct fnServerBtreeInsertByString_rets {
  BTREERESULT ReturnValue;
  int nErrorLvl ;
   string_t pszErrorMsg;
};
struct fnServerBtreeInsertByString_args {
  SHORTOBJID oShortObjIdHeap;
SHORTOBJID oShortObjIdBTree;
string_t /* <@conststring@> */ szKey;
int nValueData;
SHTYPETAG nTypeTagData ;

};
struct fnServerBtreemapSearch_rets {
  int ReturnValue;
  int nErrorLvl ;
   string_t pszErrorMsg;
};
struct fnServerBtreemapSearch_args {
  SHORTOBJID oShortObjIdMapper;
SHORTOBJID oShortObjIdHeap;
SHORTOBJID oShortObjIdBTree;
int nValueKeyLower;
SHTYPETAG nTypeTagKeyLower;
COMPARETAG eCompareLower;
int nValueKeyUpper;
SHTYPETAG nTypeTagKeyUpper;
COMPARETAG eCompareUpper;
bool_t bDescending ;

};
struct fnServerBtreemapSearchByFloat_rets {
  int ReturnValue;
  int nErrorLvl ;
   string_t pszErrorMsg;
};
struct fnServerBtreemapSearchByFloat_args {
  SHORTOBJID oShortObjIdMapper;
SHORTOBJID oShortObjIdHeap;
SHORTOBJID oShortObjIdBTree;
float fKeyLower;
SHTYPETAG nTypeTagKeyLower;
COMPARETAG eCompareLower;
float fKeyUpper;
SHTYPETAG nTypeTagKeyUpper;
COMPARETAG eCompareUpper;
bool_t bDescending ;

};
struct fnServerBtreemapSearchByDouble_rets {
  int ReturnValue;
  int nErrorLvl ;
   string_t pszErrorMsg;
};
struct fnServerBtreemapSearchByDouble_args {
  SHORTOBJID oShortObjIdMapper;
SHORTOBJID oShortObjIdHeap;
SHORTOBJID oShortObjIdBTree;
double fKeyLower;
COMPARETAG eCompareLower;
SHTYPETAG nTypeTagKeyLower;
double fKeyUpper;
SHTYPETAG nTypeTagKeyUpper;
COMPARETAG eCompareUpper;
bool_t bDescending ;

};
struct fnServerBtreemapSearchByString_rets {
  int ReturnValue;
  int nErrorLvl ;
   string_t pszErrorMsg;
};
struct fnServerBtreemapSearchByString_args {
  SHORTOBJID oShortObjIdMapper;
SHORTOBJID oShortObjIdHeap;
SHORTOBJID oShortObjIdBTree;
string_t /* <@conststring@> */ szKeyLower;
SHTYPETAG nTypeTagKeyLower;
COMPARETAG eCompareLower;
string_t /* <@conststring@> */ szKeyUpper;
SHTYPETAG nTypeTagKeyUpper;
COMPARETAG eCompareUpper;
bool_t bDescending ;

};
struct fnServerBtreemapSeek_rets {
  int ReturnValue;
  int  pnValueKey ;
   SHTYPETAG  pnTypeTagKey ;
   int  pnValueData ;
   SHTYPETAG  pnTypeTagData ;
   int nErrorLvl ;
   string_t pszErrorMsg;
};
struct fnServerBtreemapSeek_args {
  SHORTOBJID oShortObjIdHeap;
SHORTOBJID oShortObjIdMapper;
int nIncrement;
SEEK eOrigin;

};
struct fnServerBtreemapSeekSet_rets {
  int ReturnValue;
  int nErrorLvl ;
   string_t pszErrorMsg;
};
struct fnServerBtreemapSeekSet_args {
  SHORTOBJID oShortObjIdHeap;
SHORTOBJID oShortObjIdMapper;
int nIncrement;
SEEK eOrigin;
int nValueData;
SHTYPETAG nTypeTagData ;

};
struct fnServerBtreemapFirst_rets {
  int ReturnValue;
  SHORTOBJID  lpoShortObjIdMapper ;
   int_vector_t /* <nMap> */  pnValueKey ;
   u_int_vector_t /* <nMap> */  pnTypeTagKey ;
   int_vector_t /* <nMap> */  pnValueData ;
   u_int_vector_t /* <nMap> */  pnTypeTagData ;
   int nErrorLvl ;
   string_t pszErrorMsg;
};
struct fnServerBtreemapFirst_args {
  
SHORTOBJID oShortObjIdHeap;
SHORTOBJID oShortObjIdBTree;
int nValueKeyLower;
SHTYPETAG nTypeTagKeyLower;
COMPARETAG eCompareLower;
int nValueKeyUpper;
SHTYPETAG nTypeTagKeyUpper;
COMPARETAG eCompareUpper;
bool_t bDescending;
int nMap;

int pnValueKeySize;
int pnTypeTagKeySize;
int pnValueDataSize;
int pnTypeTagDataSize;
};
struct fnServerBtreemapFirstByFloat_rets {
  int ReturnValue;
  SHORTOBJID  lpoShortObjIdMapper ;
   int_vector_t /* <nMap> */  pnValueKey ;
   u_int_vector_t /* <nMap> */  pnTypeTagKey ;
   int_vector_t /* <nMap> */  pnValueData ;
   u_int_vector_t /* <nMap> */  pnTypeTagData ;
   int nErrorLvl ;
   string_t pszErrorMsg;
};
struct fnServerBtreemapFirstByFloat_args {
  
SHORTOBJID oShortObjIdHeap;
SHORTOBJID oShortObjIdBTree;
float fKeyLower;
SHTYPETAG nTypeTagKeyLower;
COMPARETAG eCompareLower;
float fKeyUpper;
SHTYPETAG nTypeTagKeyUpper;
COMPARETAG eCompareUpper;
bool_t bDescending;
int nMap;

int pnValueKeySize;
int pnTypeTagKeySize;
int pnValueDataSize;
int pnTypeTagDataSize;
};
struct fnServerBtreemapFirstByDouble_rets {
  int ReturnValue;
  SHORTOBJID  lpoShortObjIdMapper ;
   int_vector_t /* <nMap> */  pnValueKey ;
   u_int_vector_t /* <nMap> */  pnTypeTagKey ;
   int_vector_t /* <nMap> */  pnValueData ;
   u_int_vector_t /* <nMap> */  pnTypeTagData ;
   int nErrorLvl ;
   string_t pszErrorMsg;
};
struct fnServerBtreemapFirstByDouble_args {
  
SHORTOBJID oShortObjIdHeap;
SHORTOBJID oShortObjIdBTree;
double fKeyLower;
COMPARETAG eCompareLower;
SHTYPETAG nTypeTagKeyLower;
double fKeyUpper;
SHTYPETAG nTypeTagKeyUpper;
COMPARETAG eCompareUpper;
bool_t bDescending;
int nMap;

int pnValueKeySize;
int pnTypeTagKeySize;
int pnValueDataSize;
int pnTypeTagDataSize;
};
struct fnServerBtreemapFirstByString_rets {
  int ReturnValue;
  SHORTOBJID  lpoShortObjIdMapper ;
   int_vector_t /* <nMap> */  pnValueKey ;
   u_int_vector_t /* <nMap> */  pnTypeTagKey ;
   int_vector_t /* <nMap> */  pnValueData ;
   u_int_vector_t /* <nMap> */  pnTypeTagData ;
   int nErrorLvl ;
   string_t pszErrorMsg;
};
struct fnServerBtreemapFirstByString_args {
  
SHORTOBJID oShortObjIdHeap;
SHORTOBJID oShortObjIdBTree;
string_t /* <@conststring@> */ szKeyLower;
SHTYPETAG nTypeTagKeyLower;
COMPARETAG eCompareLower;
string_t /* <@conststring@> */ szKeyUpper;
SHTYPETAG nTypeTagKeyUpper;
COMPARETAG eCompareUpper;
bool_t bDescending;
int nMap;

int pnValueKeySize;
int pnTypeTagKeySize;
int pnValueDataSize;
int pnTypeTagDataSize;
};
struct fnClientBtreemapNext_rets {
  int ReturnValue;
  int_vector_t /* <nMap> */  pnValueKey ;
   u_int_vector_t /* <nMap> */  pnTypeTagKey ;
   int_vector_t /* <nMap> */  pnValueData ;
   u_int_vector_t /* <nMap> */  pnTypeTagData ;
   int nErrorLvl ;
   string_t pszErrorMsg;
};
struct fnClientBtreemapNext_args {
  SHORTOBJID oShortObjIdMapper;
SHORTOBJID oShortObjIdHeap;
int nMap;

int pnValueKeySize;
int pnTypeTagKeySize;
int pnValueDataSize;
int pnTypeTagDataSize;
};
struct fnClientBtreemapLast_rets {
  SHORTOBJID ReturnValue;
  int nErrorLvl ;
   string_t pszErrorMsg;
};
struct fnClientBtreemapLast_args {
  SHORTOBJID oShortObjIdMapper;
SHORTOBJID oShortObjIdHeap ;

};
struct fnClientBtreePrint_rets {
  int ReturnValue;
  int nErrorLvl ;
   string_t pszErrorMsg;
};
struct fnClientBtreePrint_args {
  SHORTOBJID oShortObjIdHeap;
SHORTOBJID oShortObjIdBTree;
NUMERICSTDSTREAM nStdStream ;

};
struct fnServerBtreeSearch_rets {
  BTREERESULT ReturnValue;
  int  pnValueKey ;
   SHTYPETAG  pnTypeTagKey ;
   int  pnValueData ;
   SHTYPETAG  pnTypeTagData ;
   int nErrorLvl ;
   string_t pszErrorMsg;
};
struct fnServerBtreeSearch_args {
  SHORTOBJID oShortObjIdHeap;
SHORTOBJID oShortObjIdBTree;
int nValueKey;
SHTYPETAG nTypeTagKey;

};
struct fnServerBtreeSearchByFloat_rets {
  BTREERESULT ReturnValue;
  int  pnValueKey ;
   SHTYPETAG  pnTypeTagKey ;
   int  pnValueData ;
   SHTYPETAG  pnTypeTagData ;
   int nErrorLvl ;
   string_t pszErrorMsg;
};
struct fnServerBtreeSearchByFloat_args {
  SHORTOBJID oShortObjIdHeap;
SHORTOBJID oShortObjIdBTree;
float fKey;
SHTYPETAG nTypeTagKey;

};
struct fnServerBtreeSearchByDouble_rets {
  BTREERESULT ReturnValue;
  int  pnValueKey ;
   SHTYPETAG  pnTypeTagKey ;
   int  pnValueData ;
   SHTYPETAG  pnTypeTagData ;
   int nErrorLvl ;
   string_t pszErrorMsg;
};
struct fnServerBtreeSearchByDouble_args {
  SHORTOBJID oShortObjIdHeap;
SHORTOBJID oShortObjIdBTree;
double fKey;
SHTYPETAG nTypeTagKey;

};
struct fnServerBtreeSearchByString_rets {
  BTREERESULT ReturnValue;
  int  pnValueKey ;
   SHTYPETAG  pnTypeTagKey ;
   int  pnValueData ;
   SHTYPETAG  pnTypeTagData ;
   int nErrorLvl ;
   string_t pszErrorMsg;
};
struct fnServerBtreeSearchByString_args {
  SHORTOBJID oShortObjIdHeap;
SHORTOBJID oShortObjIdBTree;
string_t /* <@conststring@> */ szKey;
SHTYPETAG nTypeTagKey;

};
struct fnClientBtreeRoot_rets {
  SHORTOBJID ReturnValue;
  int nErrorLvl ;
   string_t pszErrorMsg;
};
struct fnClientBtreeRoot_args {
  SHORTOBJID oShortObjIdHeap;
SHORTOBJID oShortObjIdBTree ;

};
struct fnClientBtreeSize_rets {
  int ReturnValue;
  int nErrorLvl ;
   string_t pszErrorMsg;
};
struct fnClientBtreeSize_args {
  SHORTOBJID oShortObjIdHeap;
SHORTOBJID oShortObjIdBTree ;

};
struct fnClientBtreeTestMode_rets {
  COMPARETAG ReturnValue;
  int nErrorLvl ;
   string_t pszErrorMsg;
};
struct fnClientBtreeTestMode_args {
  SHORTOBJID oShortObjIdHeap;
SHORTOBJID oShortObjIdBTree;
COMPARETAG nNewTestMode ;

};
struct fnClientBtreePageSize_rets {
  int ReturnValue;
  int nErrorLvl ;
   string_t pszErrorMsg;
};
struct fnClientBtreePageSize_args {
  SHORTOBJID oShortObjIdHeap;
SHORTOBJID oShortObjIdBTree;
int nNewPageSize ;

};
struct fnClientBtreepageParent_rets {
  OBJID ReturnValue;
  int nErrorLvl ;
   string_t pszErrorMsg;
};
struct fnClientBtreepageParent_args {
  SHORTOBJID oShortObjIdHeap;
SHORTOBJID oShortObjIdBTreePage ;

};
struct fnClientBtreepageCount_rets {
  int ReturnValue;
  int nErrorLvl ;
   string_t pszErrorMsg;
};
struct fnClientBtreepageCount_args {
  SHORTOBJID oShortObjIdHeap;
SHORTOBJID oShortObjIdBTreePage ;

};
struct fnClientBtreepageGetSize_rets {
  int ReturnValue;
  int nErrorLvl ;
   string_t pszErrorMsg;
};
struct fnClientBtreepageGetSize_args {
  SHORTOBJID oShortObjIdHeap;
SHORTOBJID oShortObjIdBTreePage ;

};
struct fnClientBtreepageItem_rets {
  int ReturnValue;
  int_vector_t /* <nItems> */  pnValueKey ;
   u_int_vector_t /* <nItems> */  pnTypeTagKey ;
   int_vector_t /* <nItems> */  pnValueData ;
   u_int_vector_t /* <nItems> */  pnTypeTagData ;
   u_int_vector_t /* <nItems> */  poNext ;
   int nErrorLvl ;
   string_t pszErrorMsg;
};
struct fnClientBtreepageItem_args {
  SHORTOBJID oShortObjIdHeap;
SHORTOBJID oShortObjIdBTreePage;
int nIndex;
int nItems;

int pnValueKeySize;
int pnTypeTagKeySize;
int pnValueDataSize;
int pnTypeTagDataSize;
int poNextSize;
};
#if RPC_HDR
%
%typedef long	RPCPORT;
%extern RPCPORT DLLEXPORT	fnPlobdGetPortOffset	( void );
%extern RPCPORT DLLEXPORT	fnPlobdGetPort	( void );
%extern RPCPORT DLLEXPORT	fnPlobdSetPort	( RPCPORT	lPortNew );
%
%typedef u_long	RPCVERSION;
%extern RPCVERSION DLLEXPORT	fnPlobdGetVersion	( void );
%extern RPCVERSION DLLEXPORT	fnPlobdSetVersion	( RPCVERSION	lVersionNew );
%
%extern struct svc_req *	fnServerPlobdRequest	( void );
%extern struct svc_req *	fnServerPlobdReply
%	( void (*pfnCalled)(), void * pReturnValue );
%
%extern PCLIENT DLLEXPORT fnClientPlobdCreate
%	( LPCSTR pszHost, LPCSTR pszTransport );
%extern PCLIENT DLLEXPORT fnClientPlobd	( void );
%extern LPCSTR DLLEXPORT fnClientPlobdHost	( void );
%extern LPCSTR DLLEXPORT fnClientPlobdTransport	( void );
%extern bool_t DLLEXPORT fnClientPlobdFlush	( PCLIENT pClient );
%extern PCLIENT DLLEXPORT fnClientPlobdDestroy	( PCLIENT pClient );
%
#elif ! RPC_XDR
%
%#define	SIZEOF(type)((sizeof(type)<1)?1:sizeof(type))
%
%static RPCVERSION __Version__ = 1;
%
%RPCVERSION DLLEXPORT	fnPlobdGetVersion	( void )
%{
%  return __Version__;
%} /* fnPlobdGetVersion */
%
%RPCVERSION DLLEXPORT	fnPlobdSetVersion	( RPCVERSION	lVersionNew )
%{
%  RPCVERSION	lVersionOld	= __Version__;
%  __Version__	= lVersionNew;
%  return lVersionOld;
%} /* fnPlobdSetVersion */
%
%static const RPCPORT __PortOffset__ = 0x20506E62;
%static RPCPORT __Port__ = 0;
%
%RPCPORT DLLEXPORT	fnPlobdGetPortOffset	( void )
%{
%  return __PortOffset__;
%} /* fnPlobdGetPortOffset */
%
%RPCPORT DLLEXPORT	fnPlobdGetPort	( void )
%{
%  return __Port__;
%} /* fnPlobdGetPort */
%
%RPCPORT DLLEXPORT	fnPlobdSetPort	( RPCPORT	lPortNew )
%{
%  RPCPORT	lPortOld	= __Port__;
%  __Port__	= lPortNew;
%  return lPortOld;
%} /* fnPlobdSetPort */
%
#endif	/* RPC_XDR */
#if RPC_CLNT || RPC_SVC
%#ifdef PLOBD
%#undef PLOBD
%#endif /* PLOBD */
%#define PLOBD	((u_long)fnPlobdGetPortOffset()+(u_long)fnPlobdGetPort())
%
%#ifdef PLOBDVERS
%#undef PLOBDVERS
%#endif /* PLOBDVERS */
%#define PLOBDVERS	((u_long)fnPlobdGetVersion())
%
% /* static char		szEmpty []	= ""; */
#endif /* RPC_CLNT || RPC_SVC */
%
#if RPC_SVC
%
%#include	<stdlib.h>
%#include	<rpc/svc.h>
%#if WIN32
%#include	<rpc/pmap_cln.h>
%#else
%#include	<rpc/pmap_clnt.h>
%#endif
%
%static struct svc_req	* __pRequest__	= NULL;
%
%static struct {
%  bool_t	bAnswered;
%  void		(*pfnCalled)();
%  int		*pnErrorLvl;
%  LPCSTR	*ppszErrorMsg;
%  void		*pResult;
%  void		*pReturnValue;
%  size_t	nReturnValueSize;
%  bool_t	(*pfnXdrResult)();
%}	Reply;
%
%static const char	szFormatMallocFailed []	=
%"%s: Allocating a result buffer of size %d for argument %s failed.";
%
%#ifndef	RPC_SERVER_INITIALIZE
%#define	RPC_SERVER_INITIALIZE(argc,argv)
%#endif	/* ! RPC_SERVER_INITIALIZE */
%
%#ifndef	RPC_SERVER_ERROR
%#define	RPC_SERVER_ERROR(msg)(fprintf(stderr,"Error: %s\n",msg),exit(1),0)
%#endif	/* ! RPC_SERVER_ERROR */
%
%#ifndef	RPC_SERVER_CERROR
%#define	RPC_SERVER_CERROR(cont,msg)(fprintf(stderr,"Continuable error: %s\n%s\n",msg,cont),fflush(stdin),fgetc(stdin),0)
%#endif	/* ! RPC_SERVER_CERROR */
%
%#ifndef	RPC_SERVER_ERRLVL
%#define	RPC_SERVER_ERRLVL()	0
%#endif	/* ! RPC_SERVER_ERRLVL */
%
%#ifndef	RPC_SERVER_ERRMSG
%#define	RPC_SERVER_ERRMSG()	NULL
%#endif	/* ! RPC_SERVER_ERRMSG */
%
%#ifndef	RPC_SERVER_ENTRY
%#define	RPC_SERVER_ENTRY()
%#endif	/* ! RPC_SERVER_ENTRY */
%
#endif	/* RPC_SVC */
#if RPC_CLNT
%
%static bool_t	__bClientInitialize__	= TRUE;
%static char	__szHost__ [ 256 ]	= "";
%static char	__szTransport__ [ 256 ]	= "";
%static PCLIENT	__pClient__	= NULL;
%
%static const char	szFormatNullPassed []	=
%"%s: A NULL pointer was passed for the %s argument.";
%static const char	szContNullPassed []	=
%"Set associated buffer size to 0.";
%
%static const char	szFormatNullString []	=
%"%s: A NULL string was passed for the %s argument.";
%static const char	szContNullString []	=
%"Handle as empty string of length 0.";
%
%static const char	szContNullOutPassed []	=
%"Dont copy back the values returned from the server.";
%
%static const char	szFormatNoServer []	=
%"%s: No connection to server established.";
%static const char	szContNoServer []	=
%"(Re)try to connect to a server.";
%
%static const char	szFormatRpcFailed []	=
%"%s: RPC call failed:\n       %s";
%static const char	szContRpcFailed []	=
%"Return from client procedure.";
%
%static const char	szFormatBufferOverflow []	=
%"%s: Output buffer size for argument %s is %d, server returned a buffer size of %d.";
%static const char	szContBufferOverflow []	=
%"Ignore the additional values returned from server.";
%
%static struct timeval	NullTimeout	= {  0, 0 };
%static struct timeval	DefaultTimeout	= { 20, 0 };
%
%#ifndef	RPC_CLIENT_CREATE
%#define	RPC_CLIENT_CREATE(host,transport)	fnClientPlobdCreate ( host, transport )
%#define	CLIENT_CREATE_BY_USER	0
%#else
%#define	CLIENT_CREATE_BY_USER	1
%#endif	/* ! RPC_CLIENT_CREATE */
%
%#ifndef	RPC_CLIENT_DESTROY
%#define	RPC_CLIENT_DESTROY(pclient)	fnClientPlobdDestroy ( pclient )
%#endif	/* ! RPC_CLIENT_DESTROY */
%
%#ifndef	RPC_CLIENT_INITIALIZE
%#define	RPC_CLIENT_INITIALIZE()
%#endif	/* ! RPC_CLIENT_INITIALIZE */
%
%#ifndef	RPC_CLIENT_ERROR
%#define	RPC_CLIENT_ERROR(msg)\
%	{fprintf(stderr,"Error: %s\n",msg);clnt_perror(__pClient__,__szHost__);exit(1);}
%#endif	/* ! RPC_CLIENT_ERROR */
%
%#ifndef	RPC_CLIENT_CERROR
%static const char	szFormatCError []	=
%"Continuable error: %s\n%s\n";
%#define	RPC_CLIENT_CERROR(cont,msg)	fprintf(stderr,szFormatCError,msg,cont)
%#endif	/* ! RPC_CLIENT_CERROR */
%
%#ifndef	RPC_CLIENT_SERROR
%static const char	szFormatSError []	=
%"%s: Server error, level %d: %s\n";
%#define	RPC_CLIENT_SERROR(lvl,proc,msg)	fprintf(stderr,szFormatSError,proc,lvl,msg)
%#endif	/* ! RPC_CLIENT_SERROR */
%
#endif	/* RPC_CLNT */
program PLOBD {
  version PLOBDVERS {
%
#if RPC_HDR
%
%/* 1996/09/19 HK kirschke@informatik.uni-hamburg.de		*/
%/* Following #define bypasses a declaration error in		*/
%/* /usr/include/rpc/xdr.h; the declaration found there is:	*/
%/*	extern bool_t xdr_bool(XDR *, bool_t *);		*/
%/* but should be:						*/
%/*	extern bool_t xdr_bool_t(XDR *, bool_t *);		*/
%
%#define xdr_bool_t xdr_bool
%
#endif	/* RPC_HDR */
#if RPC_SVC
%
%extern struct svc_req *	fnServerPlobdRequest	( void )
%{
%  return __pRequest__;
%} /* fnServerPlobdRequest */
%
%extern struct svc_req *	fnServerPlobdReply
%	( void (*pfnCalled)(), void * pReturnValue )
%{
%  struct svc_req	*pRequest = (struct svc_req *) NULL;
%  LPCSTR		pszErrorMsg;
%
%  if ( ! Reply.bAnswered && pfnCalled == Reply.pfnCalled ) {
%    Reply.bAnswered	= TRUE;
%    if ( Reply.pReturnValue != NULL ) {
%      if ( pReturnValue ) {
%        memcpy ( Reply.pReturnValue, pReturnValue, Reply.nReturnValueSize );
%      } else {
%        memset ( Reply.pReturnValue, 0, Reply.nReturnValueSize );
%      }
%    }
%    if ( Reply.pnErrorLvl ) {
%      *Reply.pnErrorLvl	= RPC_SERVER_ERRLVL();
%      if ( *Reply.pnErrorLvl && Reply.ppszErrorMsg != NULL ) {
%        pszErrorMsg	= RPC_SERVER_ERRMSG();
%        if ( pszErrorMsg && *pszErrorMsg ) {
%          *Reply.ppszErrorMsg	= strdup ( pszErrorMsg );
%        }
%      }
%    }
%    if ( Reply.ppszErrorMsg != NULL &&
%         *Reply.ppszErrorMsg == NULL ) {
%      *Reply.ppszErrorMsg	= szEmpty;
%    }
%    pRequest	= fnServerPlobdRequest ();
%    if ( ! svc_sendreply ( pRequest->rq_xprt,
%                           (xdrproc_t) Reply.pfnXdrResult,
%                           (caddr_t) Reply.pResult ) ) {
%      svcerr_systemerr ( pRequest->rq_xprt );
%    }
%  }
%  return pRequest;
%} /* fnServerPlobdReply */
%
#endif	/* RPC_SVC */
#if RPC_CLNT
%
%PCLIENT DLLEXPORT fnClientPlobdCreate
%	( LPCSTR pszHost, LPCSTR pszTransport )
%{
%
%  fnClientPlobdDestroy ( __pClient__ );
%  strncpy ( __szHost__, pszHost, sizeof ( __szHost__ ) );
%  strncpy ( __szTransport__, pszTransport,
%            sizeof ( __szTransport__ ) );
%  __pClient__    = clnt_create ( pszHost, PLOBD,
%                                    PLOBDVERS, pszTransport );
%  return __pClient__;
%} /* fnClientPlobdCreate */
%
%PCLIENT DLLEXPORT fnClientPlobd	( void )
%{
%  return __pClient__;
%} /* fnClientPlobd */
%
%LPCSTR DLLEXPORT fnClientPlobdHost	( void )
%{
%  return __szHost__;
%} /* fnClientPlobdHost */
%
%LPCSTR DLLEXPORT fnClientPlobdTransport	( void )
%{
%  return __szTransport__;
%} /* fnClientPlobdTransport */
%
%bool_t DLLEXPORT fnClientPlobdFlush	( PCLIENT pClient )
%{
%  enum clnt_stat	nState;
%
%  if ( pClient == NULL ) {
%    pClient	= __pClient__;
%  }
%  if ( pClient != NULL ) {
%    nState = clnt_call ( pClient, NULLPROC,
%                         (xdrproc_t) xdr_void, (caddr_t) NULL,
%                         (xdrproc_t) xdr_void, (caddr_t) NULL,
%                         DefaultTimeout );
%    return ( nState == RPC_SUCCESS );
%  }
%  return FALSE;
%} /* fnClientPlobdFlush */
%
%PCLIENT DLLEXPORT fnClientPlobdDestroy	( PCLIENT pClient )
%{
%  if ( pClient == NULL ) {
%    pClient	= __pClient__;
%  }
%  if ( pClient != NULL ) {
%    auth_destroy ( pClient->cl_auth );
%    clnt_destroy ( pClient );
%  }
%  if ( __pClient__ == pClient ) {
%    __pClient__	= NULL;
%  }
%  pClient	= NULL;
%  return pClient;
%} /* fnClientPlobdDestroy */
%
#endif	/* RPC_CLNT */
%
  fnClientDbReadRoot_rets fnRpc_fnClientDbReadRoot ( SHORTOBJID ) =  1 ;
%
#if RPC_SVC
%
%extern SHORTOBJID fnClientDbReadRoot
%	(SHORTOBJID oShortObjIdHeap);
%
%#ifdef MULTITHREAD
%bool_t
%#else
%fnClientDbReadRoot_rets *
%#endif
%	PASTE2(fnrpc_fnclientdbreadroot_1,_SVCSUFFIX)
%		( SHORTOBJID * pArguments,
%#ifdef MULTITHREAD
%		  fnClientDbReadRoot_rets * pResult,
%#endif
%		  struct svc_req * pRequest )
%{
%  static const char	__procedure__[]	= "server:fnrpc_fnclientdbreadroot_1";
%#ifdef MULTITHREAD
%  typedef bool_t RESULTTYPE;
%#else
%  typedef fnClientDbReadRoot_rets * RESULTTYPE;
%#endif
%#ifndef MULTITHREAD
%  static fnClientDbReadRoot_rets	Result;
%  RESULTTYPE			pResult = &Result;
%#endif
%  LPCSTR	pszErrorMsg;
%
%  __pRequest__	= pRequest;
%
%  RPC_SERVER_ENTRY();
%
%#ifndef MULTITHREAD
%  if ( pResult->pszErrorMsg == szEmpty ) {
%    pResult->pszErrorMsg	= NULL;
%  }
%  xdr_free ( (xdrproc_t) xdr_fnClientDbReadRoot_rets, (char *) pResult );
%#endif
%  pResult->nErrorLvl		= 0;
%
%  Reply.bAnswered		= FALSE;
%  Reply.pfnCalled		= (void(*)()) fnClientDbReadRoot;
%  Reply.pfnXdrResult		= (bool_t(*)()) xdr_fnClientDbReadRoot_rets;
%  Reply.pnErrorLvl		= &pResult->nErrorLvl;
%  Reply.ppszErrorMsg		= (LPCSTR *) &pResult->pszErrorMsg;
%  Reply.pResult		= pResult;
%  Reply.pReturnValue		= &pResult->ReturnValue;
%  Reply.nReturnValueSize	= sizeof ( pResult->ReturnValue );
%
%  pResult->ReturnValue		=
%  fnClientDbReadRoot (
%	(*pArguments) );
%
%  if ( Reply.bAnswered ) {
%    __pRequest__	= NULL;
%    return (RESULTTYPE) NULL;
%  }
%
%  pResult->nErrorLvl	= RPC_SERVER_ERRLVL();
%  if ( pResult->nErrorLvl > 0 ) {
%    pszErrorMsg		= RPC_SERVER_ERRMSG();
%    if ( pszErrorMsg && *pszErrorMsg ) {
%      pResult->pszErrorMsg	= strdup ( pszErrorMsg );
%    }
%  }
%  if ( pResult->pszErrorMsg == NULL ) {
%#ifdef MULTITHREAD
%    pResult->pszErrorMsg	= strdup ( szEmpty );
%#else
%    pResult->pszErrorMsg	= (LPSTR) szEmpty;
%#endif
%  }
%  __pRequest__	= NULL;
%  return (RESULTTYPE) pResult;
%} /* fnrpc_fnclientdbreadroot_1 */
#endif	/* RPC_SVC */
%
#if RPC_CLNT
%SHORTOBJID DLLEXPORT fnClientDbReadRoot
%	(SHORTOBJID oShortObjIdHeap)
%{
%  static const char	__procedure__[]	= "client:fnClientDbReadRoot";
%  static fnClientDbReadRoot_rets	ZeroResult;
%  fnClientDbReadRoot_rets		* pResult = NULL;
%  fnClientDbReadRoot_rets		Result = ZeroResult;
%
%  /* Client initialization: */
%  if ( __bClientInitialize__ ) {
%    __bClientInitialize__	= FALSE;
%    RPC_CLIENT_INITIALIZE();
%  }
%
%#if	CLIENT_CREATE_BY_USER
%  if ( __pClient__ == NULL ) {
%    __pClient__	= RPC_CLIENT_CREATE ( __szHost__, __szTransport__ );
%    if ( __pClient__ == NULL ) {
%      /* Error handling for a not connected client: */
%      char	szError [ 256 ];
%      sprintf ( szError, szFormatNoServer, __procedure__ );
%      RPC_CLIENT_ERROR ( szError );
%      return Result.ReturnValue;
%    }
%  }
%#else
%  while ( __pClient__ == NULL ) {
%    __pClient__	= RPC_CLIENT_CREATE ( __szHost__, __szTransport__ );
%    if ( __pClient__ == NULL ) {
%      /* Error handling for a not connected client: */
%      char	szError [ 256 ];
%      sprintf ( szError, szFormatNoServer, __procedure__ );
%      RPC_CLIENT_CERROR ( szContNoServer, szError );
%    }
%  }
%#endif	/* CLIENT_CREATE_BY_USER */
%
%  pResult	=
%#ifdef MULTITHREAD
%    (
%#else
%    (fnClientDbReadRoot_rets *)
%#endif
%    fnrpc_fnclientdbreadroot_1 (
%	&oShortObjIdHeap,
%#ifdef MULTITHREAD
%	&Result,
%#endif
%	__pClient__ )
%#ifdef MULTITHREAD
%	== RPC_SUCCESS ) ? &Result : NULL
%#endif
%	;
%
%  if ( pResult == NULL ) {
%    /* Error handling for a failed RPC call, */
%    /* i.e. the server did not respond: */
%    char	szError [ 256 ];
%    sprintf ( szError, szFormatRpcFailed, __procedure__,
%              clnt_sperror ( __pClient__, __szHost__ ) );
%    __pClient__	= RPC_CLIENT_DESTROY ( __pClient__ );
%    RPC_CLIENT_CERROR ( szContRpcFailed, szError );
%    Result	= ZeroResult;
%    return Result.ReturnValue;
%  }
%#ifndef MULTITHREAD
%  Result	= * pResult;
%#endif
%
%
%  if ( pResult && pResult->nErrorLvl ) {
%    /* Server returned a user error message: */
%    char	szErrorMsg [ 1024 ];
%    strncpy ( szErrorMsg,
%              ( pResult->pszErrorMsg && pResult->pszErrorMsg [ 0 ] ) ?
%              (LPCSTR) pResult->pszErrorMsg : (LPCSTR) szEmpty,
%              sizeof ( szErrorMsg ) );
%    szErrorMsg [ sizeof ( szErrorMsg ) - 1 ]	= (char) 0;
%    xdr_free ( (xdrproc_t) xdr_fnClientDbReadRoot_rets, (char *) pResult );
%    RPC_CLIENT_SERROR ( pResult->nErrorLvl, __procedure__,
%                        szErrorMsg );
%  } else {
%    xdr_free ( (xdrproc_t) xdr_fnClientDbReadRoot_rets, (char *) pResult );
%  }
%
%  return Result.ReturnValue;
%
%} /* fnClientDbReadRoot */
#endif	/* RPC_CLNT */
%
  fnServerDbWriteRoot_rets fnRpc_fnServerDbWriteRoot ( fnServerDbWriteRoot_args ) =  2 ;
%
#if RPC_SVC
%
%extern SHORTOBJID fnServerDbWriteRoot
%	(SHORTOBJID oShortObjIdHeap ,
%	  SHORTOBJID oShortObjId);
%
%#ifdef MULTITHREAD
%bool_t
%#else
%fnServerDbWriteRoot_rets *
%#endif
%	PASTE2(fnrpc_fnserverdbwriteroot_1,_SVCSUFFIX)
%		( fnServerDbWriteRoot_args * pArguments,
%#ifdef MULTITHREAD
%		  fnServerDbWriteRoot_rets * pResult,
%#endif
%		  struct svc_req * pRequest )
%{
%  static const char	__procedure__[]	= "server:fnrpc_fnserverdbwriteroot_1";
%#ifdef MULTITHREAD
%  typedef bool_t RESULTTYPE;
%#else
%  typedef fnServerDbWriteRoot_rets * RESULTTYPE;
%#endif
%#ifndef MULTITHREAD
%  static fnServerDbWriteRoot_rets	Result;
%  RESULTTYPE			pResult = &Result;
%#endif
%  LPCSTR	pszErrorMsg;
%
%  __pRequest__	= pRequest;
%
%  RPC_SERVER_ENTRY();
%
%#ifndef MULTITHREAD
%  if ( pResult->pszErrorMsg == szEmpty ) {
%    pResult->pszErrorMsg	= NULL;
%  }
%  xdr_free ( (xdrproc_t) xdr_fnServerDbWriteRoot_rets, (char *) pResult );
%#endif
%  pResult->nErrorLvl		= 0;
%
%  Reply.bAnswered		= FALSE;
%  Reply.pfnCalled		= (void(*)()) fnServerDbWriteRoot;
%  Reply.pfnXdrResult		= (bool_t(*)()) xdr_fnServerDbWriteRoot_rets;
%  Reply.pnErrorLvl		= &pResult->nErrorLvl;
%  Reply.ppszErrorMsg		= (LPCSTR *) &pResult->pszErrorMsg;
%  Reply.pResult		= pResult;
%  Reply.pReturnValue		= &pResult->ReturnValue;
%  Reply.nReturnValueSize	= sizeof ( pResult->ReturnValue );
%
%  pResult->ReturnValue		=
%  fnServerDbWriteRoot (
%	pArguments->oShortObjIdHeap,
%	pArguments->oShortObjId );
%
%  if ( Reply.bAnswered ) {
%    __pRequest__	= NULL;
%    return (RESULTTYPE) NULL;
%  }
%
%  pResult->nErrorLvl	= RPC_SERVER_ERRLVL();
%  if ( pResult->nErrorLvl > 0 ) {
%    pszErrorMsg		= RPC_SERVER_ERRMSG();
%    if ( pszErrorMsg && *pszErrorMsg ) {
%      pResult->pszErrorMsg	= strdup ( pszErrorMsg );
%    }
%  }
%  if ( pResult->pszErrorMsg == NULL ) {
%#ifdef MULTITHREAD
%    pResult->pszErrorMsg	= strdup ( szEmpty );
%#else
%    pResult->pszErrorMsg	= (LPSTR) szEmpty;
%#endif
%  }
%  __pRequest__	= NULL;
%  return (RESULTTYPE) pResult;
%} /* fnrpc_fnserverdbwriteroot_1 */
#endif	/* RPC_SVC */
%
#if RPC_CLNT
%SHORTOBJID DLLEXPORT fnServerDbWriteRoot
%	(SHORTOBJID oShortObjIdHeap ,
%	  SHORTOBJID oShortObjId)
%{
%  static const char	__procedure__[]	= "client:fnServerDbWriteRoot";
%  static fnServerDbWriteRoot_rets	ZeroResult;
%  fnServerDbWriteRoot_rets		* pResult = NULL;
%  fnServerDbWriteRoot_rets		Result = ZeroResult;
%  fnServerDbWriteRoot_args	InArguments;
%
%  /* Client initialization: */
%  if ( __bClientInitialize__ ) {
%    __bClientInitialize__	= FALSE;
%    RPC_CLIENT_INITIALIZE();
%  }
%
%#if	CLIENT_CREATE_BY_USER
%  if ( __pClient__ == NULL ) {
%    __pClient__	= RPC_CLIENT_CREATE ( __szHost__, __szTransport__ );
%    if ( __pClient__ == NULL ) {
%      /* Error handling for a not connected client: */
%      char	szError [ 256 ];
%      sprintf ( szError, szFormatNoServer, __procedure__ );
%      RPC_CLIENT_ERROR ( szError );
%      return Result.ReturnValue;
%    }
%  }
%#else
%  while ( __pClient__ == NULL ) {
%    __pClient__	= RPC_CLIENT_CREATE ( __szHost__, __szTransport__ );
%    if ( __pClient__ == NULL ) {
%      /* Error handling for a not connected client: */
%      char	szError [ 256 ];
%      sprintf ( szError, szFormatNoServer, __procedure__ );
%      RPC_CLIENT_CERROR ( szContNoServer, szError );
%    }
%  }
%#endif	/* CLIENT_CREATE_BY_USER */
%
%  /* Copy in the oShortObjIdHeap argument: */
%  InArguments.oShortObjIdHeap	= oShortObjIdHeap;
%  /* Copy in the oShortObjId argument: */
%  InArguments.oShortObjId	= oShortObjId;
%
%  pResult	=
%#ifdef MULTITHREAD
%    (
%#else
%    (fnServerDbWriteRoot_rets *)
%#endif
%    fnrpc_fnserverdbwriteroot_1 (
%	&InArguments,
%#ifdef MULTITHREAD
%	&Result,
%#endif
%	__pClient__ )
%#ifdef MULTITHREAD
%	== RPC_SUCCESS ) ? &Result : NULL
%#endif
%	;
%
%  if ( pResult == NULL ) {
%    /* Error handling for a failed RPC call, */
%    /* i.e. the server did not respond: */
%    char	szError [ 256 ];
%    sprintf ( szError, szFormatRpcFailed, __procedure__,
%              clnt_sperror ( __pClient__, __szHost__ ) );
%    __pClient__	= RPC_CLIENT_DESTROY ( __pClient__ );
%    RPC_CLIENT_CERROR ( szContRpcFailed, szError );
%    Result	= ZeroResult;
%    return Result.ReturnValue;
%  }
%#ifndef MULTITHREAD
%  Result	= * pResult;
%#endif
%
%
%  if ( pResult && pResult->nErrorLvl ) {
%    /* Server returned a user error message: */
%    char	szErrorMsg [ 1024 ];
%    strncpy ( szErrorMsg,
%              ( pResult->pszErrorMsg && pResult->pszErrorMsg [ 0 ] ) ?
%              (LPCSTR) pResult->pszErrorMsg : (LPCSTR) szEmpty,
%              sizeof ( szErrorMsg ) );
%    szErrorMsg [ sizeof ( szErrorMsg ) - 1 ]	= (char) 0;
%    xdr_free ( (xdrproc_t) xdr_fnServerDbWriteRoot_rets, (char *) pResult );
%    RPC_CLIENT_SERROR ( pResult->nErrorLvl, __procedure__,
%                        szErrorMsg );
%  } else {
%    xdr_free ( (xdrproc_t) xdr_fnServerDbWriteRoot_rets, (char *) pResult );
%  }
%
%  return Result.ReturnValue;
%
%} /* fnServerDbWriteRoot */
#endif	/* RPC_CLNT */
%
  fnClientDbSessions_rets fnRpc_fnClientDbSessions ( SHORTOBJID ) =  3 ;
%
#if RPC_SVC
%
%extern SHORTOBJID fnClientDbSessions
%	(SHORTOBJID oShortObjIdHeap);
%
%#ifdef MULTITHREAD
%bool_t
%#else
%fnClientDbSessions_rets *
%#endif
%	PASTE2(fnrpc_fnclientdbsessions_1,_SVCSUFFIX)
%		( SHORTOBJID * pArguments,
%#ifdef MULTITHREAD
%		  fnClientDbSessions_rets * pResult,
%#endif
%		  struct svc_req * pRequest )
%{
%  static const char	__procedure__[]	= "server:fnrpc_fnclientdbsessions_1";
%#ifdef MULTITHREAD
%  typedef bool_t RESULTTYPE;
%#else
%  typedef fnClientDbSessions_rets * RESULTTYPE;
%#endif
%#ifndef MULTITHREAD
%  static fnClientDbSessions_rets	Result;
%  RESULTTYPE			pResult = &Result;
%#endif
%  LPCSTR	pszErrorMsg;
%
%  __pRequest__	= pRequest;
%
%  RPC_SERVER_ENTRY();
%
%#ifndef MULTITHREAD
%  if ( pResult->pszErrorMsg == szEmpty ) {
%    pResult->pszErrorMsg	= NULL;
%  }
%  xdr_free ( (xdrproc_t) xdr_fnClientDbSessions_rets, (char *) pResult );
%#endif
%  pResult->nErrorLvl		= 0;
%
%  Reply.bAnswered		= FALSE;
%  Reply.pfnCalled		= (void(*)()) fnClientDbSessions;
%  Reply.pfnXdrResult		= (bool_t(*)()) xdr_fnClientDbSessions_rets;
%  Reply.pnErrorLvl		= &pResult->nErrorLvl;
%  Reply.ppszErrorMsg		= (LPCSTR *) &pResult->pszErrorMsg;
%  Reply.pResult		= pResult;
%  Reply.pReturnValue		= &pResult->ReturnValue;
%  Reply.nReturnValueSize	= sizeof ( pResult->ReturnValue );
%
%  pResult->ReturnValue		=
%  fnClientDbSessions (
%	(*pArguments) );
%
%  if ( Reply.bAnswered ) {
%    __pRequest__	= NULL;
%    return (RESULTTYPE) NULL;
%  }
%
%  pResult->nErrorLvl	= RPC_SERVER_ERRLVL();
%  if ( pResult->nErrorLvl > 0 ) {
%    pszErrorMsg		= RPC_SERVER_ERRMSG();
%    if ( pszErrorMsg && *pszErrorMsg ) {
%      pResult->pszErrorMsg	= strdup ( pszErrorMsg );
%    }
%  }
%  if ( pResult->pszErrorMsg == NULL ) {
%#ifdef MULTITHREAD
%    pResult->pszErrorMsg	= strdup ( szEmpty );
%#else
%    pResult->pszErrorMsg	= (LPSTR) szEmpty;
%#endif
%  }
%  __pRequest__	= NULL;
%  return (RESULTTYPE) pResult;
%} /* fnrpc_fnclientdbsessions_1 */
#endif	/* RPC_SVC */
%
#if RPC_CLNT
%SHORTOBJID DLLEXPORT fnClientDbSessions
%	(SHORTOBJID oShortObjIdHeap)
%{
%  static const char	__procedure__[]	= "client:fnClientDbSessions";
%  static fnClientDbSessions_rets	ZeroResult;
%  fnClientDbSessions_rets		* pResult = NULL;
%  fnClientDbSessions_rets		Result = ZeroResult;
%
%  /* Client initialization: */
%  if ( __bClientInitialize__ ) {
%    __bClientInitialize__	= FALSE;
%    RPC_CLIENT_INITIALIZE();
%  }
%
%#if	CLIENT_CREATE_BY_USER
%  if ( __pClient__ == NULL ) {
%    __pClient__	= RPC_CLIENT_CREATE ( __szHost__, __szTransport__ );
%    if ( __pClient__ == NULL ) {
%      /* Error handling for a not connected client: */
%      char	szError [ 256 ];
%      sprintf ( szError, szFormatNoServer, __procedure__ );
%      RPC_CLIENT_ERROR ( szError );
%      return Result.ReturnValue;
%    }
%  }
%#else
%  while ( __pClient__ == NULL ) {
%    __pClient__	= RPC_CLIENT_CREATE ( __szHost__, __szTransport__ );
%    if ( __pClient__ == NULL ) {
%      /* Error handling for a not connected client: */
%      char	szError [ 256 ];
%      sprintf ( szError, szFormatNoServer, __procedure__ );
%      RPC_CLIENT_CERROR ( szContNoServer, szError );
%    }
%  }
%#endif	/* CLIENT_CREATE_BY_USER */
%
%  pResult	=
%#ifdef MULTITHREAD
%    (
%#else
%    (fnClientDbSessions_rets *)
%#endif
%    fnrpc_fnclientdbsessions_1 (
%	&oShortObjIdHeap,
%#ifdef MULTITHREAD
%	&Result,
%#endif
%	__pClient__ )
%#ifdef MULTITHREAD
%	== RPC_SUCCESS ) ? &Result : NULL
%#endif
%	;
%
%  if ( pResult == NULL ) {
%    /* Error handling for a failed RPC call, */
%    /* i.e. the server did not respond: */
%    char	szError [ 256 ];
%    sprintf ( szError, szFormatRpcFailed, __procedure__,
%              clnt_sperror ( __pClient__, __szHost__ ) );
%    __pClient__	= RPC_CLIENT_DESTROY ( __pClient__ );
%    RPC_CLIENT_CERROR ( szContRpcFailed, szError );
%    Result	= ZeroResult;
%    return Result.ReturnValue;
%  }
%#ifndef MULTITHREAD
%  Result	= * pResult;
%#endif
%
%
%  if ( pResult && pResult->nErrorLvl ) {
%    /* Server returned a user error message: */
%    char	szErrorMsg [ 1024 ];
%    strncpy ( szErrorMsg,
%              ( pResult->pszErrorMsg && pResult->pszErrorMsg [ 0 ] ) ?
%              (LPCSTR) pResult->pszErrorMsg : (LPCSTR) szEmpty,
%              sizeof ( szErrorMsg ) );
%    szErrorMsg [ sizeof ( szErrorMsg ) - 1 ]	= (char) 0;
%    xdr_free ( (xdrproc_t) xdr_fnClientDbSessions_rets, (char *) pResult );
%    RPC_CLIENT_SERROR ( pResult->nErrorLvl, __procedure__,
%                        szErrorMsg );
%  } else {
%    xdr_free ( (xdrproc_t) xdr_fnClientDbSessions_rets, (char *) pResult );
%  }
%
%  return Result.ReturnValue;
%
%} /* fnClientDbSessions */
#endif	/* RPC_CLNT */
%
  fnServerGetVersion_rets fnRpc_fnServerGetVersion ( fnServerGetVersion_args ) =  4 ;
%
#if RPC_SVC
%
%extern int fnServerGetVersion
%	(SHORTOBJID oShortObjIdHeap ,
%	  GETVERSION eWhat);
%
%#ifdef MULTITHREAD
%bool_t
%#else
%fnServerGetVersion_rets *
%#endif
%	PASTE2(fnrpc_fnservergetversion_1,_SVCSUFFIX)
%		( fnServerGetVersion_args * pArguments,
%#ifdef MULTITHREAD
%		  fnServerGetVersion_rets * pResult,
%#endif
%		  struct svc_req * pRequest )
%{
%  static const char	__procedure__[]	= "server:fnrpc_fnservergetversion_1";
%#ifdef MULTITHREAD
%  typedef bool_t RESULTTYPE;
%#else
%  typedef fnServerGetVersion_rets * RESULTTYPE;
%#endif
%#ifndef MULTITHREAD
%  static fnServerGetVersion_rets	Result;
%  RESULTTYPE			pResult = &Result;
%#endif
%  LPCSTR	pszErrorMsg;
%
%  __pRequest__	= pRequest;
%
%  RPC_SERVER_ENTRY();
%
%#ifndef MULTITHREAD
%  if ( pResult->pszErrorMsg == szEmpty ) {
%    pResult->pszErrorMsg	= NULL;
%  }
%  xdr_free ( (xdrproc_t) xdr_fnServerGetVersion_rets, (char *) pResult );
%#endif
%  pResult->nErrorLvl		= 0;
%
%  Reply.bAnswered		= FALSE;
%  Reply.pfnCalled		= (void(*)()) fnServerGetVersion;
%  Reply.pfnXdrResult		= (bool_t(*)()) xdr_fnServerGetVersion_rets;
%  Reply.pnErrorLvl		= &pResult->nErrorLvl;
%  Reply.ppszErrorMsg		= (LPCSTR *) &pResult->pszErrorMsg;
%  Reply.pResult		= pResult;
%  Reply.pReturnValue		= &pResult->ReturnValue;
%  Reply.nReturnValueSize	= sizeof ( pResult->ReturnValue );
%
%  pResult->ReturnValue		=
%  fnServerGetVersion (
%	pArguments->oShortObjIdHeap,
%	pArguments->eWhat );
%
%  if ( Reply.bAnswered ) {
%    __pRequest__	= NULL;
%    return (RESULTTYPE) NULL;
%  }
%
%  pResult->nErrorLvl	= RPC_SERVER_ERRLVL();
%  if ( pResult->nErrorLvl > 0 ) {
%    pszErrorMsg		= RPC_SERVER_ERRMSG();
%    if ( pszErrorMsg && *pszErrorMsg ) {
%      pResult->pszErrorMsg	= strdup ( pszErrorMsg );
%    }
%  }
%  if ( pResult->pszErrorMsg == NULL ) {
%#ifdef MULTITHREAD
%    pResult->pszErrorMsg	= strdup ( szEmpty );
%#else
%    pResult->pszErrorMsg	= (LPSTR) szEmpty;
%#endif
%  }
%  __pRequest__	= NULL;
%  return (RESULTTYPE) pResult;
%} /* fnrpc_fnservergetversion_1 */
#endif	/* RPC_SVC */
%
#if RPC_CLNT
%int DLLEXPORT fnServerGetVersion
%	(SHORTOBJID oShortObjIdHeap ,
%	  GETVERSION eWhat)
%{
%  static const char	__procedure__[]	= "client:fnServerGetVersion";
%  static fnServerGetVersion_rets	ZeroResult;
%  fnServerGetVersion_rets		* pResult = NULL;
%  fnServerGetVersion_rets		Result = ZeroResult;
%  fnServerGetVersion_args	InArguments;
%
%  /* Client initialization: */
%  if ( __bClientInitialize__ ) {
%    __bClientInitialize__	= FALSE;
%    RPC_CLIENT_INITIALIZE();
%  }
%
%#if	CLIENT_CREATE_BY_USER
%  if ( __pClient__ == NULL ) {
%    __pClient__	= RPC_CLIENT_CREATE ( __szHost__, __szTransport__ );
%    if ( __pClient__ == NULL ) {
%      /* Error handling for a not connected client: */
%      char	szError [ 256 ];
%      sprintf ( szError, szFormatNoServer, __procedure__ );
%      RPC_CLIENT_ERROR ( szError );
%      return Result.ReturnValue;
%    }
%  }
%#else
%  while ( __pClient__ == NULL ) {
%    __pClient__	= RPC_CLIENT_CREATE ( __szHost__, __szTransport__ );
%    if ( __pClient__ == NULL ) {
%      /* Error handling for a not connected client: */
%      char	szError [ 256 ];
%      sprintf ( szError, szFormatNoServer, __procedure__ );
%      RPC_CLIENT_CERROR ( szContNoServer, szError );
%    }
%  }
%#endif	/* CLIENT_CREATE_BY_USER */
%
%  /* Copy in the oShortObjIdHeap argument: */
%  InArguments.oShortObjIdHeap	= oShortObjIdHeap;
%  /* Copy in the eWhat argument: */
%  InArguments.eWhat	= eWhat;
%
%  pResult	=
%#ifdef MULTITHREAD
%    (
%#else
%    (fnServerGetVersion_rets *)
%#endif
%    fnrpc_fnservergetversion_1 (
%	&InArguments,
%#ifdef MULTITHREAD
%	&Result,
%#endif
%	__pClient__ )
%#ifdef MULTITHREAD
%	== RPC_SUCCESS ) ? &Result : NULL
%#endif
%	;
%
%  if ( pResult == NULL ) {
%    /* Error handling for a failed RPC call, */
%    /* i.e. the server did not respond: */
%    char	szError [ 256 ];
%    sprintf ( szError, szFormatRpcFailed, __procedure__,
%              clnt_sperror ( __pClient__, __szHost__ ) );
%    __pClient__	= RPC_CLIENT_DESTROY ( __pClient__ );
%    RPC_CLIENT_CERROR ( szContRpcFailed, szError );
%    Result	= ZeroResult;
%    return Result.ReturnValue;
%  }
%#ifndef MULTITHREAD
%  Result	= * pResult;
%#endif
%
%
%  if ( pResult && pResult->nErrorLvl ) {
%    /* Server returned a user error message: */
%    char	szErrorMsg [ 1024 ];
%    strncpy ( szErrorMsg,
%              ( pResult->pszErrorMsg && pResult->pszErrorMsg [ 0 ] ) ?
%              (LPCSTR) pResult->pszErrorMsg : (LPCSTR) szEmpty,
%              sizeof ( szErrorMsg ) );
%    szErrorMsg [ sizeof ( szErrorMsg ) - 1 ]	= (char) 0;
%    xdr_free ( (xdrproc_t) xdr_fnServerGetVersion_rets, (char *) pResult );
%    RPC_CLIENT_SERROR ( pResult->nErrorLvl, __procedure__,
%                        szErrorMsg );
%  } else {
%    xdr_free ( (xdrproc_t) xdr_fnServerGetVersion_rets, (char *) pResult );
%  }
%
%  return Result.ReturnValue;
%
%} /* fnServerGetVersion */
#endif	/* RPC_CLNT */
%
  fnClientDbCreateMachine_rets fnRpc_fnClientDbCreateMachine ( fnClientDbCreateMachine_args ) =  5 ;
%
#if RPC_SVC
%
%extern SHORTOBJID fnClientDbCreateMachine
%	(SHORTOBJID oShortObjIdHeap ,
%	  int * /* _vector_t<4> */ nAddr ,
%	  MACHLOGINP eLoginP);
%
%#ifdef MULTITHREAD
%bool_t
%#else
%fnClientDbCreateMachine_rets *
%#endif
%	PASTE2(fnrpc_fnclientdbcreatemachine_1,_SVCSUFFIX)
%		( fnClientDbCreateMachine_args * pArguments,
%#ifdef MULTITHREAD
%		  fnClientDbCreateMachine_rets * pResult,
%#endif
%		  struct svc_req * pRequest )
%{
%  static const char	__procedure__[]	= "server:fnrpc_fnclientdbcreatemachine_1";
%#ifdef MULTITHREAD
%  typedef bool_t RESULTTYPE;
%#else
%  typedef fnClientDbCreateMachine_rets * RESULTTYPE;
%#endif
%#ifndef MULTITHREAD
%  static fnClientDbCreateMachine_rets	Result;
%  RESULTTYPE			pResult = &Result;
%#endif
%  LPCSTR	pszErrorMsg;
%
%  __pRequest__	= pRequest;
%
%  RPC_SERVER_ENTRY();
%
%#ifndef MULTITHREAD
%  if ( pResult->pszErrorMsg == szEmpty ) {
%    pResult->pszErrorMsg	= NULL;
%  }
%  xdr_free ( (xdrproc_t) xdr_fnClientDbCreateMachine_rets, (char *) pResult );
%#endif
%  pResult->nErrorLvl		= 0;
%
%  Reply.bAnswered		= FALSE;
%  Reply.pfnCalled		= (void(*)()) fnClientDbCreateMachine;
%  Reply.pfnXdrResult		= (bool_t(*)()) xdr_fnClientDbCreateMachine_rets;
%  Reply.pnErrorLvl		= &pResult->nErrorLvl;
%  Reply.ppszErrorMsg		= (LPCSTR *) &pResult->pszErrorMsg;
%  Reply.pResult		= pResult;
%  Reply.pReturnValue		= &pResult->ReturnValue;
%  Reply.nReturnValueSize	= sizeof ( pResult->ReturnValue );
%
%  pResult->ReturnValue		=
%  fnClientDbCreateMachine (
%	pArguments->oShortObjIdHeap,
%	pArguments->nAddr.int_vector_t_val,
%	pArguments->eLoginP );
%
%  if ( Reply.bAnswered ) {
%    __pRequest__	= NULL;
%    return (RESULTTYPE) NULL;
%  }
%
%  pResult->nErrorLvl	= RPC_SERVER_ERRLVL();
%  if ( pResult->nErrorLvl > 0 ) {
%    pszErrorMsg		= RPC_SERVER_ERRMSG();
%    if ( pszErrorMsg && *pszErrorMsg ) {
%      pResult->pszErrorMsg	= strdup ( pszErrorMsg );
%    }
%  }
%  if ( pResult->pszErrorMsg == NULL ) {
%#ifdef MULTITHREAD
%    pResult->pszErrorMsg	= strdup ( szEmpty );
%#else
%    pResult->pszErrorMsg	= (LPSTR) szEmpty;
%#endif
%  }
%  __pRequest__	= NULL;
%  return (RESULTTYPE) pResult;
%} /* fnrpc_fnclientdbcreatemachine_1 */
#endif	/* RPC_SVC */
%
#if RPC_CLNT
%SHORTOBJID DLLEXPORT fnClientDbCreateMachine
%	(SHORTOBJID oShortObjIdHeap ,
%	  int * /* _vector_t<4> */ nAddr ,
%	  MACHLOGINP eLoginP)
%{
%  static const char	__procedure__[]	= "client:fnClientDbCreateMachine";
%  static fnClientDbCreateMachine_rets	ZeroResult;
%  fnClientDbCreateMachine_rets		* pResult = NULL;
%  fnClientDbCreateMachine_rets		Result = ZeroResult;
%  fnClientDbCreateMachine_args	InArguments;
%
%  /* Client initialization: */
%  if ( __bClientInitialize__ ) {
%    __bClientInitialize__	= FALSE;
%    RPC_CLIENT_INITIALIZE();
%  }
%
%#if	CLIENT_CREATE_BY_USER
%  if ( __pClient__ == NULL ) {
%    __pClient__	= RPC_CLIENT_CREATE ( __szHost__, __szTransport__ );
%    if ( __pClient__ == NULL ) {
%      /* Error handling for a not connected client: */
%      char	szError [ 256 ];
%      sprintf ( szError, szFormatNoServer, __procedure__ );
%      RPC_CLIENT_ERROR ( szError );
%      return Result.ReturnValue;
%    }
%  }
%#else
%  while ( __pClient__ == NULL ) {
%    __pClient__	= RPC_CLIENT_CREATE ( __szHost__, __szTransport__ );
%    if ( __pClient__ == NULL ) {
%      /* Error handling for a not connected client: */
%      char	szError [ 256 ];
%      sprintf ( szError, szFormatNoServer, __procedure__ );
%      RPC_CLIENT_CERROR ( szContNoServer, szError );
%    }
%  }
%#endif	/* CLIENT_CREATE_BY_USER */
%
%  /* Copy in the oShortObjIdHeap argument: */
%  InArguments.oShortObjIdHeap	= oShortObjIdHeap;
%  /* Copy in the nAddr argument: */
%  InArguments.nAddr.int_vector_t_len	= 4;
%  InArguments.nAddr.int_vector_t_val	= nAddr;
%  if ( InArguments.nAddr.int_vector_t_len != 0 && nAddr == NULL ) {
%    /* Error handling for passing a NULL pointer on */
%    /* VECTOR declared in argument: */
%    char	szError [ 256 ];
%    InArguments.nAddr.int_vector_t_len	= 0;
%    sprintf ( szError, szFormatNullPassed,
%              __procedure__, "nAddr" );
%    RPC_CLIENT_CERROR ( szContNullPassed, szError );
%  }
%  /* Copy in the eLoginP argument: */
%  InArguments.eLoginP	= eLoginP;
%
%  pResult	=
%#ifdef MULTITHREAD
%    (
%#else
%    (fnClientDbCreateMachine_rets *)
%#endif
%    fnrpc_fnclientdbcreatemachine_1 (
%	&InArguments,
%#ifdef MULTITHREAD
%	&Result,
%#endif
%	__pClient__ )
%#ifdef MULTITHREAD
%	== RPC_SUCCESS ) ? &Result : NULL
%#endif
%	;
%
%  if ( pResult == NULL ) {
%    /* Error handling for a failed RPC call, */
%    /* i.e. the server did not respond: */
%    char	szError [ 256 ];
%    sprintf ( szError, szFormatRpcFailed, __procedure__,
%              clnt_sperror ( __pClient__, __szHost__ ) );
%    __pClient__	= RPC_CLIENT_DESTROY ( __pClient__ );
%    RPC_CLIENT_CERROR ( szContRpcFailed, szError );
%    Result	= ZeroResult;
%    return Result.ReturnValue;
%  }
%#ifndef MULTITHREAD
%  Result	= * pResult;
%#endif
%
%
%  if ( pResult && pResult->nErrorLvl ) {
%    /* Server returned a user error message: */
%    char	szErrorMsg [ 1024 ];
%    strncpy ( szErrorMsg,
%              ( pResult->pszErrorMsg && pResult->pszErrorMsg [ 0 ] ) ?
%              (LPCSTR) pResult->pszErrorMsg : (LPCSTR) szEmpty,
%              sizeof ( szErrorMsg ) );
%    szErrorMsg [ sizeof ( szErrorMsg ) - 1 ]	= (char) 0;
%    xdr_free ( (xdrproc_t) xdr_fnClientDbCreateMachine_rets, (char *) pResult );
%    RPC_CLIENT_SERROR ( pResult->nErrorLvl, __procedure__,
%                        szErrorMsg );
%  } else {
%    xdr_free ( (xdrproc_t) xdr_fnClientDbCreateMachine_rets, (char *) pResult );
%  }
%
%  return Result.ReturnValue;
%
%} /* fnClientDbCreateMachine */
#endif	/* RPC_CLNT */
%
  fnClientMachineLoginP_rets fnRpc_fnClientMachineLoginP ( fnClientMachineLoginP_args ) =  6 ;
%
#if RPC_SVC
%
%extern MACHLOGINP fnClientMachineLoginP
%	(SHORTOBJID oShortObjIdHeap ,
%	  SHORTOBJID oShortMachine ,
%	  MACHLOGINP eLoginP);
%
%#ifdef MULTITHREAD
%bool_t
%#else
%fnClientMachineLoginP_rets *
%#endif
%	PASTE2(fnrpc_fnclientmachineloginp_1,_SVCSUFFIX)
%		( fnClientMachineLoginP_args * pArguments,
%#ifdef MULTITHREAD
%		  fnClientMachineLoginP_rets * pResult,
%#endif
%		  struct svc_req * pRequest )
%{
%  static const char	__procedure__[]	= "server:fnrpc_fnclientmachineloginp_1";
%#ifdef MULTITHREAD
%  typedef bool_t RESULTTYPE;
%#else
%  typedef fnClientMachineLoginP_rets * RESULTTYPE;
%#endif
%#ifndef MULTITHREAD
%  static fnClientMachineLoginP_rets	Result;
%  RESULTTYPE			pResult = &Result;
%#endif
%  LPCSTR	pszErrorMsg;
%
%  __pRequest__	= pRequest;
%
%  RPC_SERVER_ENTRY();
%
%#ifndef MULTITHREAD
%  if ( pResult->pszErrorMsg == szEmpty ) {
%    pResult->pszErrorMsg	= NULL;
%  }
%  xdr_free ( (xdrproc_t) xdr_fnClientMachineLoginP_rets, (char *) pResult );
%#endif
%  pResult->nErrorLvl		= 0;
%
%  Reply.bAnswered		= FALSE;
%  Reply.pfnCalled		= (void(*)()) fnClientMachineLoginP;
%  Reply.pfnXdrResult		= (bool_t(*)()) xdr_fnClientMachineLoginP_rets;
%  Reply.pnErrorLvl		= &pResult->nErrorLvl;
%  Reply.ppszErrorMsg		= (LPCSTR *) &pResult->pszErrorMsg;
%  Reply.pResult		= pResult;
%  Reply.pReturnValue		= &pResult->ReturnValue;
%  Reply.nReturnValueSize	= sizeof ( pResult->ReturnValue );
%
%  pResult->ReturnValue		=
%  fnClientMachineLoginP (
%	pArguments->oShortObjIdHeap,
%	pArguments->oShortMachine,
%	pArguments->eLoginP );
%
%  if ( Reply.bAnswered ) {
%    __pRequest__	= NULL;
%    return (RESULTTYPE) NULL;
%  }
%
%  pResult->nErrorLvl	= RPC_SERVER_ERRLVL();
%  if ( pResult->nErrorLvl > 0 ) {
%    pszErrorMsg		= RPC_SERVER_ERRMSG();
%    if ( pszErrorMsg && *pszErrorMsg ) {
%      pResult->pszErrorMsg	= strdup ( pszErrorMsg );
%    }
%  }
%  if ( pResult->pszErrorMsg == NULL ) {
%#ifdef MULTITHREAD
%    pResult->pszErrorMsg	= strdup ( szEmpty );
%#else
%    pResult->pszErrorMsg	= (LPSTR) szEmpty;
%#endif
%  }
%  __pRequest__	= NULL;
%  return (RESULTTYPE) pResult;
%} /* fnrpc_fnclientmachineloginp_1 */
#endif	/* RPC_SVC */
%
#if RPC_CLNT
%MACHLOGINP DLLEXPORT fnClientMachineLoginP
%	(SHORTOBJID oShortObjIdHeap ,
%	  SHORTOBJID oShortMachine ,
%	  MACHLOGINP eLoginP)
%{
%  static const char	__procedure__[]	= "client:fnClientMachineLoginP";
%  static fnClientMachineLoginP_rets	ZeroResult;
%  fnClientMachineLoginP_rets		* pResult = NULL;
%  fnClientMachineLoginP_rets		Result = ZeroResult;
%  fnClientMachineLoginP_args	InArguments;
%
%  /* Client initialization: */
%  if ( __bClientInitialize__ ) {
%    __bClientInitialize__	= FALSE;
%    RPC_CLIENT_INITIALIZE();
%  }
%
%#if	CLIENT_CREATE_BY_USER
%  if ( __pClient__ == NULL ) {
%    __pClient__	= RPC_CLIENT_CREATE ( __szHost__, __szTransport__ );
%    if ( __pClient__ == NULL ) {
%      /* Error handling for a not connected client: */
%      char	szError [ 256 ];
%      sprintf ( szError, szFormatNoServer, __procedure__ );
%      RPC_CLIENT_ERROR ( szError );
%      return Result.ReturnValue;
%    }
%  }
%#else
%  while ( __pClient__ == NULL ) {
%    __pClient__	= RPC_CLIENT_CREATE ( __szHost__, __szTransport__ );
%    if ( __pClient__ == NULL ) {
%      /* Error handling for a not connected client: */
%      char	szError [ 256 ];
%      sprintf ( szError, szFormatNoServer, __procedure__ );
%      RPC_CLIENT_CERROR ( szContNoServer, szError );
%    }
%  }
%#endif	/* CLIENT_CREATE_BY_USER */
%
%  /* Copy in the oShortObjIdHeap argument: */
%  InArguments.oShortObjIdHeap	= oShortObjIdHeap;
%  /* Copy in the oShortMachine argument: */
%  InArguments.oShortMachine	= oShortMachine;
%  /* Copy in the eLoginP argument: */
%  InArguments.eLoginP	= eLoginP;
%
%  pResult	=
%#ifdef MULTITHREAD
%    (
%#else
%    (fnClientMachineLoginP_rets *)
%#endif
%    fnrpc_fnclientmachineloginp_1 (
%	&InArguments,
%#ifdef MULTITHREAD
%	&Result,
%#endif
%	__pClient__ )
%#ifdef MULTITHREAD
%	== RPC_SUCCESS ) ? &Result : NULL
%#endif
%	;
%
%  if ( pResult == NULL ) {
%    /* Error handling for a failed RPC call, */
%    /* i.e. the server did not respond: */
%    char	szError [ 256 ];
%    sprintf ( szError, szFormatRpcFailed, __procedure__,
%              clnt_sperror ( __pClient__, __szHost__ ) );
%    __pClient__	= RPC_CLIENT_DESTROY ( __pClient__ );
%    RPC_CLIENT_CERROR ( szContRpcFailed, szError );
%    Result	= ZeroResult;
%    return Result.ReturnValue;
%  }
%#ifndef MULTITHREAD
%  Result	= * pResult;
%#endif
%
%
%  if ( pResult && pResult->nErrorLvl ) {
%    /* Server returned a user error message: */
%    char	szErrorMsg [ 1024 ];
%    strncpy ( szErrorMsg,
%              ( pResult->pszErrorMsg && pResult->pszErrorMsg [ 0 ] ) ?
%              (LPCSTR) pResult->pszErrorMsg : (LPCSTR) szEmpty,
%              sizeof ( szErrorMsg ) );
%    szErrorMsg [ sizeof ( szErrorMsg ) - 1 ]	= (char) 0;
%    xdr_free ( (xdrproc_t) xdr_fnClientMachineLoginP_rets, (char *) pResult );
%    RPC_CLIENT_SERROR ( pResult->nErrorLvl, __procedure__,
%                        szErrorMsg );
%  } else {
%    xdr_free ( (xdrproc_t) xdr_fnClientMachineLoginP_rets, (char *) pResult );
%  }
%
%  return Result.ReturnValue;
%
%} /* fnClientMachineLoginP */
#endif	/* RPC_CLNT */
%
  fnClientMachineAddr_rets fnRpc_fnClientMachineAddr ( fnClientMachineAddr_args ) =  7 ;
%
#if RPC_SVC
%
%extern bool_t fnClientMachineAddr
%	(SHORTOBJID oShortObjIdHeap ,
%	  SHORTOBJID oShortMachine ,
%	  int * /* _vector_t<4> */  pnAddr);
%
%#ifdef MULTITHREAD
%bool_t
%#else
%fnClientMachineAddr_rets *
%#endif
%	PASTE2(fnrpc_fnclientmachineaddr_1,_SVCSUFFIX)
%		( fnClientMachineAddr_args * pArguments,
%#ifdef MULTITHREAD
%		  fnClientMachineAddr_rets * pResult,
%#endif
%		  struct svc_req * pRequest )
%{
%  static const char	__procedure__[]	= "server:fnrpc_fnclientmachineaddr_1";
%#ifdef MULTITHREAD
%  typedef bool_t RESULTTYPE;
%#else
%  typedef fnClientMachineAddr_rets * RESULTTYPE;
%#endif
%#ifndef MULTITHREAD
%  static fnClientMachineAddr_rets	Result;
%  RESULTTYPE			pResult = &Result;
%#endif
%  LPCSTR	pszErrorMsg;
%
%  __pRequest__	= pRequest;
%
%  RPC_SERVER_ENTRY();
%
%#ifndef MULTITHREAD
%  if ( pResult->pszErrorMsg == szEmpty ) {
%    pResult->pszErrorMsg	= NULL;
%  }
%  xdr_free ( (xdrproc_t) xdr_fnClientMachineAddr_rets, (char *) pResult );
%#endif
%  pResult->nErrorLvl		= 0;
%
%  pResult->pnAddr.int_vector_t_len	= pArguments->pnAddrSize;
%  if ( pArguments->pnAddrSize == 0 ) {
%    pResult->pnAddr.int_vector_t_val	= NULL;
%  } else {
%    pResult->pnAddr.int_vector_t_val	=
%      (int*) malloc ( pArguments->pnAddrSize *
%               SIZEOF ( *(pResult->pnAddr.int_vector_t_val) ) );
%    if ( pResult->pnAddr.int_vector_t_val == NULL ) {
%      char	szError [ 256 ];
%      sprintf ( szError, szFormatMallocFailed,
%                __procedure__, pArguments->pnAddrSize,
%                "pnAddr" );
%      RPC_SERVER_ERROR ( szError );
%      return (RESULTTYPE) NULL;
%    }
%  }
%  Reply.bAnswered		= FALSE;
%  Reply.pfnCalled		= (void(*)()) fnClientMachineAddr;
%  Reply.pfnXdrResult		= (bool_t(*)()) xdr_fnClientMachineAddr_rets;
%  Reply.pnErrorLvl		= &pResult->nErrorLvl;
%  Reply.ppszErrorMsg		= (LPCSTR *) &pResult->pszErrorMsg;
%  Reply.pResult		= pResult;
%  Reply.pReturnValue		= &pResult->ReturnValue;
%  Reply.nReturnValueSize	= sizeof ( pResult->ReturnValue );
%
%  pResult->ReturnValue		=
%  fnClientMachineAddr (
%	pArguments->oShortObjIdHeap,
%	pArguments->oShortMachine,
%	pResult->pnAddr.int_vector_t_val );
%
%  if ( Reply.bAnswered ) {
%    __pRequest__	= NULL;
%    return (RESULTTYPE) NULL;
%  }
%
%  pResult->nErrorLvl	= RPC_SERVER_ERRLVL();
%  if ( pResult->nErrorLvl > 0 ) {
%    pszErrorMsg		= RPC_SERVER_ERRMSG();
%    if ( pszErrorMsg && *pszErrorMsg ) {
%      pResult->pszErrorMsg	= strdup ( pszErrorMsg );
%    }
%  }
%  if ( pResult->pszErrorMsg == NULL ) {
%#ifdef MULTITHREAD
%    pResult->pszErrorMsg	= strdup ( szEmpty );
%#else
%    pResult->pszErrorMsg	= (LPSTR) szEmpty;
%#endif
%  }
%  __pRequest__	= NULL;
%  return (RESULTTYPE) pResult;
%} /* fnrpc_fnclientmachineaddr_1 */
#endif	/* RPC_SVC */
%
#if RPC_CLNT
%bool_t DLLEXPORT fnClientMachineAddr
%	(SHORTOBJID oShortObjIdHeap ,
%	  SHORTOBJID oShortMachine ,
%	  int * /* _vector_t<4> */  pnAddr)
%{
%  static const char	__procedure__[]	= "client:fnClientMachineAddr";
%  static fnClientMachineAddr_rets	ZeroResult;
%  fnClientMachineAddr_rets		* pResult = NULL;
%  fnClientMachineAddr_rets		Result = ZeroResult;
%  fnClientMachineAddr_args	InArguments;
%
%  /* Client initialization: */
%  if ( __bClientInitialize__ ) {
%    __bClientInitialize__	= FALSE;
%    RPC_CLIENT_INITIALIZE();
%  }
%
%#if	CLIENT_CREATE_BY_USER
%  if ( __pClient__ == NULL ) {
%    __pClient__	= RPC_CLIENT_CREATE ( __szHost__, __szTransport__ );
%    if ( __pClient__ == NULL ) {
%      /* Error handling for a not connected client: */
%      char	szError [ 256 ];
%      sprintf ( szError, szFormatNoServer, __procedure__ );
%      RPC_CLIENT_ERROR ( szError );
%      return Result.ReturnValue;
%    }
%  }
%#else
%  while ( __pClient__ == NULL ) {
%    __pClient__	= RPC_CLIENT_CREATE ( __szHost__, __szTransport__ );
%    if ( __pClient__ == NULL ) {
%      /* Error handling for a not connected client: */
%      char	szError [ 256 ];
%      sprintf ( szError, szFormatNoServer, __procedure__ );
%      RPC_CLIENT_CERROR ( szContNoServer, szError );
%    }
%  }
%#endif	/* CLIENT_CREATE_BY_USER */
%
%  /* Copy in the oShortObjIdHeap argument: */
%  InArguments.oShortObjIdHeap	= oShortObjIdHeap;
%  /* Copy in the oShortMachine argument: */
%  InArguments.oShortMachine	= oShortMachine;
%  InArguments.pnAddrSize	= 4;
%
%  pResult	=
%#ifdef MULTITHREAD
%    (
%#else
%    (fnClientMachineAddr_rets *)
%#endif
%    fnrpc_fnclientmachineaddr_1 (
%	&InArguments,
%#ifdef MULTITHREAD
%	&Result,
%#endif
%	__pClient__ )
%#ifdef MULTITHREAD
%	== RPC_SUCCESS ) ? &Result : NULL
%#endif
%	;
%
%  if ( pResult == NULL ) {
%    /* Error handling for a failed RPC call, */
%    /* i.e. the server did not respond: */
%    char	szError [ 256 ];
%    sprintf ( szError, szFormatRpcFailed, __procedure__,
%              clnt_sperror ( __pClient__, __szHost__ ) );
%    __pClient__	= RPC_CLIENT_DESTROY ( __pClient__ );
%    RPC_CLIENT_CERROR ( szContRpcFailed, szError );
%    Result	= ZeroResult;
%    return Result.ReturnValue;
%  }
%#ifndef MULTITHREAD
%  Result	= * pResult;
%#endif
%
%  /* Copy out the pnAddr argument: */
%  if ( ! ( 
%       pResult->pnAddr.int_vector_t_len != 0 &&
%       pnAddr == NULL ) ) {
%    memcpy ( pnAddr,
%             pResult->pnAddr.int_vector_t_val,
%             MIN ( pResult->pnAddr.int_vector_t_len,
%                   4 ) *
%             SIZEOF ( *(pResult->pnAddr.int_vector_t_val) ) );
%  }
%
%  if ( pResult && pResult->nErrorLvl ) {
%    /* Server returned a user error message: */
%    char	szErrorMsg [ 1024 ];
%    strncpy ( szErrorMsg,
%              ( pResult->pszErrorMsg && pResult->pszErrorMsg [ 0 ] ) ?
%              (LPCSTR) pResult->pszErrorMsg : (LPCSTR) szEmpty,
%              sizeof ( szErrorMsg ) );
%    szErrorMsg [ sizeof ( szErrorMsg ) - 1 ]	= (char) 0;
%    xdr_free ( (xdrproc_t) xdr_fnClientMachineAddr_rets, (char *) pResult );
%    RPC_CLIENT_SERROR ( pResult->nErrorLvl, __procedure__,
%                        szErrorMsg );
%  } else {
%    xdr_free ( (xdrproc_t) xdr_fnClientMachineAddr_rets, (char *) pResult );
%  }
%  if ( 
%       pResult->pnAddr.int_vector_t_len != 0 &&
%       pnAddr == NULL ) {
%    /* Error handling for passing a NULL pointer on */
%    /* out argument: */
%    char	szError [ 256 ];
%    sprintf ( szError, szFormatNullPassed,
%              __procedure__, "pnAddr" );
%    RPC_CLIENT_CERROR ( szContNullOutPassed, szError );
%  } else if ( pResult->pnAddr.int_vector_t_len > 4 ) {
%      /* Error handling for an output buffer overflow, */
%      /* i.e. the buffer size passed is too small: */
%      /* For example, signal a CERROR here ... */
%      char	szError [ 256 ];
%      sprintf ( szError, szFormatBufferOverflow,
%                __procedure__, "pnAddr", 
%                4, 
%                pResult->pnAddr.int_vector_t_len );
%      RPC_CLIENT_CERROR ( szContBufferOverflow, szError );
%  }
%
%  return Result.ReturnValue;
%
%} /* fnClientMachineAddr */
#endif	/* RPC_CLNT */
%
  fnClientDbMachineSearch_rets fnRpc_fnClientDbMachineSearch ( fnClientDbMachineSearch_args ) =  8 ;
%
#if RPC_SVC
%
%extern SHORTOBJID fnClientDbMachineSearch
%	(SHORTOBJID oShortObjIdHeap ,
%	  int * /* _vector_t<4> */ nAddr);
%
%#ifdef MULTITHREAD
%bool_t
%#else
%fnClientDbMachineSearch_rets *
%#endif
%	PASTE2(fnrpc_fnclientdbmachinesearch_1,_SVCSUFFIX)
%		( fnClientDbMachineSearch_args * pArguments,
%#ifdef MULTITHREAD
%		  fnClientDbMachineSearch_rets * pResult,
%#endif
%		  struct svc_req * pRequest )
%{
%  static const char	__procedure__[]	= "server:fnrpc_fnclientdbmachinesearch_1";
%#ifdef MULTITHREAD
%  typedef bool_t RESULTTYPE;
%#else
%  typedef fnClientDbMachineSearch_rets * RESULTTYPE;
%#endif
%#ifndef MULTITHREAD
%  static fnClientDbMachineSearch_rets	Result;
%  RESULTTYPE			pResult = &Result;
%#endif
%  LPCSTR	pszErrorMsg;
%
%  __pRequest__	= pRequest;
%
%  RPC_SERVER_ENTRY();
%
%#ifndef MULTITHREAD
%  if ( pResult->pszErrorMsg == szEmpty ) {
%    pResult->pszErrorMsg	= NULL;
%  }
%  xdr_free ( (xdrproc_t) xdr_fnClientDbMachineSearch_rets, (char *) pResult );
%#endif
%  pResult->nErrorLvl		= 0;
%
%  Reply.bAnswered		= FALSE;
%  Reply.pfnCalled		= (void(*)()) fnClientDbMachineSearch;
%  Reply.pfnXdrResult		= (bool_t(*)()) xdr_fnClientDbMachineSearch_rets;
%  Reply.pnErrorLvl		= &pResult->nErrorLvl;
%  Reply.ppszErrorMsg		= (LPCSTR *) &pResult->pszErrorMsg;
%  Reply.pResult		= pResult;
%  Reply.pReturnValue		= &pResult->ReturnValue;
%  Reply.nReturnValueSize	= sizeof ( pResult->ReturnValue );
%
%  pResult->ReturnValue		=
%  fnClientDbMachineSearch (
%	pArguments->oShortObjIdHeap,
%	pArguments->nAddr.int_vector_t_val );
%
%  if ( Reply.bAnswered ) {
%    __pRequest__	= NULL;
%    return (RESULTTYPE) NULL;
%  }
%
%  pResult->nErrorLvl	= RPC_SERVER_ERRLVL();
%  if ( pResult->nErrorLvl > 0 ) {
%    pszErrorMsg		= RPC_SERVER_ERRMSG();
%    if ( pszErrorMsg && *pszErrorMsg ) {
%      pResult->pszErrorMsg	= strdup ( pszErrorMsg );
%    }
%  }
%  if ( pResult->pszErrorMsg == NULL ) {
%#ifdef MULTITHREAD
%    pResult->pszErrorMsg	= strdup ( szEmpty );
%#else
%    pResult->pszErrorMsg	= (LPSTR) szEmpty;
%#endif
%  }
%  __pRequest__	= NULL;
%  return (RESULTTYPE) pResult;
%} /* fnrpc_fnclientdbmachinesearch_1 */
#endif	/* RPC_SVC */
%
#if RPC_CLNT
%SHORTOBJID DLLEXPORT fnClientDbMachineSearch
%	(SHORTOBJID oShortObjIdHeap ,
%	  int * /* _vector_t<4> */ nAddr)
%{
%  static const char	__procedure__[]	= "client:fnClientDbMachineSearch";
%  static fnClientDbMachineSearch_rets	ZeroResult;
%  fnClientDbMachineSearch_rets		* pResult = NULL;
%  fnClientDbMachineSearch_rets		Result = ZeroResult;
%  fnClientDbMachineSearch_args	InArguments;
%
%  /* Client initialization: */
%  if ( __bClientInitialize__ ) {
%    __bClientInitialize__	= FALSE;
%    RPC_CLIENT_INITIALIZE();
%  }
%
%#if	CLIENT_CREATE_BY_USER
%  if ( __pClient__ == NULL ) {
%    __pClient__	= RPC_CLIENT_CREATE ( __szHost__, __szTransport__ );
%    if ( __pClient__ == NULL ) {
%      /* Error handling for a not connected client: */
%      char	szError [ 256 ];
%      sprintf ( szError, szFormatNoServer, __procedure__ );
%      RPC_CLIENT_ERROR ( szError );
%      return Result.ReturnValue;
%    }
%  }
%#else
%  while ( __pClient__ == NULL ) {
%    __pClient__	= RPC_CLIENT_CREATE ( __szHost__, __szTransport__ );
%    if ( __pClient__ == NULL ) {
%      /* Error handling for a not connected client: */
%      char	szError [ 256 ];
%      sprintf ( szError, szFormatNoServer, __procedure__ );
%      RPC_CLIENT_CERROR ( szContNoServer, szError );
%    }
%  }
%#endif	/* CLIENT_CREATE_BY_USER */
%
%  /* Copy in the oShortObjIdHeap argument: */
%  InArguments.oShortObjIdHeap	= oShortObjIdHeap;
%  /* Copy in the nAddr argument: */
%  InArguments.nAddr.int_vector_t_len	= 4;
%  InArguments.nAddr.int_vector_t_val	= nAddr;
%  if ( InArguments.nAddr.int_vector_t_len != 0 && nAddr == NULL ) {
%    /* Error handling for passing a NULL pointer on */
%    /* VECTOR declared in argument: */
%    char	szError [ 256 ];
%    InArguments.nAddr.int_vector_t_len	= 0;
%    sprintf ( szError, szFormatNullPassed,
%              __procedure__, "nAddr" );
%    RPC_CLIENT_CERROR ( szContNullPassed, szError );
%  }
%
%  pResult	=
%#ifdef MULTITHREAD
%    (
%#else
%    (fnClientDbMachineSearch_rets *)
%#endif
%    fnrpc_fnclientdbmachinesearch_1 (
%	&InArguments,
%#ifdef MULTITHREAD
%	&Result,
%#endif
%	__pClient__ )
%#ifdef MULTITHREAD
%	== RPC_SUCCESS ) ? &Result : NULL
%#endif
%	;
%
%  if ( pResult == NULL ) {
%    /* Error handling for a failed RPC call, */
%    /* i.e. the server did not respond: */
%    char	szError [ 256 ];
%    sprintf ( szError, szFormatRpcFailed, __procedure__,
%              clnt_sperror ( __pClient__, __szHost__ ) );
%    __pClient__	= RPC_CLIENT_DESTROY ( __pClient__ );
%    RPC_CLIENT_CERROR ( szContRpcFailed, szError );
%    Result	= ZeroResult;
%    return Result.ReturnValue;
%  }
%#ifndef MULTITHREAD
%  Result	= * pResult;
%#endif
%
%
%  if ( pResult && pResult->nErrorLvl ) {
%    /* Server returned a user error message: */
%    char	szErrorMsg [ 1024 ];
%    strncpy ( szErrorMsg,
%              ( pResult->pszErrorMsg && pResult->pszErrorMsg [ 0 ] ) ?
%              (LPCSTR) pResult->pszErrorMsg : (LPCSTR) szEmpty,
%              sizeof ( szErrorMsg ) );
%    szErrorMsg [ sizeof ( szErrorMsg ) - 1 ]	= (char) 0;
%    xdr_free ( (xdrproc_t) xdr_fnClientDbMachineSearch_rets, (char *) pResult );
%    RPC_CLIENT_SERROR ( pResult->nErrorLvl, __procedure__,
%                        szErrorMsg );
%  } else {
%    xdr_free ( (xdrproc_t) xdr_fnClientDbMachineSearch_rets, (char *) pResult );
%  }
%
%  return Result.ReturnValue;
%
%} /* fnClientDbMachineSearch */
#endif	/* RPC_CLNT */
%
  fnClientDbMachineDelete_rets fnRpc_fnClientDbMachineDelete ( fnClientDbMachineDelete_args ) =  9 ;
%
#if RPC_SVC
%
%extern SHORTOBJID fnClientDbMachineDelete
%	(SHORTOBJID oShortObjIdHeap ,
%	  int * /* _vector_t<4> */ nAddr);
%
%#ifdef MULTITHREAD
%bool_t
%#else
%fnClientDbMachineDelete_rets *
%#endif
%	PASTE2(fnrpc_fnclientdbmachinedelete_1,_SVCSUFFIX)
%		( fnClientDbMachineDelete_args * pArguments,
%#ifdef MULTITHREAD
%		  fnClientDbMachineDelete_rets * pResult,
%#endif
%		  struct svc_req * pRequest )
%{
%  static const char	__procedure__[]	= "server:fnrpc_fnclientdbmachinedelete_1";
%#ifdef MULTITHREAD
%  typedef bool_t RESULTTYPE;
%#else
%  typedef fnClientDbMachineDelete_rets * RESULTTYPE;
%#endif
%#ifndef MULTITHREAD
%  static fnClientDbMachineDelete_rets	Result;
%  RESULTTYPE			pResult = &Result;
%#endif
%  LPCSTR	pszErrorMsg;
%
%  __pRequest__	= pRequest;
%
%  RPC_SERVER_ENTRY();
%
%#ifndef MULTITHREAD
%  if ( pResult->pszErrorMsg == szEmpty ) {
%    pResult->pszErrorMsg	= NULL;
%  }
%  xdr_free ( (xdrproc_t) xdr_fnClientDbMachineDelete_rets, (char *) pResult );
%#endif
%  pResult->nErrorLvl		= 0;
%
%  Reply.bAnswered		= FALSE;
%  Reply.pfnCalled		= (void(*)()) fnClientDbMachineDelete;
%  Reply.pfnXdrResult		= (bool_t(*)()) xdr_fnClientDbMachineDelete_rets;
%  Reply.pnErrorLvl		= &pResult->nErrorLvl;
%  Reply.ppszErrorMsg		= (LPCSTR *) &pResult->pszErrorMsg;
%  Reply.pResult		= pResult;
%  Reply.pReturnValue		= &pResult->ReturnValue;
%  Reply.nReturnValueSize	= sizeof ( pResult->ReturnValue );
%
%  pResult->ReturnValue		=
%  fnClientDbMachineDelete (
%	pArguments->oShortObjIdHeap,
%	pArguments->nAddr.int_vector_t_val );
%
%  if ( Reply.bAnswered ) {
%    __pRequest__	= NULL;
%    return (RESULTTYPE) NULL;
%  }
%
%  pResult->nErrorLvl	= RPC_SERVER_ERRLVL();
%  if ( pResult->nErrorLvl > 0 ) {
%    pszErrorMsg		= RPC_SERVER_ERRMSG();
%    if ( pszErrorMsg && *pszErrorMsg ) {
%      pResult->pszErrorMsg	= strdup ( pszErrorMsg );
%    }
%  }
%  if ( pResult->pszErrorMsg == NULL ) {
%#ifdef MULTITHREAD
%    pResult->pszErrorMsg	= strdup ( szEmpty );
%#else
%    pResult->pszErrorMsg	= (LPSTR) szEmpty;
%#endif
%  }
%  __pRequest__	= NULL;
%  return (RESULTTYPE) pResult;
%} /* fnrpc_fnclientdbmachinedelete_1 */
#endif	/* RPC_SVC */
%
#if RPC_CLNT
%SHORTOBJID DLLEXPORT fnClientDbMachineDelete
%	(SHORTOBJID oShortObjIdHeap ,
%	  int * /* _vector_t<4> */ nAddr)
%{
%  static const char	__procedure__[]	= "client:fnClientDbMachineDelete";
%  static fnClientDbMachineDelete_rets	ZeroResult;
%  fnClientDbMachineDelete_rets		* pResult = NULL;
%  fnClientDbMachineDelete_rets		Result = ZeroResult;
%  fnClientDbMachineDelete_args	InArguments;
%
%  /* Client initialization: */
%  if ( __bClientInitialize__ ) {
%    __bClientInitialize__	= FALSE;
%    RPC_CLIENT_INITIALIZE();
%  }
%
%#if	CLIENT_CREATE_BY_USER
%  if ( __pClient__ == NULL ) {
%    __pClient__	= RPC_CLIENT_CREATE ( __szHost__, __szTransport__ );
%    if ( __pClient__ == NULL ) {
%      /* Error handling for a not connected client: */
%      char	szError [ 256 ];
%      sprintf ( szError, szFormatNoServer, __procedure__ );
%      RPC_CLIENT_ERROR ( szError );
%      return Result.ReturnValue;
%    }
%  }
%#else
%  while ( __pClient__ == NULL ) {
%    __pClient__	= RPC_CLIENT_CREATE ( __szHost__, __szTransport__ );
%    if ( __pClient__ == NULL ) {
%      /* Error handling for a not connected client: */
%      char	szError [ 256 ];
%      sprintf ( szError, szFormatNoServer, __procedure__ );
%      RPC_CLIENT_CERROR ( szContNoServer, szError );
%    }
%  }
%#endif	/* CLIENT_CREATE_BY_USER */
%
%  /* Copy in the oShortObjIdHeap argument: */
%  InArguments.oShortObjIdHeap	= oShortObjIdHeap;
%  /* Copy in the nAddr argument: */
%  InArguments.nAddr.int_vector_t_len	= 4;
%  InArguments.nAddr.int_vector_t_val	= nAddr;
%  if ( InArguments.nAddr.int_vector_t_len != 0 && nAddr == NULL ) {
%    /* Error handling for passing a NULL pointer on */
%    /* VECTOR declared in argument: */
%    char	szError [ 256 ];
%    InArguments.nAddr.int_vector_t_len	= 0;
%    sprintf ( szError, szFormatNullPassed,
%              __procedure__, "nAddr" );
%    RPC_CLIENT_CERROR ( szContNullPassed, szError );
%  }
%
%  pResult	=
%#ifdef MULTITHREAD
%    (
%#else
%    (fnClientDbMachineDelete_rets *)
%#endif
%    fnrpc_fnclientdbmachinedelete_1 (
%	&InArguments,
%#ifdef MULTITHREAD
%	&Result,
%#endif
%	__pClient__ )
%#ifdef MULTITHREAD
%	== RPC_SUCCESS ) ? &Result : NULL
%#endif
%	;
%
%  if ( pResult == NULL ) {
%    /* Error handling for a failed RPC call, */
%    /* i.e. the server did not respond: */
%    char	szError [ 256 ];
%    sprintf ( szError, szFormatRpcFailed, __procedure__,
%              clnt_sperror ( __pClient__, __szHost__ ) );
%    __pClient__	= RPC_CLIENT_DESTROY ( __pClient__ );
%    RPC_CLIENT_CERROR ( szContRpcFailed, szError );
%    Result	= ZeroResult;
%    return Result.ReturnValue;
%  }
%#ifndef MULTITHREAD
%  Result	= * pResult;
%#endif
%
%
%  if ( pResult && pResult->nErrorLvl ) {
%    /* Server returned a user error message: */
%    char	szErrorMsg [ 1024 ];
%    strncpy ( szErrorMsg,
%              ( pResult->pszErrorMsg && pResult->pszErrorMsg [ 0 ] ) ?
%              (LPCSTR) pResult->pszErrorMsg : (LPCSTR) szEmpty,
%              sizeof ( szErrorMsg ) );
%    szErrorMsg [ sizeof ( szErrorMsg ) - 1 ]	= (char) 0;
%    xdr_free ( (xdrproc_t) xdr_fnClientDbMachineDelete_rets, (char *) pResult );
%    RPC_CLIENT_SERROR ( pResult->nErrorLvl, __procedure__,
%                        szErrorMsg );
%  } else {
%    xdr_free ( (xdrproc_t) xdr_fnClientDbMachineDelete_rets, (char *) pResult );
%  }
%
%  return Result.ReturnValue;
%
%} /* fnClientDbMachineDelete */
#endif	/* RPC_CLNT */
%
  fnClientDbMachineInsert_rets fnRpc_fnClientDbMachineInsert ( fnClientDbMachineInsert_args ) =  10 ;
%
#if RPC_SVC
%
%extern SHORTOBJID fnClientDbMachineInsert
%	(SHORTOBJID oShortObjIdHeap ,
%	  SHORTOBJID oShortMachine);
%
%#ifdef MULTITHREAD
%bool_t
%#else
%fnClientDbMachineInsert_rets *
%#endif
%	PASTE2(fnrpc_fnclientdbmachineinsert_1,_SVCSUFFIX)
%		( fnClientDbMachineInsert_args * pArguments,
%#ifdef MULTITHREAD
%		  fnClientDbMachineInsert_rets * pResult,
%#endif
%		  struct svc_req * pRequest )
%{
%  static const char	__procedure__[]	= "server:fnrpc_fnclientdbmachineinsert_1";
%#ifdef MULTITHREAD
%  typedef bool_t RESULTTYPE;
%#else
%  typedef fnClientDbMachineInsert_rets * RESULTTYPE;
%#endif
%#ifndef MULTITHREAD
%  static fnClientDbMachineInsert_rets	Result;
%  RESULTTYPE			pResult = &Result;
%#endif
%  LPCSTR	pszErrorMsg;
%
%  __pRequest__	= pRequest;
%
%  RPC_SERVER_ENTRY();
%
%#ifndef MULTITHREAD
%  if ( pResult->pszErrorMsg == szEmpty ) {
%    pResult->pszErrorMsg	= NULL;
%  }
%  xdr_free ( (xdrproc_t) xdr_fnClientDbMachineInsert_rets, (char *) pResult );
%#endif
%  pResult->nErrorLvl		= 0;
%
%  Reply.bAnswered		= FALSE;
%  Reply.pfnCalled		= (void(*)()) fnClientDbMachineInsert;
%  Reply.pfnXdrResult		= (bool_t(*)()) xdr_fnClientDbMachineInsert_rets;
%  Reply.pnErrorLvl		= &pResult->nErrorLvl;
%  Reply.ppszErrorMsg		= (LPCSTR *) &pResult->pszErrorMsg;
%  Reply.pResult		= pResult;
%  Reply.pReturnValue		= &pResult->ReturnValue;
%  Reply.nReturnValueSize	= sizeof ( pResult->ReturnValue );
%
%  pResult->ReturnValue		=
%  fnClientDbMachineInsert (
%	pArguments->oShortObjIdHeap,
%	pArguments->oShortMachine );
%
%  if ( Reply.bAnswered ) {
%    __pRequest__	= NULL;
%    return (RESULTTYPE) NULL;
%  }
%
%  pResult->nErrorLvl	= RPC_SERVER_ERRLVL();
%  if ( pResult->nErrorLvl > 0 ) {
%    pszErrorMsg		= RPC_SERVER_ERRMSG();
%    if ( pszErrorMsg && *pszErrorMsg ) {
%      pResult->pszErrorMsg	= strdup ( pszErrorMsg );
%    }
%  }
%  if ( pResult->pszErrorMsg == NULL ) {
%#ifdef MULTITHREAD
%    pResult->pszErrorMsg	= strdup ( szEmpty );
%#else
%    pResult->pszErrorMsg	= (LPSTR) szEmpty;
%#endif
%  }
%  __pRequest__	= NULL;
%  return (RESULTTYPE) pResult;
%} /* fnrpc_fnclientdbmachineinsert_1 */
#endif	/* RPC_SVC */
%
#if RPC_CLNT
%SHORTOBJID DLLEXPORT fnClientDbMachineInsert
%	(SHORTOBJID oShortObjIdHeap ,
%	  SHORTOBJID oShortMachine)
%{
%  static const char	__procedure__[]	= "client:fnClientDbMachineInsert";
%  static fnClientDbMachineInsert_rets	ZeroResult;
%  fnClientDbMachineInsert_rets		* pResult = NULL;
%  fnClientDbMachineInsert_rets		Result = ZeroResult;
%  fnClientDbMachineInsert_args	InArguments;
%
%  /* Client initialization: */
%  if ( __bClientInitialize__ ) {
%    __bClientInitialize__	= FALSE;
%    RPC_CLIENT_INITIALIZE();
%  }
%
%#if	CLIENT_CREATE_BY_USER
%  if ( __pClient__ == NULL ) {
%    __pClient__	= RPC_CLIENT_CREATE ( __szHost__, __szTransport__ );
%    if ( __pClient__ == NULL ) {
%      /* Error handling for a not connected client: */
%      char	szError [ 256 ];
%      sprintf ( szError, szFormatNoServer, __procedure__ );
%      RPC_CLIENT_ERROR ( szError );
%      return Result.ReturnValue;
%    }
%  }
%#else
%  while ( __pClient__ == NULL ) {
%    __pClient__	= RPC_CLIENT_CREATE ( __szHost__, __szTransport__ );
%    if ( __pClient__ == NULL ) {
%      /* Error handling for a not connected client: */
%      char	szError [ 256 ];
%      sprintf ( szError, szFormatNoServer, __procedure__ );
%      RPC_CLIENT_CERROR ( szContNoServer, szError );
%    }
%  }
%#endif	/* CLIENT_CREATE_BY_USER */
%
%  /* Copy in the oShortObjIdHeap argument: */
%  InArguments.oShortObjIdHeap	= oShortObjIdHeap;
%  /* Copy in the oShortMachine argument: */
%  InArguments.oShortMachine	= oShortMachine;
%
%  pResult	=
%#ifdef MULTITHREAD
%    (
%#else
%    (fnClientDbMachineInsert_rets *)
%#endif
%    fnrpc_fnclientdbmachineinsert_1 (
%	&InArguments,
%#ifdef MULTITHREAD
%	&Result,
%#endif
%	__pClient__ )
%#ifdef MULTITHREAD
%	== RPC_SUCCESS ) ? &Result : NULL
%#endif
%	;
%
%  if ( pResult == NULL ) {
%    /* Error handling for a failed RPC call, */
%    /* i.e. the server did not respond: */
%    char	szError [ 256 ];
%    sprintf ( szError, szFormatRpcFailed, __procedure__,
%              clnt_sperror ( __pClient__, __szHost__ ) );
%    __pClient__	= RPC_CLIENT_DESTROY ( __pClient__ );
%    RPC_CLIENT_CERROR ( szContRpcFailed, szError );
%    Result	= ZeroResult;
%    return Result.ReturnValue;
%  }
%#ifndef MULTITHREAD
%  Result	= * pResult;
%#endif
%
%
%  if ( pResult && pResult->nErrorLvl ) {
%    /* Server returned a user error message: */
%    char	szErrorMsg [ 1024 ];
%    strncpy ( szErrorMsg,
%              ( pResult->pszErrorMsg && pResult->pszErrorMsg [ 0 ] ) ?
%              (LPCSTR) pResult->pszErrorMsg : (LPCSTR) szEmpty,
%              sizeof ( szErrorMsg ) );
%    szErrorMsg [ sizeof ( szErrorMsg ) - 1 ]	= (char) 0;
%    xdr_free ( (xdrproc_t) xdr_fnClientDbMachineInsert_rets, (char *) pResult );
%    RPC_CLIENT_SERROR ( pResult->nErrorLvl, __procedure__,
%                        szErrorMsg );
%  } else {
%    xdr_free ( (xdrproc_t) xdr_fnClientDbMachineInsert_rets, (char *) pResult );
%  }
%
%  return Result.ReturnValue;
%
%} /* fnClientDbMachineInsert */
#endif	/* RPC_CLNT */
%
  fnClientDbMachines_rets fnRpc_fnClientDbMachines ( SHORTOBJID ) =  11 ;
%
#if RPC_SVC
%
%extern SHORTOBJID fnClientDbMachines
%	(SHORTOBJID oShortObjIdHeap);
%
%#ifdef MULTITHREAD
%bool_t
%#else
%fnClientDbMachines_rets *
%#endif
%	PASTE2(fnrpc_fnclientdbmachines_1,_SVCSUFFIX)
%		( SHORTOBJID * pArguments,
%#ifdef MULTITHREAD
%		  fnClientDbMachines_rets * pResult,
%#endif
%		  struct svc_req * pRequest )
%{
%  static const char	__procedure__[]	= "server:fnrpc_fnclientdbmachines_1";
%#ifdef MULTITHREAD
%  typedef bool_t RESULTTYPE;
%#else
%  typedef fnClientDbMachines_rets * RESULTTYPE;
%#endif
%#ifndef MULTITHREAD
%  static fnClientDbMachines_rets	Result;
%  RESULTTYPE			pResult = &Result;
%#endif
%  LPCSTR	pszErrorMsg;
%
%  __pRequest__	= pRequest;
%
%  RPC_SERVER_ENTRY();
%
%#ifndef MULTITHREAD
%  if ( pResult->pszErrorMsg == szEmpty ) {
%    pResult->pszErrorMsg	= NULL;
%  }
%  xdr_free ( (xdrproc_t) xdr_fnClientDbMachines_rets, (char *) pResult );
%#endif
%  pResult->nErrorLvl		= 0;
%
%  Reply.bAnswered		= FALSE;
%  Reply.pfnCalled		= (void(*)()) fnClientDbMachines;
%  Reply.pfnXdrResult		= (bool_t(*)()) xdr_fnClientDbMachines_rets;
%  Reply.pnErrorLvl		= &pResult->nErrorLvl;
%  Reply.ppszErrorMsg		= (LPCSTR *) &pResult->pszErrorMsg;
%  Reply.pResult		= pResult;
%  Reply.pReturnValue		= &pResult->ReturnValue;
%  Reply.nReturnValueSize	= sizeof ( pResult->ReturnValue );
%
%  pResult->ReturnValue		=
%  fnClientDbMachines (
%	(*pArguments) );
%
%  if ( Reply.bAnswered ) {
%    __pRequest__	= NULL;
%    return (RESULTTYPE) NULL;
%  }
%
%  pResult->nErrorLvl	= RPC_SERVER_ERRLVL();
%  if ( pResult->nErrorLvl > 0 ) {
%    pszErrorMsg		= RPC_SERVER_ERRMSG();
%    if ( pszErrorMsg && *pszErrorMsg ) {
%      pResult->pszErrorMsg	= strdup ( pszErrorMsg );
%    }
%  }
%  if ( pResult->pszErrorMsg == NULL ) {
%#ifdef MULTITHREAD
%    pResult->pszErrorMsg	= strdup ( szEmpty );
%#else
%    pResult->pszErrorMsg	= (LPSTR) szEmpty;
%#endif
%  }
%  __pRequest__	= NULL;
%  return (RESULTTYPE) pResult;
%} /* fnrpc_fnclientdbmachines_1 */
#endif	/* RPC_SVC */
%
#if RPC_CLNT
%SHORTOBJID DLLEXPORT fnClientDbMachines
%	(SHORTOBJID oShortObjIdHeap)
%{
%  static const char	__procedure__[]	= "client:fnClientDbMachines";
%  static fnClientDbMachines_rets	ZeroResult;
%  fnClientDbMachines_rets		* pResult = NULL;
%  fnClientDbMachines_rets		Result = ZeroResult;
%
%  /* Client initialization: */
%  if ( __bClientInitialize__ ) {
%    __bClientInitialize__	= FALSE;
%    RPC_CLIENT_INITIALIZE();
%  }
%
%#if	CLIENT_CREATE_BY_USER
%  if ( __pClient__ == NULL ) {
%    __pClient__	= RPC_CLIENT_CREATE ( __szHost__, __szTransport__ );
%    if ( __pClient__ == NULL ) {
%      /* Error handling for a not connected client: */
%      char	szError [ 256 ];
%      sprintf ( szError, szFormatNoServer, __procedure__ );
%      RPC_CLIENT_ERROR ( szError );
%      return Result.ReturnValue;
%    }
%  }
%#else
%  while ( __pClient__ == NULL ) {
%    __pClient__	= RPC_CLIENT_CREATE ( __szHost__, __szTransport__ );
%    if ( __pClient__ == NULL ) {
%      /* Error handling for a not connected client: */
%      char	szError [ 256 ];
%      sprintf ( szError, szFormatNoServer, __procedure__ );
%      RPC_CLIENT_CERROR ( szContNoServer, szError );
%    }
%  }
%#endif	/* CLIENT_CREATE_BY_USER */
%
%  pResult	=
%#ifdef MULTITHREAD
%    (
%#else
%    (fnClientDbMachines_rets *)
%#endif
%    fnrpc_fnclientdbmachines_1 (
%	&oShortObjIdHeap,
%#ifdef MULTITHREAD
%	&Result,
%#endif
%	__pClient__ )
%#ifdef MULTITHREAD
%	== RPC_SUCCESS ) ? &Result : NULL
%#endif
%	;
%
%  if ( pResult == NULL ) {
%    /* Error handling for a failed RPC call, */
%    /* i.e. the server did not respond: */
%    char	szError [ 256 ];
%    sprintf ( szError, szFormatRpcFailed, __procedure__,
%              clnt_sperror ( __pClient__, __szHost__ ) );
%    __pClient__	= RPC_CLIENT_DESTROY ( __pClient__ );
%    RPC_CLIENT_CERROR ( szContRpcFailed, szError );
%    Result	= ZeroResult;
%    return Result.ReturnValue;
%  }
%#ifndef MULTITHREAD
%  Result	= * pResult;
%#endif
%
%
%  if ( pResult && pResult->nErrorLvl ) {
%    /* Server returned a user error message: */
%    char	szErrorMsg [ 1024 ];
%    strncpy ( szErrorMsg,
%              ( pResult->pszErrorMsg && pResult->pszErrorMsg [ 0 ] ) ?
%              (LPCSTR) pResult->pszErrorMsg : (LPCSTR) szEmpty,
%              sizeof ( szErrorMsg ) );
%    szErrorMsg [ sizeof ( szErrorMsg ) - 1 ]	= (char) 0;
%    xdr_free ( (xdrproc_t) xdr_fnClientDbMachines_rets, (char *) pResult );
%    RPC_CLIENT_SERROR ( pResult->nErrorLvl, __procedure__,
%                        szErrorMsg );
%  } else {
%    xdr_free ( (xdrproc_t) xdr_fnClientDbMachines_rets, (char *) pResult );
%  }
%
%  return Result.ReturnValue;
%
%} /* fnClientDbMachines */
#endif	/* RPC_CLNT */
%
  fnServerGetPortByDirectory_rets fnRpc_fnServerGetPortByDirectory ( fnServerGetPortByDirectory_args ) =  12 ;
%
#if RPC_SVC
%
%extern int fnServerGetPortByDirectory
%	(string_t /* string_t<@conststring@> */ szDirectory ,
%	  GETACTION eAction);
%
%#ifdef MULTITHREAD
%bool_t
%#else
%fnServerGetPortByDirectory_rets *
%#endif
%	PASTE2(fnrpc_fnservergetportbydirectory_1,_SVCSUFFIX)
%		( fnServerGetPortByDirectory_args * pArguments,
%#ifdef MULTITHREAD
%		  fnServerGetPortByDirectory_rets * pResult,
%#endif
%		  struct svc_req * pRequest )
%{
%  static const char	__procedure__[]	= "server:fnrpc_fnservergetportbydirectory_1";
%#ifdef MULTITHREAD
%  typedef bool_t RESULTTYPE;
%#else
%  typedef fnServerGetPortByDirectory_rets * RESULTTYPE;
%#endif
%#ifndef MULTITHREAD
%  static fnServerGetPortByDirectory_rets	Result;
%  RESULTTYPE			pResult = &Result;
%#endif
%  LPCSTR	pszErrorMsg;
%
%  __pRequest__	= pRequest;
%
%  RPC_SERVER_ENTRY();
%
%#ifndef MULTITHREAD
%  if ( pResult->pszErrorMsg == szEmpty ) {
%    pResult->pszErrorMsg	= NULL;
%  }
%  xdr_free ( (xdrproc_t) xdr_fnServerGetPortByDirectory_rets, (char *) pResult );
%#endif
%  pResult->nErrorLvl		= 0;
%
%  Reply.bAnswered		= FALSE;
%  Reply.pfnCalled		= (void(*)()) fnServerGetPortByDirectory;
%  Reply.pfnXdrResult		= (bool_t(*)()) xdr_fnServerGetPortByDirectory_rets;
%  Reply.pnErrorLvl		= &pResult->nErrorLvl;
%  Reply.ppszErrorMsg		= (LPCSTR *) &pResult->pszErrorMsg;
%  Reply.pResult		= pResult;
%  Reply.pReturnValue		= &pResult->ReturnValue;
%  Reply.nReturnValueSize	= sizeof ( pResult->ReturnValue );
%
%  pResult->ReturnValue		=
%  fnServerGetPortByDirectory (
%	pArguments->szDirectory,
%	pArguments->eAction );
%
%  if ( Reply.bAnswered ) {
%    __pRequest__	= NULL;
%    return (RESULTTYPE) NULL;
%  }
%
%  pResult->nErrorLvl	= RPC_SERVER_ERRLVL();
%  if ( pResult->nErrorLvl > 0 ) {
%    pszErrorMsg		= RPC_SERVER_ERRMSG();
%    if ( pszErrorMsg && *pszErrorMsg ) {
%      pResult->pszErrorMsg	= strdup ( pszErrorMsg );
%    }
%  }
%  if ( pResult->pszErrorMsg == NULL ) {
%#ifdef MULTITHREAD
%    pResult->pszErrorMsg	= strdup ( szEmpty );
%#else
%    pResult->pszErrorMsg	= (LPSTR) szEmpty;
%#endif
%  }
%  __pRequest__	= NULL;
%  return (RESULTTYPE) pResult;
%} /* fnrpc_fnservergetportbydirectory_1 */
#endif	/* RPC_SVC */
%
#if RPC_CLNT
%int DLLEXPORT fnServerGetPortByDirectory
%	(string_t /* string_t<@conststring@> */ szDirectory ,
%	  GETACTION eAction)
%{
%  static const char	__procedure__[]	= "client:fnServerGetPortByDirectory";
%  static fnServerGetPortByDirectory_rets	ZeroResult;
%  fnServerGetPortByDirectory_rets		* pResult = NULL;
%  fnServerGetPortByDirectory_rets		Result = ZeroResult;
%  fnServerGetPortByDirectory_args	InArguments;
%
%  /* Client initialization: */
%  if ( __bClientInitialize__ ) {
%    __bClientInitialize__	= FALSE;
%    RPC_CLIENT_INITIALIZE();
%  }
%
%#if	CLIENT_CREATE_BY_USER
%  if ( __pClient__ == NULL ) {
%    __pClient__	= RPC_CLIENT_CREATE ( __szHost__, __szTransport__ );
%    if ( __pClient__ == NULL ) {
%      /* Error handling for a not connected client: */
%      char	szError [ 256 ];
%      sprintf ( szError, szFormatNoServer, __procedure__ );
%      RPC_CLIENT_ERROR ( szError );
%      return Result.ReturnValue;
%    }
%  }
%#else
%  while ( __pClient__ == NULL ) {
%    __pClient__	= RPC_CLIENT_CREATE ( __szHost__, __szTransport__ );
%    if ( __pClient__ == NULL ) {
%      /* Error handling for a not connected client: */
%      char	szError [ 256 ];
%      sprintf ( szError, szFormatNoServer, __procedure__ );
%      RPC_CLIENT_CERROR ( szContNoServer, szError );
%    }
%  }
%#endif	/* CLIENT_CREATE_BY_USER */
%
%  /* Copy in the szDirectory argument: */
%  InArguments.szDirectory	= szDirectory;
%  if ( szDirectory == NULL ) {
%    /* Error handling for passing a NULL string pointer: */
%    char	szError [ 256 ];
%    InArguments.szDirectory	= (LPSTR) szEmpty;
%    sprintf ( szError, szFormatNullString,
%              __procedure__, "szDirectory" );
%    RPC_CLIENT_CERROR ( szContNullString, szError );
%  }
%  /* Copy in the eAction argument: */
%  InArguments.eAction	= eAction;
%
%  pResult	=
%#ifdef MULTITHREAD
%    (
%#else
%    (fnServerGetPortByDirectory_rets *)
%#endif
%    fnrpc_fnservergetportbydirectory_1 (
%	&InArguments,
%#ifdef MULTITHREAD
%	&Result,
%#endif
%	__pClient__ )
%#ifdef MULTITHREAD
%	== RPC_SUCCESS ) ? &Result : NULL
%#endif
%	;
%
%  if ( pResult == NULL ) {
%    /* Error handling for a failed RPC call, */
%    /* i.e. the server did not respond: */
%    char	szError [ 256 ];
%    sprintf ( szError, szFormatRpcFailed, __procedure__,
%              clnt_sperror ( __pClient__, __szHost__ ) );
%    __pClient__	= RPC_CLIENT_DESTROY ( __pClient__ );
%    RPC_CLIENT_CERROR ( szContRpcFailed, szError );
%    Result	= ZeroResult;
%    return Result.ReturnValue;
%  }
%#ifndef MULTITHREAD
%  Result	= * pResult;
%#endif
%
%
%  if ( pResult && pResult->nErrorLvl ) {
%    /* Server returned a user error message: */
%    char	szErrorMsg [ 1024 ];
%    strncpy ( szErrorMsg,
%              ( pResult->pszErrorMsg && pResult->pszErrorMsg [ 0 ] ) ?
%              (LPCSTR) pResult->pszErrorMsg : (LPCSTR) szEmpty,
%              sizeof ( szErrorMsg ) );
%    szErrorMsg [ sizeof ( szErrorMsg ) - 1 ]	= (char) 0;
%    xdr_free ( (xdrproc_t) xdr_fnServerGetPortByDirectory_rets, (char *) pResult );
%    RPC_CLIENT_SERROR ( pResult->nErrorLvl, __procedure__,
%                        szErrorMsg );
%  } else {
%    xdr_free ( (xdrproc_t) xdr_fnServerGetPortByDirectory_rets, (char *) pResult );
%  }
%
%  return Result.ReturnValue;
%
%} /* fnServerGetPortByDirectory */
#endif	/* RPC_CLNT */
%
  fnServerGetPID_rets fnRpc_fnServerGetPID ( void ) =  13 ;
%
#if RPC_SVC
%
%extern int fnServerGetPID
%	(void);
%
%#ifdef MULTITHREAD
%bool_t
%#else
%fnServerGetPID_rets *
%#endif
%	PASTE2(fnrpc_fnservergetpid_1,_SVCSUFFIX)
%		( void * pArguments,
%#ifdef MULTITHREAD
%		  fnServerGetPID_rets * pResult,
%#endif
%		  struct svc_req * pRequest )
%{
%  static const char	__procedure__[]	= "server:fnrpc_fnservergetpid_1";
%#ifdef MULTITHREAD
%  typedef bool_t RESULTTYPE;
%#else
%  typedef fnServerGetPID_rets * RESULTTYPE;
%#endif
%#ifndef MULTITHREAD
%  static fnServerGetPID_rets	Result;
%  RESULTTYPE			pResult = &Result;
%#endif
%  LPCSTR	pszErrorMsg;
%
%  __pRequest__	= pRequest;
%
%  RPC_SERVER_ENTRY();
%
%#ifndef MULTITHREAD
%  if ( pResult->pszErrorMsg == szEmpty ) {
%    pResult->pszErrorMsg	= NULL;
%  }
%  xdr_free ( (xdrproc_t) xdr_fnServerGetPID_rets, (char *) pResult );
%#endif
%  pResult->nErrorLvl		= 0;
%
%  Reply.bAnswered		= FALSE;
%  Reply.pfnCalled		= (void(*)()) fnServerGetPID;
%  Reply.pfnXdrResult		= (bool_t(*)()) xdr_fnServerGetPID_rets;
%  Reply.pnErrorLvl		= &pResult->nErrorLvl;
%  Reply.ppszErrorMsg		= (LPCSTR *) &pResult->pszErrorMsg;
%  Reply.pResult		= pResult;
%  Reply.pReturnValue		= &pResult->ReturnValue;
%  Reply.nReturnValueSize	= sizeof ( pResult->ReturnValue );
%
%  pResult->ReturnValue		=
%  fnServerGetPID (
%	);
%
%  if ( Reply.bAnswered ) {
%    __pRequest__	= NULL;
%    return (RESULTTYPE) NULL;
%  }
%
%  pResult->nErrorLvl	= RPC_SERVER_ERRLVL();
%  if ( pResult->nErrorLvl > 0 ) {
%    pszErrorMsg		= RPC_SERVER_ERRMSG();
%    if ( pszErrorMsg && *pszErrorMsg ) {
%      pResult->pszErrorMsg	= strdup ( pszErrorMsg );
%    }
%  }
%  if ( pResult->pszErrorMsg == NULL ) {
%#ifdef MULTITHREAD
%    pResult->pszErrorMsg	= strdup ( szEmpty );
%#else
%    pResult->pszErrorMsg	= (LPSTR) szEmpty;
%#endif
%  }
%  __pRequest__	= NULL;
%  return (RESULTTYPE) pResult;
%} /* fnrpc_fnservergetpid_1 */
#endif	/* RPC_SVC */
%
#if RPC_CLNT
%int DLLEXPORT fnServerGetPID
%	(void)
%{
%  static const char	__procedure__[]	= "client:fnServerGetPID";
%  static fnServerGetPID_rets	ZeroResult;
%  fnServerGetPID_rets		* pResult = NULL;
%  fnServerGetPID_rets		Result = ZeroResult;
%
%  /* Client initialization: */
%  if ( __bClientInitialize__ ) {
%    __bClientInitialize__	= FALSE;
%    RPC_CLIENT_INITIALIZE();
%  }
%
%#if	CLIENT_CREATE_BY_USER
%  if ( __pClient__ == NULL ) {
%    __pClient__	= RPC_CLIENT_CREATE ( __szHost__, __szTransport__ );
%    if ( __pClient__ == NULL ) {
%      /* Error handling for a not connected client: */
%      char	szError [ 256 ];
%      sprintf ( szError, szFormatNoServer, __procedure__ );
%      RPC_CLIENT_ERROR ( szError );
%      return Result.ReturnValue;
%    }
%  }
%#else
%  while ( __pClient__ == NULL ) {
%    __pClient__	= RPC_CLIENT_CREATE ( __szHost__, __szTransport__ );
%    if ( __pClient__ == NULL ) {
%      /* Error handling for a not connected client: */
%      char	szError [ 256 ];
%      sprintf ( szError, szFormatNoServer, __procedure__ );
%      RPC_CLIENT_CERROR ( szContNoServer, szError );
%    }
%  }
%#endif	/* CLIENT_CREATE_BY_USER */
%
%  pResult	=
%#ifdef MULTITHREAD
%    (
%#else
%    (fnServerGetPID_rets *)
%#endif
%    fnrpc_fnservergetpid_1 (
%	NULL,
%#ifdef MULTITHREAD
%	&Result,
%#endif
%	__pClient__ )
%#ifdef MULTITHREAD
%	== RPC_SUCCESS ) ? &Result : NULL
%#endif
%	;
%
%  if ( pResult == NULL ) {
%    /* Error handling for a failed RPC call, */
%    /* i.e. the server did not respond: */
%    char	szError [ 256 ];
%    sprintf ( szError, szFormatRpcFailed, __procedure__,
%              clnt_sperror ( __pClient__, __szHost__ ) );
%    __pClient__	= RPC_CLIENT_DESTROY ( __pClient__ );
%    RPC_CLIENT_CERROR ( szContRpcFailed, szError );
%    Result	= ZeroResult;
%    return Result.ReturnValue;
%  }
%#ifndef MULTITHREAD
%  Result	= * pResult;
%#endif
%
%
%  if ( pResult && pResult->nErrorLvl ) {
%    /* Server returned a user error message: */
%    char	szErrorMsg [ 1024 ];
%    strncpy ( szErrorMsg,
%              ( pResult->pszErrorMsg && pResult->pszErrorMsg [ 0 ] ) ?
%              (LPCSTR) pResult->pszErrorMsg : (LPCSTR) szEmpty,
%              sizeof ( szErrorMsg ) );
%    szErrorMsg [ sizeof ( szErrorMsg ) - 1 ]	= (char) 0;
%    xdr_free ( (xdrproc_t) xdr_fnServerGetPID_rets, (char *) pResult );
%    RPC_CLIENT_SERROR ( pResult->nErrorLvl, __procedure__,
%                        szErrorMsg );
%  } else {
%    xdr_free ( (xdrproc_t) xdr_fnServerGetPID_rets, (char *) pResult );
%  }
%
%  return Result.ReturnValue;
%
%} /* fnServerGetPID */
#endif	/* RPC_CLNT */
%
  fnServerGetDirectory_rets fnRpc_fnServerGetDirectory ( fnServerGetDirectory_args ) =  14 ;
%
#if RPC_SVC
%
%extern int fnServerGetDirectory
%	(int nDirectory ,
%	  string_t /* string_t<nDirectory> */  szDirectory);
%
%#ifdef MULTITHREAD
%bool_t
%#else
%fnServerGetDirectory_rets *
%#endif
%	PASTE2(fnrpc_fnservergetdirectory_1,_SVCSUFFIX)
%		( fnServerGetDirectory_args * pArguments,
%#ifdef MULTITHREAD
%		  fnServerGetDirectory_rets * pResult,
%#endif
%		  struct svc_req * pRequest )
%{
%  static const char	__procedure__[]	= "server:fnrpc_fnservergetdirectory_1";
%#ifdef MULTITHREAD
%  typedef bool_t RESULTTYPE;
%#else
%  typedef fnServerGetDirectory_rets * RESULTTYPE;
%#endif
%#ifndef MULTITHREAD
%  static fnServerGetDirectory_rets	Result;
%  RESULTTYPE			pResult = &Result;
%#endif
%  LPCSTR	pszErrorMsg;
%
%  __pRequest__	= pRequest;
%
%  RPC_SERVER_ENTRY();
%
%#ifndef MULTITHREAD
%  if ( pResult->pszErrorMsg == szEmpty ) {
%    pResult->pszErrorMsg	= NULL;
%  }
%  xdr_free ( (xdrproc_t) xdr_fnServerGetDirectory_rets, (char *) pResult );
%#endif
%  pResult->nErrorLvl		= 0;
%
%  if ( pArguments->szDirectorySize == 0 ) {
%    pResult->szDirectory	= NULL;
%  } else {
%    pResult->szDirectory	=
%    (string_t) malloc ( pArguments->szDirectorySize );
%    if ( pResult->szDirectory == NULL ) {
%      char	szError [ 256 ];
%      sprintf ( szError, szFormatMallocFailed,
%                __procedure__, pArguments->szDirectorySize );
%      RPC_SERVER_ERROR ( szError );
%      return (RESULTTYPE) NULL;
%    }
%  }
%  Reply.bAnswered		= FALSE;
%  Reply.pfnCalled		= (void(*)()) fnServerGetDirectory;
%  Reply.pfnXdrResult		= (bool_t(*)()) xdr_fnServerGetDirectory_rets;
%  Reply.pnErrorLvl		= &pResult->nErrorLvl;
%  Reply.ppszErrorMsg		= (LPCSTR *) &pResult->pszErrorMsg;
%  Reply.pResult		= pResult;
%  Reply.pReturnValue		= &pResult->ReturnValue;
%  Reply.nReturnValueSize	= sizeof ( pResult->ReturnValue );
%
%  pResult->ReturnValue		=
%  fnServerGetDirectory (
%	pArguments->nDirectory,
%	pResult->szDirectory );
%
%  if ( Reply.bAnswered ) {
%    __pRequest__	= NULL;
%    return (RESULTTYPE) NULL;
%  }
%
%  pResult->nErrorLvl	= RPC_SERVER_ERRLVL();
%  if ( pResult->nErrorLvl > 0 ) {
%    pszErrorMsg		= RPC_SERVER_ERRMSG();
%    if ( pszErrorMsg && *pszErrorMsg ) {
%      pResult->pszErrorMsg	= strdup ( pszErrorMsg );
%    }
%  }
%  if ( pResult->pszErrorMsg == NULL ) {
%#ifdef MULTITHREAD
%    pResult->pszErrorMsg	= strdup ( szEmpty );
%#else
%    pResult->pszErrorMsg	= (LPSTR) szEmpty;
%#endif
%  }
%  __pRequest__	= NULL;
%  return (RESULTTYPE) pResult;
%} /* fnrpc_fnservergetdirectory_1 */
#endif	/* RPC_SVC */
%
#if RPC_CLNT
%int DLLEXPORT fnServerGetDirectory
%	(int nDirectory ,
%	  string_t /* string_t<nDirectory> */  szDirectory)
%{
%  static const char	__procedure__[]	= "client:fnServerGetDirectory";
%  static fnServerGetDirectory_rets	ZeroResult;
%  fnServerGetDirectory_rets		* pResult = NULL;
%  fnServerGetDirectory_rets		Result = ZeroResult;
%  fnServerGetDirectory_args	InArguments;
%
%  /* Client initialization: */
%  if ( __bClientInitialize__ ) {
%    __bClientInitialize__	= FALSE;
%    RPC_CLIENT_INITIALIZE();
%  }
%
%#if	CLIENT_CREATE_BY_USER
%  if ( __pClient__ == NULL ) {
%    __pClient__	= RPC_CLIENT_CREATE ( __szHost__, __szTransport__ );
%    if ( __pClient__ == NULL ) {
%      /* Error handling for a not connected client: */
%      char	szError [ 256 ];
%      sprintf ( szError, szFormatNoServer, __procedure__ );
%      RPC_CLIENT_ERROR ( szError );
%      return Result.ReturnValue;
%    }
%  }
%#else
%  while ( __pClient__ == NULL ) {
%    __pClient__	= RPC_CLIENT_CREATE ( __szHost__, __szTransport__ );
%    if ( __pClient__ == NULL ) {
%      /* Error handling for a not connected client: */
%      char	szError [ 256 ];
%      sprintf ( szError, szFormatNoServer, __procedure__ );
%      RPC_CLIENT_CERROR ( szContNoServer, szError );
%    }
%  }
%#endif	/* CLIENT_CREATE_BY_USER */
%
%  /* Copy in the nDirectory argument: */
%  InArguments.nDirectory	= nDirectory;
%  InArguments.szDirectorySize	= nDirectory;
%
%  pResult	=
%#ifdef MULTITHREAD
%    (
%#else
%    (fnServerGetDirectory_rets *)
%#endif
%    fnrpc_fnservergetdirectory_1 (
%	&InArguments,
%#ifdef MULTITHREAD
%	&Result,
%#endif
%	__pClient__ )
%#ifdef MULTITHREAD
%	== RPC_SUCCESS ) ? &Result : NULL
%#endif
%	;
%
%  if ( pResult == NULL ) {
%    /* Error handling for a failed RPC call, */
%    /* i.e. the server did not respond: */
%    char	szError [ 256 ];
%    sprintf ( szError, szFormatRpcFailed, __procedure__,
%              clnt_sperror ( __pClient__, __szHost__ ) );
%    __pClient__	= RPC_CLIENT_DESTROY ( __pClient__ );
%    RPC_CLIENT_CERROR ( szContRpcFailed, szError );
%    Result	= ZeroResult;
%    return Result.ReturnValue;
%  }
%#ifndef MULTITHREAD
%  Result	= * pResult;
%#endif
%
%  /* Copy out the szDirectory argument: */
%  if ( ! ( 
%       pResult->szDirectory
%       && *(pResult->szDirectory) &&
%       szDirectory == NULL ) ) {
%    if ( szDirectory != NULL ) {
%      if ( pResult->szDirectory != NULL ) {
%        strncpy ( szDirectory, pResult->szDirectory, nDirectory );
%      } else {
%        *szDirectory	= (char) 0;
%      }
%    }
%  }
%
%  if ( pResult && pResult->nErrorLvl ) {
%    /* Server returned a user error message: */
%    char	szErrorMsg [ 1024 ];
%    strncpy ( szErrorMsg,
%              ( pResult->pszErrorMsg && pResult->pszErrorMsg [ 0 ] ) ?
%              (LPCSTR) pResult->pszErrorMsg : (LPCSTR) szEmpty,
%              sizeof ( szErrorMsg ) );
%    szErrorMsg [ sizeof ( szErrorMsg ) - 1 ]	= (char) 0;
%    xdr_free ( (xdrproc_t) xdr_fnServerGetDirectory_rets, (char *) pResult );
%    RPC_CLIENT_SERROR ( pResult->nErrorLvl, __procedure__,
%                        szErrorMsg );
%  } else {
%    xdr_free ( (xdrproc_t) xdr_fnServerGetDirectory_rets, (char *) pResult );
%  }
%  if ( 
%       Result.szDirectory
%       && *(Result.szDirectory) &&
%       szDirectory == NULL ) {
%    /* Error handling for passing a NULL pointer on */
%    /* out argument: */
%    char	szError [ 256 ];
%    sprintf ( szError, szFormatNullPassed,
%              __procedure__, "szDirectory" );
%    RPC_CLIENT_CERROR ( szContNullOutPassed, szError );
%  }
%
%  return Result.ReturnValue;
%
%} /* fnServerGetDirectory */
#endif	/* RPC_CLNT */
%
  fnServerExit_rets fnRpc_fnServerExit ( fnServerExit_args ) =  15 ;
%
#if RPC_SVC
%
%extern bool_t fnServerExit
%	(SHORTOBJID oShortObjIdHeap ,
%	  bool_t bForceExit);
%
%#ifdef MULTITHREAD
%bool_t
%#else
%fnServerExit_rets *
%#endif
%	PASTE2(fnrpc_fnserverexit_1,_SVCSUFFIX)
%		( fnServerExit_args * pArguments,
%#ifdef MULTITHREAD
%		  fnServerExit_rets * pResult,
%#endif
%		  struct svc_req * pRequest )
%{
%  static const char	__procedure__[]	= "server:fnrpc_fnserverexit_1";
%#ifdef MULTITHREAD
%  typedef bool_t RESULTTYPE;
%#else
%  typedef fnServerExit_rets * RESULTTYPE;
%#endif
%#ifndef MULTITHREAD
%  static fnServerExit_rets	Result;
%  RESULTTYPE			pResult = &Result;
%#endif
%  LPCSTR	pszErrorMsg;
%
%  __pRequest__	= pRequest;
%
%  RPC_SERVER_ENTRY();
%
%#ifndef MULTITHREAD
%  if ( pResult->pszErrorMsg == szEmpty ) {
%    pResult->pszErrorMsg	= NULL;
%  }
%  xdr_free ( (xdrproc_t) xdr_fnServerExit_rets, (char *) pResult );
%#endif
%  pResult->nErrorLvl		= 0;
%
%  Reply.bAnswered		= FALSE;
%  Reply.pfnCalled		= (void(*)()) fnServerExit;
%  Reply.pfnXdrResult		= (bool_t(*)()) xdr_fnServerExit_rets;
%  Reply.pnErrorLvl		= &pResult->nErrorLvl;
%  Reply.ppszErrorMsg		= (LPCSTR *) &pResult->pszErrorMsg;
%  Reply.pResult		= pResult;
%  Reply.pReturnValue		= &pResult->ReturnValue;
%  Reply.nReturnValueSize	= sizeof ( pResult->ReturnValue );
%
%  pResult->ReturnValue		=
%  fnServerExit (
%	pArguments->oShortObjIdHeap,
%	pArguments->bForceExit );
%
%  if ( Reply.bAnswered ) {
%    __pRequest__	= NULL;
%    return (RESULTTYPE) NULL;
%  }
%
%  pResult->nErrorLvl	= RPC_SERVER_ERRLVL();
%  if ( pResult->nErrorLvl > 0 ) {
%    pszErrorMsg		= RPC_SERVER_ERRMSG();
%    if ( pszErrorMsg && *pszErrorMsg ) {
%      pResult->pszErrorMsg	= strdup ( pszErrorMsg );
%    }
%  }
%  if ( pResult->pszErrorMsg == NULL ) {
%#ifdef MULTITHREAD
%    pResult->pszErrorMsg	= strdup ( szEmpty );
%#else
%    pResult->pszErrorMsg	= (LPSTR) szEmpty;
%#endif
%  }
%  __pRequest__	= NULL;
%  return (RESULTTYPE) pResult;
%} /* fnrpc_fnserverexit_1 */
#endif	/* RPC_SVC */
%
#if RPC_CLNT
%bool_t DLLEXPORT fnServerExit
%	(SHORTOBJID oShortObjIdHeap ,
%	  bool_t bForceExit)
%{
%  static const char	__procedure__[]	= "client:fnServerExit";
%  static fnServerExit_rets	ZeroResult;
%  fnServerExit_rets		* pResult = NULL;
%  fnServerExit_rets		Result = ZeroResult;
%  fnServerExit_args	InArguments;
%
%  /* Client initialization: */
%  if ( __bClientInitialize__ ) {
%    __bClientInitialize__	= FALSE;
%    RPC_CLIENT_INITIALIZE();
%  }
%
%#if	CLIENT_CREATE_BY_USER
%  if ( __pClient__ == NULL ) {
%    __pClient__	= RPC_CLIENT_CREATE ( __szHost__, __szTransport__ );
%    if ( __pClient__ == NULL ) {
%      /* Error handling for a not connected client: */
%      char	szError [ 256 ];
%      sprintf ( szError, szFormatNoServer, __procedure__ );
%      RPC_CLIENT_ERROR ( szError );
%      return Result.ReturnValue;
%    }
%  }
%#else
%  while ( __pClient__ == NULL ) {
%    __pClient__	= RPC_CLIENT_CREATE ( __szHost__, __szTransport__ );
%    if ( __pClient__ == NULL ) {
%      /* Error handling for a not connected client: */
%      char	szError [ 256 ];
%      sprintf ( szError, szFormatNoServer, __procedure__ );
%      RPC_CLIENT_CERROR ( szContNoServer, szError );
%    }
%  }
%#endif	/* CLIENT_CREATE_BY_USER */
%
%  /* Copy in the oShortObjIdHeap argument: */
%  InArguments.oShortObjIdHeap	= oShortObjIdHeap;
%  /* Copy in the bForceExit argument: */
%  InArguments.bForceExit	= bForceExit;
%
%  pResult	=
%#ifdef MULTITHREAD
%    (
%#else
%    (fnServerExit_rets *)
%#endif
%    fnrpc_fnserverexit_1 (
%	&InArguments,
%#ifdef MULTITHREAD
%	&Result,
%#endif
%	__pClient__ )
%#ifdef MULTITHREAD
%	== RPC_SUCCESS ) ? &Result : NULL
%#endif
%	;
%
%  if ( pResult == NULL ) {
%    /* Error handling for a failed RPC call, */
%    /* i.e. the server did not respond: */
%    char	szError [ 256 ];
%    sprintf ( szError, szFormatRpcFailed, __procedure__,
%              clnt_sperror ( __pClient__, __szHost__ ) );
%    __pClient__	= RPC_CLIENT_DESTROY ( __pClient__ );
%    RPC_CLIENT_CERROR ( szContRpcFailed, szError );
%    Result	= ZeroResult;
%    return Result.ReturnValue;
%  }
%#ifndef MULTITHREAD
%  Result	= * pResult;
%#endif
%
%
%  if ( pResult && pResult->nErrorLvl ) {
%    /* Server returned a user error message: */
%    char	szErrorMsg [ 1024 ];
%    strncpy ( szErrorMsg,
%              ( pResult->pszErrorMsg && pResult->pszErrorMsg [ 0 ] ) ?
%              (LPCSTR) pResult->pszErrorMsg : (LPCSTR) szEmpty,
%              sizeof ( szErrorMsg ) );
%    szErrorMsg [ sizeof ( szErrorMsg ) - 1 ]	= (char) 0;
%    xdr_free ( (xdrproc_t) xdr_fnServerExit_rets, (char *) pResult );
%    RPC_CLIENT_SERROR ( pResult->nErrorLvl, __procedure__,
%                        szErrorMsg );
%  } else {
%    xdr_free ( (xdrproc_t) xdr_fnServerExit_rets, (char *) pResult );
%  }
%
%  return Result.ReturnValue;
%
%} /* fnServerExit */
#endif	/* RPC_CLNT */
%
  fnServerDbReset_rets fnRpc_fnServerDbReset ( fnServerDbReset_args ) =  16 ;
%
#if RPC_SVC
%
%extern bool_t fnServerDbReset
%	(SHORTOBJID oShortObjIdHeap ,
%	  bool_t bForceReset);
%
%#ifdef MULTITHREAD
%bool_t
%#else
%fnServerDbReset_rets *
%#endif
%	PASTE2(fnrpc_fnserverdbreset_1,_SVCSUFFIX)
%		( fnServerDbReset_args * pArguments,
%#ifdef MULTITHREAD
%		  fnServerDbReset_rets * pResult,
%#endif
%		  struct svc_req * pRequest )
%{
%  static const char	__procedure__[]	= "server:fnrpc_fnserverdbreset_1";
%#ifdef MULTITHREAD
%  typedef bool_t RESULTTYPE;
%#else
%  typedef fnServerDbReset_rets * RESULTTYPE;
%#endif
%#ifndef MULTITHREAD
%  static fnServerDbReset_rets	Result;
%  RESULTTYPE			pResult = &Result;
%#endif
%  LPCSTR	pszErrorMsg;
%
%  __pRequest__	= pRequest;
%
%  RPC_SERVER_ENTRY();
%
%#ifndef MULTITHREAD
%  if ( pResult->pszErrorMsg == szEmpty ) {
%    pResult->pszErrorMsg	= NULL;
%  }
%  xdr_free ( (xdrproc_t) xdr_fnServerDbReset_rets, (char *) pResult );
%#endif
%  pResult->nErrorLvl		= 0;
%
%  Reply.bAnswered		= FALSE;
%  Reply.pfnCalled		= (void(*)()) fnServerDbReset;
%  Reply.pfnXdrResult		= (bool_t(*)()) xdr_fnServerDbReset_rets;
%  Reply.pnErrorLvl		= &pResult->nErrorLvl;
%  Reply.ppszErrorMsg		= (LPCSTR *) &pResult->pszErrorMsg;
%  Reply.pResult		= pResult;
%  Reply.pReturnValue		= &pResult->ReturnValue;
%  Reply.nReturnValueSize	= sizeof ( pResult->ReturnValue );
%
%  pResult->ReturnValue		=
%  fnServerDbReset (
%	pArguments->oShortObjIdHeap,
%	pArguments->bForceReset );
%
%  if ( Reply.bAnswered ) {
%    __pRequest__	= NULL;
%    return (RESULTTYPE) NULL;
%  }
%
%  pResult->nErrorLvl	= RPC_SERVER_ERRLVL();
%  if ( pResult->nErrorLvl > 0 ) {
%    pszErrorMsg		= RPC_SERVER_ERRMSG();
%    if ( pszErrorMsg && *pszErrorMsg ) {
%      pResult->pszErrorMsg	= strdup ( pszErrorMsg );
%    }
%  }
%  if ( pResult->pszErrorMsg == NULL ) {
%#ifdef MULTITHREAD
%    pResult->pszErrorMsg	= strdup ( szEmpty );
%#else
%    pResult->pszErrorMsg	= (LPSTR) szEmpty;
%#endif
%  }
%  __pRequest__	= NULL;
%  return (RESULTTYPE) pResult;
%} /* fnrpc_fnserverdbreset_1 */
#endif	/* RPC_SVC */
%
#if RPC_CLNT
%bool_t DLLEXPORT fnServerDbReset
%	(SHORTOBJID oShortObjIdHeap ,
%	  bool_t bForceReset)
%{
%  static const char	__procedure__[]	= "client:fnServerDbReset";
%  static fnServerDbReset_rets	ZeroResult;
%  fnServerDbReset_rets		* pResult = NULL;
%  fnServerDbReset_rets		Result = ZeroResult;
%  fnServerDbReset_args	InArguments;
%
%  /* Client initialization: */
%  if ( __bClientInitialize__ ) {
%    __bClientInitialize__	= FALSE;
%    RPC_CLIENT_INITIALIZE();
%  }
%
%#if	CLIENT_CREATE_BY_USER
%  if ( __pClient__ == NULL ) {
%    __pClient__	= RPC_CLIENT_CREATE ( __szHost__, __szTransport__ );
%    if ( __pClient__ == NULL ) {
%      /* Error handling for a not connected client: */
%      char	szError [ 256 ];
%      sprintf ( szError, szFormatNoServer, __procedure__ );
%      RPC_CLIENT_ERROR ( szError );
%      return Result.ReturnValue;
%    }
%  }
%#else
%  while ( __pClient__ == NULL ) {
%    __pClient__	= RPC_CLIENT_CREATE ( __szHost__, __szTransport__ );
%    if ( __pClient__ == NULL ) {
%      /* Error handling for a not connected client: */
%      char	szError [ 256 ];
%      sprintf ( szError, szFormatNoServer, __procedure__ );
%      RPC_CLIENT_CERROR ( szContNoServer, szError );
%    }
%  }
%#endif	/* CLIENT_CREATE_BY_USER */
%
%  /* Copy in the oShortObjIdHeap argument: */
%  InArguments.oShortObjIdHeap	= oShortObjIdHeap;
%  /* Copy in the bForceReset argument: */
%  InArguments.bForceReset	= bForceReset;
%
%  pResult	=
%#ifdef MULTITHREAD
%    (
%#else
%    (fnServerDbReset_rets *)
%#endif
%    fnrpc_fnserverdbreset_1 (
%	&InArguments,
%#ifdef MULTITHREAD
%	&Result,
%#endif
%	__pClient__ )
%#ifdef MULTITHREAD
%	== RPC_SUCCESS ) ? &Result : NULL
%#endif
%	;
%
%  if ( pResult == NULL ) {
%    /* Error handling for a failed RPC call, */
%    /* i.e. the server did not respond: */
%    char	szError [ 256 ];
%    sprintf ( szError, szFormatRpcFailed, __procedure__,
%              clnt_sperror ( __pClient__, __szHost__ ) );
%    __pClient__	= RPC_CLIENT_DESTROY ( __pClient__ );
%    RPC_CLIENT_CERROR ( szContRpcFailed, szError );
%    Result	= ZeroResult;
%    return Result.ReturnValue;
%  }
%#ifndef MULTITHREAD
%  Result	= * pResult;
%#endif
%
%
%  if ( pResult && pResult->nErrorLvl ) {
%    /* Server returned a user error message: */
%    char	szErrorMsg [ 1024 ];
%    strncpy ( szErrorMsg,
%              ( pResult->pszErrorMsg && pResult->pszErrorMsg [ 0 ] ) ?
%              (LPCSTR) pResult->pszErrorMsg : (LPCSTR) szEmpty,
%              sizeof ( szErrorMsg ) );
%    szErrorMsg [ sizeof ( szErrorMsg ) - 1 ]	= (char) 0;
%    xdr_free ( (xdrproc_t) xdr_fnServerDbReset_rets, (char *) pResult );
%    RPC_CLIENT_SERROR ( pResult->nErrorLvl, __procedure__,
%                        szErrorMsg );
%  } else {
%    xdr_free ( (xdrproc_t) xdr_fnServerDbReset_rets, (char *) pResult );
%  }
%
%  return Result.ReturnValue;
%
%} /* fnServerDbReset */
#endif	/* RPC_CLNT */
%
  fnServerRestart_rets fnRpc_fnServerRestart ( fnServerRestart_args ) =  17 ;
%
#if RPC_SVC
%
%extern bool_t fnServerRestart
%	(SHORTOBJID oShortObjIdHeap ,
%	  bool_t bForceRestart);
%
%#ifdef MULTITHREAD
%bool_t
%#else
%fnServerRestart_rets *
%#endif
%	PASTE2(fnrpc_fnserverrestart_1,_SVCSUFFIX)
%		( fnServerRestart_args * pArguments,
%#ifdef MULTITHREAD
%		  fnServerRestart_rets * pResult,
%#endif
%		  struct svc_req * pRequest )
%{
%  static const char	__procedure__[]	= "server:fnrpc_fnserverrestart_1";
%#ifdef MULTITHREAD
%  typedef bool_t RESULTTYPE;
%#else
%  typedef fnServerRestart_rets * RESULTTYPE;
%#endif
%#ifndef MULTITHREAD
%  static fnServerRestart_rets	Result;
%  RESULTTYPE			pResult = &Result;
%#endif
%  LPCSTR	pszErrorMsg;
%
%  __pRequest__	= pRequest;
%
%  RPC_SERVER_ENTRY();
%
%#ifndef MULTITHREAD
%  if ( pResult->pszErrorMsg == szEmpty ) {
%    pResult->pszErrorMsg	= NULL;
%  }
%  xdr_free ( (xdrproc_t) xdr_fnServerRestart_rets, (char *) pResult );
%#endif
%  pResult->nErrorLvl		= 0;
%
%  Reply.bAnswered		= FALSE;
%  Reply.pfnCalled		= (void(*)()) fnServerRestart;
%  Reply.pfnXdrResult		= (bool_t(*)()) xdr_fnServerRestart_rets;
%  Reply.pnErrorLvl		= &pResult->nErrorLvl;
%  Reply.ppszErrorMsg		= (LPCSTR *) &pResult->pszErrorMsg;
%  Reply.pResult		= pResult;
%  Reply.pReturnValue		= &pResult->ReturnValue;
%  Reply.nReturnValueSize	= sizeof ( pResult->ReturnValue );
%
%  pResult->ReturnValue		=
%  fnServerRestart (
%	pArguments->oShortObjIdHeap,
%	pArguments->bForceRestart );
%
%  if ( Reply.bAnswered ) {
%    __pRequest__	= NULL;
%    return (RESULTTYPE) NULL;
%  }
%
%  pResult->nErrorLvl	= RPC_SERVER_ERRLVL();
%  if ( pResult->nErrorLvl > 0 ) {
%    pszErrorMsg		= RPC_SERVER_ERRMSG();
%    if ( pszErrorMsg && *pszErrorMsg ) {
%      pResult->pszErrorMsg	= strdup ( pszErrorMsg );
%    }
%  }
%  if ( pResult->pszErrorMsg == NULL ) {
%#ifdef MULTITHREAD
%    pResult->pszErrorMsg	= strdup ( szEmpty );
%#else
%    pResult->pszErrorMsg	= (LPSTR) szEmpty;
%#endif
%  }
%  __pRequest__	= NULL;
%  return (RESULTTYPE) pResult;
%} /* fnrpc_fnserverrestart_1 */
#endif	/* RPC_SVC */
%
#if RPC_CLNT
%bool_t DLLEXPORT fnServerRestart
%	(SHORTOBJID oShortObjIdHeap ,
%	  bool_t bForceRestart)
%{
%  static const char	__procedure__[]	= "client:fnServerRestart";
%  static fnServerRestart_rets	ZeroResult;
%  fnServerRestart_rets		* pResult = NULL;
%  fnServerRestart_rets		Result = ZeroResult;
%  fnServerRestart_args	InArguments;
%
%  /* Client initialization: */
%  if ( __bClientInitialize__ ) {
%    __bClientInitialize__	= FALSE;
%    RPC_CLIENT_INITIALIZE();
%  }
%
%#if	CLIENT_CREATE_BY_USER
%  if ( __pClient__ == NULL ) {
%    __pClient__	= RPC_CLIENT_CREATE ( __szHost__, __szTransport__ );
%    if ( __pClient__ == NULL ) {
%      /* Error handling for a not connected client: */
%      char	szError [ 256 ];
%      sprintf ( szError, szFormatNoServer, __procedure__ );
%      RPC_CLIENT_ERROR ( szError );
%      return Result.ReturnValue;
%    }
%  }
%#else
%  while ( __pClient__ == NULL ) {
%    __pClient__	= RPC_CLIENT_CREATE ( __szHost__, __szTransport__ );
%    if ( __pClient__ == NULL ) {
%      /* Error handling for a not connected client: */
%      char	szError [ 256 ];
%      sprintf ( szError, szFormatNoServer, __procedure__ );
%      RPC_CLIENT_CERROR ( szContNoServer, szError );
%    }
%  }
%#endif	/* CLIENT_CREATE_BY_USER */
%
%  /* Copy in the oShortObjIdHeap argument: */
%  InArguments.oShortObjIdHeap	= oShortObjIdHeap;
%  /* Copy in the bForceRestart argument: */
%  InArguments.bForceRestart	= bForceRestart;
%
%  pResult	=
%#ifdef MULTITHREAD
%    (
%#else
%    (fnServerRestart_rets *)
%#endif
%    fnrpc_fnserverrestart_1 (
%	&InArguments,
%#ifdef MULTITHREAD
%	&Result,
%#endif
%	__pClient__ )
%#ifdef MULTITHREAD
%	== RPC_SUCCESS ) ? &Result : NULL
%#endif
%	;
%
%  if ( pResult == NULL ) {
%    /* Error handling for a failed RPC call, */
%    /* i.e. the server did not respond: */
%    char	szError [ 256 ];
%    sprintf ( szError, szFormatRpcFailed, __procedure__,
%              clnt_sperror ( __pClient__, __szHost__ ) );
%    __pClient__	= RPC_CLIENT_DESTROY ( __pClient__ );
%    RPC_CLIENT_CERROR ( szContRpcFailed, szError );
%    Result	= ZeroResult;
%    return Result.ReturnValue;
%  }
%#ifndef MULTITHREAD
%  Result	= * pResult;
%#endif
%
%
%  if ( pResult && pResult->nErrorLvl ) {
%    /* Server returned a user error message: */
%    char	szErrorMsg [ 1024 ];
%    strncpy ( szErrorMsg,
%              ( pResult->pszErrorMsg && pResult->pszErrorMsg [ 0 ] ) ?
%              (LPCSTR) pResult->pszErrorMsg : (LPCSTR) szEmpty,
%              sizeof ( szErrorMsg ) );
%    szErrorMsg [ sizeof ( szErrorMsg ) - 1 ]	= (char) 0;
%    xdr_free ( (xdrproc_t) xdr_fnServerRestart_rets, (char *) pResult );
%    RPC_CLIENT_SERROR ( pResult->nErrorLvl, __procedure__,
%                        szErrorMsg );
%  } else {
%    xdr_free ( (xdrproc_t) xdr_fnServerRestart_rets, (char *) pResult );
%  }
%
%  return Result.ReturnValue;
%
%} /* fnServerRestart */
#endif	/* RPC_CLNT */
%
  fnClientObjectCanModify_rets fnRpc_fnClientObjectCanModify ( fnClientObjectCanModify_args ) =  18 ;
%
#if RPC_SVC
%
%extern bool_t fnClientObjectCanModify
%	(SHORTOBJID oShortObjIdHeap ,
%	  SHORTOBJID oShortObjId);
%
%#ifdef MULTITHREAD
%bool_t
%#else
%fnClientObjectCanModify_rets *
%#endif
%	PASTE2(fnrpc_fnclientobjectcanmodify_1,_SVCSUFFIX)
%		( fnClientObjectCanModify_args * pArguments,
%#ifdef MULTITHREAD
%		  fnClientObjectCanModify_rets * pResult,
%#endif
%		  struct svc_req * pRequest )
%{
%  static const char	__procedure__[]	= "server:fnrpc_fnclientobjectcanmodify_1";
%#ifdef MULTITHREAD
%  typedef bool_t RESULTTYPE;
%#else
%  typedef fnClientObjectCanModify_rets * RESULTTYPE;
%#endif
%#ifndef MULTITHREAD
%  static fnClientObjectCanModify_rets	Result;
%  RESULTTYPE			pResult = &Result;
%#endif
%  LPCSTR	pszErrorMsg;
%
%  __pRequest__	= pRequest;
%
%  RPC_SERVER_ENTRY();
%
%#ifndef MULTITHREAD
%  if ( pResult->pszErrorMsg == szEmpty ) {
%    pResult->pszErrorMsg	= NULL;
%  }
%  xdr_free ( (xdrproc_t) xdr_fnClientObjectCanModify_rets, (char *) pResult );
%#endif
%  pResult->nErrorLvl		= 0;
%
%  Reply.bAnswered		= FALSE;
%  Reply.pfnCalled		= (void(*)()) fnClientObjectCanModify;
%  Reply.pfnXdrResult		= (bool_t(*)()) xdr_fnClientObjectCanModify_rets;
%  Reply.pnErrorLvl		= &pResult->nErrorLvl;
%  Reply.ppszErrorMsg		= (LPCSTR *) &pResult->pszErrorMsg;
%  Reply.pResult		= pResult;
%  Reply.pReturnValue		= &pResult->ReturnValue;
%  Reply.nReturnValueSize	= sizeof ( pResult->ReturnValue );
%
%  pResult->ReturnValue		=
%  fnClientObjectCanModify (
%	pArguments->oShortObjIdHeap,
%	pArguments->oShortObjId );
%
%  if ( Reply.bAnswered ) {
%    __pRequest__	= NULL;
%    return (RESULTTYPE) NULL;
%  }
%
%  pResult->nErrorLvl	= RPC_SERVER_ERRLVL();
%  if ( pResult->nErrorLvl > 0 ) {
%    pszErrorMsg		= RPC_SERVER_ERRMSG();
%    if ( pszErrorMsg && *pszErrorMsg ) {
%      pResult->pszErrorMsg	= strdup ( pszErrorMsg );
%    }
%  }
%  if ( pResult->pszErrorMsg == NULL ) {
%#ifdef MULTITHREAD
%    pResult->pszErrorMsg	= strdup ( szEmpty );
%#else
%    pResult->pszErrorMsg	= (LPSTR) szEmpty;
%#endif
%  }
%  __pRequest__	= NULL;
%  return (RESULTTYPE) pResult;
%} /* fnrpc_fnclientobjectcanmodify_1 */
#endif	/* RPC_SVC */
%
#if RPC_CLNT
%bool_t DLLEXPORT fnClientObjectCanModify
%	(SHORTOBJID oShortObjIdHeap ,
%	  SHORTOBJID oShortObjId)
%{
%  static const char	__procedure__[]	= "client:fnClientObjectCanModify";
%  static fnClientObjectCanModify_rets	ZeroResult;
%  fnClientObjectCanModify_rets		* pResult = NULL;
%  fnClientObjectCanModify_rets		Result = ZeroResult;
%  fnClientObjectCanModify_args	InArguments;
%
%  /* Client initialization: */
%  if ( __bClientInitialize__ ) {
%    __bClientInitialize__	= FALSE;
%    RPC_CLIENT_INITIALIZE();
%  }
%
%#if	CLIENT_CREATE_BY_USER
%  if ( __pClient__ == NULL ) {
%    __pClient__	= RPC_CLIENT_CREATE ( __szHost__, __szTransport__ );
%    if ( __pClient__ == NULL ) {
%      /* Error handling for a not connected client: */
%      char	szError [ 256 ];
%      sprintf ( szError, szFormatNoServer, __procedure__ );
%      RPC_CLIENT_ERROR ( szError );
%      return Result.ReturnValue;
%    }
%  }
%#else
%  while ( __pClient__ == NULL ) {
%    __pClient__	= RPC_CLIENT_CREATE ( __szHost__, __szTransport__ );
%    if ( __pClient__ == NULL ) {
%      /* Error handling for a not connected client: */
%      char	szError [ 256 ];
%      sprintf ( szError, szFormatNoServer, __procedure__ );
%      RPC_CLIENT_CERROR ( szContNoServer, szError );
%    }
%  }
%#endif	/* CLIENT_CREATE_BY_USER */
%
%  /* Copy in the oShortObjIdHeap argument: */
%  InArguments.oShortObjIdHeap	= oShortObjIdHeap;
%  /* Copy in the oShortObjId argument: */
%  InArguments.oShortObjId	= oShortObjId;
%
%  pResult	=
%#ifdef MULTITHREAD
%    (
%#else
%    (fnClientObjectCanModify_rets *)
%#endif
%    fnrpc_fnclientobjectcanmodify_1 (
%	&InArguments,
%#ifdef MULTITHREAD
%	&Result,
%#endif
%	__pClient__ )
%#ifdef MULTITHREAD
%	== RPC_SUCCESS ) ? &Result : NULL
%#endif
%	;
%
%  if ( pResult == NULL ) {
%    /* Error handling for a failed RPC call, */
%    /* i.e. the server did not respond: */
%    char	szError [ 256 ];
%    sprintf ( szError, szFormatRpcFailed, __procedure__,
%              clnt_sperror ( __pClient__, __szHost__ ) );
%    __pClient__	= RPC_CLIENT_DESTROY ( __pClient__ );
%    RPC_CLIENT_CERROR ( szContRpcFailed, szError );
%    Result	= ZeroResult;
%    return Result.ReturnValue;
%  }
%#ifndef MULTITHREAD
%  Result	= * pResult;
%#endif
%
%
%  if ( pResult && pResult->nErrorLvl ) {
%    /* Server returned a user error message: */
%    char	szErrorMsg [ 1024 ];
%    strncpy ( szErrorMsg,
%              ( pResult->pszErrorMsg && pResult->pszErrorMsg [ 0 ] ) ?
%              (LPCSTR) pResult->pszErrorMsg : (LPCSTR) szEmpty,
%              sizeof ( szErrorMsg ) );
%    szErrorMsg [ sizeof ( szErrorMsg ) - 1 ]	= (char) 0;
%    xdr_free ( (xdrproc_t) xdr_fnClientObjectCanModify_rets, (char *) pResult );
%    RPC_CLIENT_SERROR ( pResult->nErrorLvl, __procedure__,
%                        szErrorMsg );
%  } else {
%    xdr_free ( (xdrproc_t) xdr_fnClientObjectCanModify_rets, (char *) pResult );
%  }
%
%  return Result.ReturnValue;
%
%} /* fnClientObjectCanModify */
#endif	/* RPC_CLNT */
%
  void fnRpc_fnServerDbClose_batch ( fnServerDbClose_args ) =  19 ;
%
#if RPC_SVC
%
%extern void fnServerDbClose
%	(SHORTOBJID oShortObjIdHeap ,
%	  bool_t bWithGarbageCollection);
%
%#ifdef MULTITHREAD
%bool_t
%#else
%void *
%#endif
%	PASTE2(fnrpc_fnserverdbclose_batch_1,_SVCSUFFIX)
%		( fnServerDbClose_args * pArguments,
%#ifdef MULTITHREAD
%		  void * pResult,
%#endif
%		  struct svc_req * pRequest )
%{
%  static const char	__procedure__[]	= "server:fnrpc_fnserverdbclose_batch_1";
%#ifdef MULTITHREAD
%  typedef bool_t RESULTTYPE;
%#else
%  typedef void * RESULTTYPE;
%#endif
%
%  __pRequest__	= pRequest;
%
%  RPC_SERVER_ENTRY();
%
%  Reply.bAnswered		= TRUE;
%  Reply.pfnCalled		= (void(*)()) fnServerDbClose;
%  Reply.pfnXdrResult		= (bool_t(*)()) xdr_void;
%  Reply.pnErrorLvl		= NULL;
%  Reply.ppszErrorMsg		= NULL;
%  Reply.pResult			= NULL;
%  Reply.pReturnValue		= NULL;
%  Reply.nReturnValueSize	= 0;
%  fnServerDbClose (
%	pArguments->oShortObjIdHeap,
%	pArguments->bWithGarbageCollection );
%  __pRequest__	= NULL;
%  return (RESULTTYPE) NULL;
%} /* fnrpc_fnserverdbclose_batch_1 */
#endif	/* RPC_SVC */
%
#if RPC_CLNT
%void DLLEXPORT fnServerDbClose
%	(SHORTOBJID oShortObjIdHeap ,
%	  bool_t bWithGarbageCollection)
%{
%  static const char	__procedure__[]	= "client:fnServerDbClose";
%  static char	ZeroResult;
%  void		* pResult = NULL;
%#ifdef MULTITHREAD
%  char		Result = ZeroResult;
%#endif
%  fnServerDbClose_args	InArguments;
%
%  /* Client initialization: */
%  if ( __bClientInitialize__ ) {
%    __bClientInitialize__	= FALSE;
%    RPC_CLIENT_INITIALIZE();
%  }
%
%#if	CLIENT_CREATE_BY_USER
%  if ( __pClient__ == NULL ) {
%    __pClient__	= RPC_CLIENT_CREATE ( __szHost__, __szTransport__ );
%    if ( __pClient__ == NULL ) {
%      /* Error handling for a not connected client: */
%      char	szError [ 256 ];
%      sprintf ( szError, szFormatNoServer, __procedure__ );
%      RPC_CLIENT_ERROR ( szError );
%      return;
%    }
%  }
%#else
%  while ( __pClient__ == NULL ) {
%    __pClient__	= RPC_CLIENT_CREATE ( __szHost__, __szTransport__ );
%    if ( __pClient__ == NULL ) {
%      /* Error handling for a not connected client: */
%      char	szError [ 256 ];
%      sprintf ( szError, szFormatNoServer, __procedure__ );
%      RPC_CLIENT_CERROR ( szContNoServer, szError );
%    }
%  }
%#endif	/* CLIENT_CREATE_BY_USER */
%
%  /* Copy in the oShortObjIdHeap argument: */
%  InArguments.oShortObjIdHeap	= oShortObjIdHeap;
%  /* Copy in the bWithGarbageCollection argument: */
%  InArguments.bWithGarbageCollection	= bWithGarbageCollection;
%
%  pResult	=
%#ifdef MULTITHREAD
%    (
%#else
%    (void *)
%#endif
%    fnrpc_fnserverdbclose_batch_1 (
%	&InArguments,
%#ifdef MULTITHREAD
%	&Result,
%#endif
%	__pClient__ )
%#ifdef MULTITHREAD
%	== RPC_SUCCESS ) ? &Result : NULL
%#endif
%	;
%
%  if ( pResult == NULL ) {
%    /* Error handling for a failed RPC call, */
%    /* i.e. the server did not respond: */
%    char	szError [ 256 ];
%    sprintf ( szError, szFormatRpcFailed, __procedure__,
%              clnt_sperror ( __pClient__, __szHost__ ) );
%    __pClient__	= RPC_CLIENT_DESTROY ( __pClient__ );
%    RPC_CLIENT_CERROR ( szContRpcFailed, szError );
%    return;
%  }
%} /* fnServerDbClose */
%
%#ifdef MULTITHREAD
%enum clnt_stat
%#else
%void *
%#endif
%fnrpc_fnserverdbclose_batch_1
%	( fnServerDbClose_args * pArguments,
%#ifdef MULTITHREAD
%	  void * clnt_res,
%#endif
%	  PCLIENT pClient )
%{
%#ifdef MULTITHREAD
%  return clnt_call ( pClient, fnRpc_fnServerDbClose_batch,
%                     (xdrproc_t) xdr_fnServerDbClose_args,
%                     (caddr_t) pArguments,
%                     (xdrproc_t) NULL, (caddr_t) NULL,
%                     NullTimeout );
%#else
%  if ( clnt_call ( pClient, fnRpc_fnServerDbClose_batch,
%                   (xdrproc_t) xdr_fnServerDbClose_args,
%                   (caddr_t) pArguments,
%                   (xdrproc_t) NULL, (caddr_t) NULL,
%                   NullTimeout ) != RPC_SUCCESS ) {
%    return NULL;
%  }
%  return (void *) TRUE;
%#endif
%} /* fnrpc_fnserverdbclose_batch_1 */
%#define	fnrpc_fnserverdbclose_batch_1	fnrpc_fnserverdbclose_1
#endif	/* RPC_CLNT */
%
  fnClientDbConfiguration_rets fnRpc_fnClientDbConfiguration ( SHORTOBJID ) =  20 ;
%
#if RPC_SVC
%
%extern bool_t fnClientDbConfiguration
%	(SHORTOBJID oShortObjIdHeap ,
%	  int * pnFlags ,
%	  int * pnMinimumKey ,
%	  int * pnMaximumKey ,
%	  int * pnKeyAlignment);
%
%#ifdef MULTITHREAD
%bool_t
%#else
%fnClientDbConfiguration_rets *
%#endif
%	PASTE2(fnrpc_fnclientdbconfiguration_1,_SVCSUFFIX)
%		( SHORTOBJID * pArguments,
%#ifdef MULTITHREAD
%		  fnClientDbConfiguration_rets * pResult,
%#endif
%		  struct svc_req * pRequest )
%{
%  static const char	__procedure__[]	= "server:fnrpc_fnclientdbconfiguration_1";
%#ifdef MULTITHREAD
%  typedef bool_t RESULTTYPE;
%#else
%  typedef fnClientDbConfiguration_rets * RESULTTYPE;
%#endif
%#ifndef MULTITHREAD
%  static fnClientDbConfiguration_rets	Result;
%  RESULTTYPE			pResult = &Result;
%#endif
%  LPCSTR	pszErrorMsg;
%
%  __pRequest__	= pRequest;
%
%  RPC_SERVER_ENTRY();
%
%#ifndef MULTITHREAD
%  if ( pResult->pszErrorMsg == szEmpty ) {
%    pResult->pszErrorMsg	= NULL;
%  }
%  xdr_free ( (xdrproc_t) xdr_fnClientDbConfiguration_rets, (char *) pResult );
%#endif
%  pResult->nErrorLvl		= 0;
%
%  Reply.bAnswered		= FALSE;
%  Reply.pfnCalled		= (void(*)()) fnClientDbConfiguration;
%  Reply.pfnXdrResult		= (bool_t(*)()) xdr_fnClientDbConfiguration_rets;
%  Reply.pnErrorLvl		= &pResult->nErrorLvl;
%  Reply.ppszErrorMsg		= (LPCSTR *) &pResult->pszErrorMsg;
%  Reply.pResult		= pResult;
%  Reply.pReturnValue		= &pResult->ReturnValue;
%  Reply.nReturnValueSize	= sizeof ( pResult->ReturnValue );
%
%  pResult->ReturnValue		=
%  fnClientDbConfiguration (
%	(*pArguments),
%	&pResult->pnFlags,
%	&pResult->pnMinimumKey,
%	&pResult->pnMaximumKey,
%	&pResult->pnKeyAlignment );
%
%  if ( Reply.bAnswered ) {
%    __pRequest__	= NULL;
%    return (RESULTTYPE) NULL;
%  }
%
%  pResult->nErrorLvl	= RPC_SERVER_ERRLVL();
%  if ( pResult->nErrorLvl > 0 ) {
%    pszErrorMsg		= RPC_SERVER_ERRMSG();
%    if ( pszErrorMsg && *pszErrorMsg ) {
%      pResult->pszErrorMsg	= strdup ( pszErrorMsg );
%    }
%  }
%  if ( pResult->pszErrorMsg == NULL ) {
%#ifdef MULTITHREAD
%    pResult->pszErrorMsg	= strdup ( szEmpty );
%#else
%    pResult->pszErrorMsg	= (LPSTR) szEmpty;
%#endif
%  }
%  __pRequest__	= NULL;
%  return (RESULTTYPE) pResult;
%} /* fnrpc_fnclientdbconfiguration_1 */
#endif	/* RPC_SVC */
%
#if RPC_CLNT
%bool_t DLLEXPORT fnClientDbConfiguration
%	(SHORTOBJID oShortObjIdHeap ,
%	  int * pnFlags ,
%	  int * pnMinimumKey ,
%	  int * pnMaximumKey ,
%	  int * pnKeyAlignment)
%{
%  static const char	__procedure__[]	= "client:fnClientDbConfiguration";
%  static fnClientDbConfiguration_rets	ZeroResult;
%  fnClientDbConfiguration_rets		* pResult = NULL;
%  fnClientDbConfiguration_rets		Result = ZeroResult;
%
%  /* Client initialization: */
%  if ( __bClientInitialize__ ) {
%    __bClientInitialize__	= FALSE;
%    RPC_CLIENT_INITIALIZE();
%  }
%
%#if	CLIENT_CREATE_BY_USER
%  if ( __pClient__ == NULL ) {
%    __pClient__	= RPC_CLIENT_CREATE ( __szHost__, __szTransport__ );
%    if ( __pClient__ == NULL ) {
%      /* Error handling for a not connected client: */
%      char	szError [ 256 ];
%      sprintf ( szError, szFormatNoServer, __procedure__ );
%      RPC_CLIENT_ERROR ( szError );
%      return Result.ReturnValue;
%    }
%  }
%#else
%  while ( __pClient__ == NULL ) {
%    __pClient__	= RPC_CLIENT_CREATE ( __szHost__, __szTransport__ );
%    if ( __pClient__ == NULL ) {
%      /* Error handling for a not connected client: */
%      char	szError [ 256 ];
%      sprintf ( szError, szFormatNoServer, __procedure__ );
%      RPC_CLIENT_CERROR ( szContNoServer, szError );
%    }
%  }
%#endif	/* CLIENT_CREATE_BY_USER */
%
%  pResult	=
%#ifdef MULTITHREAD
%    (
%#else
%    (fnClientDbConfiguration_rets *)
%#endif
%    fnrpc_fnclientdbconfiguration_1 (
%	&oShortObjIdHeap,
%#ifdef MULTITHREAD
%	&Result,
%#endif
%	__pClient__ )
%#ifdef MULTITHREAD
%	== RPC_SUCCESS ) ? &Result : NULL
%#endif
%	;
%
%  if ( pResult == NULL ) {
%    /* Error handling for a failed RPC call, */
%    /* i.e. the server did not respond: */
%    char	szError [ 256 ];
%    sprintf ( szError, szFormatRpcFailed, __procedure__,
%              clnt_sperror ( __pClient__, __szHost__ ) );
%    __pClient__	= RPC_CLIENT_DESTROY ( __pClient__ );
%    RPC_CLIENT_CERROR ( szContRpcFailed, szError );
%    Result	= ZeroResult;
%    return Result.ReturnValue;
%  }
%#ifndef MULTITHREAD
%  Result	= * pResult;
%#endif
%
%  /* Copy out the pnFlags argument: */
%  if ( ! ( 
%       pnFlags == NULL ) ) {
%    *pnFlags	= pResult->pnFlags;
%  }
%  /* Copy out the pnMinimumKey argument: */
%  if ( ! ( 
%       pnMinimumKey == NULL ) ) {
%    *pnMinimumKey	= pResult->pnMinimumKey;
%  }
%  /* Copy out the pnMaximumKey argument: */
%  if ( ! ( 
%       pnMaximumKey == NULL ) ) {
%    *pnMaximumKey	= pResult->pnMaximumKey;
%  }
%  /* Copy out the pnKeyAlignment argument: */
%  if ( ! ( 
%       pnKeyAlignment == NULL ) ) {
%    *pnKeyAlignment	= pResult->pnKeyAlignment;
%  }
%
%  if ( pResult && pResult->nErrorLvl ) {
%    /* Server returned a user error message: */
%    char	szErrorMsg [ 1024 ];
%    strncpy ( szErrorMsg,
%              ( pResult->pszErrorMsg && pResult->pszErrorMsg [ 0 ] ) ?
%              (LPCSTR) pResult->pszErrorMsg : (LPCSTR) szEmpty,
%              sizeof ( szErrorMsg ) );
%    szErrorMsg [ sizeof ( szErrorMsg ) - 1 ]	= (char) 0;
%    xdr_free ( (xdrproc_t) xdr_fnClientDbConfiguration_rets, (char *) pResult );
%    RPC_CLIENT_SERROR ( pResult->nErrorLvl, __procedure__,
%                        szErrorMsg );
%  } else {
%    xdr_free ( (xdrproc_t) xdr_fnClientDbConfiguration_rets, (char *) pResult );
%  }
%  if ( 
%       pnFlags == NULL ) {
%    /* Error handling for passing a NULL pointer on */
%    /* out argument: */
%    char	szError [ 256 ];
%    sprintf ( szError, szFormatNullPassed,
%              __procedure__, "pnFlags" );
%    RPC_CLIENT_CERROR ( szContNullOutPassed, szError );
%  }
%  if ( 
%       pnMinimumKey == NULL ) {
%    /* Error handling for passing a NULL pointer on */
%    /* out argument: */
%    char	szError [ 256 ];
%    sprintf ( szError, szFormatNullPassed,
%              __procedure__, "pnMinimumKey" );
%    RPC_CLIENT_CERROR ( szContNullOutPassed, szError );
%  }
%  if ( 
%       pnMaximumKey == NULL ) {
%    /* Error handling for passing a NULL pointer on */
%    /* out argument: */
%    char	szError [ 256 ];
%    sprintf ( szError, szFormatNullPassed,
%              __procedure__, "pnMaximumKey" );
%    RPC_CLIENT_CERROR ( szContNullOutPassed, szError );
%  }
%  if ( 
%       pnKeyAlignment == NULL ) {
%    /* Error handling for passing a NULL pointer on */
%    /* out argument: */
%    char	szError [ 256 ];
%    sprintf ( szError, szFormatNullPassed,
%              __procedure__, "pnKeyAlignment" );
%    RPC_CLIENT_CERROR ( szContNullOutPassed, szError );
%  }
%
%  return Result.ReturnValue;
%
%} /* fnClientDbConfiguration */
#endif	/* RPC_CLNT */
%
  fnServerDbCreateObject_rets fnRpc_fnServerDbCreateObject ( fnServerDbCreateObject_args ) =  21 ;
%
#if RPC_SVC
%
%extern SHORTOBJID fnServerDbCreateObject
%	(SHORTOBJID oShortObjIdHeap ,
%	  SHTYPETAG nTypeTag ,
%	  int nExtraReferences ,
%	  SHTYPETAG eTypeTagValues ,
%	  int nExtraValues);
%
%#ifdef MULTITHREAD
%bool_t
%#else
%fnServerDbCreateObject_rets *
%#endif
%	PASTE2(fnrpc_fnserverdbcreateobject_1,_SVCSUFFIX)
%		( fnServerDbCreateObject_args * pArguments,
%#ifdef MULTITHREAD
%		  fnServerDbCreateObject_rets * pResult,
%#endif
%		  struct svc_req * pRequest )
%{
%  static const char	__procedure__[]	= "server:fnrpc_fnserverdbcreateobject_1";
%#ifdef MULTITHREAD
%  typedef bool_t RESULTTYPE;
%#else
%  typedef fnServerDbCreateObject_rets * RESULTTYPE;
%#endif
%#ifndef MULTITHREAD
%  static fnServerDbCreateObject_rets	Result;
%  RESULTTYPE			pResult = &Result;
%#endif
%  LPCSTR	pszErrorMsg;
%
%  __pRequest__	= pRequest;
%
%  RPC_SERVER_ENTRY();
%
%#ifndef MULTITHREAD
%  if ( pResult->pszErrorMsg == szEmpty ) {
%    pResult->pszErrorMsg	= NULL;
%  }
%  xdr_free ( (xdrproc_t) xdr_fnServerDbCreateObject_rets, (char *) pResult );
%#endif
%  pResult->nErrorLvl		= 0;
%
%  Reply.bAnswered		= FALSE;
%  Reply.pfnCalled		= (void(*)()) fnServerDbCreateObject;
%  Reply.pfnXdrResult		= (bool_t(*)()) xdr_fnServerDbCreateObject_rets;
%  Reply.pnErrorLvl		= &pResult->nErrorLvl;
%  Reply.ppszErrorMsg		= (LPCSTR *) &pResult->pszErrorMsg;
%  Reply.pResult		= pResult;
%  Reply.pReturnValue		= &pResult->ReturnValue;
%  Reply.nReturnValueSize	= sizeof ( pResult->ReturnValue );
%
%  pResult->ReturnValue		=
%  fnServerDbCreateObject (
%	pArguments->oShortObjIdHeap,
%	pArguments->nTypeTag,
%	pArguments->nExtraReferences,
%	pArguments->eTypeTagValues,
%	pArguments->nExtraValues );
%
%  if ( Reply.bAnswered ) {
%    __pRequest__	= NULL;
%    return (RESULTTYPE) NULL;
%  }
%
%  pResult->nErrorLvl	= RPC_SERVER_ERRLVL();
%  if ( pResult->nErrorLvl > 0 ) {
%    pszErrorMsg		= RPC_SERVER_ERRMSG();
%    if ( pszErrorMsg && *pszErrorMsg ) {
%      pResult->pszErrorMsg	= strdup ( pszErrorMsg );
%    }
%  }
%  if ( pResult->pszErrorMsg == NULL ) {
%#ifdef MULTITHREAD
%    pResult->pszErrorMsg	= strdup ( szEmpty );
%#else
%    pResult->pszErrorMsg	= (LPSTR) szEmpty;
%#endif
%  }
%  __pRequest__	= NULL;
%  return (RESULTTYPE) pResult;
%} /* fnrpc_fnserverdbcreateobject_1 */
#endif	/* RPC_SVC */
%
#if RPC_CLNT
%SHORTOBJID DLLEXPORT fnServerDbCreateObject
%	(SHORTOBJID oShortObjIdHeap ,
%	  SHTYPETAG nTypeTag ,
%	  int nExtraReferences ,
%	  SHTYPETAG eTypeTagValues ,
%	  int nExtraValues)
%{
%  static const char	__procedure__[]	= "client:fnServerDbCreateObject";
%  static fnServerDbCreateObject_rets	ZeroResult;
%  fnServerDbCreateObject_rets		* pResult = NULL;
%  fnServerDbCreateObject_rets		Result = ZeroResult;
%  fnServerDbCreateObject_args	InArguments;
%
%  /* Client initialization: */
%  if ( __bClientInitialize__ ) {
%    __bClientInitialize__	= FALSE;
%    RPC_CLIENT_INITIALIZE();
%  }
%
%#if	CLIENT_CREATE_BY_USER
%  if ( __pClient__ == NULL ) {
%    __pClient__	= RPC_CLIENT_CREATE ( __szHost__, __szTransport__ );
%    if ( __pClient__ == NULL ) {
%      /* Error handling for a not connected client: */
%      char	szError [ 256 ];
%      sprintf ( szError, szFormatNoServer, __procedure__ );
%      RPC_CLIENT_ERROR ( szError );
%      return Result.ReturnValue;
%    }
%  }
%#else
%  while ( __pClient__ == NULL ) {
%    __pClient__	= RPC_CLIENT_CREATE ( __szHost__, __szTransport__ );
%    if ( __pClient__ == NULL ) {
%      /* Error handling for a not connected client: */
%      char	szError [ 256 ];
%      sprintf ( szError, szFormatNoServer, __procedure__ );
%      RPC_CLIENT_CERROR ( szContNoServer, szError );
%    }
%  }
%#endif	/* CLIENT_CREATE_BY_USER */
%
%  /* Copy in the oShortObjIdHeap argument: */
%  InArguments.oShortObjIdHeap	= oShortObjIdHeap;
%  /* Copy in the nTypeTag argument: */
%  InArguments.nTypeTag	= nTypeTag;
%  /* Copy in the nExtraReferences argument: */
%  InArguments.nExtraReferences	= nExtraReferences;
%  /* Copy in the eTypeTagValues argument: */
%  InArguments.eTypeTagValues	= eTypeTagValues;
%  /* Copy in the nExtraValues argument: */
%  InArguments.nExtraValues	= nExtraValues;
%
%  pResult	=
%#ifdef MULTITHREAD
%    (
%#else
%    (fnServerDbCreateObject_rets *)
%#endif
%    fnrpc_fnserverdbcreateobject_1 (
%	&InArguments,
%#ifdef MULTITHREAD
%	&Result,
%#endif
%	__pClient__ )
%#ifdef MULTITHREAD
%	== RPC_SUCCESS ) ? &Result : NULL
%#endif
%	;
%
%  if ( pResult == NULL ) {
%    /* Error handling for a failed RPC call, */
%    /* i.e. the server did not respond: */
%    char	szError [ 256 ];
%    sprintf ( szError, szFormatRpcFailed, __procedure__,
%              clnt_sperror ( __pClient__, __szHost__ ) );
%    __pClient__	= RPC_CLIENT_DESTROY ( __pClient__ );
%    RPC_CLIENT_CERROR ( szContRpcFailed, szError );
%    Result	= ZeroResult;
%    return Result.ReturnValue;
%  }
%#ifndef MULTITHREAD
%  Result	= * pResult;
%#endif
%
%
%  if ( pResult && pResult->nErrorLvl ) {
%    /* Server returned a user error message: */
%    char	szErrorMsg [ 1024 ];
%    strncpy ( szErrorMsg,
%              ( pResult->pszErrorMsg && pResult->pszErrorMsg [ 0 ] ) ?
%              (LPCSTR) pResult->pszErrorMsg : (LPCSTR) szEmpty,
%              sizeof ( szErrorMsg ) );
%    szErrorMsg [ sizeof ( szErrorMsg ) - 1 ]	= (char) 0;
%    xdr_free ( (xdrproc_t) xdr_fnServerDbCreateObject_rets, (char *) pResult );
%    RPC_CLIENT_SERROR ( pResult->nErrorLvl, __procedure__,
%                        szErrorMsg );
%  } else {
%    xdr_free ( (xdrproc_t) xdr_fnServerDbCreateObject_rets, (char *) pResult );
%  }
%
%  return Result.ReturnValue;
%
%} /* fnServerDbCreateObject */
#endif	/* RPC_CLNT */
%
  fnServerDbCreateObjects_rets fnRpc_fnServerDbCreateObjects ( fnServerDbCreateObjects_args ) =  22 ;
%
#if RPC_SVC
%
%extern int fnServerDbCreateObjects
%	(SHORTOBJID oShortObjIdHeap ,
%	  SHTYPETAG nTypeTag ,
%	  int nExtraReferences ,
%	  SHTYPETAG eTypeTagValues ,
%	  int nExtraValues ,
%	  int nObjIds ,
%	  u_int * /* _vector_t<nObjIds> */  pObjIds);
%
%#ifdef MULTITHREAD
%bool_t
%#else
%fnServerDbCreateObjects_rets *
%#endif
%	PASTE2(fnrpc_fnserverdbcreateobjects_1,_SVCSUFFIX)
%		( fnServerDbCreateObjects_args * pArguments,
%#ifdef MULTITHREAD
%		  fnServerDbCreateObjects_rets * pResult,
%#endif
%		  struct svc_req * pRequest )
%{
%  static const char	__procedure__[]	= "server:fnrpc_fnserverdbcreateobjects_1";
%#ifdef MULTITHREAD
%  typedef bool_t RESULTTYPE;
%#else
%  typedef fnServerDbCreateObjects_rets * RESULTTYPE;
%#endif
%#ifndef MULTITHREAD
%  static fnServerDbCreateObjects_rets	Result;
%  RESULTTYPE			pResult = &Result;
%#endif
%  LPCSTR	pszErrorMsg;
%
%  __pRequest__	= pRequest;
%
%  RPC_SERVER_ENTRY();
%
%#ifndef MULTITHREAD
%  if ( pResult->pszErrorMsg == szEmpty ) {
%    pResult->pszErrorMsg	= NULL;
%  }
%  xdr_free ( (xdrproc_t) xdr_fnServerDbCreateObjects_rets, (char *) pResult );
%#endif
%  pResult->nErrorLvl		= 0;
%
%  pResult->pObjIds.u_int_vector_t_len	= pArguments->pObjIdsSize;
%  if ( pArguments->pObjIdsSize == 0 ) {
%    pResult->pObjIds.u_int_vector_t_val	= NULL;
%  } else {
%    pResult->pObjIds.u_int_vector_t_val	=
%      (u_int*) malloc ( pArguments->pObjIdsSize *
%               SIZEOF ( *(pResult->pObjIds.u_int_vector_t_val) ) );
%    if ( pResult->pObjIds.u_int_vector_t_val == NULL ) {
%      char	szError [ 256 ];
%      sprintf ( szError, szFormatMallocFailed,
%                __procedure__, pArguments->pObjIdsSize,
%                "pObjIds" );
%      RPC_SERVER_ERROR ( szError );
%      return (RESULTTYPE) NULL;
%    }
%  }
%  Reply.bAnswered		= FALSE;
%  Reply.pfnCalled		= (void(*)()) fnServerDbCreateObjects;
%  Reply.pfnXdrResult		= (bool_t(*)()) xdr_fnServerDbCreateObjects_rets;
%  Reply.pnErrorLvl		= &pResult->nErrorLvl;
%  Reply.ppszErrorMsg		= (LPCSTR *) &pResult->pszErrorMsg;
%  Reply.pResult		= pResult;
%  Reply.pReturnValue		= &pResult->ReturnValue;
%  Reply.nReturnValueSize	= sizeof ( pResult->ReturnValue );
%
%  pResult->ReturnValue		=
%  fnServerDbCreateObjects (
%	pArguments->oShortObjIdHeap,
%	pArguments->nTypeTag,
%	pArguments->nExtraReferences,
%	pArguments->eTypeTagValues,
%	pArguments->nExtraValues,
%	pArguments->nObjIds,
%	pResult->pObjIds.u_int_vector_t_val );
%
%  if ( Reply.bAnswered ) {
%    __pRequest__	= NULL;
%    return (RESULTTYPE) NULL;
%  }
%
%  pResult->nErrorLvl	= RPC_SERVER_ERRLVL();
%  if ( pResult->nErrorLvl > 0 ) {
%    pszErrorMsg		= RPC_SERVER_ERRMSG();
%    if ( pszErrorMsg && *pszErrorMsg ) {
%      pResult->pszErrorMsg	= strdup ( pszErrorMsg );
%    }
%  }
%  if ( pResult->pszErrorMsg == NULL ) {
%#ifdef MULTITHREAD
%    pResult->pszErrorMsg	= strdup ( szEmpty );
%#else
%    pResult->pszErrorMsg	= (LPSTR) szEmpty;
%#endif
%  }
%  __pRequest__	= NULL;
%  return (RESULTTYPE) pResult;
%} /* fnrpc_fnserverdbcreateobjects_1 */
#endif	/* RPC_SVC */
%
#if RPC_CLNT
%int DLLEXPORT fnServerDbCreateObjects
%	(SHORTOBJID oShortObjIdHeap ,
%	  SHTYPETAG nTypeTag ,
%	  int nExtraReferences ,
%	  SHTYPETAG eTypeTagValues ,
%	  int nExtraValues ,
%	  int nObjIds ,
%	  u_int * /* _vector_t<nObjIds> */  pObjIds)
%{
%  static const char	__procedure__[]	= "client:fnServerDbCreateObjects";
%  static fnServerDbCreateObjects_rets	ZeroResult;
%  fnServerDbCreateObjects_rets		* pResult = NULL;
%  fnServerDbCreateObjects_rets		Result = ZeroResult;
%  fnServerDbCreateObjects_args	InArguments;
%
%  /* Client initialization: */
%  if ( __bClientInitialize__ ) {
%    __bClientInitialize__	= FALSE;
%    RPC_CLIENT_INITIALIZE();
%  }
%
%#if	CLIENT_CREATE_BY_USER
%  if ( __pClient__ == NULL ) {
%    __pClient__	= RPC_CLIENT_CREATE ( __szHost__, __szTransport__ );
%    if ( __pClient__ == NULL ) {
%      /* Error handling for a not connected client: */
%      char	szError [ 256 ];
%      sprintf ( szError, szFormatNoServer, __procedure__ );
%      RPC_CLIENT_ERROR ( szError );
%      return Result.ReturnValue;
%    }
%  }
%#else
%  while ( __pClient__ == NULL ) {
%    __pClient__	= RPC_CLIENT_CREATE ( __szHost__, __szTransport__ );
%    if ( __pClient__ == NULL ) {
%      /* Error handling for a not connected client: */
%      char	szError [ 256 ];
%      sprintf ( szError, szFormatNoServer, __procedure__ );
%      RPC_CLIENT_CERROR ( szContNoServer, szError );
%    }
%  }
%#endif	/* CLIENT_CREATE_BY_USER */
%
%  /* Copy in the oShortObjIdHeap argument: */
%  InArguments.oShortObjIdHeap	= oShortObjIdHeap;
%  /* Copy in the nTypeTag argument: */
%  InArguments.nTypeTag	= nTypeTag;
%  /* Copy in the nExtraReferences argument: */
%  InArguments.nExtraReferences	= nExtraReferences;
%  /* Copy in the eTypeTagValues argument: */
%  InArguments.eTypeTagValues	= eTypeTagValues;
%  /* Copy in the nExtraValues argument: */
%  InArguments.nExtraValues	= nExtraValues;
%  /* Copy in the nObjIds argument: */
%  InArguments.nObjIds	= nObjIds;
%  InArguments.pObjIdsSize	= nObjIds;
%
%  pResult	=
%#ifdef MULTITHREAD
%    (
%#else
%    (fnServerDbCreateObjects_rets *)
%#endif
%    fnrpc_fnserverdbcreateobjects_1 (
%	&InArguments,
%#ifdef MULTITHREAD
%	&Result,
%#endif
%	__pClient__ )
%#ifdef MULTITHREAD
%	== RPC_SUCCESS ) ? &Result : NULL
%#endif
%	;
%
%  if ( pResult == NULL ) {
%    /* Error handling for a failed RPC call, */
%    /* i.e. the server did not respond: */
%    char	szError [ 256 ];
%    sprintf ( szError, szFormatRpcFailed, __procedure__,
%              clnt_sperror ( __pClient__, __szHost__ ) );
%    __pClient__	= RPC_CLIENT_DESTROY ( __pClient__ );
%    RPC_CLIENT_CERROR ( szContRpcFailed, szError );
%    Result	= ZeroResult;
%    return Result.ReturnValue;
%  }
%#ifndef MULTITHREAD
%  Result	= * pResult;
%#endif
%
%  /* Copy out the pObjIds argument: */
%  if ( ! ( 
%       pResult->pObjIds.u_int_vector_t_len != 0 &&
%       pObjIds == NULL ) ) {
%    memcpy ( pObjIds,
%             pResult->pObjIds.u_int_vector_t_val,
%             MIN ( pResult->pObjIds.u_int_vector_t_len,
%                   nObjIds ) *
%             SIZEOF ( *(pResult->pObjIds.u_int_vector_t_val) ) );
%  }
%
%  if ( pResult && pResult->nErrorLvl ) {
%    /* Server returned a user error message: */
%    char	szErrorMsg [ 1024 ];
%    strncpy ( szErrorMsg,
%              ( pResult->pszErrorMsg && pResult->pszErrorMsg [ 0 ] ) ?
%              (LPCSTR) pResult->pszErrorMsg : (LPCSTR) szEmpty,
%              sizeof ( szErrorMsg ) );
%    szErrorMsg [ sizeof ( szErrorMsg ) - 1 ]	= (char) 0;
%    xdr_free ( (xdrproc_t) xdr_fnServerDbCreateObjects_rets, (char *) pResult );
%    RPC_CLIENT_SERROR ( pResult->nErrorLvl, __procedure__,
%                        szErrorMsg );
%  } else {
%    xdr_free ( (xdrproc_t) xdr_fnServerDbCreateObjects_rets, (char *) pResult );
%  }
%  if ( 
%       pResult->pObjIds.u_int_vector_t_len != 0 &&
%       pObjIds == NULL ) {
%    /* Error handling for passing a NULL pointer on */
%    /* out argument: */
%    char	szError [ 256 ];
%    sprintf ( szError, szFormatNullPassed,
%              __procedure__, "pObjIds" );
%    RPC_CLIENT_CERROR ( szContNullOutPassed, szError );
%  } else if ( pResult->pObjIds.u_int_vector_t_len > nObjIds ) {
%      /* Error handling for an output buffer overflow, */
%      /* i.e. the buffer size passed is too small: */
%      /* For example, signal a CERROR here ... */
%      char	szError [ 256 ];
%      sprintf ( szError, szFormatBufferOverflow,
%                __procedure__, "pObjIds", 
%                nObjIds, 
%                pResult->pObjIds.u_int_vector_t_len );
%      RPC_CLIENT_CERROR ( szContBufferOverflow, szError );
%  }
%
%  return Result.ReturnValue;
%
%} /* fnServerDbCreateObjects */
#endif	/* RPC_CLNT */
%
  void fnRpc_fnServerObjectDestroy_batch ( fnServerObjectDestroy_args ) =  23 ;
%
#if RPC_SVC
%
%extern void fnServerObjectDestroy
%	(SHORTOBJID oShortObjIdHeap ,
%	  SHORTOBJID oShortObjId);
%
%#ifdef MULTITHREAD
%bool_t
%#else
%void *
%#endif
%	PASTE2(fnrpc_fnserverobjectdestroy_batch_1,_SVCSUFFIX)
%		( fnServerObjectDestroy_args * pArguments,
%#ifdef MULTITHREAD
%		  void * pResult,
%#endif
%		  struct svc_req * pRequest )
%{
%  static const char	__procedure__[]	= "server:fnrpc_fnserverobjectdestroy_batch_1";
%#ifdef MULTITHREAD
%  typedef bool_t RESULTTYPE;
%#else
%  typedef void * RESULTTYPE;
%#endif
%
%  __pRequest__	= pRequest;
%
%  RPC_SERVER_ENTRY();
%
%  Reply.bAnswered		= TRUE;
%  Reply.pfnCalled		= (void(*)()) fnServerObjectDestroy;
%  Reply.pfnXdrResult		= (bool_t(*)()) xdr_void;
%  Reply.pnErrorLvl		= NULL;
%  Reply.ppszErrorMsg		= NULL;
%  Reply.pResult			= NULL;
%  Reply.pReturnValue		= NULL;
%  Reply.nReturnValueSize	= 0;
%  fnServerObjectDestroy (
%	pArguments->oShortObjIdHeap,
%	pArguments->oShortObjId );
%  __pRequest__	= NULL;
%  return (RESULTTYPE) NULL;
%} /* fnrpc_fnserverobjectdestroy_batch_1 */
#endif	/* RPC_SVC */
%
#if RPC_CLNT
%void DLLEXPORT fnServerObjectDestroy
%	(SHORTOBJID oShortObjIdHeap ,
%	  SHORTOBJID oShortObjId)
%{
%  static const char	__procedure__[]	= "client:fnServerObjectDestroy";
%  static char	ZeroResult;
%  void		* pResult = NULL;
%#ifdef MULTITHREAD
%  char		Result = ZeroResult;
%#endif
%  fnServerObjectDestroy_args	InArguments;
%
%  /* Client initialization: */
%  if ( __bClientInitialize__ ) {
%    __bClientInitialize__	= FALSE;
%    RPC_CLIENT_INITIALIZE();
%  }
%
%#if	CLIENT_CREATE_BY_USER
%  if ( __pClient__ == NULL ) {
%    __pClient__	= RPC_CLIENT_CREATE ( __szHost__, __szTransport__ );
%    if ( __pClient__ == NULL ) {
%      /* Error handling for a not connected client: */
%      char	szError [ 256 ];
%      sprintf ( szError, szFormatNoServer, __procedure__ );
%      RPC_CLIENT_ERROR ( szError );
%      return;
%    }
%  }
%#else
%  while ( __pClient__ == NULL ) {
%    __pClient__	= RPC_CLIENT_CREATE ( __szHost__, __szTransport__ );
%    if ( __pClient__ == NULL ) {
%      /* Error handling for a not connected client: */
%      char	szError [ 256 ];
%      sprintf ( szError, szFormatNoServer, __procedure__ );
%      RPC_CLIENT_CERROR ( szContNoServer, szError );
%    }
%  }
%#endif	/* CLIENT_CREATE_BY_USER */
%
%  /* Copy in the oShortObjIdHeap argument: */
%  InArguments.oShortObjIdHeap	= oShortObjIdHeap;
%  /* Copy in the oShortObjId argument: */
%  InArguments.oShortObjId	= oShortObjId;
%
%  pResult	=
%#ifdef MULTITHREAD
%    (
%#else
%    (void *)
%#endif
%    fnrpc_fnserverobjectdestroy_batch_1 (
%	&InArguments,
%#ifdef MULTITHREAD
%	&Result,
%#endif
%	__pClient__ )
%#ifdef MULTITHREAD
%	== RPC_SUCCESS ) ? &Result : NULL
%#endif
%	;
%
%  if ( pResult == NULL ) {
%    /* Error handling for a failed RPC call, */
%    /* i.e. the server did not respond: */
%    char	szError [ 256 ];
%    sprintf ( szError, szFormatRpcFailed, __procedure__,
%              clnt_sperror ( __pClient__, __szHost__ ) );
%    __pClient__	= RPC_CLIENT_DESTROY ( __pClient__ );
%    RPC_CLIENT_CERROR ( szContRpcFailed, szError );
%    return;
%  }
%} /* fnServerObjectDestroy */
%
%#ifdef MULTITHREAD
%enum clnt_stat
%#else
%void *
%#endif
%fnrpc_fnserverobjectdestroy_batch_1
%	( fnServerObjectDestroy_args * pArguments,
%#ifdef MULTITHREAD
%	  void * clnt_res,
%#endif
%	  PCLIENT pClient )
%{
%#ifdef MULTITHREAD
%  return clnt_call ( pClient, fnRpc_fnServerObjectDestroy_batch,
%                     (xdrproc_t) xdr_fnServerObjectDestroy_args,
%                     (caddr_t) pArguments,
%                     (xdrproc_t) NULL, (caddr_t) NULL,
%                     NullTimeout );
%#else
%  if ( clnt_call ( pClient, fnRpc_fnServerObjectDestroy_batch,
%                   (xdrproc_t) xdr_fnServerObjectDestroy_args,
%                   (caddr_t) pArguments,
%                   (xdrproc_t) NULL, (caddr_t) NULL,
%                   NullTimeout ) != RPC_SUCCESS ) {
%    return NULL;
%  }
%  return (void *) TRUE;
%#endif
%} /* fnrpc_fnserverobjectdestroy_batch_1 */
%#define	fnrpc_fnserverobjectdestroy_batch_1	fnrpc_fnserverobjectdestroy_1
#endif	/* RPC_CLNT */
%
  fnServerObjectObjIdSize_rets fnRpc_fnServerObjectObjIdSize ( fnServerObjectObjIdSize_args ) =  24 ;
%
#if RPC_SVC
%
%extern int fnServerObjectObjIdSize
%	(SHORTOBJID oShortObjIdHeap ,
%	  SHORTOBJID oShortObjId);
%
%#ifdef MULTITHREAD
%bool_t
%#else
%fnServerObjectObjIdSize_rets *
%#endif
%	PASTE2(fnrpc_fnserverobjectobjidsize_1,_SVCSUFFIX)
%		( fnServerObjectObjIdSize_args * pArguments,
%#ifdef MULTITHREAD
%		  fnServerObjectObjIdSize_rets * pResult,
%#endif
%		  struct svc_req * pRequest )
%{
%  static const char	__procedure__[]	= "server:fnrpc_fnserverobjectobjidsize_1";
%#ifdef MULTITHREAD
%  typedef bool_t RESULTTYPE;
%#else
%  typedef fnServerObjectObjIdSize_rets * RESULTTYPE;
%#endif
%#ifndef MULTITHREAD
%  static fnServerObjectObjIdSize_rets	Result;
%  RESULTTYPE			pResult = &Result;
%#endif
%  LPCSTR	pszErrorMsg;
%
%  __pRequest__	= pRequest;
%
%  RPC_SERVER_ENTRY();
%
%#ifndef MULTITHREAD
%  if ( pResult->pszErrorMsg == szEmpty ) {
%    pResult->pszErrorMsg	= NULL;
%  }
%  xdr_free ( (xdrproc_t) xdr_fnServerObjectObjIdSize_rets, (char *) pResult );
%#endif
%  pResult->nErrorLvl		= 0;
%
%  Reply.bAnswered		= FALSE;
%  Reply.pfnCalled		= (void(*)()) fnServerObjectObjIdSize;
%  Reply.pfnXdrResult		= (bool_t(*)()) xdr_fnServerObjectObjIdSize_rets;
%  Reply.pnErrorLvl		= &pResult->nErrorLvl;
%  Reply.ppszErrorMsg		= (LPCSTR *) &pResult->pszErrorMsg;
%  Reply.pResult		= pResult;
%  Reply.pReturnValue		= &pResult->ReturnValue;
%  Reply.nReturnValueSize	= sizeof ( pResult->ReturnValue );
%
%  pResult->ReturnValue		=
%  fnServerObjectObjIdSize (
%	pArguments->oShortObjIdHeap,
%	pArguments->oShortObjId );
%
%  if ( Reply.bAnswered ) {
%    __pRequest__	= NULL;
%    return (RESULTTYPE) NULL;
%  }
%
%  pResult->nErrorLvl	= RPC_SERVER_ERRLVL();
%  if ( pResult->nErrorLvl > 0 ) {
%    pszErrorMsg		= RPC_SERVER_ERRMSG();
%    if ( pszErrorMsg && *pszErrorMsg ) {
%      pResult->pszErrorMsg	= strdup ( pszErrorMsg );
%    }
%  }
%  if ( pResult->pszErrorMsg == NULL ) {
%#ifdef MULTITHREAD
%    pResult->pszErrorMsg	= strdup ( szEmpty );
%#else
%    pResult->pszErrorMsg	= (LPSTR) szEmpty;
%#endif
%  }
%  __pRequest__	= NULL;
%  return (RESULTTYPE) pResult;
%} /* fnrpc_fnserverobjectobjidsize_1 */
#endif	/* RPC_SVC */
%
#if RPC_CLNT
%int DLLEXPORT fnServerObjectObjIdSize
%	(SHORTOBJID oShortObjIdHeap ,
%	  SHORTOBJID oShortObjId)
%{
%  static const char	__procedure__[]	= "client:fnServerObjectObjIdSize";
%  static fnServerObjectObjIdSize_rets	ZeroResult;
%  fnServerObjectObjIdSize_rets		* pResult = NULL;
%  fnServerObjectObjIdSize_rets		Result = ZeroResult;
%  fnServerObjectObjIdSize_args	InArguments;
%
%  /* Client initialization: */
%  if ( __bClientInitialize__ ) {
%    __bClientInitialize__	= FALSE;
%    RPC_CLIENT_INITIALIZE();
%  }
%
%#if	CLIENT_CREATE_BY_USER
%  if ( __pClient__ == NULL ) {
%    __pClient__	= RPC_CLIENT_CREATE ( __szHost__, __szTransport__ );
%    if ( __pClient__ == NULL ) {
%      /* Error handling for a not connected client: */
%      char	szError [ 256 ];
%      sprintf ( szError, szFormatNoServer, __procedure__ );
%      RPC_CLIENT_ERROR ( szError );
%      return Result.ReturnValue;
%    }
%  }
%#else
%  while ( __pClient__ == NULL ) {
%    __pClient__	= RPC_CLIENT_CREATE ( __szHost__, __szTransport__ );
%    if ( __pClient__ == NULL ) {
%      /* Error handling for a not connected client: */
%      char	szError [ 256 ];
%      sprintf ( szError, szFormatNoServer, __procedure__ );
%      RPC_CLIENT_CERROR ( szContNoServer, szError );
%    }
%  }
%#endif	/* CLIENT_CREATE_BY_USER */
%
%  /* Copy in the oShortObjIdHeap argument: */
%  InArguments.oShortObjIdHeap	= oShortObjIdHeap;
%  /* Copy in the oShortObjId argument: */
%  InArguments.oShortObjId	= oShortObjId;
%
%  pResult	=
%#ifdef MULTITHREAD
%    (
%#else
%    (fnServerObjectObjIdSize_rets *)
%#endif
%    fnrpc_fnserverobjectobjidsize_1 (
%	&InArguments,
%#ifdef MULTITHREAD
%	&Result,
%#endif
%	__pClient__ )
%#ifdef MULTITHREAD
%	== RPC_SUCCESS ) ? &Result : NULL
%#endif
%	;
%
%  if ( pResult == NULL ) {
%    /* Error handling for a failed RPC call, */
%    /* i.e. the server did not respond: */
%    char	szError [ 256 ];
%    sprintf ( szError, szFormatRpcFailed, __procedure__,
%              clnt_sperror ( __pClient__, __szHost__ ) );
%    __pClient__	= RPC_CLIENT_DESTROY ( __pClient__ );
%    RPC_CLIENT_CERROR ( szContRpcFailed, szError );
%    Result	= ZeroResult;
%    return Result.ReturnValue;
%  }
%#ifndef MULTITHREAD
%  Result	= * pResult;
%#endif
%
%
%  if ( pResult && pResult->nErrorLvl ) {
%    /* Server returned a user error message: */
%    char	szErrorMsg [ 1024 ];
%    strncpy ( szErrorMsg,
%              ( pResult->pszErrorMsg && pResult->pszErrorMsg [ 0 ] ) ?
%              (LPCSTR) pResult->pszErrorMsg : (LPCSTR) szEmpty,
%              sizeof ( szErrorMsg ) );
%    szErrorMsg [ sizeof ( szErrorMsg ) - 1 ]	= (char) 0;
%    xdr_free ( (xdrproc_t) xdr_fnServerObjectObjIdSize_rets, (char *) pResult );
%    RPC_CLIENT_SERROR ( pResult->nErrorLvl, __procedure__,
%                        szErrorMsg );
%  } else {
%    xdr_free ( (xdrproc_t) xdr_fnServerObjectObjIdSize_rets, (char *) pResult );
%  }
%
%  return Result.ReturnValue;
%
%} /* fnServerObjectObjIdSize */
#endif	/* RPC_CLNT */
%
  fnServerDbOpen_rets fnRpc_fnServerDbOpen ( fnServerDbOpen_args ) =  25 ;
%
#if RPC_SVC
%
%extern SHORTOBJID fnServerDbOpen
%	(string_t /* string_t<@conststring@> */ szDirectory ,
%	  string_t /* string_t<@conststring@> */ szUserName ,
%	  string_t /* string_t<@conststring@> */ szDescription ,
%	  int nMinAddrInK ,
%	  OBJID * poObjIdMin ,
%	  OBJID * poObjIdMax);
%
%#ifdef MULTITHREAD
%bool_t
%#else
%fnServerDbOpen_rets *
%#endif
%	PASTE2(fnrpc_fnserverdbopen_1,_SVCSUFFIX)
%		( fnServerDbOpen_args * pArguments,
%#ifdef MULTITHREAD
%		  fnServerDbOpen_rets * pResult,
%#endif
%		  struct svc_req * pRequest )
%{
%  static const char	__procedure__[]	= "server:fnrpc_fnserverdbopen_1";
%#ifdef MULTITHREAD
%  typedef bool_t RESULTTYPE;
%#else
%  typedef fnServerDbOpen_rets * RESULTTYPE;
%#endif
%#ifndef MULTITHREAD
%  static fnServerDbOpen_rets	Result;
%  RESULTTYPE			pResult = &Result;
%#endif
%  LPCSTR	pszErrorMsg;
%
%  __pRequest__	= pRequest;
%
%  RPC_SERVER_ENTRY();
%
%#ifndef MULTITHREAD
%  if ( pResult->pszErrorMsg == szEmpty ) {
%    pResult->pszErrorMsg	= NULL;
%  }
%  xdr_free ( (xdrproc_t) xdr_fnServerDbOpen_rets, (char *) pResult );
%#endif
%  pResult->nErrorLvl		= 0;
%
%  Reply.bAnswered		= FALSE;
%  Reply.pfnCalled		= (void(*)()) fnServerDbOpen;
%  Reply.pfnXdrResult		= (bool_t(*)()) xdr_fnServerDbOpen_rets;
%  Reply.pnErrorLvl		= &pResult->nErrorLvl;
%  Reply.ppszErrorMsg		= (LPCSTR *) &pResult->pszErrorMsg;
%  Reply.pResult		= pResult;
%  Reply.pReturnValue		= &pResult->ReturnValue;
%  Reply.nReturnValueSize	= sizeof ( pResult->ReturnValue );
%
%  pResult->ReturnValue		=
%  fnServerDbOpen (
%	pArguments->szDirectory,
%	pArguments->szUserName,
%	pArguments->szDescription,
%	pArguments->nMinAddrInK,
%	&pResult->poObjIdMin,
%	&pResult->poObjIdMax );
%
%  if ( Reply.bAnswered ) {
%    __pRequest__	= NULL;
%    return (RESULTTYPE) NULL;
%  }
%
%  pResult->nErrorLvl	= RPC_SERVER_ERRLVL();
%  if ( pResult->nErrorLvl > 0 ) {
%    pszErrorMsg		= RPC_SERVER_ERRMSG();
%    if ( pszErrorMsg && *pszErrorMsg ) {
%      pResult->pszErrorMsg	= strdup ( pszErrorMsg );
%    }
%  }
%  if ( pResult->pszErrorMsg == NULL ) {
%#ifdef MULTITHREAD
%    pResult->pszErrorMsg	= strdup ( szEmpty );
%#else
%    pResult->pszErrorMsg	= (LPSTR) szEmpty;
%#endif
%  }
%  __pRequest__	= NULL;
%  return (RESULTTYPE) pResult;
%} /* fnrpc_fnserverdbopen_1 */
#endif	/* RPC_SVC */
%
#if RPC_CLNT
%SHORTOBJID DLLEXPORT fnServerDbOpen
%	(string_t /* string_t<@conststring@> */ szDirectory ,
%	  string_t /* string_t<@conststring@> */ szUserName ,
%	  string_t /* string_t<@conststring@> */ szDescription ,
%	  int nMinAddrInK ,
%	  OBJID * poObjIdMin ,
%	  OBJID * poObjIdMax)
%{
%  static const char	__procedure__[]	= "client:fnServerDbOpen";
%  static fnServerDbOpen_rets	ZeroResult;
%  fnServerDbOpen_rets		* pResult = NULL;
%  fnServerDbOpen_rets		Result = ZeroResult;
%  fnServerDbOpen_args	InArguments;
%
%  /* Client initialization: */
%  if ( __bClientInitialize__ ) {
%    __bClientInitialize__	= FALSE;
%    RPC_CLIENT_INITIALIZE();
%  }
%
%#if	CLIENT_CREATE_BY_USER
%  if ( __pClient__ == NULL ) {
%    __pClient__	= RPC_CLIENT_CREATE ( __szHost__, __szTransport__ );
%    if ( __pClient__ == NULL ) {
%      /* Error handling for a not connected client: */
%      char	szError [ 256 ];
%      sprintf ( szError, szFormatNoServer, __procedure__ );
%      RPC_CLIENT_ERROR ( szError );
%      return Result.ReturnValue;
%    }
%  }
%#else
%  while ( __pClient__ == NULL ) {
%    __pClient__	= RPC_CLIENT_CREATE ( __szHost__, __szTransport__ );
%    if ( __pClient__ == NULL ) {
%      /* Error handling for a not connected client: */
%      char	szError [ 256 ];
%      sprintf ( szError, szFormatNoServer, __procedure__ );
%      RPC_CLIENT_CERROR ( szContNoServer, szError );
%    }
%  }
%#endif	/* CLIENT_CREATE_BY_USER */
%
%  /* Copy in the szDirectory argument: */
%  InArguments.szDirectory	= szDirectory;
%  if ( szDirectory == NULL ) {
%    /* Error handling for passing a NULL string pointer: */
%    char	szError [ 256 ];
%    InArguments.szDirectory	= (LPSTR) szEmpty;
%    sprintf ( szError, szFormatNullString,
%              __procedure__, "szDirectory" );
%    RPC_CLIENT_CERROR ( szContNullString, szError );
%  }
%  /* Copy in the szUserName argument: */
%  InArguments.szUserName	= szUserName;
%  if ( szUserName == NULL ) {
%    /* Error handling for passing a NULL string pointer: */
%    char	szError [ 256 ];
%    InArguments.szUserName	= (LPSTR) szEmpty;
%    sprintf ( szError, szFormatNullString,
%              __procedure__, "szUserName" );
%    RPC_CLIENT_CERROR ( szContNullString, szError );
%  }
%  /* Copy in the szDescription argument: */
%  InArguments.szDescription	= szDescription;
%  if ( szDescription == NULL ) {
%    /* Error handling for passing a NULL string pointer: */
%    char	szError [ 256 ];
%    InArguments.szDescription	= (LPSTR) szEmpty;
%    sprintf ( szError, szFormatNullString,
%              __procedure__, "szDescription" );
%    RPC_CLIENT_CERROR ( szContNullString, szError );
%  }
%  /* Copy in the nMinAddrInK argument: */
%  InArguments.nMinAddrInK	= nMinAddrInK;
%
%  pResult	=
%#ifdef MULTITHREAD
%    (
%#else
%    (fnServerDbOpen_rets *)
%#endif
%    fnrpc_fnserverdbopen_1 (
%	&InArguments,
%#ifdef MULTITHREAD
%	&Result,
%#endif
%	__pClient__ )
%#ifdef MULTITHREAD
%	== RPC_SUCCESS ) ? &Result : NULL
%#endif
%	;
%
%  if ( pResult == NULL ) {
%    /* Error handling for a failed RPC call, */
%    /* i.e. the server did not respond: */
%    char	szError [ 256 ];
%    sprintf ( szError, szFormatRpcFailed, __procedure__,
%              clnt_sperror ( __pClient__, __szHost__ ) );
%    __pClient__	= RPC_CLIENT_DESTROY ( __pClient__ );
%    RPC_CLIENT_CERROR ( szContRpcFailed, szError );
%    Result	= ZeroResult;
%    return Result.ReturnValue;
%  }
%#ifndef MULTITHREAD
%  Result	= * pResult;
%#endif
%
%  /* Copy out the poObjIdMin argument: */
%  if ( ! ( 
%       poObjIdMin == NULL ) ) {
%    *poObjIdMin	= pResult->poObjIdMin;
%  }
%  /* Copy out the poObjIdMax argument: */
%  if ( ! ( 
%       poObjIdMax == NULL ) ) {
%    *poObjIdMax	= pResult->poObjIdMax;
%  }
%
%  if ( pResult && pResult->nErrorLvl ) {
%    /* Server returned a user error message: */
%    char	szErrorMsg [ 1024 ];
%    strncpy ( szErrorMsg,
%              ( pResult->pszErrorMsg && pResult->pszErrorMsg [ 0 ] ) ?
%              (LPCSTR) pResult->pszErrorMsg : (LPCSTR) szEmpty,
%              sizeof ( szErrorMsg ) );
%    szErrorMsg [ sizeof ( szErrorMsg ) - 1 ]	= (char) 0;
%    xdr_free ( (xdrproc_t) xdr_fnServerDbOpen_rets, (char *) pResult );
%    RPC_CLIENT_SERROR ( pResult->nErrorLvl, __procedure__,
%                        szErrorMsg );
%  } else {
%    xdr_free ( (xdrproc_t) xdr_fnServerDbOpen_rets, (char *) pResult );
%  }
%  if ( 
%       poObjIdMin == NULL ) {
%    /* Error handling for passing a NULL pointer on */
%    /* out argument: */
%    char	szError [ 256 ];
%    sprintf ( szError, szFormatNullPassed,
%              __procedure__, "poObjIdMin" );
%    RPC_CLIENT_CERROR ( szContNullOutPassed, szError );
%  }
%  if ( 
%       poObjIdMax == NULL ) {
%    /* Error handling for passing a NULL pointer on */
%    /* out argument: */
%    char	szError [ 256 ];
%    sprintf ( szError, szFormatNullPassed,
%              __procedure__, "poObjIdMax" );
%    RPC_CLIENT_CERROR ( szContNullOutPassed, szError );
%  }
%
%  return Result.ReturnValue;
%
%} /* fnServerDbOpen */
#endif	/* RPC_CLNT */
%
  fnServerObjectFlush_rets fnRpc_fnServerObjectFlush ( fnServerObjectFlush_args ) =  26 ;
%
#if RPC_SVC
%
%extern bool_t fnServerObjectFlush
%	(SHORTOBJID oShortObjIdHeap ,
%	  SHORTOBJID oShortObjId);
%
%#ifdef MULTITHREAD
%bool_t
%#else
%fnServerObjectFlush_rets *
%#endif
%	PASTE2(fnrpc_fnserverobjectflush_1,_SVCSUFFIX)
%		( fnServerObjectFlush_args * pArguments,
%#ifdef MULTITHREAD
%		  fnServerObjectFlush_rets * pResult,
%#endif
%		  struct svc_req * pRequest )
%{
%  static const char	__procedure__[]	= "server:fnrpc_fnserverobjectflush_1";
%#ifdef MULTITHREAD
%  typedef bool_t RESULTTYPE;
%#else
%  typedef fnServerObjectFlush_rets * RESULTTYPE;
%#endif
%#ifndef MULTITHREAD
%  static fnServerObjectFlush_rets	Result;
%  RESULTTYPE			pResult = &Result;
%#endif
%  LPCSTR	pszErrorMsg;
%
%  __pRequest__	= pRequest;
%
%  RPC_SERVER_ENTRY();
%
%#ifndef MULTITHREAD
%  if ( pResult->pszErrorMsg == szEmpty ) {
%    pResult->pszErrorMsg	= NULL;
%  }
%  xdr_free ( (xdrproc_t) xdr_fnServerObjectFlush_rets, (char *) pResult );
%#endif
%  pResult->nErrorLvl		= 0;
%
%  Reply.bAnswered		= FALSE;
%  Reply.pfnCalled		= (void(*)()) fnServerObjectFlush;
%  Reply.pfnXdrResult		= (bool_t(*)()) xdr_fnServerObjectFlush_rets;
%  Reply.pnErrorLvl		= &pResult->nErrorLvl;
%  Reply.ppszErrorMsg		= (LPCSTR *) &pResult->pszErrorMsg;
%  Reply.pResult		= pResult;
%  Reply.pReturnValue		= &pResult->ReturnValue;
%  Reply.nReturnValueSize	= sizeof ( pResult->ReturnValue );
%
%  pResult->ReturnValue		=
%  fnServerObjectFlush (
%	pArguments->oShortObjIdHeap,
%	pArguments->oShortObjId );
%
%  if ( Reply.bAnswered ) {
%    __pRequest__	= NULL;
%    return (RESULTTYPE) NULL;
%  }
%
%  pResult->nErrorLvl	= RPC_SERVER_ERRLVL();
%  if ( pResult->nErrorLvl > 0 ) {
%    pszErrorMsg		= RPC_SERVER_ERRMSG();
%    if ( pszErrorMsg && *pszErrorMsg ) {
%      pResult->pszErrorMsg	= strdup ( pszErrorMsg );
%    }
%  }
%  if ( pResult->pszErrorMsg == NULL ) {
%#ifdef MULTITHREAD
%    pResult->pszErrorMsg	= strdup ( szEmpty );
%#else
%    pResult->pszErrorMsg	= (LPSTR) szEmpty;
%#endif
%  }
%  __pRequest__	= NULL;
%  return (RESULTTYPE) pResult;
%} /* fnrpc_fnserverobjectflush_1 */
#endif	/* RPC_SVC */
%
#if RPC_CLNT
%bool_t DLLEXPORT fnServerObjectFlush
%	(SHORTOBJID oShortObjIdHeap ,
%	  SHORTOBJID oShortObjId)
%{
%  static const char	__procedure__[]	= "client:fnServerObjectFlush";
%  static fnServerObjectFlush_rets	ZeroResult;
%  fnServerObjectFlush_rets		* pResult = NULL;
%  fnServerObjectFlush_rets		Result = ZeroResult;
%  fnServerObjectFlush_args	InArguments;
%
%  /* Client initialization: */
%  if ( __bClientInitialize__ ) {
%    __bClientInitialize__	= FALSE;
%    RPC_CLIENT_INITIALIZE();
%  }
%
%#if	CLIENT_CREATE_BY_USER
%  if ( __pClient__ == NULL ) {
%    __pClient__	= RPC_CLIENT_CREATE ( __szHost__, __szTransport__ );
%    if ( __pClient__ == NULL ) {
%      /* Error handling for a not connected client: */
%      char	szError [ 256 ];
%      sprintf ( szError, szFormatNoServer, __procedure__ );
%      RPC_CLIENT_ERROR ( szError );
%      return Result.ReturnValue;
%    }
%  }
%#else
%  while ( __pClient__ == NULL ) {
%    __pClient__	= RPC_CLIENT_CREATE ( __szHost__, __szTransport__ );
%    if ( __pClient__ == NULL ) {
%      /* Error handling for a not connected client: */
%      char	szError [ 256 ];
%      sprintf ( szError, szFormatNoServer, __procedure__ );
%      RPC_CLIENT_CERROR ( szContNoServer, szError );
%    }
%  }
%#endif	/* CLIENT_CREATE_BY_USER */
%
%  /* Copy in the oShortObjIdHeap argument: */
%  InArguments.oShortObjIdHeap	= oShortObjIdHeap;
%  /* Copy in the oShortObjId argument: */
%  InArguments.oShortObjId	= oShortObjId;
%
%  pResult	=
%#ifdef MULTITHREAD
%    (
%#else
%    (fnServerObjectFlush_rets *)
%#endif
%    fnrpc_fnserverobjectflush_1 (
%	&InArguments,
%#ifdef MULTITHREAD
%	&Result,
%#endif
%	__pClient__ )
%#ifdef MULTITHREAD
%	== RPC_SUCCESS ) ? &Result : NULL
%#endif
%	;
%
%  if ( pResult == NULL ) {
%    /* Error handling for a failed RPC call, */
%    /* i.e. the server did not respond: */
%    char	szError [ 256 ];
%    sprintf ( szError, szFormatRpcFailed, __procedure__,
%              clnt_sperror ( __pClient__, __szHost__ ) );
%    __pClient__	= RPC_CLIENT_DESTROY ( __pClient__ );
%    RPC_CLIENT_CERROR ( szContRpcFailed, szError );
%    Result	= ZeroResult;
%    return Result.ReturnValue;
%  }
%#ifndef MULTITHREAD
%  Result	= * pResult;
%#endif
%
%
%  if ( pResult && pResult->nErrorLvl ) {
%    /* Server returned a user error message: */
%    char	szErrorMsg [ 1024 ];
%    strncpy ( szErrorMsg,
%              ( pResult->pszErrorMsg && pResult->pszErrorMsg [ 0 ] ) ?
%              (LPCSTR) pResult->pszErrorMsg : (LPCSTR) szEmpty,
%              sizeof ( szErrorMsg ) );
%    szErrorMsg [ sizeof ( szErrorMsg ) - 1 ]	= (char) 0;
%    xdr_free ( (xdrproc_t) xdr_fnServerObjectFlush_rets, (char *) pResult );
%    RPC_CLIENT_SERROR ( pResult->nErrorLvl, __procedure__,
%                        szErrorMsg );
%  } else {
%    xdr_free ( (xdrproc_t) xdr_fnServerObjectFlush_rets, (char *) pResult );
%  }
%
%  return Result.ReturnValue;
%
%} /* fnServerObjectFlush */
#endif	/* RPC_CLNT */
%
  fnServerObjectReadAtIndex_rets fnRpc_fnServerObjectReadAtIndex ( fnServerObjectReadAtIndex_args ) =  27 ;
%
#if RPC_SVC
%
%extern SHLOCK fnServerObjectReadAtIndex
%	(SHORTOBJID oShortObjIdHeap ,
%	  SHORTOBJID oShortObjId ,
%	  SHORTOBJID oExpectingClass ,
%	  SHTYPETAG nExpectingTypeTag ,
%	  int nIndex ,
%	  int * pnValue ,
%	  SHTYPETAG * pnTypeTag);
%
%#ifdef MULTITHREAD
%bool_t
%#else
%fnServerObjectReadAtIndex_rets *
%#endif
%	PASTE2(fnrpc_fnserverobjectreadatindex_1,_SVCSUFFIX)
%		( fnServerObjectReadAtIndex_args * pArguments,
%#ifdef MULTITHREAD
%		  fnServerObjectReadAtIndex_rets * pResult,
%#endif
%		  struct svc_req * pRequest )
%{
%  static const char	__procedure__[]	= "server:fnrpc_fnserverobjectreadatindex_1";
%#ifdef MULTITHREAD
%  typedef bool_t RESULTTYPE;
%#else
%  typedef fnServerObjectReadAtIndex_rets * RESULTTYPE;
%#endif
%#ifndef MULTITHREAD
%  static fnServerObjectReadAtIndex_rets	Result;
%  RESULTTYPE			pResult = &Result;
%#endif
%  LPCSTR	pszErrorMsg;
%
%  __pRequest__	= pRequest;
%
%  RPC_SERVER_ENTRY();
%
%#ifndef MULTITHREAD
%  if ( pResult->pszErrorMsg == szEmpty ) {
%    pResult->pszErrorMsg	= NULL;
%  }
%  xdr_free ( (xdrproc_t) xdr_fnServerObjectReadAtIndex_rets, (char *) pResult );
%#endif
%  pResult->nErrorLvl		= 0;
%
%  Reply.bAnswered		= FALSE;
%  Reply.pfnCalled		= (void(*)()) fnServerObjectReadAtIndex;
%  Reply.pfnXdrResult		= (bool_t(*)()) xdr_fnServerObjectReadAtIndex_rets;
%  Reply.pnErrorLvl		= &pResult->nErrorLvl;
%  Reply.ppszErrorMsg		= (LPCSTR *) &pResult->pszErrorMsg;
%  Reply.pResult		= pResult;
%  Reply.pReturnValue		= &pResult->ReturnValue;
%  Reply.nReturnValueSize	= sizeof ( pResult->ReturnValue );
%
%  pResult->ReturnValue		=
%  fnServerObjectReadAtIndex (
%	pArguments->oShortObjIdHeap,
%	pArguments->oShortObjId,
%	pArguments->oExpectingClass,
%	pArguments->nExpectingTypeTag,
%	pArguments->nIndex,
%	&pResult->pnValue,
%	&pResult->pnTypeTag );
%
%  if ( Reply.bAnswered ) {
%    __pRequest__	= NULL;
%    return (RESULTTYPE) NULL;
%  }
%
%  pResult->nErrorLvl	= RPC_SERVER_ERRLVL();
%  if ( pResult->nErrorLvl > 0 ) {
%    pszErrorMsg		= RPC_SERVER_ERRMSG();
%    if ( pszErrorMsg && *pszErrorMsg ) {
%      pResult->pszErrorMsg	= strdup ( pszErrorMsg );
%    }
%  }
%  if ( pResult->pszErrorMsg == NULL ) {
%#ifdef MULTITHREAD
%    pResult->pszErrorMsg	= strdup ( szEmpty );
%#else
%    pResult->pszErrorMsg	= (LPSTR) szEmpty;
%#endif
%  }
%  __pRequest__	= NULL;
%  return (RESULTTYPE) pResult;
%} /* fnrpc_fnserverobjectreadatindex_1 */
#endif	/* RPC_SVC */
%
#if RPC_CLNT
%SHLOCK DLLEXPORT fnServerObjectReadAtIndex
%	(SHORTOBJID oShortObjIdHeap ,
%	  SHORTOBJID oShortObjId ,
%	  SHORTOBJID oExpectingClass ,
%	  SHTYPETAG nExpectingTypeTag ,
%	  int nIndex ,
%	  int * pnValue ,
%	  SHTYPETAG * pnTypeTag)
%{
%  static const char	__procedure__[]	= "client:fnServerObjectReadAtIndex";
%  static fnServerObjectReadAtIndex_rets	ZeroResult;
%  fnServerObjectReadAtIndex_rets		* pResult = NULL;
%  fnServerObjectReadAtIndex_rets		Result = ZeroResult;
%  fnServerObjectReadAtIndex_args	InArguments;
%
%  /* Client initialization: */
%  if ( __bClientInitialize__ ) {
%    __bClientInitialize__	= FALSE;
%    RPC_CLIENT_INITIALIZE();
%  }
%
%#if	CLIENT_CREATE_BY_USER
%  if ( __pClient__ == NULL ) {
%    __pClient__	= RPC_CLIENT_CREATE ( __szHost__, __szTransport__ );
%    if ( __pClient__ == NULL ) {
%      /* Error handling for a not connected client: */
%      char	szError [ 256 ];
%      sprintf ( szError, szFormatNoServer, __procedure__ );
%      RPC_CLIENT_ERROR ( szError );
%      return Result.ReturnValue;
%    }
%  }
%#else
%  while ( __pClient__ == NULL ) {
%    __pClient__	= RPC_CLIENT_CREATE ( __szHost__, __szTransport__ );
%    if ( __pClient__ == NULL ) {
%      /* Error handling for a not connected client: */
%      char	szError [ 256 ];
%      sprintf ( szError, szFormatNoServer, __procedure__ );
%      RPC_CLIENT_CERROR ( szContNoServer, szError );
%    }
%  }
%#endif	/* CLIENT_CREATE_BY_USER */
%
%  /* Copy in the oShortObjIdHeap argument: */
%  InArguments.oShortObjIdHeap	= oShortObjIdHeap;
%  /* Copy in the oShortObjId argument: */
%  InArguments.oShortObjId	= oShortObjId;
%  /* Copy in the oExpectingClass argument: */
%  InArguments.oExpectingClass	= oExpectingClass;
%  /* Copy in the nExpectingTypeTag argument: */
%  InArguments.nExpectingTypeTag	= nExpectingTypeTag;
%  /* Copy in the nIndex argument: */
%  InArguments.nIndex	= nIndex;
%
%  pResult	=
%#ifdef MULTITHREAD
%    (
%#else
%    (fnServerObjectReadAtIndex_rets *)
%#endif
%    fnrpc_fnserverobjectreadatindex_1 (
%	&InArguments,
%#ifdef MULTITHREAD
%	&Result,
%#endif
%	__pClient__ )
%#ifdef MULTITHREAD
%	== RPC_SUCCESS ) ? &Result : NULL
%#endif
%	;
%
%  if ( pResult == NULL ) {
%    /* Error handling for a failed RPC call, */
%    /* i.e. the server did not respond: */
%    char	szError [ 256 ];
%    sprintf ( szError, szFormatRpcFailed, __procedure__,
%              clnt_sperror ( __pClient__, __szHost__ ) );
%    __pClient__	= RPC_CLIENT_DESTROY ( __pClient__ );
%    RPC_CLIENT_CERROR ( szContRpcFailed, szError );
%    Result	= ZeroResult;
%    return Result.ReturnValue;
%  }
%#ifndef MULTITHREAD
%  Result	= * pResult;
%#endif
%
%  /* Copy out the pnValue argument: */
%  if ( ! ( 
%       pnValue == NULL ) ) {
%    *pnValue	= pResult->pnValue;
%  }
%  /* Copy out the pnTypeTag argument: */
%  if ( ! ( 
%       pnTypeTag == NULL ) ) {
%    *pnTypeTag	= pResult->pnTypeTag;
%  }
%
%  if ( pResult && pResult->nErrorLvl ) {
%    /* Server returned a user error message: */
%    char	szErrorMsg [ 1024 ];
%    strncpy ( szErrorMsg,
%              ( pResult->pszErrorMsg && pResult->pszErrorMsg [ 0 ] ) ?
%              (LPCSTR) pResult->pszErrorMsg : (LPCSTR) szEmpty,
%              sizeof ( szErrorMsg ) );
%    szErrorMsg [ sizeof ( szErrorMsg ) - 1 ]	= (char) 0;
%    xdr_free ( (xdrproc_t) xdr_fnServerObjectReadAtIndex_rets, (char *) pResult );
%    RPC_CLIENT_SERROR ( pResult->nErrorLvl, __procedure__,
%                        szErrorMsg );
%  } else {
%    xdr_free ( (xdrproc_t) xdr_fnServerObjectReadAtIndex_rets, (char *) pResult );
%  }
%  if ( 
%       pnValue == NULL ) {
%    /* Error handling for passing a NULL pointer on */
%    /* out argument: */
%    char	szError [ 256 ];
%    sprintf ( szError, szFormatNullPassed,
%              __procedure__, "pnValue" );
%    RPC_CLIENT_CERROR ( szContNullOutPassed, szError );
%  }
%  if ( 
%       pnTypeTag == NULL ) {
%    /* Error handling for passing a NULL pointer on */
%    /* out argument: */
%    char	szError [ 256 ];
%    sprintf ( szError, szFormatNullPassed,
%              __procedure__, "pnTypeTag" );
%    RPC_CLIENT_CERROR ( szContNullOutPassed, szError );
%  }
%
%  return Result.ReturnValue;
%
%} /* fnServerObjectReadAtIndex */
#endif	/* RPC_CLNT */
%
  fnServerObjectReadAtIndices_rets fnRpc_fnServerObjectReadAtIndices ( fnServerObjectReadAtIndices_args ) =  28 ;
%
#if RPC_SVC
%
%extern int fnServerObjectReadAtIndices
%	(SHORTOBJID oShortObjIdHeap ,
%	  SHORTOBJID oShortObjId ,
%	  SHORTOBJID oExpectingClass ,
%	  SHTYPETAG nExpectingTypeTag ,
%	  int nIndex ,
%	  int nObjIds ,
%	  int * /* _vector_t<nObjIds> */  pObjIds ,
%	  u_int * /* _vector_t<nObjIds> */  pnTypeTags);
%
%#ifdef MULTITHREAD
%bool_t
%#else
%fnServerObjectReadAtIndices_rets *
%#endif
%	PASTE2(fnrpc_fnserverobjectreadatindices_1,_SVCSUFFIX)
%		( fnServerObjectReadAtIndices_args * pArguments,
%#ifdef MULTITHREAD
%		  fnServerObjectReadAtIndices_rets * pResult,
%#endif
%		  struct svc_req * pRequest )
%{
%  static const char	__procedure__[]	= "server:fnrpc_fnserverobjectreadatindices_1";
%#ifdef MULTITHREAD
%  typedef bool_t RESULTTYPE;
%#else
%  typedef fnServerObjectReadAtIndices_rets * RESULTTYPE;
%#endif
%#ifndef MULTITHREAD
%  static fnServerObjectReadAtIndices_rets	Result;
%  RESULTTYPE			pResult = &Result;
%#endif
%  LPCSTR	pszErrorMsg;
%
%  __pRequest__	= pRequest;
%
%  RPC_SERVER_ENTRY();
%
%#ifndef MULTITHREAD
%  if ( pResult->pszErrorMsg == szEmpty ) {
%    pResult->pszErrorMsg	= NULL;
%  }
%  xdr_free ( (xdrproc_t) xdr_fnServerObjectReadAtIndices_rets, (char *) pResult );
%#endif
%  pResult->nErrorLvl		= 0;
%
%  pResult->pObjIds.int_vector_t_len	= pArguments->pObjIdsSize;
%  if ( pArguments->pObjIdsSize == 0 ) {
%    pResult->pObjIds.int_vector_t_val	= NULL;
%  } else {
%    pResult->pObjIds.int_vector_t_val	=
%      (int*) malloc ( pArguments->pObjIdsSize *
%               SIZEOF ( *(pResult->pObjIds.int_vector_t_val) ) );
%    if ( pResult->pObjIds.int_vector_t_val == NULL ) {
%      char	szError [ 256 ];
%      sprintf ( szError, szFormatMallocFailed,
%                __procedure__, pArguments->pObjIdsSize,
%                "pObjIds" );
%      RPC_SERVER_ERROR ( szError );
%      return (RESULTTYPE) NULL;
%    }
%  }
%  pResult->pnTypeTags.u_int_vector_t_len	= pArguments->pnTypeTagsSize;
%  if ( pArguments->pnTypeTagsSize == 0 ) {
%    pResult->pnTypeTags.u_int_vector_t_val	= NULL;
%  } else {
%    pResult->pnTypeTags.u_int_vector_t_val	=
%      (u_int*) malloc ( pArguments->pnTypeTagsSize *
%               SIZEOF ( *(pResult->pnTypeTags.u_int_vector_t_val) ) );
%    if ( pResult->pnTypeTags.u_int_vector_t_val == NULL ) {
%      char	szError [ 256 ];
%      sprintf ( szError, szFormatMallocFailed,
%                __procedure__, pArguments->pnTypeTagsSize,
%                "pnTypeTags" );
%      RPC_SERVER_ERROR ( szError );
%      return (RESULTTYPE) NULL;
%    }
%  }
%  Reply.bAnswered		= FALSE;
%  Reply.pfnCalled		= (void(*)()) fnServerObjectReadAtIndices;
%  Reply.pfnXdrResult		= (bool_t(*)()) xdr_fnServerObjectReadAtIndices_rets;
%  Reply.pnErrorLvl		= &pResult->nErrorLvl;
%  Reply.ppszErrorMsg		= (LPCSTR *) &pResult->pszErrorMsg;
%  Reply.pResult		= pResult;
%  Reply.pReturnValue		= &pResult->ReturnValue;
%  Reply.nReturnValueSize	= sizeof ( pResult->ReturnValue );
%
%  pResult->ReturnValue		=
%  fnServerObjectReadAtIndices (
%	pArguments->oShortObjIdHeap,
%	pArguments->oShortObjId,
%	pArguments->oExpectingClass,
%	pArguments->nExpectingTypeTag,
%	pArguments->nIndex,
%	pArguments->nObjIds,
%	pResult->pObjIds.int_vector_t_val,
%	pResult->pnTypeTags.u_int_vector_t_val );
%
%  if ( Reply.bAnswered ) {
%    __pRequest__	= NULL;
%    return (RESULTTYPE) NULL;
%  }
%
%  pResult->nErrorLvl	= RPC_SERVER_ERRLVL();
%  if ( pResult->nErrorLvl > 0 ) {
%    pszErrorMsg		= RPC_SERVER_ERRMSG();
%    if ( pszErrorMsg && *pszErrorMsg ) {
%      pResult->pszErrorMsg	= strdup ( pszErrorMsg );
%    }
%  }
%  if ( pResult->pszErrorMsg == NULL ) {
%#ifdef MULTITHREAD
%    pResult->pszErrorMsg	= strdup ( szEmpty );
%#else
%    pResult->pszErrorMsg	= (LPSTR) szEmpty;
%#endif
%  }
%  __pRequest__	= NULL;
%  return (RESULTTYPE) pResult;
%} /* fnrpc_fnserverobjectreadatindices_1 */
#endif	/* RPC_SVC */
%
#if RPC_CLNT
%int DLLEXPORT fnServerObjectReadAtIndices
%	(SHORTOBJID oShortObjIdHeap ,
%	  SHORTOBJID oShortObjId ,
%	  SHORTOBJID oExpectingClass ,
%	  SHTYPETAG nExpectingTypeTag ,
%	  int nIndex ,
%	  int nObjIds ,
%	  int * /* _vector_t<nObjIds> */  pObjIds ,
%	  u_int * /* _vector_t<nObjIds> */  pnTypeTags)
%{
%  static const char	__procedure__[]	= "client:fnServerObjectReadAtIndices";
%  static fnServerObjectReadAtIndices_rets	ZeroResult;
%  fnServerObjectReadAtIndices_rets		* pResult = NULL;
%  fnServerObjectReadAtIndices_rets		Result = ZeroResult;
%  fnServerObjectReadAtIndices_args	InArguments;
%
%  /* Client initialization: */
%  if ( __bClientInitialize__ ) {
%    __bClientInitialize__	= FALSE;
%    RPC_CLIENT_INITIALIZE();
%  }
%
%#if	CLIENT_CREATE_BY_USER
%  if ( __pClient__ == NULL ) {
%    __pClient__	= RPC_CLIENT_CREATE ( __szHost__, __szTransport__ );
%    if ( __pClient__ == NULL ) {
%      /* Error handling for a not connected client: */
%      char	szError [ 256 ];
%      sprintf ( szError, szFormatNoServer, __procedure__ );
%      RPC_CLIENT_ERROR ( szError );
%      return Result.ReturnValue;
%    }
%  }
%#else
%  while ( __pClient__ == NULL ) {
%    __pClient__	= RPC_CLIENT_CREATE ( __szHost__, __szTransport__ );
%    if ( __pClient__ == NULL ) {
%      /* Error handling for a not connected client: */
%      char	szError [ 256 ];
%      sprintf ( szError, szFormatNoServer, __procedure__ );
%      RPC_CLIENT_CERROR ( szContNoServer, szError );
%    }
%  }
%#endif	/* CLIENT_CREATE_BY_USER */
%
%  /* Copy in the oShortObjIdHeap argument: */
%  InArguments.oShortObjIdHeap	= oShortObjIdHeap;
%  /* Copy in the oShortObjId argument: */
%  InArguments.oShortObjId	= oShortObjId;
%  /* Copy in the oExpectingClass argument: */
%  InArguments.oExpectingClass	= oExpectingClass;
%  /* Copy in the nExpectingTypeTag argument: */
%  InArguments.nExpectingTypeTag	= nExpectingTypeTag;
%  /* Copy in the nIndex argument: */
%  InArguments.nIndex	= nIndex;
%  /* Copy in the nObjIds argument: */
%  InArguments.nObjIds	= nObjIds;
%  InArguments.pObjIdsSize	= nObjIds;
%  InArguments.pnTypeTagsSize	= nObjIds;
%
%  pResult	=
%#ifdef MULTITHREAD
%    (
%#else
%    (fnServerObjectReadAtIndices_rets *)
%#endif
%    fnrpc_fnserverobjectreadatindices_1 (
%	&InArguments,
%#ifdef MULTITHREAD
%	&Result,
%#endif
%	__pClient__ )
%#ifdef MULTITHREAD
%	== RPC_SUCCESS ) ? &Result : NULL
%#endif
%	;
%
%  if ( pResult == NULL ) {
%    /* Error handling for a failed RPC call, */
%    /* i.e. the server did not respond: */
%    char	szError [ 256 ];
%    sprintf ( szError, szFormatRpcFailed, __procedure__,
%              clnt_sperror ( __pClient__, __szHost__ ) );
%    __pClient__	= RPC_CLIENT_DESTROY ( __pClient__ );
%    RPC_CLIENT_CERROR ( szContRpcFailed, szError );
%    Result	= ZeroResult;
%    return Result.ReturnValue;
%  }
%#ifndef MULTITHREAD
%  Result	= * pResult;
%#endif
%
%  /* Copy out the pObjIds argument: */
%  if ( ! ( 
%       pResult->pObjIds.int_vector_t_len != 0 &&
%       pObjIds == NULL ) ) {
%    memcpy ( pObjIds,
%             pResult->pObjIds.int_vector_t_val,
%             MIN ( pResult->pObjIds.int_vector_t_len,
%                   nObjIds ) *
%             SIZEOF ( *(pResult->pObjIds.int_vector_t_val) ) );
%  }
%  /* Copy out the pnTypeTags argument: */
%  if ( ! ( 
%       pResult->pnTypeTags.u_int_vector_t_len != 0 &&
%       pnTypeTags == NULL ) ) {
%    memcpy ( pnTypeTags,
%             pResult->pnTypeTags.u_int_vector_t_val,
%             MIN ( pResult->pnTypeTags.u_int_vector_t_len,
%                   nObjIds ) *
%             SIZEOF ( *(pResult->pnTypeTags.u_int_vector_t_val) ) );
%  }
%
%  if ( pResult && pResult->nErrorLvl ) {
%    /* Server returned a user error message: */
%    char	szErrorMsg [ 1024 ];
%    strncpy ( szErrorMsg,
%              ( pResult->pszErrorMsg && pResult->pszErrorMsg [ 0 ] ) ?
%              (LPCSTR) pResult->pszErrorMsg : (LPCSTR) szEmpty,
%              sizeof ( szErrorMsg ) );
%    szErrorMsg [ sizeof ( szErrorMsg ) - 1 ]	= (char) 0;
%    xdr_free ( (xdrproc_t) xdr_fnServerObjectReadAtIndices_rets, (char *) pResult );
%    RPC_CLIENT_SERROR ( pResult->nErrorLvl, __procedure__,
%                        szErrorMsg );
%  } else {
%    xdr_free ( (xdrproc_t) xdr_fnServerObjectReadAtIndices_rets, (char *) pResult );
%  }
%  if ( 
%       pResult->pObjIds.int_vector_t_len != 0 &&
%       pObjIds == NULL ) {
%    /* Error handling for passing a NULL pointer on */
%    /* out argument: */
%    char	szError [ 256 ];
%    sprintf ( szError, szFormatNullPassed,
%              __procedure__, "pObjIds" );
%    RPC_CLIENT_CERROR ( szContNullOutPassed, szError );
%  } else if ( pResult->pObjIds.int_vector_t_len > nObjIds ) {
%      /* Error handling for an output buffer overflow, */
%      /* i.e. the buffer size passed is too small: */
%      /* For example, signal a CERROR here ... */
%      char	szError [ 256 ];
%      sprintf ( szError, szFormatBufferOverflow,
%                __procedure__, "pObjIds", 
%                nObjIds, 
%                pResult->pObjIds.int_vector_t_len );
%      RPC_CLIENT_CERROR ( szContBufferOverflow, szError );
%  }
%  if ( 
%       pResult->pnTypeTags.u_int_vector_t_len != 0 &&
%       pnTypeTags == NULL ) {
%    /* Error handling for passing a NULL pointer on */
%    /* out argument: */
%    char	szError [ 256 ];
%    sprintf ( szError, szFormatNullPassed,
%              __procedure__, "pnTypeTags" );
%    RPC_CLIENT_CERROR ( szContNullOutPassed, szError );
%  } else if ( pResult->pnTypeTags.u_int_vector_t_len > nObjIds ) {
%      /* Error handling for an output buffer overflow, */
%      /* i.e. the buffer size passed is too small: */
%      /* For example, signal a CERROR here ... */
%      char	szError [ 256 ];
%      sprintf ( szError, szFormatBufferOverflow,
%                __procedure__, "pnTypeTags", 
%                nObjIds, 
%                pResult->pnTypeTags.u_int_vector_t_len );
%      RPC_CLIENT_CERROR ( szContBufferOverflow, szError );
%  }
%
%  return Result.ReturnValue;
%
%} /* fnServerObjectReadAtIndices */
#endif	/* RPC_CLNT */
%
  fnServerObjectReadObjId_rets fnRpc_fnServerObjectReadObjId ( fnServerObjectReadObjId_args ) =  29 ;
%
#if RPC_SVC
%
%extern SHLOCK fnServerObjectReadObjId
%	(SHORTOBJID oShortObjIdHeap ,
%	  SHORTOBJID oShortObjId ,
%	  SHORTOBJID oExpectingClass ,
%	  SHTYPETAG nExpectingTypeTag ,
%	  int nIndex ,
%	  int * pnObjId);
%
%#ifdef MULTITHREAD
%bool_t
%#else
%fnServerObjectReadObjId_rets *
%#endif
%	PASTE2(fnrpc_fnserverobjectreadobjid_1,_SVCSUFFIX)
%		( fnServerObjectReadObjId_args * pArguments,
%#ifdef MULTITHREAD
%		  fnServerObjectReadObjId_rets * pResult,
%#endif
%		  struct svc_req * pRequest )
%{
%  static const char	__procedure__[]	= "server:fnrpc_fnserverobjectreadobjid_1";
%#ifdef MULTITHREAD
%  typedef bool_t RESULTTYPE;
%#else
%  typedef fnServerObjectReadObjId_rets * RESULTTYPE;
%#endif
%#ifndef MULTITHREAD
%  static fnServerObjectReadObjId_rets	Result;
%  RESULTTYPE			pResult = &Result;
%#endif
%  LPCSTR	pszErrorMsg;
%
%  __pRequest__	= pRequest;
%
%  RPC_SERVER_ENTRY();
%
%#ifndef MULTITHREAD
%  if ( pResult->pszErrorMsg == szEmpty ) {
%    pResult->pszErrorMsg	= NULL;
%  }
%  xdr_free ( (xdrproc_t) xdr_fnServerObjectReadObjId_rets, (char *) pResult );
%#endif
%  pResult->nErrorLvl		= 0;
%
%  Reply.bAnswered		= FALSE;
%  Reply.pfnCalled		= (void(*)()) fnServerObjectReadObjId;
%  Reply.pfnXdrResult		= (bool_t(*)()) xdr_fnServerObjectReadObjId_rets;
%  Reply.pnErrorLvl		= &pResult->nErrorLvl;
%  Reply.ppszErrorMsg		= (LPCSTR *) &pResult->pszErrorMsg;
%  Reply.pResult		= pResult;
%  Reply.pReturnValue		= &pResult->ReturnValue;
%  Reply.nReturnValueSize	= sizeof ( pResult->ReturnValue );
%
%  pResult->ReturnValue		=
%  fnServerObjectReadObjId (
%	pArguments->oShortObjIdHeap,
%	pArguments->oShortObjId,
%	pArguments->oExpectingClass,
%	pArguments->nExpectingTypeTag,
%	pArguments->nIndex,
%	&pResult->pnObjId );
%
%  if ( Reply.bAnswered ) {
%    __pRequest__	= NULL;
%    return (RESULTTYPE) NULL;
%  }
%
%  pResult->nErrorLvl	= RPC_SERVER_ERRLVL();
%  if ( pResult->nErrorLvl > 0 ) {
%    pszErrorMsg		= RPC_SERVER_ERRMSG();
%    if ( pszErrorMsg && *pszErrorMsg ) {
%      pResult->pszErrorMsg	= strdup ( pszErrorMsg );
%    }
%  }
%  if ( pResult->pszErrorMsg == NULL ) {
%#ifdef MULTITHREAD
%    pResult->pszErrorMsg	= strdup ( szEmpty );
%#else
%    pResult->pszErrorMsg	= (LPSTR) szEmpty;
%#endif
%  }
%  __pRequest__	= NULL;
%  return (RESULTTYPE) pResult;
%} /* fnrpc_fnserverobjectreadobjid_1 */
#endif	/* RPC_SVC */
%
#if RPC_CLNT
%SHLOCK DLLEXPORT fnServerObjectReadObjId
%	(SHORTOBJID oShortObjIdHeap ,
%	  SHORTOBJID oShortObjId ,
%	  SHORTOBJID oExpectingClass ,
%	  SHTYPETAG nExpectingTypeTag ,
%	  int nIndex ,
%	  int * pnObjId)
%{
%  static const char	__procedure__[]	= "client:fnServerObjectReadObjId";
%  static fnServerObjectReadObjId_rets	ZeroResult;
%  fnServerObjectReadObjId_rets		* pResult = NULL;
%  fnServerObjectReadObjId_rets		Result = ZeroResult;
%  fnServerObjectReadObjId_args	InArguments;
%
%  /* Client initialization: */
%  if ( __bClientInitialize__ ) {
%    __bClientInitialize__	= FALSE;
%    RPC_CLIENT_INITIALIZE();
%  }
%
%#if	CLIENT_CREATE_BY_USER
%  if ( __pClient__ == NULL ) {
%    __pClient__	= RPC_CLIENT_CREATE ( __szHost__, __szTransport__ );
%    if ( __pClient__ == NULL ) {
%      /* Error handling for a not connected client: */
%      char	szError [ 256 ];
%      sprintf ( szError, szFormatNoServer, __procedure__ );
%      RPC_CLIENT_ERROR ( szError );
%      return Result.ReturnValue;
%    }
%  }
%#else
%  while ( __pClient__ == NULL ) {
%    __pClient__	= RPC_CLIENT_CREATE ( __szHost__, __szTransport__ );
%    if ( __pClient__ == NULL ) {
%      /* Error handling for a not connected client: */
%      char	szError [ 256 ];
%      sprintf ( szError, szFormatNoServer, __procedure__ );
%      RPC_CLIENT_CERROR ( szContNoServer, szError );
%    }
%  }
%#endif	/* CLIENT_CREATE_BY_USER */
%
%  /* Copy in the oShortObjIdHeap argument: */
%  InArguments.oShortObjIdHeap	= oShortObjIdHeap;
%  /* Copy in the oShortObjId argument: */
%  InArguments.oShortObjId	= oShortObjId;
%  /* Copy in the oExpectingClass argument: */
%  InArguments.oExpectingClass	= oExpectingClass;
%  /* Copy in the nExpectingTypeTag argument: */
%  InArguments.nExpectingTypeTag	= nExpectingTypeTag;
%  /* Copy in the nIndex argument: */
%  InArguments.nIndex	= nIndex;
%
%  pResult	=
%#ifdef MULTITHREAD
%    (
%#else
%    (fnServerObjectReadObjId_rets *)
%#endif
%    fnrpc_fnserverobjectreadobjid_1 (
%	&InArguments,
%#ifdef MULTITHREAD
%	&Result,
%#endif
%	__pClient__ )
%#ifdef MULTITHREAD
%	== RPC_SUCCESS ) ? &Result : NULL
%#endif
%	;
%
%  if ( pResult == NULL ) {
%    /* Error handling for a failed RPC call, */
%    /* i.e. the server did not respond: */
%    char	szError [ 256 ];
%    sprintf ( szError, szFormatRpcFailed, __procedure__,
%              clnt_sperror ( __pClient__, __szHost__ ) );
%    __pClient__	= RPC_CLIENT_DESTROY ( __pClient__ );
%    RPC_CLIENT_CERROR ( szContRpcFailed, szError );
%    Result	= ZeroResult;
%    return Result.ReturnValue;
%  }
%#ifndef MULTITHREAD
%  Result	= * pResult;
%#endif
%
%  /* Copy out the pnObjId argument: */
%  if ( ! ( 
%       pnObjId == NULL ) ) {
%    *pnObjId	= pResult->pnObjId;
%  }
%
%  if ( pResult && pResult->nErrorLvl ) {
%    /* Server returned a user error message: */
%    char	szErrorMsg [ 1024 ];
%    strncpy ( szErrorMsg,
%              ( pResult->pszErrorMsg && pResult->pszErrorMsg [ 0 ] ) ?
%              (LPCSTR) pResult->pszErrorMsg : (LPCSTR) szEmpty,
%              sizeof ( szErrorMsg ) );
%    szErrorMsg [ sizeof ( szErrorMsg ) - 1 ]	= (char) 0;
%    xdr_free ( (xdrproc_t) xdr_fnServerObjectReadObjId_rets, (char *) pResult );
%    RPC_CLIENT_SERROR ( pResult->nErrorLvl, __procedure__,
%                        szErrorMsg );
%  } else {
%    xdr_free ( (xdrproc_t) xdr_fnServerObjectReadObjId_rets, (char *) pResult );
%  }
%  if ( 
%       pnObjId == NULL ) {
%    /* Error handling for passing a NULL pointer on */
%    /* out argument: */
%    char	szError [ 256 ];
%    sprintf ( szError, szFormatNullPassed,
%              __procedure__, "pnObjId" );
%    RPC_CLIENT_CERROR ( szContNullOutPassed, szError );
%  }
%
%  return Result.ReturnValue;
%
%} /* fnServerObjectReadObjId */
#endif	/* RPC_CLNT */
%
  fnServerObjectReadValues_rets fnRpc_fnServerObjectReadValues ( fnServerObjectReadValues_args ) =  30 ;
%
#if RPC_SVC
%
%extern int fnServerObjectReadValues
%	(SHORTOBJID oShortObjIdHeap ,
%	  SHORTOBJID oShortObjId ,
%	  SHORTOBJID oExpectingClass ,
%	  SHTYPETAG nExpectingTypeTag ,
%	  int nIndex ,
%	  SHTYPETAG nElementTypeTagIn ,
%	  int nSizeInElementsIn ,
%	  SHTYPETAG * pnElementTypeTagOut ,
%	  int * pnSizeInElementsOut ,
%	  void * /* _vector_t<((( fnTypeTagSizeValue(1,&nElementTypeTagIn, &nSizeInElementsIn) )*( sizeof(int) )) )> */  pBuffer);
%
%#ifdef MULTITHREAD
%bool_t
%#else
%fnServerObjectReadValues_rets *
%#endif
%	PASTE2(fnrpc_fnserverobjectreadvalues_1,_SVCSUFFIX)
%		( fnServerObjectReadValues_args * pArguments,
%#ifdef MULTITHREAD
%		  fnServerObjectReadValues_rets * pResult,
%#endif
%		  struct svc_req * pRequest )
%{
%  static const char	__procedure__[]	= "server:fnrpc_fnserverobjectreadvalues_1";
%#ifdef MULTITHREAD
%  typedef bool_t RESULTTYPE;
%#else
%  typedef fnServerObjectReadValues_rets * RESULTTYPE;
%#endif
%#ifndef MULTITHREAD
%  static fnServerObjectReadValues_rets	Result;
%  RESULTTYPE			pResult = &Result;
%#endif
%  LPCSTR	pszErrorMsg;
%
%  __pRequest__	= pRequest;
%
%  RPC_SERVER_ENTRY();
%
%#ifndef MULTITHREAD
%  if ( pResult->pszErrorMsg == szEmpty ) {
%    pResult->pszErrorMsg	= NULL;
%  }
%  xdr_free ( (xdrproc_t) xdr_fnServerObjectReadValues_rets, (char *) pResult );
%#endif
%  pResult->nErrorLvl		= 0;
%
%  pResult->pBuffer.void_vector_t_len	= pArguments->pBufferSize;
%  if ( pArguments->pBufferSize == 0 ) {
%    pResult->pBuffer.void_vector_t_val	= NULL;
%  } else {
%    pResult->pBuffer.void_vector_t_val	=
%      (char*) malloc ( pArguments->pBufferSize *
%               SIZEOF ( *(pResult->pBuffer.void_vector_t_val) ) );
%    if ( pResult->pBuffer.void_vector_t_val == NULL ) {
%      char	szError [ 256 ];
%      sprintf ( szError, szFormatMallocFailed,
%                __procedure__, pArguments->pBufferSize,
%                "pBuffer" );
%      RPC_SERVER_ERROR ( szError );
%      return (RESULTTYPE) NULL;
%    }
%  }
%  Reply.bAnswered		= FALSE;
%  Reply.pfnCalled		= (void(*)()) fnServerObjectReadValues;
%  Reply.pfnXdrResult		= (bool_t(*)()) xdr_fnServerObjectReadValues_rets;
%  Reply.pnErrorLvl		= &pResult->nErrorLvl;
%  Reply.ppszErrorMsg		= (LPCSTR *) &pResult->pszErrorMsg;
%  Reply.pResult		= pResult;
%  Reply.pReturnValue		= &pResult->ReturnValue;
%  Reply.nReturnValueSize	= sizeof ( pResult->ReturnValue );
%
%  pResult->ReturnValue		=
%  fnServerObjectReadValues (
%	pArguments->oShortObjIdHeap,
%	pArguments->oShortObjId,
%	pArguments->oExpectingClass,
%	pArguments->nExpectingTypeTag,
%	pArguments->nIndex,
%	pArguments->nElementTypeTagIn,
%	pArguments->nSizeInElementsIn,
%	&pResult->pnElementTypeTagOut,
%	&pResult->pnSizeInElementsOut,
%	pResult->pBuffer.void_vector_t_val );
%
%  if ( Reply.bAnswered ) {
%    __pRequest__	= NULL;
%    return (RESULTTYPE) NULL;
%  }
%
%  pResult->nErrorLvl	= RPC_SERVER_ERRLVL();
%  if ( pResult->nErrorLvl > 0 ) {
%    pszErrorMsg		= RPC_SERVER_ERRMSG();
%    if ( pszErrorMsg && *pszErrorMsg ) {
%      pResult->pszErrorMsg	= strdup ( pszErrorMsg );
%    }
%  }
%  if ( pResult->pszErrorMsg == NULL ) {
%#ifdef MULTITHREAD
%    pResult->pszErrorMsg	= strdup ( szEmpty );
%#else
%    pResult->pszErrorMsg	= (LPSTR) szEmpty;
%#endif
%  }
%  __pRequest__	= NULL;
%  return (RESULTTYPE) pResult;
%} /* fnrpc_fnserverobjectreadvalues_1 */
#endif	/* RPC_SVC */
%
#if RPC_CLNT
%int DLLEXPORT fnServerObjectReadValues
%	(SHORTOBJID oShortObjIdHeap ,
%	  SHORTOBJID oShortObjId ,
%	  SHORTOBJID oExpectingClass ,
%	  SHTYPETAG nExpectingTypeTag ,
%	  int nIndex ,
%	  SHTYPETAG nElementTypeTagIn ,
%	  int nSizeInElementsIn ,
%	  SHTYPETAG * pnElementTypeTagOut ,
%	  int * pnSizeInElementsOut ,
%	  void * /* _vector_t<((( fnTypeTagSizeValue(1,&nElementTypeTagIn, &nSizeInElementsIn) )*( sizeof(int) )) )> */  pBuffer)
%{
%  static const char	__procedure__[]	= "client:fnServerObjectReadValues";
%  static fnServerObjectReadValues_rets	ZeroResult;
%  fnServerObjectReadValues_rets		* pResult = NULL;
%  fnServerObjectReadValues_rets		Result = ZeroResult;
%  fnServerObjectReadValues_args	InArguments;
%
%  /* Client initialization: */
%  if ( __bClientInitialize__ ) {
%    __bClientInitialize__	= FALSE;
%    RPC_CLIENT_INITIALIZE();
%  }
%
%#if	CLIENT_CREATE_BY_USER
%  if ( __pClient__ == NULL ) {
%    __pClient__	= RPC_CLIENT_CREATE ( __szHost__, __szTransport__ );
%    if ( __pClient__ == NULL ) {
%      /* Error handling for a not connected client: */
%      char	szError [ 256 ];
%      sprintf ( szError, szFormatNoServer, __procedure__ );
%      RPC_CLIENT_ERROR ( szError );
%      return Result.ReturnValue;
%    }
%  }
%#else
%  while ( __pClient__ == NULL ) {
%    __pClient__	= RPC_CLIENT_CREATE ( __szHost__, __szTransport__ );
%    if ( __pClient__ == NULL ) {
%      /* Error handling for a not connected client: */
%      char	szError [ 256 ];
%      sprintf ( szError, szFormatNoServer, __procedure__ );
%      RPC_CLIENT_CERROR ( szContNoServer, szError );
%    }
%  }
%#endif	/* CLIENT_CREATE_BY_USER */
%
%  /* Copy in the oShortObjIdHeap argument: */
%  InArguments.oShortObjIdHeap	= oShortObjIdHeap;
%  /* Copy in the oShortObjId argument: */
%  InArguments.oShortObjId	= oShortObjId;
%  /* Copy in the oExpectingClass argument: */
%  InArguments.oExpectingClass	= oExpectingClass;
%  /* Copy in the nExpectingTypeTag argument: */
%  InArguments.nExpectingTypeTag	= nExpectingTypeTag;
%  /* Copy in the nIndex argument: */
%  InArguments.nIndex	= nIndex;
%  /* Copy in the nElementTypeTagIn argument: */
%  InArguments.nElementTypeTagIn	= nElementTypeTagIn;
%  /* Copy in the nSizeInElementsIn argument: */
%  InArguments.nSizeInElementsIn	= nSizeInElementsIn;
%  InArguments.pBufferSize	= ((( fnTypeTagSizeValue(1,&nElementTypeTagIn, &nSizeInElementsIn) )*( sizeof(int) )) );
%
%  pResult	=
%#ifdef MULTITHREAD
%    (
%#else
%    (fnServerObjectReadValues_rets *)
%#endif
%    fnrpc_fnserverobjectreadvalues_1 (
%	&InArguments,
%#ifdef MULTITHREAD
%	&Result,
%#endif
%	__pClient__ )
%#ifdef MULTITHREAD
%	== RPC_SUCCESS ) ? &Result : NULL
%#endif
%	;
%
%  if ( pResult == NULL ) {
%    /* Error handling for a failed RPC call, */
%    /* i.e. the server did not respond: */
%    char	szError [ 256 ];
%    sprintf ( szError, szFormatRpcFailed, __procedure__,
%              clnt_sperror ( __pClient__, __szHost__ ) );
%    __pClient__	= RPC_CLIENT_DESTROY ( __pClient__ );
%    RPC_CLIENT_CERROR ( szContRpcFailed, szError );
%    Result	= ZeroResult;
%    return Result.ReturnValue;
%  }
%#ifndef MULTITHREAD
%  Result	= * pResult;
%#endif
%
%  /* Copy out the pnElementTypeTagOut argument: */
%  if ( ! ( 
%       pnElementTypeTagOut == NULL ) ) {
%    *pnElementTypeTagOut	= pResult->pnElementTypeTagOut;
%  }
%  /* Copy out the pnSizeInElementsOut argument: */
%  if ( ! ( 
%       pnSizeInElementsOut == NULL ) ) {
%    *pnSizeInElementsOut	= pResult->pnSizeInElementsOut;
%  }
%  /* Copy out the pBuffer argument: */
%  if ( ! ( 
%       pResult->pBuffer.void_vector_t_len != 0 &&
%       pBuffer == NULL ) ) {
%    memcpy ( pBuffer,
%             pResult->pBuffer.void_vector_t_val,
%             MIN ( pResult->pBuffer.void_vector_t_len,
%                   ((( fnTypeTagSizeValue(1,&nElementTypeTagIn, &nSizeInElementsIn) )*( sizeof(int) )) ) ) *
%             SIZEOF ( *(pResult->pBuffer.void_vector_t_val) ) );
%  }
%
%  if ( pResult && pResult->nErrorLvl ) {
%    /* Server returned a user error message: */
%    char	szErrorMsg [ 1024 ];
%    strncpy ( szErrorMsg,
%              ( pResult->pszErrorMsg && pResult->pszErrorMsg [ 0 ] ) ?
%              (LPCSTR) pResult->pszErrorMsg : (LPCSTR) szEmpty,
%              sizeof ( szErrorMsg ) );
%    szErrorMsg [ sizeof ( szErrorMsg ) - 1 ]	= (char) 0;
%    xdr_free ( (xdrproc_t) xdr_fnServerObjectReadValues_rets, (char *) pResult );
%    RPC_CLIENT_SERROR ( pResult->nErrorLvl, __procedure__,
%                        szErrorMsg );
%  } else {
%    xdr_free ( (xdrproc_t) xdr_fnServerObjectReadValues_rets, (char *) pResult );
%  }
%  if ( 
%       pnElementTypeTagOut == NULL ) {
%    /* Error handling for passing a NULL pointer on */
%    /* out argument: */
%    char	szError [ 256 ];
%    sprintf ( szError, szFormatNullPassed,
%              __procedure__, "pnElementTypeTagOut" );
%    RPC_CLIENT_CERROR ( szContNullOutPassed, szError );
%  }
%  if ( 
%       pnSizeInElementsOut == NULL ) {
%    /* Error handling for passing a NULL pointer on */
%    /* out argument: */
%    char	szError [ 256 ];
%    sprintf ( szError, szFormatNullPassed,
%              __procedure__, "pnSizeInElementsOut" );
%    RPC_CLIENT_CERROR ( szContNullOutPassed, szError );
%  }
%  if ( 
%       pResult->pBuffer.void_vector_t_len != 0 &&
%       pBuffer == NULL ) {
%    /* Error handling for passing a NULL pointer on */
%    /* out argument: */
%    char	szError [ 256 ];
%    sprintf ( szError, szFormatNullPassed,
%              __procedure__, "pBuffer" );
%    RPC_CLIENT_CERROR ( szContNullOutPassed, szError );
%  } else if ( pResult->pBuffer.void_vector_t_len > ((( fnTypeTagSizeValue(1,&nElementTypeTagIn, &nSizeInElementsIn) )*( sizeof(int) )) ) ) {
%      /* Error handling for an output buffer overflow, */
%      /* i.e. the buffer size passed is too small: */
%      /* For example, signal a CERROR here ... */
%      char	szError [ 256 ];
%      sprintf ( szError, szFormatBufferOverflow,
%                __procedure__, "pBuffer", 
%                ((( fnTypeTagSizeValue(1,&nElementTypeTagIn, &nSizeInElementsIn) )*( sizeof(int) )) ), 
%                pResult->pBuffer.void_vector_t_len );
%      RPC_CLIENT_CERROR ( szContBufferOverflow, szError );
%  }
%
%  return Result.ReturnValue;
%
%} /* fnServerObjectReadValues */
#endif	/* RPC_CLNT */
%
  fnClientDbStatistics_rets fnRpc_fnClientDbStatistics ( SHORTOBJID ) =  31 ;
%
#if RPC_SVC
%
%extern bool_t fnClientDbStatistics
%	(SHORTOBJID oShortObjIdHeap ,
%	  int * pnMaximumSpace ,
%	  int * pnAllocatedSpace ,
%	  int * pnUnallocatedSpace ,
%	  int * pnUnusedAllocatedSpace ,
%	  int * pnAllocatedManagementSpace ,
%	  int * pnNumberOfObjects);
%
%#ifdef MULTITHREAD
%bool_t
%#else
%fnClientDbStatistics_rets *
%#endif
%	PASTE2(fnrpc_fnclientdbstatistics_1,_SVCSUFFIX)
%		( SHORTOBJID * pArguments,
%#ifdef MULTITHREAD
%		  fnClientDbStatistics_rets * pResult,
%#endif
%		  struct svc_req * pRequest )
%{
%  static const char	__procedure__[]	= "server:fnrpc_fnclientdbstatistics_1";
%#ifdef MULTITHREAD
%  typedef bool_t RESULTTYPE;
%#else
%  typedef fnClientDbStatistics_rets * RESULTTYPE;
%#endif
%#ifndef MULTITHREAD
%  static fnClientDbStatistics_rets	Result;
%  RESULTTYPE			pResult = &Result;
%#endif
%  LPCSTR	pszErrorMsg;
%
%  __pRequest__	= pRequest;
%
%  RPC_SERVER_ENTRY();
%
%#ifndef MULTITHREAD
%  if ( pResult->pszErrorMsg == szEmpty ) {
%    pResult->pszErrorMsg	= NULL;
%  }
%  xdr_free ( (xdrproc_t) xdr_fnClientDbStatistics_rets, (char *) pResult );
%#endif
%  pResult->nErrorLvl		= 0;
%
%  Reply.bAnswered		= FALSE;
%  Reply.pfnCalled		= (void(*)()) fnClientDbStatistics;
%  Reply.pfnXdrResult		= (bool_t(*)()) xdr_fnClientDbStatistics_rets;
%  Reply.pnErrorLvl		= &pResult->nErrorLvl;
%  Reply.ppszErrorMsg		= (LPCSTR *) &pResult->pszErrorMsg;
%  Reply.pResult		= pResult;
%  Reply.pReturnValue		= &pResult->ReturnValue;
%  Reply.nReturnValueSize	= sizeof ( pResult->ReturnValue );
%
%  pResult->ReturnValue		=
%  fnClientDbStatistics (
%	(*pArguments),
%	&pResult->pnMaximumSpace,
%	&pResult->pnAllocatedSpace,
%	&pResult->pnUnallocatedSpace,
%	&pResult->pnUnusedAllocatedSpace,
%	&pResult->pnAllocatedManagementSpace,
%	&pResult->pnNumberOfObjects );
%
%  if ( Reply.bAnswered ) {
%    __pRequest__	= NULL;
%    return (RESULTTYPE) NULL;
%  }
%
%  pResult->nErrorLvl	= RPC_SERVER_ERRLVL();
%  if ( pResult->nErrorLvl > 0 ) {
%    pszErrorMsg		= RPC_SERVER_ERRMSG();
%    if ( pszErrorMsg && *pszErrorMsg ) {
%      pResult->pszErrorMsg	= strdup ( pszErrorMsg );
%    }
%  }
%  if ( pResult->pszErrorMsg == NULL ) {
%#ifdef MULTITHREAD
%    pResult->pszErrorMsg	= strdup ( szEmpty );
%#else
%    pResult->pszErrorMsg	= (LPSTR) szEmpty;
%#endif
%  }
%  __pRequest__	= NULL;
%  return (RESULTTYPE) pResult;
%} /* fnrpc_fnclientdbstatistics_1 */
#endif	/* RPC_SVC */
%
#if RPC_CLNT
%bool_t DLLEXPORT fnClientDbStatistics
%	(SHORTOBJID oShortObjIdHeap ,
%	  int * pnMaximumSpace ,
%	  int * pnAllocatedSpace ,
%	  int * pnUnallocatedSpace ,
%	  int * pnUnusedAllocatedSpace ,
%	  int * pnAllocatedManagementSpace ,
%	  int * pnNumberOfObjects)
%{
%  static const char	__procedure__[]	= "client:fnClientDbStatistics";
%  static fnClientDbStatistics_rets	ZeroResult;
%  fnClientDbStatistics_rets		* pResult = NULL;
%  fnClientDbStatistics_rets		Result = ZeroResult;
%
%  /* Client initialization: */
%  if ( __bClientInitialize__ ) {
%    __bClientInitialize__	= FALSE;
%    RPC_CLIENT_INITIALIZE();
%  }
%
%#if	CLIENT_CREATE_BY_USER
%  if ( __pClient__ == NULL ) {
%    __pClient__	= RPC_CLIENT_CREATE ( __szHost__, __szTransport__ );
%    if ( __pClient__ == NULL ) {
%      /* Error handling for a not connected client: */
%      char	szError [ 256 ];
%      sprintf ( szError, szFormatNoServer, __procedure__ );
%      RPC_CLIENT_ERROR ( szError );
%      return Result.ReturnValue;
%    }
%  }
%#else
%  while ( __pClient__ == NULL ) {
%    __pClient__	= RPC_CLIENT_CREATE ( __szHost__, __szTransport__ );
%    if ( __pClient__ == NULL ) {
%      /* Error handling for a not connected client: */
%      char	szError [ 256 ];
%      sprintf ( szError, szFormatNoServer, __procedure__ );
%      RPC_CLIENT_CERROR ( szContNoServer, szError );
%    }
%  }
%#endif	/* CLIENT_CREATE_BY_USER */
%
%  pResult	=
%#ifdef MULTITHREAD
%    (
%#else
%    (fnClientDbStatistics_rets *)
%#endif
%    fnrpc_fnclientdbstatistics_1 (
%	&oShortObjIdHeap,
%#ifdef MULTITHREAD
%	&Result,
%#endif
%	__pClient__ )
%#ifdef MULTITHREAD
%	== RPC_SUCCESS ) ? &Result : NULL
%#endif
%	;
%
%  if ( pResult == NULL ) {
%    /* Error handling for a failed RPC call, */
%    /* i.e. the server did not respond: */
%    char	szError [ 256 ];
%    sprintf ( szError, szFormatRpcFailed, __procedure__,
%              clnt_sperror ( __pClient__, __szHost__ ) );
%    __pClient__	= RPC_CLIENT_DESTROY ( __pClient__ );
%    RPC_CLIENT_CERROR ( szContRpcFailed, szError );
%    Result	= ZeroResult;
%    return Result.ReturnValue;
%  }
%#ifndef MULTITHREAD
%  Result	= * pResult;
%#endif
%
%  /* Copy out the pnMaximumSpace argument: */
%  if ( ! ( 
%       pnMaximumSpace == NULL ) ) {
%    *pnMaximumSpace	= pResult->pnMaximumSpace;
%  }
%  /* Copy out the pnAllocatedSpace argument: */
%  if ( ! ( 
%       pnAllocatedSpace == NULL ) ) {
%    *pnAllocatedSpace	= pResult->pnAllocatedSpace;
%  }
%  /* Copy out the pnUnallocatedSpace argument: */
%  if ( ! ( 
%       pnUnallocatedSpace == NULL ) ) {
%    *pnUnallocatedSpace	= pResult->pnUnallocatedSpace;
%  }
%  /* Copy out the pnUnusedAllocatedSpace argument: */
%  if ( ! ( 
%       pnUnusedAllocatedSpace == NULL ) ) {
%    *pnUnusedAllocatedSpace	= pResult->pnUnusedAllocatedSpace;
%  }
%  /* Copy out the pnAllocatedManagementSpace argument: */
%  if ( ! ( 
%       pnAllocatedManagementSpace == NULL ) ) {
%    *pnAllocatedManagementSpace	= pResult->pnAllocatedManagementSpace;
%  }
%  /* Copy out the pnNumberOfObjects argument: */
%  if ( ! ( 
%       pnNumberOfObjects == NULL ) ) {
%    *pnNumberOfObjects	= pResult->pnNumberOfObjects;
%  }
%
%  if ( pResult && pResult->nErrorLvl ) {
%    /* Server returned a user error message: */
%    char	szErrorMsg [ 1024 ];
%    strncpy ( szErrorMsg,
%              ( pResult->pszErrorMsg && pResult->pszErrorMsg [ 0 ] ) ?
%              (LPCSTR) pResult->pszErrorMsg : (LPCSTR) szEmpty,
%              sizeof ( szErrorMsg ) );
%    szErrorMsg [ sizeof ( szErrorMsg ) - 1 ]	= (char) 0;
%    xdr_free ( (xdrproc_t) xdr_fnClientDbStatistics_rets, (char *) pResult );
%    RPC_CLIENT_SERROR ( pResult->nErrorLvl, __procedure__,
%                        szErrorMsg );
%  } else {
%    xdr_free ( (xdrproc_t) xdr_fnClientDbStatistics_rets, (char *) pResult );
%  }
%  if ( 
%       pnMaximumSpace == NULL ) {
%    /* Error handling for passing a NULL pointer on */
%    /* out argument: */
%    char	szError [ 256 ];
%    sprintf ( szError, szFormatNullPassed,
%              __procedure__, "pnMaximumSpace" );
%    RPC_CLIENT_CERROR ( szContNullOutPassed, szError );
%  }
%  if ( 
%       pnAllocatedSpace == NULL ) {
%    /* Error handling for passing a NULL pointer on */
%    /* out argument: */
%    char	szError [ 256 ];
%    sprintf ( szError, szFormatNullPassed,
%              __procedure__, "pnAllocatedSpace" );
%    RPC_CLIENT_CERROR ( szContNullOutPassed, szError );
%  }
%  if ( 
%       pnUnallocatedSpace == NULL ) {
%    /* Error handling for passing a NULL pointer on */
%    /* out argument: */
%    char	szError [ 256 ];
%    sprintf ( szError, szFormatNullPassed,
%              __procedure__, "pnUnallocatedSpace" );
%    RPC_CLIENT_CERROR ( szContNullOutPassed, szError );
%  }
%  if ( 
%       pnUnusedAllocatedSpace == NULL ) {
%    /* Error handling for passing a NULL pointer on */
%    /* out argument: */
%    char	szError [ 256 ];
%    sprintf ( szError, szFormatNullPassed,
%              __procedure__, "pnUnusedAllocatedSpace" );
%    RPC_CLIENT_CERROR ( szContNullOutPassed, szError );
%  }
%  if ( 
%       pnAllocatedManagementSpace == NULL ) {
%    /* Error handling for passing a NULL pointer on */
%    /* out argument: */
%    char	szError [ 256 ];
%    sprintf ( szError, szFormatNullPassed,
%              __procedure__, "pnAllocatedManagementSpace" );
%    RPC_CLIENT_CERROR ( szContNullOutPassed, szError );
%  }
%  if ( 
%       pnNumberOfObjects == NULL ) {
%    /* Error handling for passing a NULL pointer on */
%    /* out argument: */
%    char	szError [ 256 ];
%    sprintf ( szError, szFormatNullPassed,
%              __procedure__, "pnNumberOfObjects" );
%    RPC_CLIENT_CERROR ( szContNullOutPassed, szError );
%  }
%
%  return Result.ReturnValue;
%
%} /* fnClientDbStatistics */
#endif	/* RPC_CLNT */
%
  void fnRpc_fnServerDbStabilise_batch ( SHORTOBJID ) =  32 ;
%
#if RPC_SVC
%
%extern void fnServerDbStabilise
%	(SHORTOBJID oShortObjIdHeap);
%
%#ifdef MULTITHREAD
%bool_t
%#else
%void *
%#endif
%	PASTE2(fnrpc_fnserverdbstabilise_batch_1,_SVCSUFFIX)
%		( SHORTOBJID * pArguments,
%#ifdef MULTITHREAD
%		  void * pResult,
%#endif
%		  struct svc_req * pRequest )
%{
%  static const char	__procedure__[]	= "server:fnrpc_fnserverdbstabilise_batch_1";
%#ifdef MULTITHREAD
%  typedef bool_t RESULTTYPE;
%#else
%  typedef void * RESULTTYPE;
%#endif
%
%  __pRequest__	= pRequest;
%
%  RPC_SERVER_ENTRY();
%
%  Reply.bAnswered		= TRUE;
%  Reply.pfnCalled		= (void(*)()) fnServerDbStabilise;
%  Reply.pfnXdrResult		= (bool_t(*)()) xdr_void;
%  Reply.pnErrorLvl		= NULL;
%  Reply.ppszErrorMsg		= NULL;
%  Reply.pResult			= NULL;
%  Reply.pReturnValue		= NULL;
%  Reply.nReturnValueSize	= 0;
%  fnServerDbStabilise (
%	(*pArguments) );
%  __pRequest__	= NULL;
%  return (RESULTTYPE) NULL;
%} /* fnrpc_fnserverdbstabilise_batch_1 */
#endif	/* RPC_SVC */
%
#if RPC_CLNT
%void DLLEXPORT fnServerDbStabilise
%	(SHORTOBJID oShortObjIdHeap)
%{
%  static const char	__procedure__[]	= "client:fnServerDbStabilise";
%  static char	ZeroResult;
%  void		* pResult = NULL;
%#ifdef MULTITHREAD
%  char		Result = ZeroResult;
%#endif
%
%  /* Client initialization: */
%  if ( __bClientInitialize__ ) {
%    __bClientInitialize__	= FALSE;
%    RPC_CLIENT_INITIALIZE();
%  }
%
%#if	CLIENT_CREATE_BY_USER
%  if ( __pClient__ == NULL ) {
%    __pClient__	= RPC_CLIENT_CREATE ( __szHost__, __szTransport__ );
%    if ( __pClient__ == NULL ) {
%      /* Error handling for a not connected client: */
%      char	szError [ 256 ];
%      sprintf ( szError, szFormatNoServer, __procedure__ );
%      RPC_CLIENT_ERROR ( szError );
%      return;
%    }
%  }
%#else
%  while ( __pClient__ == NULL ) {
%    __pClient__	= RPC_CLIENT_CREATE ( __szHost__, __szTransport__ );
%    if ( __pClient__ == NULL ) {
%      /* Error handling for a not connected client: */
%      char	szError [ 256 ];
%      sprintf ( szError, szFormatNoServer, __procedure__ );
%      RPC_CLIENT_CERROR ( szContNoServer, szError );
%    }
%  }
%#endif	/* CLIENT_CREATE_BY_USER */
%
%  pResult	=
%#ifdef MULTITHREAD
%    (
%#else
%    (void *)
%#endif
%    fnrpc_fnserverdbstabilise_batch_1 (
%	&oShortObjIdHeap,
%#ifdef MULTITHREAD
%	&Result,
%#endif
%	__pClient__ )
%#ifdef MULTITHREAD
%	== RPC_SUCCESS ) ? &Result : NULL
%#endif
%	;
%
%  if ( pResult == NULL ) {
%    /* Error handling for a failed RPC call, */
%    /* i.e. the server did not respond: */
%    char	szError [ 256 ];
%    sprintf ( szError, szFormatRpcFailed, __procedure__,
%              clnt_sperror ( __pClient__, __szHost__ ) );
%    __pClient__	= RPC_CLIENT_DESTROY ( __pClient__ );
%    RPC_CLIENT_CERROR ( szContRpcFailed, szError );
%    return;
%  }
%} /* fnServerDbStabilise */
%
%#ifdef MULTITHREAD
%enum clnt_stat
%#else
%void *
%#endif
%fnrpc_fnserverdbstabilise_batch_1
%	( SHORTOBJID * pArguments,
%#ifdef MULTITHREAD
%	  void * clnt_res,
%#endif
%	  PCLIENT pClient )
%{
%#ifdef MULTITHREAD
%  return clnt_call ( pClient, fnRpc_fnServerDbStabilise_batch,
%                     (xdrproc_t) xdr_SHORTOBJID,
%                     (caddr_t) pArguments,
%                     (xdrproc_t) NULL, (caddr_t) NULL,
%                     NullTimeout );
%#else
%  if ( clnt_call ( pClient, fnRpc_fnServerDbStabilise_batch,
%                   (xdrproc_t) xdr_SHORTOBJID,
%                   (caddr_t) pArguments,
%                   (xdrproc_t) NULL, (caddr_t) NULL,
%                   NullTimeout ) != RPC_SUCCESS ) {
%    return NULL;
%  }
%  return (void *) TRUE;
%#endif
%} /* fnrpc_fnserverdbstabilise_batch_1 */
%#define	fnrpc_fnserverdbstabilise_batch_1	fnrpc_fnserverdbstabilise_1
#endif	/* RPC_CLNT */
%
  fnServerObjectTypeTag_rets fnRpc_fnServerObjectTypeTag ( fnServerObjectTypeTag_args ) =  33 ;
%
#if RPC_SVC
%
%extern SHTYPETAG fnServerObjectTypeTag
%	(SHORTOBJID oShortObjIdHeap ,
%	  SHORTOBJID oShortObjId);
%
%#ifdef MULTITHREAD
%bool_t
%#else
%fnServerObjectTypeTag_rets *
%#endif
%	PASTE2(fnrpc_fnserverobjecttypetag_1,_SVCSUFFIX)
%		( fnServerObjectTypeTag_args * pArguments,
%#ifdef MULTITHREAD
%		  fnServerObjectTypeTag_rets * pResult,
%#endif
%		  struct svc_req * pRequest )
%{
%  static const char	__procedure__[]	= "server:fnrpc_fnserverobjecttypetag_1";
%#ifdef MULTITHREAD
%  typedef bool_t RESULTTYPE;
%#else
%  typedef fnServerObjectTypeTag_rets * RESULTTYPE;
%#endif
%#ifndef MULTITHREAD
%  static fnServerObjectTypeTag_rets	Result;
%  RESULTTYPE			pResult = &Result;
%#endif
%  LPCSTR	pszErrorMsg;
%
%  __pRequest__	= pRequest;
%
%  RPC_SERVER_ENTRY();
%
%#ifndef MULTITHREAD
%  if ( pResult->pszErrorMsg == szEmpty ) {
%    pResult->pszErrorMsg	= NULL;
%  }
%  xdr_free ( (xdrproc_t) xdr_fnServerObjectTypeTag_rets, (char *) pResult );
%#endif
%  pResult->nErrorLvl		= 0;
%
%  Reply.bAnswered		= FALSE;
%  Reply.pfnCalled		= (void(*)()) fnServerObjectTypeTag;
%  Reply.pfnXdrResult		= (bool_t(*)()) xdr_fnServerObjectTypeTag_rets;
%  Reply.pnErrorLvl		= &pResult->nErrorLvl;
%  Reply.ppszErrorMsg		= (LPCSTR *) &pResult->pszErrorMsg;
%  Reply.pResult		= pResult;
%  Reply.pReturnValue		= &pResult->ReturnValue;
%  Reply.nReturnValueSize	= sizeof ( pResult->ReturnValue );
%
%  pResult->ReturnValue		=
%  fnServerObjectTypeTag (
%	pArguments->oShortObjIdHeap,
%	pArguments->oShortObjId );
%
%  if ( Reply.bAnswered ) {
%    __pRequest__	= NULL;
%    return (RESULTTYPE) NULL;
%  }
%
%  pResult->nErrorLvl	= RPC_SERVER_ERRLVL();
%  if ( pResult->nErrorLvl > 0 ) {
%    pszErrorMsg		= RPC_SERVER_ERRMSG();
%    if ( pszErrorMsg && *pszErrorMsg ) {
%      pResult->pszErrorMsg	= strdup ( pszErrorMsg );
%    }
%  }
%  if ( pResult->pszErrorMsg == NULL ) {
%#ifdef MULTITHREAD
%    pResult->pszErrorMsg	= strdup ( szEmpty );
%#else
%    pResult->pszErrorMsg	= (LPSTR) szEmpty;
%#endif
%  }
%  __pRequest__	= NULL;
%  return (RESULTTYPE) pResult;
%} /* fnrpc_fnserverobjecttypetag_1 */
#endif	/* RPC_SVC */
%
#if RPC_CLNT
%SHTYPETAG DLLEXPORT fnServerObjectTypeTag
%	(SHORTOBJID oShortObjIdHeap ,
%	  SHORTOBJID oShortObjId)
%{
%  static const char	__procedure__[]	= "client:fnServerObjectTypeTag";
%  static fnServerObjectTypeTag_rets	ZeroResult;
%  fnServerObjectTypeTag_rets		* pResult = NULL;
%  fnServerObjectTypeTag_rets		Result = ZeroResult;
%  fnServerObjectTypeTag_args	InArguments;
%
%  /* Client initialization: */
%  if ( __bClientInitialize__ ) {
%    __bClientInitialize__	= FALSE;
%    RPC_CLIENT_INITIALIZE();
%  }
%
%#if	CLIENT_CREATE_BY_USER
%  if ( __pClient__ == NULL ) {
%    __pClient__	= RPC_CLIENT_CREATE ( __szHost__, __szTransport__ );
%    if ( __pClient__ == NULL ) {
%      /* Error handling for a not connected client: */
%      char	szError [ 256 ];
%      sprintf ( szError, szFormatNoServer, __procedure__ );
%      RPC_CLIENT_ERROR ( szError );
%      return Result.ReturnValue;
%    }
%  }
%#else
%  while ( __pClient__ == NULL ) {
%    __pClient__	= RPC_CLIENT_CREATE ( __szHost__, __szTransport__ );
%    if ( __pClient__ == NULL ) {
%      /* Error handling for a not connected client: */
%      char	szError [ 256 ];
%      sprintf ( szError, szFormatNoServer, __procedure__ );
%      RPC_CLIENT_CERROR ( szContNoServer, szError );
%    }
%  }
%#endif	/* CLIENT_CREATE_BY_USER */
%
%  /* Copy in the oShortObjIdHeap argument: */
%  InArguments.oShortObjIdHeap	= oShortObjIdHeap;
%  /* Copy in the oShortObjId argument: */
%  InArguments.oShortObjId	= oShortObjId;
%
%  pResult	=
%#ifdef MULTITHREAD
%    (
%#else
%    (fnServerObjectTypeTag_rets *)
%#endif
%    fnrpc_fnserverobjecttypetag_1 (
%	&InArguments,
%#ifdef MULTITHREAD
%	&Result,
%#endif
%	__pClient__ )
%#ifdef MULTITHREAD
%	== RPC_SUCCESS ) ? &Result : NULL
%#endif
%	;
%
%  if ( pResult == NULL ) {
%    /* Error handling for a failed RPC call, */
%    /* i.e. the server did not respond: */
%    char	szError [ 256 ];
%    sprintf ( szError, szFormatRpcFailed, __procedure__,
%              clnt_sperror ( __pClient__, __szHost__ ) );
%    __pClient__	= RPC_CLIENT_DESTROY ( __pClient__ );
%    RPC_CLIENT_CERROR ( szContRpcFailed, szError );
%    Result	= ZeroResult;
%    return Result.ReturnValue;
%  }
%#ifndef MULTITHREAD
%  Result	= * pResult;
%#endif
%
%
%  if ( pResult && pResult->nErrorLvl ) {
%    /* Server returned a user error message: */
%    char	szErrorMsg [ 1024 ];
%    strncpy ( szErrorMsg,
%              ( pResult->pszErrorMsg && pResult->pszErrorMsg [ 0 ] ) ?
%              (LPCSTR) pResult->pszErrorMsg : (LPCSTR) szEmpty,
%              sizeof ( szErrorMsg ) );
%    szErrorMsg [ sizeof ( szErrorMsg ) - 1 ]	= (char) 0;
%    xdr_free ( (xdrproc_t) xdr_fnServerObjectTypeTag_rets, (char *) pResult );
%    RPC_CLIENT_SERROR ( pResult->nErrorLvl, __procedure__,
%                        szErrorMsg );
%  } else {
%    xdr_free ( (xdrproc_t) xdr_fnServerObjectTypeTag_rets, (char *) pResult );
%  }
%
%  return Result.ReturnValue;
%
%} /* fnServerObjectTypeTag */
#endif	/* RPC_CLNT */
%
  fnServerObjectValueSize_rets fnRpc_fnServerObjectValueSize ( fnServerObjectValueSize_args ) =  34 ;
%
#if RPC_SVC
%
%extern int fnServerObjectValueSize
%	(SHORTOBJID oShortObjIdHeap ,
%	  SHORTOBJID oShortObjId);
%
%#ifdef MULTITHREAD
%bool_t
%#else
%fnServerObjectValueSize_rets *
%#endif
%	PASTE2(fnrpc_fnserverobjectvaluesize_1,_SVCSUFFIX)
%		( fnServerObjectValueSize_args * pArguments,
%#ifdef MULTITHREAD
%		  fnServerObjectValueSize_rets * pResult,
%#endif
%		  struct svc_req * pRequest )
%{
%  static const char	__procedure__[]	= "server:fnrpc_fnserverobjectvaluesize_1";
%#ifdef MULTITHREAD
%  typedef bool_t RESULTTYPE;
%#else
%  typedef fnServerObjectValueSize_rets * RESULTTYPE;
%#endif
%#ifndef MULTITHREAD
%  static fnServerObjectValueSize_rets	Result;
%  RESULTTYPE			pResult = &Result;
%#endif
%  LPCSTR	pszErrorMsg;
%
%  __pRequest__	= pRequest;
%
%  RPC_SERVER_ENTRY();
%
%#ifndef MULTITHREAD
%  if ( pResult->pszErrorMsg == szEmpty ) {
%    pResult->pszErrorMsg	= NULL;
%  }
%  xdr_free ( (xdrproc_t) xdr_fnServerObjectValueSize_rets, (char *) pResult );
%#endif
%  pResult->nErrorLvl		= 0;
%
%  Reply.bAnswered		= FALSE;
%  Reply.pfnCalled		= (void(*)()) fnServerObjectValueSize;
%  Reply.pfnXdrResult		= (bool_t(*)()) xdr_fnServerObjectValueSize_rets;
%  Reply.pnErrorLvl		= &pResult->nErrorLvl;
%  Reply.ppszErrorMsg		= (LPCSTR *) &pResult->pszErrorMsg;
%  Reply.pResult		= pResult;
%  Reply.pReturnValue		= &pResult->ReturnValue;
%  Reply.nReturnValueSize	= sizeof ( pResult->ReturnValue );
%
%  pResult->ReturnValue		=
%  fnServerObjectValueSize (
%	pArguments->oShortObjIdHeap,
%	pArguments->oShortObjId );
%
%  if ( Reply.bAnswered ) {
%    __pRequest__	= NULL;
%    return (RESULTTYPE) NULL;
%  }
%
%  pResult->nErrorLvl	= RPC_SERVER_ERRLVL();
%  if ( pResult->nErrorLvl > 0 ) {
%    pszErrorMsg		= RPC_SERVER_ERRMSG();
%    if ( pszErrorMsg && *pszErrorMsg ) {
%      pResult->pszErrorMsg	= strdup ( pszErrorMsg );
%    }
%  }
%  if ( pResult->pszErrorMsg == NULL ) {
%#ifdef MULTITHREAD
%    pResult->pszErrorMsg	= strdup ( szEmpty );
%#else
%    pResult->pszErrorMsg	= (LPSTR) szEmpty;
%#endif
%  }
%  __pRequest__	= NULL;
%  return (RESULTTYPE) pResult;
%} /* fnrpc_fnserverobjectvaluesize_1 */
#endif	/* RPC_SVC */
%
#if RPC_CLNT
%int DLLEXPORT fnServerObjectValueSize
%	(SHORTOBJID oShortObjIdHeap ,
%	  SHORTOBJID oShortObjId)
%{
%  static const char	__procedure__[]	= "client:fnServerObjectValueSize";
%  static fnServerObjectValueSize_rets	ZeroResult;
%  fnServerObjectValueSize_rets		* pResult = NULL;
%  fnServerObjectValueSize_rets		Result = ZeroResult;
%  fnServerObjectValueSize_args	InArguments;
%
%  /* Client initialization: */
%  if ( __bClientInitialize__ ) {
%    __bClientInitialize__	= FALSE;
%    RPC_CLIENT_INITIALIZE();
%  }
%
%#if	CLIENT_CREATE_BY_USER
%  if ( __pClient__ == NULL ) {
%    __pClient__	= RPC_CLIENT_CREATE ( __szHost__, __szTransport__ );
%    if ( __pClient__ == NULL ) {
%      /* Error handling for a not connected client: */
%      char	szError [ 256 ];
%      sprintf ( szError, szFormatNoServer, __procedure__ );
%      RPC_CLIENT_ERROR ( szError );
%      return Result.ReturnValue;
%    }
%  }
%#else
%  while ( __pClient__ == NULL ) {
%    __pClient__	= RPC_CLIENT_CREATE ( __szHost__, __szTransport__ );
%    if ( __pClient__ == NULL ) {
%      /* Error handling for a not connected client: */
%      char	szError [ 256 ];
%      sprintf ( szError, szFormatNoServer, __procedure__ );
%      RPC_CLIENT_CERROR ( szContNoServer, szError );
%    }
%  }
%#endif	/* CLIENT_CREATE_BY_USER */
%
%  /* Copy in the oShortObjIdHeap argument: */
%  InArguments.oShortObjIdHeap	= oShortObjIdHeap;
%  /* Copy in the oShortObjId argument: */
%  InArguments.oShortObjId	= oShortObjId;
%
%  pResult	=
%#ifdef MULTITHREAD
%    (
%#else
%    (fnServerObjectValueSize_rets *)
%#endif
%    fnrpc_fnserverobjectvaluesize_1 (
%	&InArguments,
%#ifdef MULTITHREAD
%	&Result,
%#endif
%	__pClient__ )
%#ifdef MULTITHREAD
%	== RPC_SUCCESS ) ? &Result : NULL
%#endif
%	;
%
%  if ( pResult == NULL ) {
%    /* Error handling for a failed RPC call, */
%    /* i.e. the server did not respond: */
%    char	szError [ 256 ];
%    sprintf ( szError, szFormatRpcFailed, __procedure__,
%              clnt_sperror ( __pClient__, __szHost__ ) );
%    __pClient__	= RPC_CLIENT_DESTROY ( __pClient__ );
%    RPC_CLIENT_CERROR ( szContRpcFailed, szError );
%    Result	= ZeroResult;
%    return Result.ReturnValue;
%  }
%#ifndef MULTITHREAD
%  Result	= * pResult;
%#endif
%
%
%  if ( pResult && pResult->nErrorLvl ) {
%    /* Server returned a user error message: */
%    char	szErrorMsg [ 1024 ];
%    strncpy ( szErrorMsg,
%              ( pResult->pszErrorMsg && pResult->pszErrorMsg [ 0 ] ) ?
%              (LPCSTR) pResult->pszErrorMsg : (LPCSTR) szEmpty,
%              sizeof ( szErrorMsg ) );
%    szErrorMsg [ sizeof ( szErrorMsg ) - 1 ]	= (char) 0;
%    xdr_free ( (xdrproc_t) xdr_fnServerObjectValueSize_rets, (char *) pResult );
%    RPC_CLIENT_SERROR ( pResult->nErrorLvl, __procedure__,
%                        szErrorMsg );
%  } else {
%    xdr_free ( (xdrproc_t) xdr_fnServerObjectValueSize_rets, (char *) pResult );
%  }
%
%  return Result.ReturnValue;
%
%} /* fnServerObjectValueSize */
#endif	/* RPC_CLNT */
%
  fnServerObjectWriteAtIndex_rets fnRpc_fnServerObjectWriteAtIndex ( fnServerObjectWriteAtIndex_args ) =  35 ;
%
#if RPC_SVC
%
%extern SHLOCK fnServerObjectWriteAtIndex
%	(SHORTOBJID oShortObjIdHeap ,
%	  SHORTOBJID oShortObjId ,
%	  SHORTOBJID oExpectingClass ,
%	  SHTYPETAG nExpectingTypeTag ,
%	  int nIndex ,
%	  int nValue ,
%	  SHTYPETAG nTypeTagValue);
%
%#ifdef MULTITHREAD
%bool_t
%#else
%fnServerObjectWriteAtIndex_rets *
%#endif
%	PASTE2(fnrpc_fnserverobjectwriteatindex_1,_SVCSUFFIX)
%		( fnServerObjectWriteAtIndex_args * pArguments,
%#ifdef MULTITHREAD
%		  fnServerObjectWriteAtIndex_rets * pResult,
%#endif
%		  struct svc_req * pRequest )
%{
%  static const char	__procedure__[]	= "server:fnrpc_fnserverobjectwriteatindex_1";
%#ifdef MULTITHREAD
%  typedef bool_t RESULTTYPE;
%#else
%  typedef fnServerObjectWriteAtIndex_rets * RESULTTYPE;
%#endif
%#ifndef MULTITHREAD
%  static fnServerObjectWriteAtIndex_rets	Result;
%  RESULTTYPE			pResult = &Result;
%#endif
%  LPCSTR	pszErrorMsg;
%
%  __pRequest__	= pRequest;
%
%  RPC_SERVER_ENTRY();
%
%#ifndef MULTITHREAD
%  if ( pResult->pszErrorMsg == szEmpty ) {
%    pResult->pszErrorMsg	= NULL;
%  }
%  xdr_free ( (xdrproc_t) xdr_fnServerObjectWriteAtIndex_rets, (char *) pResult );
%#endif
%  pResult->nErrorLvl		= 0;
%
%  Reply.bAnswered		= FALSE;
%  Reply.pfnCalled		= (void(*)()) fnServerObjectWriteAtIndex;
%  Reply.pfnXdrResult		= (bool_t(*)()) xdr_fnServerObjectWriteAtIndex_rets;
%  Reply.pnErrorLvl		= &pResult->nErrorLvl;
%  Reply.ppszErrorMsg		= (LPCSTR *) &pResult->pszErrorMsg;
%  Reply.pResult		= pResult;
%  Reply.pReturnValue		= &pResult->ReturnValue;
%  Reply.nReturnValueSize	= sizeof ( pResult->ReturnValue );
%
%  pResult->ReturnValue		=
%  fnServerObjectWriteAtIndex (
%	pArguments->oShortObjIdHeap,
%	pArguments->oShortObjId,
%	pArguments->oExpectingClass,
%	pArguments->nExpectingTypeTag,
%	pArguments->nIndex,
%	pArguments->nValue,
%	pArguments->nTypeTagValue );
%
%  if ( Reply.bAnswered ) {
%    __pRequest__	= NULL;
%    return (RESULTTYPE) NULL;
%  }
%
%  pResult->nErrorLvl	= RPC_SERVER_ERRLVL();
%  if ( pResult->nErrorLvl > 0 ) {
%    pszErrorMsg		= RPC_SERVER_ERRMSG();
%    if ( pszErrorMsg && *pszErrorMsg ) {
%      pResult->pszErrorMsg	= strdup ( pszErrorMsg );
%    }
%  }
%  if ( pResult->pszErrorMsg == NULL ) {
%#ifdef MULTITHREAD
%    pResult->pszErrorMsg	= strdup ( szEmpty );
%#else
%    pResult->pszErrorMsg	= (LPSTR) szEmpty;
%#endif
%  }
%  __pRequest__	= NULL;
%  return (RESULTTYPE) pResult;
%} /* fnrpc_fnserverobjectwriteatindex_1 */
#endif	/* RPC_SVC */
%
#if RPC_CLNT
%SHLOCK DLLEXPORT fnServerObjectWriteAtIndex
%	(SHORTOBJID oShortObjIdHeap ,
%	  SHORTOBJID oShortObjId ,
%	  SHORTOBJID oExpectingClass ,
%	  SHTYPETAG nExpectingTypeTag ,
%	  int nIndex ,
%	  int nValue ,
%	  SHTYPETAG nTypeTagValue)
%{
%  static const char	__procedure__[]	= "client:fnServerObjectWriteAtIndex";
%  static fnServerObjectWriteAtIndex_rets	ZeroResult;
%  fnServerObjectWriteAtIndex_rets		* pResult = NULL;
%  fnServerObjectWriteAtIndex_rets		Result = ZeroResult;
%  fnServerObjectWriteAtIndex_args	InArguments;
%
%  /* Client initialization: */
%  if ( __bClientInitialize__ ) {
%    __bClientInitialize__	= FALSE;
%    RPC_CLIENT_INITIALIZE();
%  }
%
%#if	CLIENT_CREATE_BY_USER
%  if ( __pClient__ == NULL ) {
%    __pClient__	= RPC_CLIENT_CREATE ( __szHost__, __szTransport__ );
%    if ( __pClient__ == NULL ) {
%      /* Error handling for a not connected client: */
%      char	szError [ 256 ];
%      sprintf ( szError, szFormatNoServer, __procedure__ );
%      RPC_CLIENT_ERROR ( szError );
%      return Result.ReturnValue;
%    }
%  }
%#else
%  while ( __pClient__ == NULL ) {
%    __pClient__	= RPC_CLIENT_CREATE ( __szHost__, __szTransport__ );
%    if ( __pClient__ == NULL ) {
%      /* Error handling for a not connected client: */
%      char	szError [ 256 ];
%      sprintf ( szError, szFormatNoServer, __procedure__ );
%      RPC_CLIENT_CERROR ( szContNoServer, szError );
%    }
%  }
%#endif	/* CLIENT_CREATE_BY_USER */
%
%  /* Copy in the oShortObjIdHeap argument: */
%  InArguments.oShortObjIdHeap	= oShortObjIdHeap;
%  /* Copy in the oShortObjId argument: */
%  InArguments.oShortObjId	= oShortObjId;
%  /* Copy in the oExpectingClass argument: */
%  InArguments.oExpectingClass	= oExpectingClass;
%  /* Copy in the nExpectingTypeTag argument: */
%  InArguments.nExpectingTypeTag	= nExpectingTypeTag;
%  /* Copy in the nIndex argument: */
%  InArguments.nIndex	= nIndex;
%  /* Copy in the nValue argument: */
%  InArguments.nValue	= nValue;
%  /* Copy in the nTypeTagValue argument: */
%  InArguments.nTypeTagValue	= nTypeTagValue;
%
%  pResult	=
%#ifdef MULTITHREAD
%    (
%#else
%    (fnServerObjectWriteAtIndex_rets *)
%#endif
%    fnrpc_fnserverobjectwriteatindex_1 (
%	&InArguments,
%#ifdef MULTITHREAD
%	&Result,
%#endif
%	__pClient__ )
%#ifdef MULTITHREAD
%	== RPC_SUCCESS ) ? &Result : NULL
%#endif
%	;
%
%  if ( pResult == NULL ) {
%    /* Error handling for a failed RPC call, */
%    /* i.e. the server did not respond: */
%    char	szError [ 256 ];
%    sprintf ( szError, szFormatRpcFailed, __procedure__,
%              clnt_sperror ( __pClient__, __szHost__ ) );
%    __pClient__	= RPC_CLIENT_DESTROY ( __pClient__ );
%    RPC_CLIENT_CERROR ( szContRpcFailed, szError );
%    Result	= ZeroResult;
%    return Result.ReturnValue;
%  }
%#ifndef MULTITHREAD
%  Result	= * pResult;
%#endif
%
%
%  if ( pResult && pResult->nErrorLvl ) {
%    /* Server returned a user error message: */
%    char	szErrorMsg [ 1024 ];
%    strncpy ( szErrorMsg,
%              ( pResult->pszErrorMsg && pResult->pszErrorMsg [ 0 ] ) ?
%              (LPCSTR) pResult->pszErrorMsg : (LPCSTR) szEmpty,
%              sizeof ( szErrorMsg ) );
%    szErrorMsg [ sizeof ( szErrorMsg ) - 1 ]	= (char) 0;
%    xdr_free ( (xdrproc_t) xdr_fnServerObjectWriteAtIndex_rets, (char *) pResult );
%    RPC_CLIENT_SERROR ( pResult->nErrorLvl, __procedure__,
%                        szErrorMsg );
%  } else {
%    xdr_free ( (xdrproc_t) xdr_fnServerObjectWriteAtIndex_rets, (char *) pResult );
%  }
%
%  return Result.ReturnValue;
%
%} /* fnServerObjectWriteAtIndex */
#endif	/* RPC_CLNT */
%
  fnServerObjectWriteAtIndices_rets fnRpc_fnServerObjectWriteAtIndices ( fnServerObjectWriteAtIndices_args ) =  36 ;
%
#if RPC_SVC
%
%extern int fnServerObjectWriteAtIndices
%	(SHORTOBJID oShortObjIdHeap ,
%	  SHORTOBJID oShortObjId ,
%	  SHORTOBJID oExpectingClass ,
%	  SHTYPETAG nExpectingTypeTag ,
%	  int nIndex ,
%	  int nObjIds ,
%	  int * /* _vector_t<nObjIds> */ pObjIds ,
%	  u_int * /* _vector_t<nObjIds> */ pnTypeTags);
%
%#ifdef MULTITHREAD
%bool_t
%#else
%fnServerObjectWriteAtIndices_rets *
%#endif
%	PASTE2(fnrpc_fnserverobjectwriteatindices_1,_SVCSUFFIX)
%		( fnServerObjectWriteAtIndices_args * pArguments,
%#ifdef MULTITHREAD
%		  fnServerObjectWriteAtIndices_rets * pResult,
%#endif
%		  struct svc_req * pRequest )
%{
%  static const char	__procedure__[]	= "server:fnrpc_fnserverobjectwriteatindices_1";
%#ifdef MULTITHREAD
%  typedef bool_t RESULTTYPE;
%#else
%  typedef fnServerObjectWriteAtIndices_rets * RESULTTYPE;
%#endif
%#ifndef MULTITHREAD
%  static fnServerObjectWriteAtIndices_rets	Result;
%  RESULTTYPE			pResult = &Result;
%#endif
%  LPCSTR	pszErrorMsg;
%
%  __pRequest__	= pRequest;
%
%  RPC_SERVER_ENTRY();
%
%#ifndef MULTITHREAD
%  if ( pResult->pszErrorMsg == szEmpty ) {
%    pResult->pszErrorMsg	= NULL;
%  }
%  xdr_free ( (xdrproc_t) xdr_fnServerObjectWriteAtIndices_rets, (char *) pResult );
%#endif
%  pResult->nErrorLvl		= 0;
%
%  Reply.bAnswered		= FALSE;
%  Reply.pfnCalled		= (void(*)()) fnServerObjectWriteAtIndices;
%  Reply.pfnXdrResult		= (bool_t(*)()) xdr_fnServerObjectWriteAtIndices_rets;
%  Reply.pnErrorLvl		= &pResult->nErrorLvl;
%  Reply.ppszErrorMsg		= (LPCSTR *) &pResult->pszErrorMsg;
%  Reply.pResult		= pResult;
%  Reply.pReturnValue		= &pResult->ReturnValue;
%  Reply.nReturnValueSize	= sizeof ( pResult->ReturnValue );
%
%  pResult->ReturnValue		=
%  fnServerObjectWriteAtIndices (
%	pArguments->oShortObjIdHeap,
%	pArguments->oShortObjId,
%	pArguments->oExpectingClass,
%	pArguments->nExpectingTypeTag,
%	pArguments->nIndex,
%	pArguments->nObjIds,
%	pArguments->pObjIds.int_vector_t_val,
%	pArguments->pnTypeTags.u_int_vector_t_val );
%
%  if ( Reply.bAnswered ) {
%    __pRequest__	= NULL;
%    return (RESULTTYPE) NULL;
%  }
%
%  pResult->nErrorLvl	= RPC_SERVER_ERRLVL();
%  if ( pResult->nErrorLvl > 0 ) {
%    pszErrorMsg		= RPC_SERVER_ERRMSG();
%    if ( pszErrorMsg && *pszErrorMsg ) {
%      pResult->pszErrorMsg	= strdup ( pszErrorMsg );
%    }
%  }
%  if ( pResult->pszErrorMsg == NULL ) {
%#ifdef MULTITHREAD
%    pResult->pszErrorMsg	= strdup ( szEmpty );
%#else
%    pResult->pszErrorMsg	= (LPSTR) szEmpty;
%#endif
%  }
%  __pRequest__	= NULL;
%  return (RESULTTYPE) pResult;
%} /* fnrpc_fnserverobjectwriteatindices_1 */
#endif	/* RPC_SVC */
%
#if RPC_CLNT
%int DLLEXPORT fnServerObjectWriteAtIndices
%	(SHORTOBJID oShortObjIdHeap ,
%	  SHORTOBJID oShortObjId ,
%	  SHORTOBJID oExpectingClass ,
%	  SHTYPETAG nExpectingTypeTag ,
%	  int nIndex ,
%	  int nObjIds ,
%	  int * /* _vector_t<nObjIds> */ pObjIds ,
%	  u_int * /* _vector_t<nObjIds> */ pnTypeTags)
%{
%  static const char	__procedure__[]	= "client:fnServerObjectWriteAtIndices";
%  static fnServerObjectWriteAtIndices_rets	ZeroResult;
%  fnServerObjectWriteAtIndices_rets		* pResult = NULL;
%  fnServerObjectWriteAtIndices_rets		Result = ZeroResult;
%  fnServerObjectWriteAtIndices_args	InArguments;
%
%  /* Client initialization: */
%  if ( __bClientInitialize__ ) {
%    __bClientInitialize__	= FALSE;
%    RPC_CLIENT_INITIALIZE();
%  }
%
%#if	CLIENT_CREATE_BY_USER
%  if ( __pClient__ == NULL ) {
%    __pClient__	= RPC_CLIENT_CREATE ( __szHost__, __szTransport__ );
%    if ( __pClient__ == NULL ) {
%      /* Error handling for a not connected client: */
%      char	szError [ 256 ];
%      sprintf ( szError, szFormatNoServer, __procedure__ );
%      RPC_CLIENT_ERROR ( szError );
%      return Result.ReturnValue;
%    }
%  }
%#else
%  while ( __pClient__ == NULL ) {
%    __pClient__	= RPC_CLIENT_CREATE ( __szHost__, __szTransport__ );
%    if ( __pClient__ == NULL ) {
%      /* Error handling for a not connected client: */
%      char	szError [ 256 ];
%      sprintf ( szError, szFormatNoServer, __procedure__ );
%      RPC_CLIENT_CERROR ( szContNoServer, szError );
%    }
%  }
%#endif	/* CLIENT_CREATE_BY_USER */
%
%  /* Copy in the oShortObjIdHeap argument: */
%  InArguments.oShortObjIdHeap	= oShortObjIdHeap;
%  /* Copy in the oShortObjId argument: */
%  InArguments.oShortObjId	= oShortObjId;
%  /* Copy in the oExpectingClass argument: */
%  InArguments.oExpectingClass	= oExpectingClass;
%  /* Copy in the nExpectingTypeTag argument: */
%  InArguments.nExpectingTypeTag	= nExpectingTypeTag;
%  /* Copy in the nIndex argument: */
%  InArguments.nIndex	= nIndex;
%  /* Copy in the nObjIds argument: */
%  InArguments.nObjIds	= nObjIds;
%  /* Copy in the pObjIds argument: */
%  InArguments.pObjIds.int_vector_t_len	= nObjIds;
%  InArguments.pObjIds.int_vector_t_val	= pObjIds;
%  if ( InArguments.pObjIds.int_vector_t_len != 0 && pObjIds == NULL ) {
%    /* Error handling for passing a NULL pointer on */
%    /* VECTOR declared in argument: */
%    char	szError [ 256 ];
%    InArguments.pObjIds.int_vector_t_len	= 0;
%    sprintf ( szError, szFormatNullPassed,
%              __procedure__, "pObjIds" );
%    RPC_CLIENT_CERROR ( szContNullPassed, szError );
%  }
%  /* Copy in the pnTypeTags argument: */
%  InArguments.pnTypeTags.u_int_vector_t_len	= nObjIds;
%  InArguments.pnTypeTags.u_int_vector_t_val	= pnTypeTags;
%  if ( InArguments.pnTypeTags.u_int_vector_t_len != 0 && pnTypeTags == NULL ) {
%    /* Error handling for passing a NULL pointer on */
%    /* VECTOR declared in argument: */
%    char	szError [ 256 ];
%    InArguments.pnTypeTags.u_int_vector_t_len	= 0;
%    sprintf ( szError, szFormatNullPassed,
%              __procedure__, "pnTypeTags" );
%    RPC_CLIENT_CERROR ( szContNullPassed, szError );
%  }
%
%  pResult	=
%#ifdef MULTITHREAD
%    (
%#else
%    (fnServerObjectWriteAtIndices_rets *)
%#endif
%    fnrpc_fnserverobjectwriteatindices_1 (
%	&InArguments,
%#ifdef MULTITHREAD
%	&Result,
%#endif
%	__pClient__ )
%#ifdef MULTITHREAD
%	== RPC_SUCCESS ) ? &Result : NULL
%#endif
%	;
%
%  if ( pResult == NULL ) {
%    /* Error handling for a failed RPC call, */
%    /* i.e. the server did not respond: */
%    char	szError [ 256 ];
%    sprintf ( szError, szFormatRpcFailed, __procedure__,
%              clnt_sperror ( __pClient__, __szHost__ ) );
%    __pClient__	= RPC_CLIENT_DESTROY ( __pClient__ );
%    RPC_CLIENT_CERROR ( szContRpcFailed, szError );
%    Result	= ZeroResult;
%    return Result.ReturnValue;
%  }
%#ifndef MULTITHREAD
%  Result	= * pResult;
%#endif
%
%
%  if ( pResult && pResult->nErrorLvl ) {
%    /* Server returned a user error message: */
%    char	szErrorMsg [ 1024 ];
%    strncpy ( szErrorMsg,
%              ( pResult->pszErrorMsg && pResult->pszErrorMsg [ 0 ] ) ?
%              (LPCSTR) pResult->pszErrorMsg : (LPCSTR) szEmpty,
%              sizeof ( szErrorMsg ) );
%    szErrorMsg [ sizeof ( szErrorMsg ) - 1 ]	= (char) 0;
%    xdr_free ( (xdrproc_t) xdr_fnServerObjectWriteAtIndices_rets, (char *) pResult );
%    RPC_CLIENT_SERROR ( pResult->nErrorLvl, __procedure__,
%                        szErrorMsg );
%  } else {
%    xdr_free ( (xdrproc_t) xdr_fnServerObjectWriteAtIndices_rets, (char *) pResult );
%  }
%
%  return Result.ReturnValue;
%
%} /* fnServerObjectWriteAtIndices */
#endif	/* RPC_CLNT */
%
  fnServerObjectWriteObjId_rets fnRpc_fnServerObjectWriteObjId ( fnServerObjectWriteObjId_args ) =  37 ;
%
#if RPC_SVC
%
%extern SHLOCK fnServerObjectWriteObjId
%	(SHORTOBJID oShortObjIdHeap ,
%	  SHORTOBJID oShortObjId ,
%	  SHORTOBJID oExpectingClass ,
%	  SHTYPETAG nExpectingTypeTag ,
%	  int nIndex ,
%	  SHORTOBJID oShortObjIdWrite);
%
%#ifdef MULTITHREAD
%bool_t
%#else
%fnServerObjectWriteObjId_rets *
%#endif
%	PASTE2(fnrpc_fnserverobjectwriteobjid_1,_SVCSUFFIX)
%		( fnServerObjectWriteObjId_args * pArguments,
%#ifdef MULTITHREAD
%		  fnServerObjectWriteObjId_rets * pResult,
%#endif
%		  struct svc_req * pRequest )
%{
%  static const char	__procedure__[]	= "server:fnrpc_fnserverobjectwriteobjid_1";
%#ifdef MULTITHREAD
%  typedef bool_t RESULTTYPE;
%#else
%  typedef fnServerObjectWriteObjId_rets * RESULTTYPE;
%#endif
%#ifndef MULTITHREAD
%  static fnServerObjectWriteObjId_rets	Result;
%  RESULTTYPE			pResult = &Result;
%#endif
%  LPCSTR	pszErrorMsg;
%
%  __pRequest__	= pRequest;
%
%  RPC_SERVER_ENTRY();
%
%#ifndef MULTITHREAD
%  if ( pResult->pszErrorMsg == szEmpty ) {
%    pResult->pszErrorMsg	= NULL;
%  }
%  xdr_free ( (xdrproc_t) xdr_fnServerObjectWriteObjId_rets, (char *) pResult );
%#endif
%  pResult->nErrorLvl		= 0;
%
%  Reply.bAnswered		= FALSE;
%  Reply.pfnCalled		= (void(*)()) fnServerObjectWriteObjId;
%  Reply.pfnXdrResult		= (bool_t(*)()) xdr_fnServerObjectWriteObjId_rets;
%  Reply.pnErrorLvl		= &pResult->nErrorLvl;
%  Reply.ppszErrorMsg		= (LPCSTR *) &pResult->pszErrorMsg;
%  Reply.pResult		= pResult;
%  Reply.pReturnValue		= &pResult->ReturnValue;
%  Reply.nReturnValueSize	= sizeof ( pResult->ReturnValue );
%
%  pResult->ReturnValue		=
%  fnServerObjectWriteObjId (
%	pArguments->oShortObjIdHeap,
%	pArguments->oShortObjId,
%	pArguments->oExpectingClass,
%	pArguments->nExpectingTypeTag,
%	pArguments->nIndex,
%	pArguments->oShortObjIdWrite );
%
%  if ( Reply.bAnswered ) {
%    __pRequest__	= NULL;
%    return (RESULTTYPE) NULL;
%  }
%
%  pResult->nErrorLvl	= RPC_SERVER_ERRLVL();
%  if ( pResult->nErrorLvl > 0 ) {
%    pszErrorMsg		= RPC_SERVER_ERRMSG();
%    if ( pszErrorMsg && *pszErrorMsg ) {
%      pResult->pszErrorMsg	= strdup ( pszErrorMsg );
%    }
%  }
%  if ( pResult->pszErrorMsg == NULL ) {
%#ifdef MULTITHREAD
%    pResult->pszErrorMsg	= strdup ( szEmpty );
%#else
%    pResult->pszErrorMsg	= (LPSTR) szEmpty;
%#endif
%  }
%  __pRequest__	= NULL;
%  return (RESULTTYPE) pResult;
%} /* fnrpc_fnserverobjectwriteobjid_1 */
#endif	/* RPC_SVC */
%
#if RPC_CLNT
%SHLOCK DLLEXPORT fnServerObjectWriteObjId
%	(SHORTOBJID oShortObjIdHeap ,
%	  SHORTOBJID oShortObjId ,
%	  SHORTOBJID oExpectingClass ,
%	  SHTYPETAG nExpectingTypeTag ,
%	  int nIndex ,
%	  SHORTOBJID oShortObjIdWrite)
%{
%  static const char	__procedure__[]	= "client:fnServerObjectWriteObjId";
%  static fnServerObjectWriteObjId_rets	ZeroResult;
%  fnServerObjectWriteObjId_rets		* pResult = NULL;
%  fnServerObjectWriteObjId_rets		Result = ZeroResult;
%  fnServerObjectWriteObjId_args	InArguments;
%
%  /* Client initialization: */
%  if ( __bClientInitialize__ ) {
%    __bClientInitialize__	= FALSE;
%    RPC_CLIENT_INITIALIZE();
%  }
%
%#if	CLIENT_CREATE_BY_USER
%  if ( __pClient__ == NULL ) {
%    __pClient__	= RPC_CLIENT_CREATE ( __szHost__, __szTransport__ );
%    if ( __pClient__ == NULL ) {
%      /* Error handling for a not connected client: */
%      char	szError [ 256 ];
%      sprintf ( szError, szFormatNoServer, __procedure__ );
%      RPC_CLIENT_ERROR ( szError );
%      return Result.ReturnValue;
%    }
%  }
%#else
%  while ( __pClient__ == NULL ) {
%    __pClient__	= RPC_CLIENT_CREATE ( __szHost__, __szTransport__ );
%    if ( __pClient__ == NULL ) {
%      /* Error handling for a not connected client: */
%      char	szError [ 256 ];
%      sprintf ( szError, szFormatNoServer, __procedure__ );
%      RPC_CLIENT_CERROR ( szContNoServer, szError );
%    }
%  }
%#endif	/* CLIENT_CREATE_BY_USER */
%
%  /* Copy in the oShortObjIdHeap argument: */
%  InArguments.oShortObjIdHeap	= oShortObjIdHeap;
%  /* Copy in the oShortObjId argument: */
%  InArguments.oShortObjId	= oShortObjId;
%  /* Copy in the oExpectingClass argument: */
%  InArguments.oExpectingClass	= oExpectingClass;
%  /* Copy in the nExpectingTypeTag argument: */
%  InArguments.nExpectingTypeTag	= nExpectingTypeTag;
%  /* Copy in the nIndex argument: */
%  InArguments.nIndex	= nIndex;
%  /* Copy in the oShortObjIdWrite argument: */
%  InArguments.oShortObjIdWrite	= oShortObjIdWrite;
%
%  pResult	=
%#ifdef MULTITHREAD
%    (
%#else
%    (fnServerObjectWriteObjId_rets *)
%#endif
%    fnrpc_fnserverobjectwriteobjid_1 (
%	&InArguments,
%#ifdef MULTITHREAD
%	&Result,
%#endif
%	__pClient__ )
%#ifdef MULTITHREAD
%	== RPC_SUCCESS ) ? &Result : NULL
%#endif
%	;
%
%  if ( pResult == NULL ) {
%    /* Error handling for a failed RPC call, */
%    /* i.e. the server did not respond: */
%    char	szError [ 256 ];
%    sprintf ( szError, szFormatRpcFailed, __procedure__,
%              clnt_sperror ( __pClient__, __szHost__ ) );
%    __pClient__	= RPC_CLIENT_DESTROY ( __pClient__ );
%    RPC_CLIENT_CERROR ( szContRpcFailed, szError );
%    Result	= ZeroResult;
%    return Result.ReturnValue;
%  }
%#ifndef MULTITHREAD
%  Result	= * pResult;
%#endif
%
%
%  if ( pResult && pResult->nErrorLvl ) {
%    /* Server returned a user error message: */
%    char	szErrorMsg [ 1024 ];
%    strncpy ( szErrorMsg,
%              ( pResult->pszErrorMsg && pResult->pszErrorMsg [ 0 ] ) ?
%              (LPCSTR) pResult->pszErrorMsg : (LPCSTR) szEmpty,
%              sizeof ( szErrorMsg ) );
%    szErrorMsg [ sizeof ( szErrorMsg ) - 1 ]	= (char) 0;
%    xdr_free ( (xdrproc_t) xdr_fnServerObjectWriteObjId_rets, (char *) pResult );
%    RPC_CLIENT_SERROR ( pResult->nErrorLvl, __procedure__,
%                        szErrorMsg );
%  } else {
%    xdr_free ( (xdrproc_t) xdr_fnServerObjectWriteObjId_rets, (char *) pResult );
%  }
%
%  return Result.ReturnValue;
%
%} /* fnServerObjectWriteObjId */
#endif	/* RPC_CLNT */
%
  fnServerObjectWriteValues_rets fnRpc_fnServerObjectWriteValues ( fnServerObjectWriteValues_args ) =  38 ;
%
#if RPC_SVC
%
%extern int fnServerObjectWriteValues
%	(SHORTOBJID oShortObjIdHeap ,
%	  SHORTOBJID oShortObjId ,
%	  SHORTOBJID oExpectingClass ,
%	  SHTYPETAG nExpectingTypeTag ,
%	  int nIndex ,
%	  SHTYPETAG nElementTypeTag ,
%	  int nSizeInElements ,
%	  void * /* _vector_t<((( fnTypeTagSizeValue(1,&nElementTypeTag, &nSizeInElements ) )*( sizeof(int) )) )> */ pBuffer);
%
%#ifdef MULTITHREAD
%bool_t
%#else
%fnServerObjectWriteValues_rets *
%#endif
%	PASTE2(fnrpc_fnserverobjectwritevalues_1,_SVCSUFFIX)
%		( fnServerObjectWriteValues_args * pArguments,
%#ifdef MULTITHREAD
%		  fnServerObjectWriteValues_rets * pResult,
%#endif
%		  struct svc_req * pRequest )
%{
%  static const char	__procedure__[]	= "server:fnrpc_fnserverobjectwritevalues_1";
%#ifdef MULTITHREAD
%  typedef bool_t RESULTTYPE;
%#else
%  typedef fnServerObjectWriteValues_rets * RESULTTYPE;
%#endif
%#ifndef MULTITHREAD
%  static fnServerObjectWriteValues_rets	Result;
%  RESULTTYPE			pResult = &Result;
%#endif
%  LPCSTR	pszErrorMsg;
%
%  __pRequest__	= pRequest;
%
%  RPC_SERVER_ENTRY();
%
%#ifndef MULTITHREAD
%  if ( pResult->pszErrorMsg == szEmpty ) {
%    pResult->pszErrorMsg	= NULL;
%  }
%  xdr_free ( (xdrproc_t) xdr_fnServerObjectWriteValues_rets, (char *) pResult );
%#endif
%  pResult->nErrorLvl		= 0;
%
%  Reply.bAnswered		= FALSE;
%  Reply.pfnCalled		= (void(*)()) fnServerObjectWriteValues;
%  Reply.pfnXdrResult		= (bool_t(*)()) xdr_fnServerObjectWriteValues_rets;
%  Reply.pnErrorLvl		= &pResult->nErrorLvl;
%  Reply.ppszErrorMsg		= (LPCSTR *) &pResult->pszErrorMsg;
%  Reply.pResult		= pResult;
%  Reply.pReturnValue		= &pResult->ReturnValue;
%  Reply.nReturnValueSize	= sizeof ( pResult->ReturnValue );
%
%  pResult->ReturnValue		=
%  fnServerObjectWriteValues (
%	pArguments->oShortObjIdHeap,
%	pArguments->oShortObjId,
%	pArguments->oExpectingClass,
%	pArguments->nExpectingTypeTag,
%	pArguments->nIndex,
%	pArguments->nElementTypeTag,
%	pArguments->nSizeInElements,
%	pArguments->pBuffer.void_vector_t_val );
%
%  if ( Reply.bAnswered ) {
%    __pRequest__	= NULL;
%    return (RESULTTYPE) NULL;
%  }
%
%  pResult->nErrorLvl	= RPC_SERVER_ERRLVL();
%  if ( pResult->nErrorLvl > 0 ) {
%    pszErrorMsg		= RPC_SERVER_ERRMSG();
%    if ( pszErrorMsg && *pszErrorMsg ) {
%      pResult->pszErrorMsg	= strdup ( pszErrorMsg );
%    }
%  }
%  if ( pResult->pszErrorMsg == NULL ) {
%#ifdef MULTITHREAD
%    pResult->pszErrorMsg	= strdup ( szEmpty );
%#else
%    pResult->pszErrorMsg	= (LPSTR) szEmpty;
%#endif
%  }
%  __pRequest__	= NULL;
%  return (RESULTTYPE) pResult;
%} /* fnrpc_fnserverobjectwritevalues_1 */
#endif	/* RPC_SVC */
%
#if RPC_CLNT
%int DLLEXPORT fnServerObjectWriteValues
%	(SHORTOBJID oShortObjIdHeap ,
%	  SHORTOBJID oShortObjId ,
%	  SHORTOBJID oExpectingClass ,
%	  SHTYPETAG nExpectingTypeTag ,
%	  int nIndex ,
%	  SHTYPETAG nElementTypeTag ,
%	  int nSizeInElements ,
%	  void * /* _vector_t<((( fnTypeTagSizeValue(1,&nElementTypeTag, &nSizeInElements ) )*( sizeof(int) )) )> */ pBuffer)
%{
%  static const char	__procedure__[]	= "client:fnServerObjectWriteValues";
%  static fnServerObjectWriteValues_rets	ZeroResult;
%  fnServerObjectWriteValues_rets		* pResult = NULL;
%  fnServerObjectWriteValues_rets		Result = ZeroResult;
%  fnServerObjectWriteValues_args	InArguments;
%
%  /* Client initialization: */
%  if ( __bClientInitialize__ ) {
%    __bClientInitialize__	= FALSE;
%    RPC_CLIENT_INITIALIZE();
%  }
%
%#if	CLIENT_CREATE_BY_USER
%  if ( __pClient__ == NULL ) {
%    __pClient__	= RPC_CLIENT_CREATE ( __szHost__, __szTransport__ );
%    if ( __pClient__ == NULL ) {
%      /* Error handling for a not connected client: */
%      char	szError [ 256 ];
%      sprintf ( szError, szFormatNoServer, __procedure__ );
%      RPC_CLIENT_ERROR ( szError );
%      return Result.ReturnValue;
%    }
%  }
%#else
%  while ( __pClient__ == NULL ) {
%    __pClient__	= RPC_CLIENT_CREATE ( __szHost__, __szTransport__ );
%    if ( __pClient__ == NULL ) {
%      /* Error handling for a not connected client: */
%      char	szError [ 256 ];
%      sprintf ( szError, szFormatNoServer, __procedure__ );
%      RPC_CLIENT_CERROR ( szContNoServer, szError );
%    }
%  }
%#endif	/* CLIENT_CREATE_BY_USER */
%
%  /* Copy in the oShortObjIdHeap argument: */
%  InArguments.oShortObjIdHeap	= oShortObjIdHeap;
%  /* Copy in the oShortObjId argument: */
%  InArguments.oShortObjId	= oShortObjId;
%  /* Copy in the oExpectingClass argument: */
%  InArguments.oExpectingClass	= oExpectingClass;
%  /* Copy in the nExpectingTypeTag argument: */
%  InArguments.nExpectingTypeTag	= nExpectingTypeTag;
%  /* Copy in the nIndex argument: */
%  InArguments.nIndex	= nIndex;
%  /* Copy in the nElementTypeTag argument: */
%  InArguments.nElementTypeTag	= nElementTypeTag;
%  /* Copy in the nSizeInElements argument: */
%  InArguments.nSizeInElements	= nSizeInElements;
%  /* Copy in the pBuffer argument: */
%  InArguments.pBuffer.void_vector_t_len	= ((( fnTypeTagSizeValue(1,&nElementTypeTag, &nSizeInElements ) )*( sizeof(int) )) );
%  InArguments.pBuffer.void_vector_t_val	= pBuffer;
%  if ( InArguments.pBuffer.void_vector_t_len != 0 && pBuffer == NULL ) {
%    /* Error handling for passing a NULL pointer on */
%    /* VECTOR declared in argument: */
%    char	szError [ 256 ];
%    InArguments.pBuffer.void_vector_t_len	= 0;
%    sprintf ( szError, szFormatNullPassed,
%              __procedure__, "pBuffer" );
%    RPC_CLIENT_CERROR ( szContNullPassed, szError );
%  }
%
%  pResult	=
%#ifdef MULTITHREAD
%    (
%#else
%    (fnServerObjectWriteValues_rets *)
%#endif
%    fnrpc_fnserverobjectwritevalues_1 (
%	&InArguments,
%#ifdef MULTITHREAD
%	&Result,
%#endif
%	__pClient__ )
%#ifdef MULTITHREAD
%	== RPC_SUCCESS ) ? &Result : NULL
%#endif
%	;
%
%  if ( pResult == NULL ) {
%    /* Error handling for a failed RPC call, */
%    /* i.e. the server did not respond: */
%    char	szError [ 256 ];
%    sprintf ( szError, szFormatRpcFailed, __procedure__,
%              clnt_sperror ( __pClient__, __szHost__ ) );
%    __pClient__	= RPC_CLIENT_DESTROY ( __pClient__ );
%    RPC_CLIENT_CERROR ( szContRpcFailed, szError );
%    Result	= ZeroResult;
%    return Result.ReturnValue;
%  }
%#ifndef MULTITHREAD
%  Result	= * pResult;
%#endif
%
%
%  if ( pResult && pResult->nErrorLvl ) {
%    /* Server returned a user error message: */
%    char	szErrorMsg [ 1024 ];
%    strncpy ( szErrorMsg,
%              ( pResult->pszErrorMsg && pResult->pszErrorMsg [ 0 ] ) ?
%              (LPCSTR) pResult->pszErrorMsg : (LPCSTR) szEmpty,
%              sizeof ( szErrorMsg ) );
%    szErrorMsg [ sizeof ( szErrorMsg ) - 1 ]	= (char) 0;
%    xdr_free ( (xdrproc_t) xdr_fnServerObjectWriteValues_rets, (char *) pResult );
%    RPC_CLIENT_SERROR ( pResult->nErrorLvl, __procedure__,
%                        szErrorMsg );
%  } else {
%    xdr_free ( (xdrproc_t) xdr_fnServerObjectWriteValues_rets, (char *) pResult );
%  }
%
%  return Result.ReturnValue;
%
%} /* fnServerObjectWriteValues */
#endif	/* RPC_CLNT */
%
  fnShortMakeDependent_rets fnRpc_fnShortMakeDependent ( fnShortMakeDependent_args ) =  39 ;
%
#if RPC_SVC
%
%extern DEPENDENTMODE fnShortMakeDependent
%	(SHORTOBJID oShortObjIdHeap ,
%	  SHORTOBJID oShortSelf ,
%	  DEPENDENTMODE nDependentMode);
%
%#ifdef MULTITHREAD
%bool_t
%#else
%fnShortMakeDependent_rets *
%#endif
%	PASTE2(fnrpc_fnshortmakedependent_1,_SVCSUFFIX)
%		( fnShortMakeDependent_args * pArguments,
%#ifdef MULTITHREAD
%		  fnShortMakeDependent_rets * pResult,
%#endif
%		  struct svc_req * pRequest )
%{
%  static const char	__procedure__[]	= "server:fnrpc_fnshortmakedependent_1";
%#ifdef MULTITHREAD
%  typedef bool_t RESULTTYPE;
%#else
%  typedef fnShortMakeDependent_rets * RESULTTYPE;
%#endif
%#ifndef MULTITHREAD
%  static fnShortMakeDependent_rets	Result;
%  RESULTTYPE			pResult = &Result;
%#endif
%  LPCSTR	pszErrorMsg;
%
%  __pRequest__	= pRequest;
%
%  RPC_SERVER_ENTRY();
%
%#ifndef MULTITHREAD
%  if ( pResult->pszErrorMsg == szEmpty ) {
%    pResult->pszErrorMsg	= NULL;
%  }
%  xdr_free ( (xdrproc_t) xdr_fnShortMakeDependent_rets, (char *) pResult );
%#endif
%  pResult->nErrorLvl		= 0;
%
%  Reply.bAnswered		= FALSE;
%  Reply.pfnCalled		= (void(*)()) fnShortMakeDependent;
%  Reply.pfnXdrResult		= (bool_t(*)()) xdr_fnShortMakeDependent_rets;
%  Reply.pnErrorLvl		= &pResult->nErrorLvl;
%  Reply.ppszErrorMsg		= (LPCSTR *) &pResult->pszErrorMsg;
%  Reply.pResult		= pResult;
%  Reply.pReturnValue		= &pResult->ReturnValue;
%  Reply.nReturnValueSize	= sizeof ( pResult->ReturnValue );
%
%  pResult->ReturnValue		=
%  fnShortMakeDependent (
%	pArguments->oShortObjIdHeap,
%	pArguments->oShortSelf,
%	pArguments->nDependentMode );
%
%  if ( Reply.bAnswered ) {
%    __pRequest__	= NULL;
%    return (RESULTTYPE) NULL;
%  }
%
%  pResult->nErrorLvl	= RPC_SERVER_ERRLVL();
%  if ( pResult->nErrorLvl > 0 ) {
%    pszErrorMsg		= RPC_SERVER_ERRMSG();
%    if ( pszErrorMsg && *pszErrorMsg ) {
%      pResult->pszErrorMsg	= strdup ( pszErrorMsg );
%    }
%  }
%  if ( pResult->pszErrorMsg == NULL ) {
%#ifdef MULTITHREAD
%    pResult->pszErrorMsg	= strdup ( szEmpty );
%#else
%    pResult->pszErrorMsg	= (LPSTR) szEmpty;
%#endif
%  }
%  __pRequest__	= NULL;
%  return (RESULTTYPE) pResult;
%} /* fnrpc_fnshortmakedependent_1 */
#endif	/* RPC_SVC */
%
#if RPC_CLNT
%DEPENDENTMODE DLLEXPORT fnShortMakeDependent
%	(SHORTOBJID oShortObjIdHeap ,
%	  SHORTOBJID oShortSelf ,
%	  DEPENDENTMODE nDependentMode)
%{
%  static const char	__procedure__[]	= "client:fnShortMakeDependent";
%  static fnShortMakeDependent_rets	ZeroResult;
%  fnShortMakeDependent_rets		* pResult = NULL;
%  fnShortMakeDependent_rets		Result = ZeroResult;
%  fnShortMakeDependent_args	InArguments;
%
%  /* Client initialization: */
%  if ( __bClientInitialize__ ) {
%    __bClientInitialize__	= FALSE;
%    RPC_CLIENT_INITIALIZE();
%  }
%
%#if	CLIENT_CREATE_BY_USER
%  if ( __pClient__ == NULL ) {
%    __pClient__	= RPC_CLIENT_CREATE ( __szHost__, __szTransport__ );
%    if ( __pClient__ == NULL ) {
%      /* Error handling for a not connected client: */
%      char	szError [ 256 ];
%      sprintf ( szError, szFormatNoServer, __procedure__ );
%      RPC_CLIENT_ERROR ( szError );
%      return Result.ReturnValue;
%    }
%  }
%#else
%  while ( __pClient__ == NULL ) {
%    __pClient__	= RPC_CLIENT_CREATE ( __szHost__, __szTransport__ );
%    if ( __pClient__ == NULL ) {
%      /* Error handling for a not connected client: */
%      char	szError [ 256 ];
%      sprintf ( szError, szFormatNoServer, __procedure__ );
%      RPC_CLIENT_CERROR ( szContNoServer, szError );
%    }
%  }
%#endif	/* CLIENT_CREATE_BY_USER */
%
%  /* Copy in the oShortObjIdHeap argument: */
%  InArguments.oShortObjIdHeap	= oShortObjIdHeap;
%  /* Copy in the oShortSelf argument: */
%  InArguments.oShortSelf	= oShortSelf;
%  /* Copy in the nDependentMode argument: */
%  InArguments.nDependentMode	= nDependentMode;
%
%  pResult	=
%#ifdef MULTITHREAD
%    (
%#else
%    (fnShortMakeDependent_rets *)
%#endif
%    fnrpc_fnshortmakedependent_1 (
%	&InArguments,
%#ifdef MULTITHREAD
%	&Result,
%#endif
%	__pClient__ )
%#ifdef MULTITHREAD
%	== RPC_SUCCESS ) ? &Result : NULL
%#endif
%	;
%
%  if ( pResult == NULL ) {
%    /* Error handling for a failed RPC call, */
%    /* i.e. the server did not respond: */
%    char	szError [ 256 ];
%    sprintf ( szError, szFormatRpcFailed, __procedure__,
%              clnt_sperror ( __pClient__, __szHost__ ) );
%    __pClient__	= RPC_CLIENT_DESTROY ( __pClient__ );
%    RPC_CLIENT_CERROR ( szContRpcFailed, szError );
%    Result	= ZeroResult;
%    return Result.ReturnValue;
%  }
%#ifndef MULTITHREAD
%  Result	= * pResult;
%#endif
%
%
%  if ( pResult && pResult->nErrorLvl ) {
%    /* Server returned a user error message: */
%    char	szErrorMsg [ 1024 ];
%    strncpy ( szErrorMsg,
%              ( pResult->pszErrorMsg && pResult->pszErrorMsg [ 0 ] ) ?
%              (LPCSTR) pResult->pszErrorMsg : (LPCSTR) szEmpty,
%              sizeof ( szErrorMsg ) );
%    szErrorMsg [ sizeof ( szErrorMsg ) - 1 ]	= (char) 0;
%    xdr_free ( (xdrproc_t) xdr_fnShortMakeDependent_rets, (char *) pResult );
%    RPC_CLIENT_SERROR ( pResult->nErrorLvl, __procedure__,
%                        szErrorMsg );
%  } else {
%    xdr_free ( (xdrproc_t) xdr_fnShortMakeDependent_rets, (char *) pResult );
%  }
%
%  return Result.ReturnValue;
%
%} /* fnShortMakeDependent */
#endif	/* RPC_CLNT */
%
  fnServerObjectPeekSlots_rets fnRpc_fnServerObjectPeekSlots ( fnServerObjectPeekSlots_args ) =  40 ;
%
#if RPC_SVC
%
%extern SHLOCK fnServerObjectPeekSlots
%	(SHORTOBJID oShortObjIdHeap ,
%	  int hPeek ,
%	  int nWords ,
%	  u_int * /* _vector_t<nWords> */  pBuffer);
%
%#ifdef MULTITHREAD
%bool_t
%#else
%fnServerObjectPeekSlots_rets *
%#endif
%	PASTE2(fnrpc_fnserverobjectpeekslots_1,_SVCSUFFIX)
%		( fnServerObjectPeekSlots_args * pArguments,
%#ifdef MULTITHREAD
%		  fnServerObjectPeekSlots_rets * pResult,
%#endif
%		  struct svc_req * pRequest )
%{
%  static const char	__procedure__[]	= "server:fnrpc_fnserverobjectpeekslots_1";
%#ifdef MULTITHREAD
%  typedef bool_t RESULTTYPE;
%#else
%  typedef fnServerObjectPeekSlots_rets * RESULTTYPE;
%#endif
%#ifndef MULTITHREAD
%  static fnServerObjectPeekSlots_rets	Result;
%  RESULTTYPE			pResult = &Result;
%#endif
%  LPCSTR	pszErrorMsg;
%
%  __pRequest__	= pRequest;
%
%  RPC_SERVER_ENTRY();
%
%#ifndef MULTITHREAD
%  if ( pResult->pszErrorMsg == szEmpty ) {
%    pResult->pszErrorMsg	= NULL;
%  }
%  xdr_free ( (xdrproc_t) xdr_fnServerObjectPeekSlots_rets, (char *) pResult );
%#endif
%  pResult->nErrorLvl		= 0;
%
%  pResult->pBuffer.u_int_vector_t_len	= pArguments->pBufferSize;
%  if ( pArguments->pBufferSize == 0 ) {
%    pResult->pBuffer.u_int_vector_t_val	= NULL;
%  } else {
%    pResult->pBuffer.u_int_vector_t_val	=
%      (u_int*) malloc ( pArguments->pBufferSize *
%               SIZEOF ( *(pResult->pBuffer.u_int_vector_t_val) ) );
%    if ( pResult->pBuffer.u_int_vector_t_val == NULL ) {
%      char	szError [ 256 ];
%      sprintf ( szError, szFormatMallocFailed,
%                __procedure__, pArguments->pBufferSize,
%                "pBuffer" );
%      RPC_SERVER_ERROR ( szError );
%      return (RESULTTYPE) NULL;
%    }
%  }
%  Reply.bAnswered		= FALSE;
%  Reply.pfnCalled		= (void(*)()) fnServerObjectPeekSlots;
%  Reply.pfnXdrResult		= (bool_t(*)()) xdr_fnServerObjectPeekSlots_rets;
%  Reply.pnErrorLvl		= &pResult->nErrorLvl;
%  Reply.ppszErrorMsg		= (LPCSTR *) &pResult->pszErrorMsg;
%  Reply.pResult		= pResult;
%  Reply.pReturnValue		= &pResult->ReturnValue;
%  Reply.nReturnValueSize	= sizeof ( pResult->ReturnValue );
%
%  pResult->ReturnValue		=
%  fnServerObjectPeekSlots (
%	pArguments->oShortObjIdHeap,
%	pArguments->hPeek,
%	pArguments->nWords,
%	pResult->pBuffer.u_int_vector_t_val );
%
%  if ( Reply.bAnswered ) {
%    __pRequest__	= NULL;
%    return (RESULTTYPE) NULL;
%  }
%
%  pResult->nErrorLvl	= RPC_SERVER_ERRLVL();
%  if ( pResult->nErrorLvl > 0 ) {
%    pszErrorMsg		= RPC_SERVER_ERRMSG();
%    if ( pszErrorMsg && *pszErrorMsg ) {
%      pResult->pszErrorMsg	= strdup ( pszErrorMsg );
%    }
%  }
%  if ( pResult->pszErrorMsg == NULL ) {
%#ifdef MULTITHREAD
%    pResult->pszErrorMsg	= strdup ( szEmpty );
%#else
%    pResult->pszErrorMsg	= (LPSTR) szEmpty;
%#endif
%  }
%  __pRequest__	= NULL;
%  return (RESULTTYPE) pResult;
%} /* fnrpc_fnserverobjectpeekslots_1 */
#endif	/* RPC_SVC */
%
#if RPC_CLNT
%SHLOCK DLLEXPORT fnServerObjectPeekSlots
%	(SHORTOBJID oShortObjIdHeap ,
%	  int hPeek ,
%	  int nWords ,
%	  u_int * /* _vector_t<nWords> */  pBuffer)
%{
%  static const char	__procedure__[]	= "client:fnServerObjectPeekSlots";
%  static fnServerObjectPeekSlots_rets	ZeroResult;
%  fnServerObjectPeekSlots_rets		* pResult = NULL;
%  fnServerObjectPeekSlots_rets		Result = ZeroResult;
%  fnServerObjectPeekSlots_args	InArguments;
%
%  /* Client initialization: */
%  if ( __bClientInitialize__ ) {
%    __bClientInitialize__	= FALSE;
%    RPC_CLIENT_INITIALIZE();
%  }
%
%#if	CLIENT_CREATE_BY_USER
%  if ( __pClient__ == NULL ) {
%    __pClient__	= RPC_CLIENT_CREATE ( __szHost__, __szTransport__ );
%    if ( __pClient__ == NULL ) {
%      /* Error handling for a not connected client: */
%      char	szError [ 256 ];
%      sprintf ( szError, szFormatNoServer, __procedure__ );
%      RPC_CLIENT_ERROR ( szError );
%      return Result.ReturnValue;
%    }
%  }
%#else
%  while ( __pClient__ == NULL ) {
%    __pClient__	= RPC_CLIENT_CREATE ( __szHost__, __szTransport__ );
%    if ( __pClient__ == NULL ) {
%      /* Error handling for a not connected client: */
%      char	szError [ 256 ];
%      sprintf ( szError, szFormatNoServer, __procedure__ );
%      RPC_CLIENT_CERROR ( szContNoServer, szError );
%    }
%  }
%#endif	/* CLIENT_CREATE_BY_USER */
%
%  /* Copy in the oShortObjIdHeap argument: */
%  InArguments.oShortObjIdHeap	= oShortObjIdHeap;
%  /* Copy in the hPeek argument: */
%  InArguments.hPeek	= hPeek;
%  /* Copy in the nWords argument: */
%  InArguments.nWords	= nWords;
%  InArguments.pBufferSize	= nWords;
%
%  pResult	=
%#ifdef MULTITHREAD
%    (
%#else
%    (fnServerObjectPeekSlots_rets *)
%#endif
%    fnrpc_fnserverobjectpeekslots_1 (
%	&InArguments,
%#ifdef MULTITHREAD
%	&Result,
%#endif
%	__pClient__ )
%#ifdef MULTITHREAD
%	== RPC_SUCCESS ) ? &Result : NULL
%#endif
%	;
%
%  if ( pResult == NULL ) {
%    /* Error handling for a failed RPC call, */
%    /* i.e. the server did not respond: */
%    char	szError [ 256 ];
%    sprintf ( szError, szFormatRpcFailed, __procedure__,
%              clnt_sperror ( __pClient__, __szHost__ ) );
%    __pClient__	= RPC_CLIENT_DESTROY ( __pClient__ );
%    RPC_CLIENT_CERROR ( szContRpcFailed, szError );
%    Result	= ZeroResult;
%    return Result.ReturnValue;
%  }
%#ifndef MULTITHREAD
%  Result	= * pResult;
%#endif
%
%  /* Copy out the pBuffer argument: */
%  if ( ! ( 
%       pResult->pBuffer.u_int_vector_t_len != 0 &&
%       pBuffer == NULL ) ) {
%    memcpy ( pBuffer,
%             pResult->pBuffer.u_int_vector_t_val,
%             MIN ( pResult->pBuffer.u_int_vector_t_len,
%                   nWords ) *
%             SIZEOF ( *(pResult->pBuffer.u_int_vector_t_val) ) );
%  }
%
%  if ( pResult && pResult->nErrorLvl ) {
%    /* Server returned a user error message: */
%    char	szErrorMsg [ 1024 ];
%    strncpy ( szErrorMsg,
%              ( pResult->pszErrorMsg && pResult->pszErrorMsg [ 0 ] ) ?
%              (LPCSTR) pResult->pszErrorMsg : (LPCSTR) szEmpty,
%              sizeof ( szErrorMsg ) );
%    szErrorMsg [ sizeof ( szErrorMsg ) - 1 ]	= (char) 0;
%    xdr_free ( (xdrproc_t) xdr_fnServerObjectPeekSlots_rets, (char *) pResult );
%    RPC_CLIENT_SERROR ( pResult->nErrorLvl, __procedure__,
%                        szErrorMsg );
%  } else {
%    xdr_free ( (xdrproc_t) xdr_fnServerObjectPeekSlots_rets, (char *) pResult );
%  }
%  if ( 
%       pResult->pBuffer.u_int_vector_t_len != 0 &&
%       pBuffer == NULL ) {
%    /* Error handling for passing a NULL pointer on */
%    /* out argument: */
%    char	szError [ 256 ];
%    sprintf ( szError, szFormatNullPassed,
%              __procedure__, "pBuffer" );
%    RPC_CLIENT_CERROR ( szContNullOutPassed, szError );
%  } else if ( pResult->pBuffer.u_int_vector_t_len > nWords ) {
%      /* Error handling for an output buffer overflow, */
%      /* i.e. the buffer size passed is too small: */
%      /* For example, signal a CERROR here ... */
%      char	szError [ 256 ];
%      sprintf ( szError, szFormatBufferOverflow,
%                __procedure__, "pBuffer", 
%                nWords, 
%                pResult->pBuffer.u_int_vector_t_len );
%      RPC_CLIENT_CERROR ( szContBufferOverflow, szError );
%  }
%
%  return Result.ReturnValue;
%
%} /* fnServerObjectPeekSlots */
#endif	/* RPC_CLNT */
%
  fnServerObjectPeekValues_rets fnRpc_fnServerObjectPeekValues ( fnServerObjectPeekValues_args ) =  41 ;
%
#if RPC_SVC
%
%extern SHLOCK fnServerObjectPeekValues
%	(SHORTOBJID oShortObjIdHeap ,
%	  int hPeek ,
%	  int nObjects ,
%	  u_int * /* _vector_t<nObjects> */ pnElementTypeTagsIn ,
%	  u_int * /* _vector_t<nObjects> */ pnSizesInElementsIn ,
%	  u_int * /* _vector_t<nObjects> */  pnElementTypeTagsOut ,
%	  u_int * /* _vector_t<nObjects> */  pnSizesInElementsOut ,
%	  void * /* _vector_t<((( fnTypeTagSizeValue ( nObjects,pnElementTypeTagsIn, pnSizesInElementsIn ) )*( sizeof(int) )) )> */  pBuffer);
%
%#ifdef MULTITHREAD
%bool_t
%#else
%fnServerObjectPeekValues_rets *
%#endif
%	PASTE2(fnrpc_fnserverobjectpeekvalues_1,_SVCSUFFIX)
%		( fnServerObjectPeekValues_args * pArguments,
%#ifdef MULTITHREAD
%		  fnServerObjectPeekValues_rets * pResult,
%#endif
%		  struct svc_req * pRequest )
%{
%  static const char	__procedure__[]	= "server:fnrpc_fnserverobjectpeekvalues_1";
%#ifdef MULTITHREAD
%  typedef bool_t RESULTTYPE;
%#else
%  typedef fnServerObjectPeekValues_rets * RESULTTYPE;
%#endif
%#ifndef MULTITHREAD
%  static fnServerObjectPeekValues_rets	Result;
%  RESULTTYPE			pResult = &Result;
%#endif
%  LPCSTR	pszErrorMsg;
%
%  __pRequest__	= pRequest;
%
%  RPC_SERVER_ENTRY();
%
%#ifndef MULTITHREAD
%  if ( pResult->pszErrorMsg == szEmpty ) {
%    pResult->pszErrorMsg	= NULL;
%  }
%  xdr_free ( (xdrproc_t) xdr_fnServerObjectPeekValues_rets, (char *) pResult );
%#endif
%  pResult->nErrorLvl		= 0;
%
%  pResult->pnElementTypeTagsOut.u_int_vector_t_len	= pArguments->pnElementTypeTagsOutSize;
%  if ( pArguments->pnElementTypeTagsOutSize == 0 ) {
%    pResult->pnElementTypeTagsOut.u_int_vector_t_val	= NULL;
%  } else {
%    pResult->pnElementTypeTagsOut.u_int_vector_t_val	=
%      (u_int*) malloc ( pArguments->pnElementTypeTagsOutSize *
%               SIZEOF ( *(pResult->pnElementTypeTagsOut.u_int_vector_t_val) ) );
%    if ( pResult->pnElementTypeTagsOut.u_int_vector_t_val == NULL ) {
%      char	szError [ 256 ];
%      sprintf ( szError, szFormatMallocFailed,
%                __procedure__, pArguments->pnElementTypeTagsOutSize,
%                "pnElementTypeTagsOut" );
%      RPC_SERVER_ERROR ( szError );
%      return (RESULTTYPE) NULL;
%    }
%  }
%  pResult->pnSizesInElementsOut.u_int_vector_t_len	= pArguments->pnSizesInElementsOutSize;
%  if ( pArguments->pnSizesInElementsOutSize == 0 ) {
%    pResult->pnSizesInElementsOut.u_int_vector_t_val	= NULL;
%  } else {
%    pResult->pnSizesInElementsOut.u_int_vector_t_val	=
%      (u_int*) malloc ( pArguments->pnSizesInElementsOutSize *
%               SIZEOF ( *(pResult->pnSizesInElementsOut.u_int_vector_t_val) ) );
%    if ( pResult->pnSizesInElementsOut.u_int_vector_t_val == NULL ) {
%      char	szError [ 256 ];
%      sprintf ( szError, szFormatMallocFailed,
%                __procedure__, pArguments->pnSizesInElementsOutSize,
%                "pnSizesInElementsOut" );
%      RPC_SERVER_ERROR ( szError );
%      return (RESULTTYPE) NULL;
%    }
%  }
%  pResult->pBuffer.void_vector_t_len	= pArguments->pBufferSize;
%  if ( pArguments->pBufferSize == 0 ) {
%    pResult->pBuffer.void_vector_t_val	= NULL;
%  } else {
%    pResult->pBuffer.void_vector_t_val	=
%      (char*) malloc ( pArguments->pBufferSize *
%               SIZEOF ( *(pResult->pBuffer.void_vector_t_val) ) );
%    if ( pResult->pBuffer.void_vector_t_val == NULL ) {
%      char	szError [ 256 ];
%      sprintf ( szError, szFormatMallocFailed,
%                __procedure__, pArguments->pBufferSize,
%                "pBuffer" );
%      RPC_SERVER_ERROR ( szError );
%      return (RESULTTYPE) NULL;
%    }
%  }
%  Reply.bAnswered		= FALSE;
%  Reply.pfnCalled		= (void(*)()) fnServerObjectPeekValues;
%  Reply.pfnXdrResult		= (bool_t(*)()) xdr_fnServerObjectPeekValues_rets;
%  Reply.pnErrorLvl		= &pResult->nErrorLvl;
%  Reply.ppszErrorMsg		= (LPCSTR *) &pResult->pszErrorMsg;
%  Reply.pResult		= pResult;
%  Reply.pReturnValue		= &pResult->ReturnValue;
%  Reply.nReturnValueSize	= sizeof ( pResult->ReturnValue );
%
%  pResult->ReturnValue		=
%  fnServerObjectPeekValues (
%	pArguments->oShortObjIdHeap,
%	pArguments->hPeek,
%	pArguments->nObjects,
%	pArguments->pnElementTypeTagsIn.u_int_vector_t_val,
%	pArguments->pnSizesInElementsIn.u_int_vector_t_val,
%	pResult->pnElementTypeTagsOut.u_int_vector_t_val,
%	pResult->pnSizesInElementsOut.u_int_vector_t_val,
%	pResult->pBuffer.void_vector_t_val );
%
%  if ( Reply.bAnswered ) {
%    __pRequest__	= NULL;
%    return (RESULTTYPE) NULL;
%  }
%
%  pResult->nErrorLvl	= RPC_SERVER_ERRLVL();
%  if ( pResult->nErrorLvl > 0 ) {
%    pszErrorMsg		= RPC_SERVER_ERRMSG();
%    if ( pszErrorMsg && *pszErrorMsg ) {
%      pResult->pszErrorMsg	= strdup ( pszErrorMsg );
%    }
%  }
%  if ( pResult->pszErrorMsg == NULL ) {
%#ifdef MULTITHREAD
%    pResult->pszErrorMsg	= strdup ( szEmpty );
%#else
%    pResult->pszErrorMsg	= (LPSTR) szEmpty;
%#endif
%  }
%  __pRequest__	= NULL;
%  return (RESULTTYPE) pResult;
%} /* fnrpc_fnserverobjectpeekvalues_1 */
#endif	/* RPC_SVC */
%
#if RPC_CLNT
%SHLOCK DLLEXPORT fnServerObjectPeekValues
%	(SHORTOBJID oShortObjIdHeap ,
%	  int hPeek ,
%	  int nObjects ,
%	  u_int * /* _vector_t<nObjects> */ pnElementTypeTagsIn ,
%	  u_int * /* _vector_t<nObjects> */ pnSizesInElementsIn ,
%	  u_int * /* _vector_t<nObjects> */  pnElementTypeTagsOut ,
%	  u_int * /* _vector_t<nObjects> */  pnSizesInElementsOut ,
%	  void * /* _vector_t<((( fnTypeTagSizeValue ( nObjects,pnElementTypeTagsIn, pnSizesInElementsIn ) )*( sizeof(int) )) )> */  pBuffer)
%{
%  static const char	__procedure__[]	= "client:fnServerObjectPeekValues";
%  static fnServerObjectPeekValues_rets	ZeroResult;
%  fnServerObjectPeekValues_rets		* pResult = NULL;
%  fnServerObjectPeekValues_rets		Result = ZeroResult;
%  fnServerObjectPeekValues_args	InArguments;
%
%  /* Client initialization: */
%  if ( __bClientInitialize__ ) {
%    __bClientInitialize__	= FALSE;
%    RPC_CLIENT_INITIALIZE();
%  }
%
%#if	CLIENT_CREATE_BY_USER
%  if ( __pClient__ == NULL ) {
%    __pClient__	= RPC_CLIENT_CREATE ( __szHost__, __szTransport__ );
%    if ( __pClient__ == NULL ) {
%      /* Error handling for a not connected client: */
%      char	szError [ 256 ];
%      sprintf ( szError, szFormatNoServer, __procedure__ );
%      RPC_CLIENT_ERROR ( szError );
%      return Result.ReturnValue;
%    }
%  }
%#else
%  while ( __pClient__ == NULL ) {
%    __pClient__	= RPC_CLIENT_CREATE ( __szHost__, __szTransport__ );
%    if ( __pClient__ == NULL ) {
%      /* Error handling for a not connected client: */
%      char	szError [ 256 ];
%      sprintf ( szError, szFormatNoServer, __procedure__ );
%      RPC_CLIENT_CERROR ( szContNoServer, szError );
%    }
%  }
%#endif	/* CLIENT_CREATE_BY_USER */
%
%  /* Copy in the oShortObjIdHeap argument: */
%  InArguments.oShortObjIdHeap	= oShortObjIdHeap;
%  /* Copy in the hPeek argument: */
%  InArguments.hPeek	= hPeek;
%  /* Copy in the nObjects argument: */
%  InArguments.nObjects	= nObjects;
%  /* Copy in the pnElementTypeTagsIn argument: */
%  InArguments.pnElementTypeTagsIn.u_int_vector_t_len	= nObjects;
%  InArguments.pnElementTypeTagsIn.u_int_vector_t_val	= pnElementTypeTagsIn;
%  if ( InArguments.pnElementTypeTagsIn.u_int_vector_t_len != 0 && pnElementTypeTagsIn == NULL ) {
%    /* Error handling for passing a NULL pointer on */
%    /* VECTOR declared in argument: */
%    char	szError [ 256 ];
%    InArguments.pnElementTypeTagsIn.u_int_vector_t_len	= 0;
%    sprintf ( szError, szFormatNullPassed,
%              __procedure__, "pnElementTypeTagsIn" );
%    RPC_CLIENT_CERROR ( szContNullPassed, szError );
%  }
%  /* Copy in the pnSizesInElementsIn argument: */
%  InArguments.pnSizesInElementsIn.u_int_vector_t_len	= nObjects;
%  InArguments.pnSizesInElementsIn.u_int_vector_t_val	= pnSizesInElementsIn;
%  if ( InArguments.pnSizesInElementsIn.u_int_vector_t_len != 0 && pnSizesInElementsIn == NULL ) {
%    /* Error handling for passing a NULL pointer on */
%    /* VECTOR declared in argument: */
%    char	szError [ 256 ];
%    InArguments.pnSizesInElementsIn.u_int_vector_t_len	= 0;
%    sprintf ( szError, szFormatNullPassed,
%              __procedure__, "pnSizesInElementsIn" );
%    RPC_CLIENT_CERROR ( szContNullPassed, szError );
%  }
%  InArguments.pnElementTypeTagsOutSize	= nObjects;
%  InArguments.pnSizesInElementsOutSize	= nObjects;
%  InArguments.pBufferSize	= ((( fnTypeTagSizeValue ( nObjects,pnElementTypeTagsIn, pnSizesInElementsIn ) )*( sizeof(int) )) );
%
%  pResult	=
%#ifdef MULTITHREAD
%    (
%#else
%    (fnServerObjectPeekValues_rets *)
%#endif
%    fnrpc_fnserverobjectpeekvalues_1 (
%	&InArguments,
%#ifdef MULTITHREAD
%	&Result,
%#endif
%	__pClient__ )
%#ifdef MULTITHREAD
%	== RPC_SUCCESS ) ? &Result : NULL
%#endif
%	;
%
%  if ( pResult == NULL ) {
%    /* Error handling for a failed RPC call, */
%    /* i.e. the server did not respond: */
%    char	szError [ 256 ];
%    sprintf ( szError, szFormatRpcFailed, __procedure__,
%              clnt_sperror ( __pClient__, __szHost__ ) );
%    __pClient__	= RPC_CLIENT_DESTROY ( __pClient__ );
%    RPC_CLIENT_CERROR ( szContRpcFailed, szError );
%    Result	= ZeroResult;
%    return Result.ReturnValue;
%  }
%#ifndef MULTITHREAD
%  Result	= * pResult;
%#endif
%
%  /* Copy out the pnElementTypeTagsOut argument: */
%  if ( ! ( 
%       pResult->pnElementTypeTagsOut.u_int_vector_t_len != 0 &&
%       pnElementTypeTagsOut == NULL ) ) {
%    memcpy ( pnElementTypeTagsOut,
%             pResult->pnElementTypeTagsOut.u_int_vector_t_val,
%             MIN ( pResult->pnElementTypeTagsOut.u_int_vector_t_len,
%                   nObjects ) *
%             SIZEOF ( *(pResult->pnElementTypeTagsOut.u_int_vector_t_val) ) );
%  }
%  /* Copy out the pnSizesInElementsOut argument: */
%  if ( ! ( 
%       pResult->pnSizesInElementsOut.u_int_vector_t_len != 0 &&
%       pnSizesInElementsOut == NULL ) ) {
%    memcpy ( pnSizesInElementsOut,
%             pResult->pnSizesInElementsOut.u_int_vector_t_val,
%             MIN ( pResult->pnSizesInElementsOut.u_int_vector_t_len,
%                   nObjects ) *
%             SIZEOF ( *(pResult->pnSizesInElementsOut.u_int_vector_t_val) ) );
%  }
%  /* Copy out the pBuffer argument: */
%  if ( ! ( 
%       pResult->pBuffer.void_vector_t_len != 0 &&
%       pBuffer == NULL ) ) {
%    memcpy ( pBuffer,
%             pResult->pBuffer.void_vector_t_val,
%             MIN ( pResult->pBuffer.void_vector_t_len,
%                   ((( fnTypeTagSizeValue ( nObjects,pnElementTypeTagsIn, pnSizesInElementsIn ) )*( sizeof(int) )) ) ) *
%             SIZEOF ( *(pResult->pBuffer.void_vector_t_val) ) );
%  }
%
%  if ( pResult && pResult->nErrorLvl ) {
%    /* Server returned a user error message: */
%    char	szErrorMsg [ 1024 ];
%    strncpy ( szErrorMsg,
%              ( pResult->pszErrorMsg && pResult->pszErrorMsg [ 0 ] ) ?
%              (LPCSTR) pResult->pszErrorMsg : (LPCSTR) szEmpty,
%              sizeof ( szErrorMsg ) );
%    szErrorMsg [ sizeof ( szErrorMsg ) - 1 ]	= (char) 0;
%    xdr_free ( (xdrproc_t) xdr_fnServerObjectPeekValues_rets, (char *) pResult );
%    RPC_CLIENT_SERROR ( pResult->nErrorLvl, __procedure__,
%                        szErrorMsg );
%  } else {
%    xdr_free ( (xdrproc_t) xdr_fnServerObjectPeekValues_rets, (char *) pResult );
%  }
%  if ( 
%       pResult->pnElementTypeTagsOut.u_int_vector_t_len != 0 &&
%       pnElementTypeTagsOut == NULL ) {
%    /* Error handling for passing a NULL pointer on */
%    /* out argument: */
%    char	szError [ 256 ];
%    sprintf ( szError, szFormatNullPassed,
%              __procedure__, "pnElementTypeTagsOut" );
%    RPC_CLIENT_CERROR ( szContNullOutPassed, szError );
%  } else if ( pResult->pnElementTypeTagsOut.u_int_vector_t_len > nObjects ) {
%      /* Error handling for an output buffer overflow, */
%      /* i.e. the buffer size passed is too small: */
%      /* For example, signal a CERROR here ... */
%      char	szError [ 256 ];
%      sprintf ( szError, szFormatBufferOverflow,
%                __procedure__, "pnElementTypeTagsOut", 
%                nObjects, 
%                pResult->pnElementTypeTagsOut.u_int_vector_t_len );
%      RPC_CLIENT_CERROR ( szContBufferOverflow, szError );
%  }
%  if ( 
%       pResult->pnSizesInElementsOut.u_int_vector_t_len != 0 &&
%       pnSizesInElementsOut == NULL ) {
%    /* Error handling for passing a NULL pointer on */
%    /* out argument: */
%    char	szError [ 256 ];
%    sprintf ( szError, szFormatNullPassed,
%              __procedure__, "pnSizesInElementsOut" );
%    RPC_CLIENT_CERROR ( szContNullOutPassed, szError );
%  } else if ( pResult->pnSizesInElementsOut.u_int_vector_t_len > nObjects ) {
%      /* Error handling for an output buffer overflow, */
%      /* i.e. the buffer size passed is too small: */
%      /* For example, signal a CERROR here ... */
%      char	szError [ 256 ];
%      sprintf ( szError, szFormatBufferOverflow,
%                __procedure__, "pnSizesInElementsOut", 
%                nObjects, 
%                pResult->pnSizesInElementsOut.u_int_vector_t_len );
%      RPC_CLIENT_CERROR ( szContBufferOverflow, szError );
%  }
%  if ( 
%       pResult->pBuffer.void_vector_t_len != 0 &&
%       pBuffer == NULL ) {
%    /* Error handling for passing a NULL pointer on */
%    /* out argument: */
%    char	szError [ 256 ];
%    sprintf ( szError, szFormatNullPassed,
%              __procedure__, "pBuffer" );
%    RPC_CLIENT_CERROR ( szContNullOutPassed, szError );
%  } else if ( pResult->pBuffer.void_vector_t_len > ((( fnTypeTagSizeValue ( nObjects,pnElementTypeTagsIn, pnSizesInElementsIn ) )*( sizeof(int) )) ) ) {
%      /* Error handling for an output buffer overflow, */
%      /* i.e. the buffer size passed is too small: */
%      /* For example, signal a CERROR here ... */
%      char	szError [ 256 ];
%      sprintf ( szError, szFormatBufferOverflow,
%                __procedure__, "pBuffer", 
%                ((( fnTypeTagSizeValue ( nObjects,pnElementTypeTagsIn, pnSizesInElementsIn ) )*( sizeof(int) )) ), 
%                pResult->pBuffer.void_vector_t_len );
%      RPC_CLIENT_CERROR ( szContBufferOverflow, szError );
%  }
%
%  return Result.ReturnValue;
%
%} /* fnServerObjectPeekValues */
#endif	/* RPC_CLNT */
%
  void fnRpc_fnServerObjectPoke_batch ( fnServerObjectPoke_args ) =  42 ;
%
#if RPC_SVC
%
%extern void fnServerObjectPoke
%	(SHORTOBJID oShortObjIdHeap ,
%	  SHORTOBJID oShortObjId ,
%	  int nSlots ,
%	  u_int * /* _vector_t<nSlots> */ pSlots ,
%	  SHTYPETAG nElementTypeTag ,
%	  int nSizeInElements ,
%	  void * /* _vector_t<((( fnTypeTagSizeValue(1,&nElementTypeTag, &nSizeInElements ) )*( sizeof(int) )) )> */ pValues);
%
%#ifdef MULTITHREAD
%bool_t
%#else
%void *
%#endif
%	PASTE2(fnrpc_fnserverobjectpoke_batch_1,_SVCSUFFIX)
%		( fnServerObjectPoke_args * pArguments,
%#ifdef MULTITHREAD
%		  void * pResult,
%#endif
%		  struct svc_req * pRequest )
%{
%  static const char	__procedure__[]	= "server:fnrpc_fnserverobjectpoke_batch_1";
%#ifdef MULTITHREAD
%  typedef bool_t RESULTTYPE;
%#else
%  typedef void * RESULTTYPE;
%#endif
%
%  __pRequest__	= pRequest;
%
%  RPC_SERVER_ENTRY();
%
%  Reply.bAnswered		= TRUE;
%  Reply.pfnCalled		= (void(*)()) fnServerObjectPoke;
%  Reply.pfnXdrResult		= (bool_t(*)()) xdr_void;
%  Reply.pnErrorLvl		= NULL;
%  Reply.ppszErrorMsg		= NULL;
%  Reply.pResult			= NULL;
%  Reply.pReturnValue		= NULL;
%  Reply.nReturnValueSize	= 0;
%  fnServerObjectPoke (
%	pArguments->oShortObjIdHeap,
%	pArguments->oShortObjId,
%	pArguments->nSlots,
%	pArguments->pSlots.u_int_vector_t_val,
%	pArguments->nElementTypeTag,
%	pArguments->nSizeInElements,
%	pArguments->pValues.void_vector_t_val );
%  __pRequest__	= NULL;
%  return (RESULTTYPE) NULL;
%} /* fnrpc_fnserverobjectpoke_batch_1 */
#endif	/* RPC_SVC */
%
#if RPC_CLNT
%void DLLEXPORT fnServerObjectPoke
%	(SHORTOBJID oShortObjIdHeap ,
%	  SHORTOBJID oShortObjId ,
%	  int nSlots ,
%	  u_int * /* _vector_t<nSlots> */ pSlots ,
%	  SHTYPETAG nElementTypeTag ,
%	  int nSizeInElements ,
%	  void * /* _vector_t<((( fnTypeTagSizeValue(1,&nElementTypeTag, &nSizeInElements ) )*( sizeof(int) )) )> */ pValues)
%{
%  static const char	__procedure__[]	= "client:fnServerObjectPoke";
%  static char	ZeroResult;
%  void		* pResult = NULL;
%#ifdef MULTITHREAD
%  char		Result = ZeroResult;
%#endif
%  fnServerObjectPoke_args	InArguments;
%
%  /* Client initialization: */
%  if ( __bClientInitialize__ ) {
%    __bClientInitialize__	= FALSE;
%    RPC_CLIENT_INITIALIZE();
%  }
%
%#if	CLIENT_CREATE_BY_USER
%  if ( __pClient__ == NULL ) {
%    __pClient__	= RPC_CLIENT_CREATE ( __szHost__, __szTransport__ );
%    if ( __pClient__ == NULL ) {
%      /* Error handling for a not connected client: */
%      char	szError [ 256 ];
%      sprintf ( szError, szFormatNoServer, __procedure__ );
%      RPC_CLIENT_ERROR ( szError );
%      return;
%    }
%  }
%#else
%  while ( __pClient__ == NULL ) {
%    __pClient__	= RPC_CLIENT_CREATE ( __szHost__, __szTransport__ );
%    if ( __pClient__ == NULL ) {
%      /* Error handling for a not connected client: */
%      char	szError [ 256 ];
%      sprintf ( szError, szFormatNoServer, __procedure__ );
%      RPC_CLIENT_CERROR ( szContNoServer, szError );
%    }
%  }
%#endif	/* CLIENT_CREATE_BY_USER */
%
%  /* Copy in the oShortObjIdHeap argument: */
%  InArguments.oShortObjIdHeap	= oShortObjIdHeap;
%  /* Copy in the oShortObjId argument: */
%  InArguments.oShortObjId	= oShortObjId;
%  /* Copy in the nSlots argument: */
%  InArguments.nSlots	= nSlots;
%  /* Copy in the pSlots argument: */
%  InArguments.pSlots.u_int_vector_t_len	= nSlots;
%  InArguments.pSlots.u_int_vector_t_val	= pSlots;
%  if ( InArguments.pSlots.u_int_vector_t_len != 0 && pSlots == NULL ) {
%    /* Error handling for passing a NULL pointer on */
%    /* VECTOR declared in argument: */
%    char	szError [ 256 ];
%    InArguments.pSlots.u_int_vector_t_len	= 0;
%    sprintf ( szError, szFormatNullPassed,
%              __procedure__, "pSlots" );
%    RPC_CLIENT_CERROR ( szContNullPassed, szError );
%  }
%  /* Copy in the nElementTypeTag argument: */
%  InArguments.nElementTypeTag	= nElementTypeTag;
%  /* Copy in the nSizeInElements argument: */
%  InArguments.nSizeInElements	= nSizeInElements;
%  /* Copy in the pValues argument: */
%  InArguments.pValues.void_vector_t_len	= ((( fnTypeTagSizeValue(1,&nElementTypeTag, &nSizeInElements ) )*( sizeof(int) )) );
%  InArguments.pValues.void_vector_t_val	= pValues;
%  if ( InArguments.pValues.void_vector_t_len != 0 && pValues == NULL ) {
%    /* Error handling for passing a NULL pointer on */
%    /* VECTOR declared in argument: */
%    char	szError [ 256 ];
%    InArguments.pValues.void_vector_t_len	= 0;
%    sprintf ( szError, szFormatNullPassed,
%              __procedure__, "pValues" );
%    RPC_CLIENT_CERROR ( szContNullPassed, szError );
%  }
%
%  pResult	=
%#ifdef MULTITHREAD
%    (
%#else
%    (void *)
%#endif
%    fnrpc_fnserverobjectpoke_batch_1 (
%	&InArguments,
%#ifdef MULTITHREAD
%	&Result,
%#endif
%	__pClient__ )
%#ifdef MULTITHREAD
%	== RPC_SUCCESS ) ? &Result : NULL
%#endif
%	;
%
%  if ( pResult == NULL ) {
%    /* Error handling for a failed RPC call, */
%    /* i.e. the server did not respond: */
%    char	szError [ 256 ];
%    sprintf ( szError, szFormatRpcFailed, __procedure__,
%              clnt_sperror ( __pClient__, __szHost__ ) );
%    __pClient__	= RPC_CLIENT_DESTROY ( __pClient__ );
%    RPC_CLIENT_CERROR ( szContRpcFailed, szError );
%    return;
%  }
%} /* fnServerObjectPoke */
%
%#ifdef MULTITHREAD
%enum clnt_stat
%#else
%void *
%#endif
%fnrpc_fnserverobjectpoke_batch_1
%	( fnServerObjectPoke_args * pArguments,
%#ifdef MULTITHREAD
%	  void * clnt_res,
%#endif
%	  PCLIENT pClient )
%{
%#ifdef MULTITHREAD
%  return clnt_call ( pClient, fnRpc_fnServerObjectPoke_batch,
%                     (xdrproc_t) xdr_fnServerObjectPoke_args,
%                     (caddr_t) pArguments,
%                     (xdrproc_t) NULL, (caddr_t) NULL,
%                     NullTimeout );
%#else
%  if ( clnt_call ( pClient, fnRpc_fnServerObjectPoke_batch,
%                   (xdrproc_t) xdr_fnServerObjectPoke_args,
%                   (caddr_t) pArguments,
%                   (xdrproc_t) NULL, (caddr_t) NULL,
%                   NullTimeout ) != RPC_SUCCESS ) {
%    return NULL;
%  }
%  return (void *) TRUE;
%#endif
%} /* fnrpc_fnserverobjectpoke_batch_1 */
%#define	fnrpc_fnserverobjectpoke_batch_1	fnrpc_fnserverobjectpoke_1
#endif	/* RPC_CLNT */
%
  fnFlushMode_rets fnRpc_fnFlushMode ( fnFlushMode_args ) =  43 ;
%
#if RPC_SVC
%
%extern FLUSHMODE fnFlushMode
%	(SHORTOBJID oShortObjIdHeap ,
%	  FLUSHMODE nMode);
%
%#ifdef MULTITHREAD
%bool_t
%#else
%fnFlushMode_rets *
%#endif
%	PASTE2(fnrpc_fnflushmode_1,_SVCSUFFIX)
%		( fnFlushMode_args * pArguments,
%#ifdef MULTITHREAD
%		  fnFlushMode_rets * pResult,
%#endif
%		  struct svc_req * pRequest )
%{
%  static const char	__procedure__[]	= "server:fnrpc_fnflushmode_1";
%#ifdef MULTITHREAD
%  typedef bool_t RESULTTYPE;
%#else
%  typedef fnFlushMode_rets * RESULTTYPE;
%#endif
%#ifndef MULTITHREAD
%  static fnFlushMode_rets	Result;
%  RESULTTYPE			pResult = &Result;
%#endif
%  LPCSTR	pszErrorMsg;
%
%  __pRequest__	= pRequest;
%
%  RPC_SERVER_ENTRY();
%
%#ifndef MULTITHREAD
%  if ( pResult->pszErrorMsg == szEmpty ) {
%    pResult->pszErrorMsg	= NULL;
%  }
%  xdr_free ( (xdrproc_t) xdr_fnFlushMode_rets, (char *) pResult );
%#endif
%  pResult->nErrorLvl		= 0;
%
%  Reply.bAnswered		= FALSE;
%  Reply.pfnCalled		= (void(*)()) fnFlushMode;
%  Reply.pfnXdrResult		= (bool_t(*)()) xdr_fnFlushMode_rets;
%  Reply.pnErrorLvl		= &pResult->nErrorLvl;
%  Reply.ppszErrorMsg		= (LPCSTR *) &pResult->pszErrorMsg;
%  Reply.pResult		= pResult;
%  Reply.pReturnValue		= &pResult->ReturnValue;
%  Reply.nReturnValueSize	= sizeof ( pResult->ReturnValue );
%
%  pResult->ReturnValue		=
%  fnFlushMode (
%	pArguments->oShortObjIdHeap,
%	pArguments->nMode );
%
%  if ( Reply.bAnswered ) {
%    __pRequest__	= NULL;
%    return (RESULTTYPE) NULL;
%  }
%
%  pResult->nErrorLvl	= RPC_SERVER_ERRLVL();
%  if ( pResult->nErrorLvl > 0 ) {
%    pszErrorMsg		= RPC_SERVER_ERRMSG();
%    if ( pszErrorMsg && *pszErrorMsg ) {
%      pResult->pszErrorMsg	= strdup ( pszErrorMsg );
%    }
%  }
%  if ( pResult->pszErrorMsg == NULL ) {
%#ifdef MULTITHREAD
%    pResult->pszErrorMsg	= strdup ( szEmpty );
%#else
%    pResult->pszErrorMsg	= (LPSTR) szEmpty;
%#endif
%  }
%  __pRequest__	= NULL;
%  return (RESULTTYPE) pResult;
%} /* fnrpc_fnflushmode_1 */
#endif	/* RPC_SVC */
%
#if RPC_CLNT
%FLUSHMODE DLLEXPORT fnFlushMode
%	(SHORTOBJID oShortObjIdHeap ,
%	  FLUSHMODE nMode)
%{
%  static const char	__procedure__[]	= "client:fnFlushMode";
%  static fnFlushMode_rets	ZeroResult;
%  fnFlushMode_rets		* pResult = NULL;
%  fnFlushMode_rets		Result = ZeroResult;
%  fnFlushMode_args	InArguments;
%
%  /* Client initialization: */
%  if ( __bClientInitialize__ ) {
%    __bClientInitialize__	= FALSE;
%    RPC_CLIENT_INITIALIZE();
%  }
%
%#if	CLIENT_CREATE_BY_USER
%  if ( __pClient__ == NULL ) {
%    __pClient__	= RPC_CLIENT_CREATE ( __szHost__, __szTransport__ );
%    if ( __pClient__ == NULL ) {
%      /* Error handling for a not connected client: */
%      char	szError [ 256 ];
%      sprintf ( szError, szFormatNoServer, __procedure__ );
%      RPC_CLIENT_ERROR ( szError );
%      return Result.ReturnValue;
%    }
%  }
%#else
%  while ( __pClient__ == NULL ) {
%    __pClient__	= RPC_CLIENT_CREATE ( __szHost__, __szTransport__ );
%    if ( __pClient__ == NULL ) {
%      /* Error handling for a not connected client: */
%      char	szError [ 256 ];
%      sprintf ( szError, szFormatNoServer, __procedure__ );
%      RPC_CLIENT_CERROR ( szContNoServer, szError );
%    }
%  }
%#endif	/* CLIENT_CREATE_BY_USER */
%
%  /* Copy in the oShortObjIdHeap argument: */
%  InArguments.oShortObjIdHeap	= oShortObjIdHeap;
%  /* Copy in the nMode argument: */
%  InArguments.nMode	= nMode;
%
%  pResult	=
%#ifdef MULTITHREAD
%    (
%#else
%    (fnFlushMode_rets *)
%#endif
%    fnrpc_fnflushmode_1 (
%	&InArguments,
%#ifdef MULTITHREAD
%	&Result,
%#endif
%	__pClient__ )
%#ifdef MULTITHREAD
%	== RPC_SUCCESS ) ? &Result : NULL
%#endif
%	;
%
%  if ( pResult == NULL ) {
%    /* Error handling for a failed RPC call, */
%    /* i.e. the server did not respond: */
%    char	szError [ 256 ];
%    sprintf ( szError, szFormatRpcFailed, __procedure__,
%              clnt_sperror ( __pClient__, __szHost__ ) );
%    __pClient__	= RPC_CLIENT_DESTROY ( __pClient__ );
%    RPC_CLIENT_CERROR ( szContRpcFailed, szError );
%    Result	= ZeroResult;
%    return Result.ReturnValue;
%  }
%#ifndef MULTITHREAD
%  Result	= * pResult;
%#endif
%
%
%  if ( pResult && pResult->nErrorLvl ) {
%    /* Server returned a user error message: */
%    char	szErrorMsg [ 1024 ];
%    strncpy ( szErrorMsg,
%              ( pResult->pszErrorMsg && pResult->pszErrorMsg [ 0 ] ) ?
%              (LPCSTR) pResult->pszErrorMsg : (LPCSTR) szEmpty,
%              sizeof ( szErrorMsg ) );
%    szErrorMsg [ sizeof ( szErrorMsg ) - 1 ]	= (char) 0;
%    xdr_free ( (xdrproc_t) xdr_fnFlushMode_rets, (char *) pResult );
%    RPC_CLIENT_SERROR ( pResult->nErrorLvl, __procedure__,
%                        szErrorMsg );
%  } else {
%    xdr_free ( (xdrproc_t) xdr_fnFlushMode_rets, (char *) pResult );
%  }
%
%  return Result.ReturnValue;
%
%} /* fnFlushMode */
#endif	/* RPC_CLNT */
%
  fnFlagWord_rets fnRpc_fnFlagWord ( fnFlagWord_args ) =  44 ;
%
#if RPC_SVC
%
%extern int fnFlagWord
%	(FLAGMODE nGetOrSet ,
%	  int nFlagWord);
%
%#ifdef MULTITHREAD
%bool_t
%#else
%fnFlagWord_rets *
%#endif
%	PASTE2(fnrpc_fnflagword_1,_SVCSUFFIX)
%		( fnFlagWord_args * pArguments,
%#ifdef MULTITHREAD
%		  fnFlagWord_rets * pResult,
%#endif
%		  struct svc_req * pRequest )
%{
%  static const char	__procedure__[]	= "server:fnrpc_fnflagword_1";
%#ifdef MULTITHREAD
%  typedef bool_t RESULTTYPE;
%#else
%  typedef fnFlagWord_rets * RESULTTYPE;
%#endif
%#ifndef MULTITHREAD
%  static fnFlagWord_rets	Result;
%  RESULTTYPE			pResult = &Result;
%#endif
%  LPCSTR	pszErrorMsg;
%
%  __pRequest__	= pRequest;
%
%  RPC_SERVER_ENTRY();
%
%#ifndef MULTITHREAD
%  if ( pResult->pszErrorMsg == szEmpty ) {
%    pResult->pszErrorMsg	= NULL;
%  }
%  xdr_free ( (xdrproc_t) xdr_fnFlagWord_rets, (char *) pResult );
%#endif
%  pResult->nErrorLvl		= 0;
%
%  Reply.bAnswered		= FALSE;
%  Reply.pfnCalled		= (void(*)()) fnFlagWord;
%  Reply.pfnXdrResult		= (bool_t(*)()) xdr_fnFlagWord_rets;
%  Reply.pnErrorLvl		= &pResult->nErrorLvl;
%  Reply.ppszErrorMsg		= (LPCSTR *) &pResult->pszErrorMsg;
%  Reply.pResult		= pResult;
%  Reply.pReturnValue		= &pResult->ReturnValue;
%  Reply.nReturnValueSize	= sizeof ( pResult->ReturnValue );
%
%  pResult->ReturnValue		=
%  fnFlagWord (
%	pArguments->nGetOrSet,
%	pArguments->nFlagWord );
%
%  if ( Reply.bAnswered ) {
%    __pRequest__	= NULL;
%    return (RESULTTYPE) NULL;
%  }
%
%  pResult->nErrorLvl	= RPC_SERVER_ERRLVL();
%  if ( pResult->nErrorLvl > 0 ) {
%    pszErrorMsg		= RPC_SERVER_ERRMSG();
%    if ( pszErrorMsg && *pszErrorMsg ) {
%      pResult->pszErrorMsg	= strdup ( pszErrorMsg );
%    }
%  }
%  if ( pResult->pszErrorMsg == NULL ) {
%#ifdef MULTITHREAD
%    pResult->pszErrorMsg	= strdup ( szEmpty );
%#else
%    pResult->pszErrorMsg	= (LPSTR) szEmpty;
%#endif
%  }
%  __pRequest__	= NULL;
%  return (RESULTTYPE) pResult;
%} /* fnrpc_fnflagword_1 */
#endif	/* RPC_SVC */
%
#if RPC_CLNT
%int DLLEXPORT fnFlagWord
%	(FLAGMODE nGetOrSet ,
%	  int nFlagWord)
%{
%  static const char	__procedure__[]	= "client:fnFlagWord";
%  static fnFlagWord_rets	ZeroResult;
%  fnFlagWord_rets		* pResult = NULL;
%  fnFlagWord_rets		Result = ZeroResult;
%  fnFlagWord_args	InArguments;
%
%  /* Client initialization: */
%  if ( __bClientInitialize__ ) {
%    __bClientInitialize__	= FALSE;
%    RPC_CLIENT_INITIALIZE();
%  }
%
%#if	CLIENT_CREATE_BY_USER
%  if ( __pClient__ == NULL ) {
%    __pClient__	= RPC_CLIENT_CREATE ( __szHost__, __szTransport__ );
%    if ( __pClient__ == NULL ) {
%      /* Error handling for a not connected client: */
%      char	szError [ 256 ];
%      sprintf ( szError, szFormatNoServer, __procedure__ );
%      RPC_CLIENT_ERROR ( szError );
%      return Result.ReturnValue;
%    }
%  }
%#else
%  while ( __pClient__ == NULL ) {
%    __pClient__	= RPC_CLIENT_CREATE ( __szHost__, __szTransport__ );
%    if ( __pClient__ == NULL ) {
%      /* Error handling for a not connected client: */
%      char	szError [ 256 ];
%      sprintf ( szError, szFormatNoServer, __procedure__ );
%      RPC_CLIENT_CERROR ( szContNoServer, szError );
%    }
%  }
%#endif	/* CLIENT_CREATE_BY_USER */
%
%  /* Copy in the nGetOrSet argument: */
%  InArguments.nGetOrSet	= nGetOrSet;
%  /* Copy in the nFlagWord argument: */
%  InArguments.nFlagWord	= nFlagWord;
%
%  pResult	=
%#ifdef MULTITHREAD
%    (
%#else
%    (fnFlagWord_rets *)
%#endif
%    fnrpc_fnflagword_1 (
%	&InArguments,
%#ifdef MULTITHREAD
%	&Result,
%#endif
%	__pClient__ )
%#ifdef MULTITHREAD
%	== RPC_SUCCESS ) ? &Result : NULL
%#endif
%	;
%
%  if ( pResult == NULL ) {
%    /* Error handling for a failed RPC call, */
%    /* i.e. the server did not respond: */
%    char	szError [ 256 ];
%    sprintf ( szError, szFormatRpcFailed, __procedure__,
%              clnt_sperror ( __pClient__, __szHost__ ) );
%    __pClient__	= RPC_CLIENT_DESTROY ( __pClient__ );
%    RPC_CLIENT_CERROR ( szContRpcFailed, szError );
%    Result	= ZeroResult;
%    return Result.ReturnValue;
%  }
%#ifndef MULTITHREAD
%  Result	= * pResult;
%#endif
%
%
%  if ( pResult && pResult->nErrorLvl ) {
%    /* Server returned a user error message: */
%    char	szErrorMsg [ 1024 ];
%    strncpy ( szErrorMsg,
%              ( pResult->pszErrorMsg && pResult->pszErrorMsg [ 0 ] ) ?
%              (LPCSTR) pResult->pszErrorMsg : (LPCSTR) szEmpty,
%              sizeof ( szErrorMsg ) );
%    szErrorMsg [ sizeof ( szErrorMsg ) - 1 ]	= (char) 0;
%    xdr_free ( (xdrproc_t) xdr_fnFlagWord_rets, (char *) pResult );
%    RPC_CLIENT_SERROR ( pResult->nErrorLvl, __procedure__,
%                        szErrorMsg );
%  } else {
%    xdr_free ( (xdrproc_t) xdr_fnFlagWord_rets, (char *) pResult );
%  }
%
%  return Result.ReturnValue;
%
%} /* fnFlagWord */
#endif	/* RPC_CLNT */
%
  fnShortMakeIVector_rets fnRpc_fnShortMakeIVector ( fnShortMakeIVector_args ) =  45 ;
%
#if RPC_SVC
%
%extern SHORTOBJID fnShortMakeIVector
%	(SHORTOBJID oShortObjIdHeap ,
%	  SHTYPETAG nTypeTag ,
%	  int nElements);
%
%#ifdef MULTITHREAD
%bool_t
%#else
%fnShortMakeIVector_rets *
%#endif
%	PASTE2(fnrpc_fnshortmakeivector_1,_SVCSUFFIX)
%		( fnShortMakeIVector_args * pArguments,
%#ifdef MULTITHREAD
%		  fnShortMakeIVector_rets * pResult,
%#endif
%		  struct svc_req * pRequest )
%{
%  static const char	__procedure__[]	= "server:fnrpc_fnshortmakeivector_1";
%#ifdef MULTITHREAD
%  typedef bool_t RESULTTYPE;
%#else
%  typedef fnShortMakeIVector_rets * RESULTTYPE;
%#endif
%#ifndef MULTITHREAD
%  static fnShortMakeIVector_rets	Result;
%  RESULTTYPE			pResult = &Result;
%#endif
%  LPCSTR	pszErrorMsg;
%
%  __pRequest__	= pRequest;
%
%  RPC_SERVER_ENTRY();
%
%#ifndef MULTITHREAD
%  if ( pResult->pszErrorMsg == szEmpty ) {
%    pResult->pszErrorMsg	= NULL;
%  }
%  xdr_free ( (xdrproc_t) xdr_fnShortMakeIVector_rets, (char *) pResult );
%#endif
%  pResult->nErrorLvl		= 0;
%
%  Reply.bAnswered		= FALSE;
%  Reply.pfnCalled		= (void(*)()) fnShortMakeIVector;
%  Reply.pfnXdrResult		= (bool_t(*)()) xdr_fnShortMakeIVector_rets;
%  Reply.pnErrorLvl		= &pResult->nErrorLvl;
%  Reply.ppszErrorMsg		= (LPCSTR *) &pResult->pszErrorMsg;
%  Reply.pResult		= pResult;
%  Reply.pReturnValue		= &pResult->ReturnValue;
%  Reply.nReturnValueSize	= sizeof ( pResult->ReturnValue );
%
%  pResult->ReturnValue		=
%  fnShortMakeIVector (
%	pArguments->oShortObjIdHeap,
%	pArguments->nTypeTag,
%	pArguments->nElements );
%
%  if ( Reply.bAnswered ) {
%    __pRequest__	= NULL;
%    return (RESULTTYPE) NULL;
%  }
%
%  pResult->nErrorLvl	= RPC_SERVER_ERRLVL();
%  if ( pResult->nErrorLvl > 0 ) {
%    pszErrorMsg		= RPC_SERVER_ERRMSG();
%    if ( pszErrorMsg && *pszErrorMsg ) {
%      pResult->pszErrorMsg	= strdup ( pszErrorMsg );
%    }
%  }
%  if ( pResult->pszErrorMsg == NULL ) {
%#ifdef MULTITHREAD
%    pResult->pszErrorMsg	= strdup ( szEmpty );
%#else
%    pResult->pszErrorMsg	= (LPSTR) szEmpty;
%#endif
%  }
%  __pRequest__	= NULL;
%  return (RESULTTYPE) pResult;
%} /* fnrpc_fnshortmakeivector_1 */
#endif	/* RPC_SVC */
%
#if RPC_CLNT
%SHORTOBJID DLLEXPORT fnShortMakeIVector
%	(SHORTOBJID oShortObjIdHeap ,
%	  SHTYPETAG nTypeTag ,
%	  int nElements)
%{
%  static const char	__procedure__[]	= "client:fnShortMakeIVector";
%  static fnShortMakeIVector_rets	ZeroResult;
%  fnShortMakeIVector_rets		* pResult = NULL;
%  fnShortMakeIVector_rets		Result = ZeroResult;
%  fnShortMakeIVector_args	InArguments;
%
%  /* Client initialization: */
%  if ( __bClientInitialize__ ) {
%    __bClientInitialize__	= FALSE;
%    RPC_CLIENT_INITIALIZE();
%  }
%
%#if	CLIENT_CREATE_BY_USER
%  if ( __pClient__ == NULL ) {
%    __pClient__	= RPC_CLIENT_CREATE ( __szHost__, __szTransport__ );
%    if ( __pClient__ == NULL ) {
%      /* Error handling for a not connected client: */
%      char	szError [ 256 ];
%      sprintf ( szError, szFormatNoServer, __procedure__ );
%      RPC_CLIENT_ERROR ( szError );
%      return Result.ReturnValue;
%    }
%  }
%#else
%  while ( __pClient__ == NULL ) {
%    __pClient__	= RPC_CLIENT_CREATE ( __szHost__, __szTransport__ );
%    if ( __pClient__ == NULL ) {
%      /* Error handling for a not connected client: */
%      char	szError [ 256 ];
%      sprintf ( szError, szFormatNoServer, __procedure__ );
%      RPC_CLIENT_CERROR ( szContNoServer, szError );
%    }
%  }
%#endif	/* CLIENT_CREATE_BY_USER */
%
%  /* Copy in the oShortObjIdHeap argument: */
%  InArguments.oShortObjIdHeap	= oShortObjIdHeap;
%  /* Copy in the nTypeTag argument: */
%  InArguments.nTypeTag	= nTypeTag;
%  /* Copy in the nElements argument: */
%  InArguments.nElements	= nElements;
%
%  pResult	=
%#ifdef MULTITHREAD
%    (
%#else
%    (fnShortMakeIVector_rets *)
%#endif
%    fnrpc_fnshortmakeivector_1 (
%	&InArguments,
%#ifdef MULTITHREAD
%	&Result,
%#endif
%	__pClient__ )
%#ifdef MULTITHREAD
%	== RPC_SUCCESS ) ? &Result : NULL
%#endif
%	;
%
%  if ( pResult == NULL ) {
%    /* Error handling for a failed RPC call, */
%    /* i.e. the server did not respond: */
%    char	szError [ 256 ];
%    sprintf ( szError, szFormatRpcFailed, __procedure__,
%              clnt_sperror ( __pClient__, __szHost__ ) );
%    __pClient__	= RPC_CLIENT_DESTROY ( __pClient__ );
%    RPC_CLIENT_CERROR ( szContRpcFailed, szError );
%    Result	= ZeroResult;
%    return Result.ReturnValue;
%  }
%#ifndef MULTITHREAD
%  Result	= * pResult;
%#endif
%
%
%  if ( pResult && pResult->nErrorLvl ) {
%    /* Server returned a user error message: */
%    char	szErrorMsg [ 1024 ];
%    strncpy ( szErrorMsg,
%              ( pResult->pszErrorMsg && pResult->pszErrorMsg [ 0 ] ) ?
%              (LPCSTR) pResult->pszErrorMsg : (LPCSTR) szEmpty,
%              sizeof ( szErrorMsg ) );
%    szErrorMsg [ sizeof ( szErrorMsg ) - 1 ]	= (char) 0;
%    xdr_free ( (xdrproc_t) xdr_fnShortMakeIVector_rets, (char *) pResult );
%    RPC_CLIENT_SERROR ( pResult->nErrorLvl, __procedure__,
%                        szErrorMsg );
%  } else {
%    xdr_free ( (xdrproc_t) xdr_fnShortMakeIVector_rets, (char *) pResult );
%  }
%
%  return Result.ReturnValue;
%
%} /* fnShortMakeIVector */
#endif	/* RPC_CLNT */
%
  fnShortMakeString_rets fnRpc_fnShortMakeString ( fnShortMakeString_args ) =  46 ;
%
#if RPC_SVC
%
%extern SHORTOBJID fnShortMakeString
%	(SHORTOBJID oShortObjIdHeap ,
%	  string_t /* string_t<@conststring@> */ lpszFrom);
%
%#ifdef MULTITHREAD
%bool_t
%#else
%fnShortMakeString_rets *
%#endif
%	PASTE2(fnrpc_fnshortmakestring_1,_SVCSUFFIX)
%		( fnShortMakeString_args * pArguments,
%#ifdef MULTITHREAD
%		  fnShortMakeString_rets * pResult,
%#endif
%		  struct svc_req * pRequest )
%{
%  static const char	__procedure__[]	= "server:fnrpc_fnshortmakestring_1";
%#ifdef MULTITHREAD
%  typedef bool_t RESULTTYPE;
%#else
%  typedef fnShortMakeString_rets * RESULTTYPE;
%#endif
%#ifndef MULTITHREAD
%  static fnShortMakeString_rets	Result;
%  RESULTTYPE			pResult = &Result;
%#endif
%  LPCSTR	pszErrorMsg;
%
%  __pRequest__	= pRequest;
%
%  RPC_SERVER_ENTRY();
%
%#ifndef MULTITHREAD
%  if ( pResult->pszErrorMsg == szEmpty ) {
%    pResult->pszErrorMsg	= NULL;
%  }
%  xdr_free ( (xdrproc_t) xdr_fnShortMakeString_rets, (char *) pResult );
%#endif
%  pResult->nErrorLvl		= 0;
%
%  Reply.bAnswered		= FALSE;
%  Reply.pfnCalled		= (void(*)()) fnShortMakeString;
%  Reply.pfnXdrResult		= (bool_t(*)()) xdr_fnShortMakeString_rets;
%  Reply.pnErrorLvl		= &pResult->nErrorLvl;
%  Reply.ppszErrorMsg		= (LPCSTR *) &pResult->pszErrorMsg;
%  Reply.pResult		= pResult;
%  Reply.pReturnValue		= &pResult->ReturnValue;
%  Reply.nReturnValueSize	= sizeof ( pResult->ReturnValue );
%
%  pResult->ReturnValue		=
%  fnShortMakeString (
%	pArguments->oShortObjIdHeap,
%	pArguments->lpszFrom );
%
%  if ( Reply.bAnswered ) {
%    __pRequest__	= NULL;
%    return (RESULTTYPE) NULL;
%  }
%
%  pResult->nErrorLvl	= RPC_SERVER_ERRLVL();
%  if ( pResult->nErrorLvl > 0 ) {
%    pszErrorMsg		= RPC_SERVER_ERRMSG();
%    if ( pszErrorMsg && *pszErrorMsg ) {
%      pResult->pszErrorMsg	= strdup ( pszErrorMsg );
%    }
%  }
%  if ( pResult->pszErrorMsg == NULL ) {
%#ifdef MULTITHREAD
%    pResult->pszErrorMsg	= strdup ( szEmpty );
%#else
%    pResult->pszErrorMsg	= (LPSTR) szEmpty;
%#endif
%  }
%  __pRequest__	= NULL;
%  return (RESULTTYPE) pResult;
%} /* fnrpc_fnshortmakestring_1 */
#endif	/* RPC_SVC */
%
#if RPC_CLNT
%SHORTOBJID DLLEXPORT fnShortMakeString
%	(SHORTOBJID oShortObjIdHeap ,
%	  string_t /* string_t<@conststring@> */ lpszFrom)
%{
%  static const char	__procedure__[]	= "client:fnShortMakeString";
%  static fnShortMakeString_rets	ZeroResult;
%  fnShortMakeString_rets		* pResult = NULL;
%  fnShortMakeString_rets		Result = ZeroResult;
%  fnShortMakeString_args	InArguments;
%
%  /* Client initialization: */
%  if ( __bClientInitialize__ ) {
%    __bClientInitialize__	= FALSE;
%    RPC_CLIENT_INITIALIZE();
%  }
%
%#if	CLIENT_CREATE_BY_USER
%  if ( __pClient__ == NULL ) {
%    __pClient__	= RPC_CLIENT_CREATE ( __szHost__, __szTransport__ );
%    if ( __pClient__ == NULL ) {
%      /* Error handling for a not connected client: */
%      char	szError [ 256 ];
%      sprintf ( szError, szFormatNoServer, __procedure__ );
%      RPC_CLIENT_ERROR ( szError );
%      return Result.ReturnValue;
%    }
%  }
%#else
%  while ( __pClient__ == NULL ) {
%    __pClient__	= RPC_CLIENT_CREATE ( __szHost__, __szTransport__ );
%    if ( __pClient__ == NULL ) {
%      /* Error handling for a not connected client: */
%      char	szError [ 256 ];
%      sprintf ( szError, szFormatNoServer, __procedure__ );
%      RPC_CLIENT_CERROR ( szContNoServer, szError );
%    }
%  }
%#endif	/* CLIENT_CREATE_BY_USER */
%
%  /* Copy in the oShortObjIdHeap argument: */
%  InArguments.oShortObjIdHeap	= oShortObjIdHeap;
%  /* Copy in the lpszFrom argument: */
%  InArguments.lpszFrom	= lpszFrom;
%  if ( lpszFrom == NULL ) {
%    /* Error handling for passing a NULL string pointer: */
%    char	szError [ 256 ];
%    InArguments.lpszFrom	= (LPSTR) szEmpty;
%    sprintf ( szError, szFormatNullString,
%              __procedure__, "lpszFrom" );
%    RPC_CLIENT_CERROR ( szContNullString, szError );
%  }
%
%  pResult	=
%#ifdef MULTITHREAD
%    (
%#else
%    (fnShortMakeString_rets *)
%#endif
%    fnrpc_fnshortmakestring_1 (
%	&InArguments,
%#ifdef MULTITHREAD
%	&Result,
%#endif
%	__pClient__ )
%#ifdef MULTITHREAD
%	== RPC_SUCCESS ) ? &Result : NULL
%#endif
%	;
%
%  if ( pResult == NULL ) {
%    /* Error handling for a failed RPC call, */
%    /* i.e. the server did not respond: */
%    char	szError [ 256 ];
%    sprintf ( szError, szFormatRpcFailed, __procedure__,
%              clnt_sperror ( __pClient__, __szHost__ ) );
%    __pClient__	= RPC_CLIENT_DESTROY ( __pClient__ );
%    RPC_CLIENT_CERROR ( szContRpcFailed, szError );
%    Result	= ZeroResult;
%    return Result.ReturnValue;
%  }
%#ifndef MULTITHREAD
%  Result	= * pResult;
%#endif
%
%
%  if ( pResult && pResult->nErrorLvl ) {
%    /* Server returned a user error message: */
%    char	szErrorMsg [ 1024 ];
%    strncpy ( szErrorMsg,
%              ( pResult->pszErrorMsg && pResult->pszErrorMsg [ 0 ] ) ?
%              (LPCSTR) pResult->pszErrorMsg : (LPCSTR) szEmpty,
%              sizeof ( szErrorMsg ) );
%    szErrorMsg [ sizeof ( szErrorMsg ) - 1 ]	= (char) 0;
%    xdr_free ( (xdrproc_t) xdr_fnShortMakeString_rets, (char *) pResult );
%    RPC_CLIENT_SERROR ( pResult->nErrorLvl, __procedure__,
%                        szErrorMsg );
%  } else {
%    xdr_free ( (xdrproc_t) xdr_fnShortMakeString_rets, (char *) pResult );
%  }
%
%  return Result.ReturnValue;
%
%} /* fnShortMakeString */
#endif	/* RPC_CLNT */
%
  fnServerDbCreateStructures_rets fnRpc_fnServerDbCreateStructures ( fnServerDbCreateStructures_args ) =  47 ;
%
#if RPC_SVC
%
%extern int fnServerDbCreateStructures
%	(SHORTOBJID oShortObjIdHeap ,
%	  SHORTOBJID oShortObjIdStructDescr ,
%	  int nObjIds ,
%	  u_int * /* _vector_t<nObjIds> */  pObjIds ,
%	  u_int * pnSlots);
%
%#ifdef MULTITHREAD
%bool_t
%#else
%fnServerDbCreateStructures_rets *
%#endif
%	PASTE2(fnrpc_fnserverdbcreatestructures_1,_SVCSUFFIX)
%		( fnServerDbCreateStructures_args * pArguments,
%#ifdef MULTITHREAD
%		  fnServerDbCreateStructures_rets * pResult,
%#endif
%		  struct svc_req * pRequest )
%{
%  static const char	__procedure__[]	= "server:fnrpc_fnserverdbcreatestructures_1";
%#ifdef MULTITHREAD
%  typedef bool_t RESULTTYPE;
%#else
%  typedef fnServerDbCreateStructures_rets * RESULTTYPE;
%#endif
%#ifndef MULTITHREAD
%  static fnServerDbCreateStructures_rets	Result;
%  RESULTTYPE			pResult = &Result;
%#endif
%  LPCSTR	pszErrorMsg;
%
%  __pRequest__	= pRequest;
%
%  RPC_SERVER_ENTRY();
%
%#ifndef MULTITHREAD
%  if ( pResult->pszErrorMsg == szEmpty ) {
%    pResult->pszErrorMsg	= NULL;
%  }
%  xdr_free ( (xdrproc_t) xdr_fnServerDbCreateStructures_rets, (char *) pResult );
%#endif
%  pResult->nErrorLvl		= 0;
%
%  pResult->pObjIds.u_int_vector_t_len	= pArguments->pObjIdsSize;
%  if ( pArguments->pObjIdsSize == 0 ) {
%    pResult->pObjIds.u_int_vector_t_val	= NULL;
%  } else {
%    pResult->pObjIds.u_int_vector_t_val	=
%      (u_int*) malloc ( pArguments->pObjIdsSize *
%               SIZEOF ( *(pResult->pObjIds.u_int_vector_t_val) ) );
%    if ( pResult->pObjIds.u_int_vector_t_val == NULL ) {
%      char	szError [ 256 ];
%      sprintf ( szError, szFormatMallocFailed,
%                __procedure__, pArguments->pObjIdsSize,
%                "pObjIds" );
%      RPC_SERVER_ERROR ( szError );
%      return (RESULTTYPE) NULL;
%    }
%  }
%  Reply.bAnswered		= FALSE;
%  Reply.pfnCalled		= (void(*)()) fnServerDbCreateStructures;
%  Reply.pfnXdrResult		= (bool_t(*)()) xdr_fnServerDbCreateStructures_rets;
%  Reply.pnErrorLvl		= &pResult->nErrorLvl;
%  Reply.ppszErrorMsg		= (LPCSTR *) &pResult->pszErrorMsg;
%  Reply.pResult		= pResult;
%  Reply.pReturnValue		= &pResult->ReturnValue;
%  Reply.nReturnValueSize	= sizeof ( pResult->ReturnValue );
%
%  pResult->ReturnValue		=
%  fnServerDbCreateStructures (
%	pArguments->oShortObjIdHeap,
%	pArguments->oShortObjIdStructDescr,
%	pArguments->nObjIds,
%	pResult->pObjIds.u_int_vector_t_val,
%	&pResult->pnSlots );
%
%  if ( Reply.bAnswered ) {
%    __pRequest__	= NULL;
%    return (RESULTTYPE) NULL;
%  }
%
%  pResult->nErrorLvl	= RPC_SERVER_ERRLVL();
%  if ( pResult->nErrorLvl > 0 ) {
%    pszErrorMsg		= RPC_SERVER_ERRMSG();
%    if ( pszErrorMsg && *pszErrorMsg ) {
%      pResult->pszErrorMsg	= strdup ( pszErrorMsg );
%    }
%  }
%  if ( pResult->pszErrorMsg == NULL ) {
%#ifdef MULTITHREAD
%    pResult->pszErrorMsg	= strdup ( szEmpty );
%#else
%    pResult->pszErrorMsg	= (LPSTR) szEmpty;
%#endif
%  }
%  __pRequest__	= NULL;
%  return (RESULTTYPE) pResult;
%} /* fnrpc_fnserverdbcreatestructures_1 */
#endif	/* RPC_SVC */
%
#if RPC_CLNT
%int DLLEXPORT fnServerDbCreateStructures
%	(SHORTOBJID oShortObjIdHeap ,
%	  SHORTOBJID oShortObjIdStructDescr ,
%	  int nObjIds ,
%	  u_int * /* _vector_t<nObjIds> */  pObjIds ,
%	  u_int * pnSlots)
%{
%  static const char	__procedure__[]	= "client:fnServerDbCreateStructures";
%  static fnServerDbCreateStructures_rets	ZeroResult;
%  fnServerDbCreateStructures_rets		* pResult = NULL;
%  fnServerDbCreateStructures_rets		Result = ZeroResult;
%  fnServerDbCreateStructures_args	InArguments;
%
%  /* Client initialization: */
%  if ( __bClientInitialize__ ) {
%    __bClientInitialize__	= FALSE;
%    RPC_CLIENT_INITIALIZE();
%  }
%
%#if	CLIENT_CREATE_BY_USER
%  if ( __pClient__ == NULL ) {
%    __pClient__	= RPC_CLIENT_CREATE ( __szHost__, __szTransport__ );
%    if ( __pClient__ == NULL ) {
%      /* Error handling for a not connected client: */
%      char	szError [ 256 ];
%      sprintf ( szError, szFormatNoServer, __procedure__ );
%      RPC_CLIENT_ERROR ( szError );
%      return Result.ReturnValue;
%    }
%  }
%#else
%  while ( __pClient__ == NULL ) {
%    __pClient__	= RPC_CLIENT_CREATE ( __szHost__, __szTransport__ );
%    if ( __pClient__ == NULL ) {
%      /* Error handling for a not connected client: */
%      char	szError [ 256 ];
%      sprintf ( szError, szFormatNoServer, __procedure__ );
%      RPC_CLIENT_CERROR ( szContNoServer, szError );
%    }
%  }
%#endif	/* CLIENT_CREATE_BY_USER */
%
%  /* Copy in the oShortObjIdHeap argument: */
%  InArguments.oShortObjIdHeap	= oShortObjIdHeap;
%  /* Copy in the oShortObjIdStructDescr argument: */
%  InArguments.oShortObjIdStructDescr	= oShortObjIdStructDescr;
%  /* Copy in the nObjIds argument: */
%  InArguments.nObjIds	= nObjIds;
%  InArguments.pObjIdsSize	= nObjIds;
%
%  pResult	=
%#ifdef MULTITHREAD
%    (
%#else
%    (fnServerDbCreateStructures_rets *)
%#endif
%    fnrpc_fnserverdbcreatestructures_1 (
%	&InArguments,
%#ifdef MULTITHREAD
%	&Result,
%#endif
%	__pClient__ )
%#ifdef MULTITHREAD
%	== RPC_SUCCESS ) ? &Result : NULL
%#endif
%	;
%
%  if ( pResult == NULL ) {
%    /* Error handling for a failed RPC call, */
%    /* i.e. the server did not respond: */
%    char	szError [ 256 ];
%    sprintf ( szError, szFormatRpcFailed, __procedure__,
%              clnt_sperror ( __pClient__, __szHost__ ) );
%    __pClient__	= RPC_CLIENT_DESTROY ( __pClient__ );
%    RPC_CLIENT_CERROR ( szContRpcFailed, szError );
%    Result	= ZeroResult;
%    return Result.ReturnValue;
%  }
%#ifndef MULTITHREAD
%  Result	= * pResult;
%#endif
%
%  /* Copy out the pObjIds argument: */
%  if ( ! ( 
%       pResult->pObjIds.u_int_vector_t_len != 0 &&
%       pObjIds == NULL ) ) {
%    memcpy ( pObjIds,
%             pResult->pObjIds.u_int_vector_t_val,
%             MIN ( pResult->pObjIds.u_int_vector_t_len,
%                   nObjIds ) *
%             SIZEOF ( *(pResult->pObjIds.u_int_vector_t_val) ) );
%  }
%  /* Copy out the pnSlots argument: */
%  if ( ! ( 
%       pnSlots == NULL ) ) {
%    *pnSlots	= pResult->pnSlots;
%  }
%
%  if ( pResult && pResult->nErrorLvl ) {
%    /* Server returned a user error message: */
%    char	szErrorMsg [ 1024 ];
%    strncpy ( szErrorMsg,
%              ( pResult->pszErrorMsg && pResult->pszErrorMsg [ 0 ] ) ?
%              (LPCSTR) pResult->pszErrorMsg : (LPCSTR) szEmpty,
%              sizeof ( szErrorMsg ) );
%    szErrorMsg [ sizeof ( szErrorMsg ) - 1 ]	= (char) 0;
%    xdr_free ( (xdrproc_t) xdr_fnServerDbCreateStructures_rets, (char *) pResult );
%    RPC_CLIENT_SERROR ( pResult->nErrorLvl, __procedure__,
%                        szErrorMsg );
%  } else {
%    xdr_free ( (xdrproc_t) xdr_fnServerDbCreateStructures_rets, (char *) pResult );
%  }
%  if ( 
%       pResult->pObjIds.u_int_vector_t_len != 0 &&
%       pObjIds == NULL ) {
%    /* Error handling for passing a NULL pointer on */
%    /* out argument: */
%    char	szError [ 256 ];
%    sprintf ( szError, szFormatNullPassed,
%              __procedure__, "pObjIds" );
%    RPC_CLIENT_CERROR ( szContNullOutPassed, szError );
%  } else if ( pResult->pObjIds.u_int_vector_t_len > nObjIds ) {
%      /* Error handling for an output buffer overflow, */
%      /* i.e. the buffer size passed is too small: */
%      /* For example, signal a CERROR here ... */
%      char	szError [ 256 ];
%      sprintf ( szError, szFormatBufferOverflow,
%                __procedure__, "pObjIds", 
%                nObjIds, 
%                pResult->pObjIds.u_int_vector_t_len );
%      RPC_CLIENT_CERROR ( szContBufferOverflow, szError );
%  }
%  if ( 
%       pnSlots == NULL ) {
%    /* Error handling for passing a NULL pointer on */
%    /* out argument: */
%    char	szError [ 256 ];
%    sprintf ( szError, szFormatNullPassed,
%              __procedure__, "pnSlots" );
%    RPC_CLIENT_CERROR ( szContNullOutPassed, szError );
%  }
%
%  return Result.ReturnValue;
%
%} /* fnServerDbCreateStructures */
#endif	/* RPC_CLNT */
%
  fnServerDbCreateInstances_rets fnRpc_fnServerDbCreateInstances ( fnServerDbCreateInstances_args ) =  48 ;
%
#if RPC_SVC
%
%extern int fnServerDbCreateInstances
%	(SHORTOBJID oShortObjIdHeap ,
%	  SHORTOBJID oShortObjIdClassDescr ,
%	  int nObjIds ,
%	  u_int * /* _vector_t<nObjIds> */  pObjIds ,
%	  u_int * pnSlots ,
%	  u_int * /* _vector_t<nObjIds> */  pDatas);
%
%#ifdef MULTITHREAD
%bool_t
%#else
%fnServerDbCreateInstances_rets *
%#endif
%	PASTE2(fnrpc_fnserverdbcreateinstances_1,_SVCSUFFIX)
%		( fnServerDbCreateInstances_args * pArguments,
%#ifdef MULTITHREAD
%		  fnServerDbCreateInstances_rets * pResult,
%#endif
%		  struct svc_req * pRequest )
%{
%  static const char	__procedure__[]	= "server:fnrpc_fnserverdbcreateinstances_1";
%#ifdef MULTITHREAD
%  typedef bool_t RESULTTYPE;
%#else
%  typedef fnServerDbCreateInstances_rets * RESULTTYPE;
%#endif
%#ifndef MULTITHREAD
%  static fnServerDbCreateInstances_rets	Result;
%  RESULTTYPE			pResult = &Result;
%#endif
%  LPCSTR	pszErrorMsg;
%
%  __pRequest__	= pRequest;
%
%  RPC_SERVER_ENTRY();
%
%#ifndef MULTITHREAD
%  if ( pResult->pszErrorMsg == szEmpty ) {
%    pResult->pszErrorMsg	= NULL;
%  }
%  xdr_free ( (xdrproc_t) xdr_fnServerDbCreateInstances_rets, (char *) pResult );
%#endif
%  pResult->nErrorLvl		= 0;
%
%  pResult->pObjIds.u_int_vector_t_len	= pArguments->pObjIdsSize;
%  if ( pArguments->pObjIdsSize == 0 ) {
%    pResult->pObjIds.u_int_vector_t_val	= NULL;
%  } else {
%    pResult->pObjIds.u_int_vector_t_val	=
%      (u_int*) malloc ( pArguments->pObjIdsSize *
%               SIZEOF ( *(pResult->pObjIds.u_int_vector_t_val) ) );
%    if ( pResult->pObjIds.u_int_vector_t_val == NULL ) {
%      char	szError [ 256 ];
%      sprintf ( szError, szFormatMallocFailed,
%                __procedure__, pArguments->pObjIdsSize,
%                "pObjIds" );
%      RPC_SERVER_ERROR ( szError );
%      return (RESULTTYPE) NULL;
%    }
%  }
%  pResult->pDatas.u_int_vector_t_len	= pArguments->pDatasSize;
%  if ( pArguments->pDatasSize == 0 ) {
%    pResult->pDatas.u_int_vector_t_val	= NULL;
%  } else {
%    pResult->pDatas.u_int_vector_t_val	=
%      (u_int*) malloc ( pArguments->pDatasSize *
%               SIZEOF ( *(pResult->pDatas.u_int_vector_t_val) ) );
%    if ( pResult->pDatas.u_int_vector_t_val == NULL ) {
%      char	szError [ 256 ];
%      sprintf ( szError, szFormatMallocFailed,
%                __procedure__, pArguments->pDatasSize,
%                "pDatas" );
%      RPC_SERVER_ERROR ( szError );
%      return (RESULTTYPE) NULL;
%    }
%  }
%  Reply.bAnswered		= FALSE;
%  Reply.pfnCalled		= (void(*)()) fnServerDbCreateInstances;
%  Reply.pfnXdrResult		= (bool_t(*)()) xdr_fnServerDbCreateInstances_rets;
%  Reply.pnErrorLvl		= &pResult->nErrorLvl;
%  Reply.ppszErrorMsg		= (LPCSTR *) &pResult->pszErrorMsg;
%  Reply.pResult		= pResult;
%  Reply.pReturnValue		= &pResult->ReturnValue;
%  Reply.nReturnValueSize	= sizeof ( pResult->ReturnValue );
%
%  pResult->ReturnValue		=
%  fnServerDbCreateInstances (
%	pArguments->oShortObjIdHeap,
%	pArguments->oShortObjIdClassDescr,
%	pArguments->nObjIds,
%	pResult->pObjIds.u_int_vector_t_val,
%	&pResult->pnSlots,
%	pResult->pDatas.u_int_vector_t_val );
%
%  if ( Reply.bAnswered ) {
%    __pRequest__	= NULL;
%    return (RESULTTYPE) NULL;
%  }
%
%  pResult->nErrorLvl	= RPC_SERVER_ERRLVL();
%  if ( pResult->nErrorLvl > 0 ) {
%    pszErrorMsg		= RPC_SERVER_ERRMSG();
%    if ( pszErrorMsg && *pszErrorMsg ) {
%      pResult->pszErrorMsg	= strdup ( pszErrorMsg );
%    }
%  }
%  if ( pResult->pszErrorMsg == NULL ) {
%#ifdef MULTITHREAD
%    pResult->pszErrorMsg	= strdup ( szEmpty );
%#else
%    pResult->pszErrorMsg	= (LPSTR) szEmpty;
%#endif
%  }
%  __pRequest__	= NULL;
%  return (RESULTTYPE) pResult;
%} /* fnrpc_fnserverdbcreateinstances_1 */
#endif	/* RPC_SVC */
%
#if RPC_CLNT
%int DLLEXPORT fnServerDbCreateInstances
%	(SHORTOBJID oShortObjIdHeap ,
%	  SHORTOBJID oShortObjIdClassDescr ,
%	  int nObjIds ,
%	  u_int * /* _vector_t<nObjIds> */  pObjIds ,
%	  u_int * pnSlots ,
%	  u_int * /* _vector_t<nObjIds> */  pDatas)
%{
%  static const char	__procedure__[]	= "client:fnServerDbCreateInstances";
%  static fnServerDbCreateInstances_rets	ZeroResult;
%  fnServerDbCreateInstances_rets		* pResult = NULL;
%  fnServerDbCreateInstances_rets		Result = ZeroResult;
%  fnServerDbCreateInstances_args	InArguments;
%
%  /* Client initialization: */
%  if ( __bClientInitialize__ ) {
%    __bClientInitialize__	= FALSE;
%    RPC_CLIENT_INITIALIZE();
%  }
%
%#if	CLIENT_CREATE_BY_USER
%  if ( __pClient__ == NULL ) {
%    __pClient__	= RPC_CLIENT_CREATE ( __szHost__, __szTransport__ );
%    if ( __pClient__ == NULL ) {
%      /* Error handling for a not connected client: */
%      char	szError [ 256 ];
%      sprintf ( szError, szFormatNoServer, __procedure__ );
%      RPC_CLIENT_ERROR ( szError );
%      return Result.ReturnValue;
%    }
%  }
%#else
%  while ( __pClient__ == NULL ) {
%    __pClient__	= RPC_CLIENT_CREATE ( __szHost__, __szTransport__ );
%    if ( __pClient__ == NULL ) {
%      /* Error handling for a not connected client: */
%      char	szError [ 256 ];
%      sprintf ( szError, szFormatNoServer, __procedure__ );
%      RPC_CLIENT_CERROR ( szContNoServer, szError );
%    }
%  }
%#endif	/* CLIENT_CREATE_BY_USER */
%
%  /* Copy in the oShortObjIdHeap argument: */
%  InArguments.oShortObjIdHeap	= oShortObjIdHeap;
%  /* Copy in the oShortObjIdClassDescr argument: */
%  InArguments.oShortObjIdClassDescr	= oShortObjIdClassDescr;
%  /* Copy in the nObjIds argument: */
%  InArguments.nObjIds	= nObjIds;
%  InArguments.pObjIdsSize	= nObjIds;
%  InArguments.pDatasSize	= nObjIds;
%
%  pResult	=
%#ifdef MULTITHREAD
%    (
%#else
%    (fnServerDbCreateInstances_rets *)
%#endif
%    fnrpc_fnserverdbcreateinstances_1 (
%	&InArguments,
%#ifdef MULTITHREAD
%	&Result,
%#endif
%	__pClient__ )
%#ifdef MULTITHREAD
%	== RPC_SUCCESS ) ? &Result : NULL
%#endif
%	;
%
%  if ( pResult == NULL ) {
%    /* Error handling for a failed RPC call, */
%    /* i.e. the server did not respond: */
%    char	szError [ 256 ];
%    sprintf ( szError, szFormatRpcFailed, __procedure__,
%              clnt_sperror ( __pClient__, __szHost__ ) );
%    __pClient__	= RPC_CLIENT_DESTROY ( __pClient__ );
%    RPC_CLIENT_CERROR ( szContRpcFailed, szError );
%    Result	= ZeroResult;
%    return Result.ReturnValue;
%  }
%#ifndef MULTITHREAD
%  Result	= * pResult;
%#endif
%
%  /* Copy out the pObjIds argument: */
%  if ( ! ( 
%       pResult->pObjIds.u_int_vector_t_len != 0 &&
%       pObjIds == NULL ) ) {
%    memcpy ( pObjIds,
%             pResult->pObjIds.u_int_vector_t_val,
%             MIN ( pResult->pObjIds.u_int_vector_t_len,
%                   nObjIds ) *
%             SIZEOF ( *(pResult->pObjIds.u_int_vector_t_val) ) );
%  }
%  /* Copy out the pnSlots argument: */
%  if ( ! ( 
%       pnSlots == NULL ) ) {
%    *pnSlots	= pResult->pnSlots;
%  }
%  /* Copy out the pDatas argument: */
%  if ( ! ( 
%       pResult->pDatas.u_int_vector_t_len != 0 &&
%       pDatas == NULL ) ) {
%    memcpy ( pDatas,
%             pResult->pDatas.u_int_vector_t_val,
%             MIN ( pResult->pDatas.u_int_vector_t_len,
%                   nObjIds ) *
%             SIZEOF ( *(pResult->pDatas.u_int_vector_t_val) ) );
%  }
%
%  if ( pResult && pResult->nErrorLvl ) {
%    /* Server returned a user error message: */
%    char	szErrorMsg [ 1024 ];
%    strncpy ( szErrorMsg,
%              ( pResult->pszErrorMsg && pResult->pszErrorMsg [ 0 ] ) ?
%              (LPCSTR) pResult->pszErrorMsg : (LPCSTR) szEmpty,
%              sizeof ( szErrorMsg ) );
%    szErrorMsg [ sizeof ( szErrorMsg ) - 1 ]	= (char) 0;
%    xdr_free ( (xdrproc_t) xdr_fnServerDbCreateInstances_rets, (char *) pResult );
%    RPC_CLIENT_SERROR ( pResult->nErrorLvl, __procedure__,
%                        szErrorMsg );
%  } else {
%    xdr_free ( (xdrproc_t) xdr_fnServerDbCreateInstances_rets, (char *) pResult );
%  }
%  if ( 
%       pResult->pObjIds.u_int_vector_t_len != 0 &&
%       pObjIds == NULL ) {
%    /* Error handling for passing a NULL pointer on */
%    /* out argument: */
%    char	szError [ 256 ];
%    sprintf ( szError, szFormatNullPassed,
%              __procedure__, "pObjIds" );
%    RPC_CLIENT_CERROR ( szContNullOutPassed, szError );
%  } else if ( pResult->pObjIds.u_int_vector_t_len > nObjIds ) {
%      /* Error handling for an output buffer overflow, */
%      /* i.e. the buffer size passed is too small: */
%      /* For example, signal a CERROR here ... */
%      char	szError [ 256 ];
%      sprintf ( szError, szFormatBufferOverflow,
%                __procedure__, "pObjIds", 
%                nObjIds, 
%                pResult->pObjIds.u_int_vector_t_len );
%      RPC_CLIENT_CERROR ( szContBufferOverflow, szError );
%  }
%  if ( 
%       pnSlots == NULL ) {
%    /* Error handling for passing a NULL pointer on */
%    /* out argument: */
%    char	szError [ 256 ];
%    sprintf ( szError, szFormatNullPassed,
%              __procedure__, "pnSlots" );
%    RPC_CLIENT_CERROR ( szContNullOutPassed, szError );
%  }
%  if ( 
%       pResult->pDatas.u_int_vector_t_len != 0 &&
%       pDatas == NULL ) {
%    /* Error handling for passing a NULL pointer on */
%    /* out argument: */
%    char	szError [ 256 ];
%    sprintf ( szError, szFormatNullPassed,
%              __procedure__, "pDatas" );
%    RPC_CLIENT_CERROR ( szContNullOutPassed, szError );
%  } else if ( pResult->pDatas.u_int_vector_t_len > nObjIds ) {
%      /* Error handling for an output buffer overflow, */
%      /* i.e. the buffer size passed is too small: */
%      /* For example, signal a CERROR here ... */
%      char	szError [ 256 ];
%      sprintf ( szError, szFormatBufferOverflow,
%                __procedure__, "pDatas", 
%                nObjIds, 
%                pResult->pDatas.u_int_vector_t_len );
%      RPC_CLIENT_CERROR ( szContBufferOverflow, szError );
%  }
%
%  return Result.ReturnValue;
%
%} /* fnServerDbCreateInstances */
#endif	/* RPC_CLNT */
%
  fnServerInstanceWriteWrapper_rets fnRpc_fnServerInstanceWriteWrapper ( fnServerInstanceWriteWrapper_args ) =  49 ;
%
#if RPC_SVC
%
%extern SHLOCK fnServerInstanceWriteWrapper
%	(SHORTOBJID oShortObjIdHeap ,
%	  SHORTOBJID oShortObjIdInstance ,
%	  SHORTOBJID oShortObjIdClassDescr);
%
%#ifdef MULTITHREAD
%bool_t
%#else
%fnServerInstanceWriteWrapper_rets *
%#endif
%	PASTE2(fnrpc_fnserverinstancewritewrapper_1,_SVCSUFFIX)
%		( fnServerInstanceWriteWrapper_args * pArguments,
%#ifdef MULTITHREAD
%		  fnServerInstanceWriteWrapper_rets * pResult,
%#endif
%		  struct svc_req * pRequest )
%{
%  static const char	__procedure__[]	= "server:fnrpc_fnserverinstancewritewrapper_1";
%#ifdef MULTITHREAD
%  typedef bool_t RESULTTYPE;
%#else
%  typedef fnServerInstanceWriteWrapper_rets * RESULTTYPE;
%#endif
%#ifndef MULTITHREAD
%  static fnServerInstanceWriteWrapper_rets	Result;
%  RESULTTYPE			pResult = &Result;
%#endif
%  LPCSTR	pszErrorMsg;
%
%  __pRequest__	= pRequest;
%
%  RPC_SERVER_ENTRY();
%
%#ifndef MULTITHREAD
%  if ( pResult->pszErrorMsg == szEmpty ) {
%    pResult->pszErrorMsg	= NULL;
%  }
%  xdr_free ( (xdrproc_t) xdr_fnServerInstanceWriteWrapper_rets, (char *) pResult );
%#endif
%  pResult->nErrorLvl		= 0;
%
%  Reply.bAnswered		= FALSE;
%  Reply.pfnCalled		= (void(*)()) fnServerInstanceWriteWrapper;
%  Reply.pfnXdrResult		= (bool_t(*)()) xdr_fnServerInstanceWriteWrapper_rets;
%  Reply.pnErrorLvl		= &pResult->nErrorLvl;
%  Reply.ppszErrorMsg		= (LPCSTR *) &pResult->pszErrorMsg;
%  Reply.pResult		= pResult;
%  Reply.pReturnValue		= &pResult->ReturnValue;
%  Reply.nReturnValueSize	= sizeof ( pResult->ReturnValue );
%
%  pResult->ReturnValue		=
%  fnServerInstanceWriteWrapper (
%	pArguments->oShortObjIdHeap,
%	pArguments->oShortObjIdInstance,
%	pArguments->oShortObjIdClassDescr );
%
%  if ( Reply.bAnswered ) {
%    __pRequest__	= NULL;
%    return (RESULTTYPE) NULL;
%  }
%
%  pResult->nErrorLvl	= RPC_SERVER_ERRLVL();
%  if ( pResult->nErrorLvl > 0 ) {
%    pszErrorMsg		= RPC_SERVER_ERRMSG();
%    if ( pszErrorMsg && *pszErrorMsg ) {
%      pResult->pszErrorMsg	= strdup ( pszErrorMsg );
%    }
%  }
%  if ( pResult->pszErrorMsg == NULL ) {
%#ifdef MULTITHREAD
%    pResult->pszErrorMsg	= strdup ( szEmpty );
%#else
%    pResult->pszErrorMsg	= (LPSTR) szEmpty;
%#endif
%  }
%  __pRequest__	= NULL;
%  return (RESULTTYPE) pResult;
%} /* fnrpc_fnserverinstancewritewrapper_1 */
#endif	/* RPC_SVC */
%
#if RPC_CLNT
%SHLOCK DLLEXPORT fnServerInstanceWriteWrapper
%	(SHORTOBJID oShortObjIdHeap ,
%	  SHORTOBJID oShortObjIdInstance ,
%	  SHORTOBJID oShortObjIdClassDescr)
%{
%  static const char	__procedure__[]	= "client:fnServerInstanceWriteWrapper";
%  static fnServerInstanceWriteWrapper_rets	ZeroResult;
%  fnServerInstanceWriteWrapper_rets		* pResult = NULL;
%  fnServerInstanceWriteWrapper_rets		Result = ZeroResult;
%  fnServerInstanceWriteWrapper_args	InArguments;
%
%  /* Client initialization: */
%  if ( __bClientInitialize__ ) {
%    __bClientInitialize__	= FALSE;
%    RPC_CLIENT_INITIALIZE();
%  }
%
%#if	CLIENT_CREATE_BY_USER
%  if ( __pClient__ == NULL ) {
%    __pClient__	= RPC_CLIENT_CREATE ( __szHost__, __szTransport__ );
%    if ( __pClient__ == NULL ) {
%      /* Error handling for a not connected client: */
%      char	szError [ 256 ];
%      sprintf ( szError, szFormatNoServer, __procedure__ );
%      RPC_CLIENT_ERROR ( szError );
%      return Result.ReturnValue;
%    }
%  }
%#else
%  while ( __pClient__ == NULL ) {
%    __pClient__	= RPC_CLIENT_CREATE ( __szHost__, __szTransport__ );
%    if ( __pClient__ == NULL ) {
%      /* Error handling for a not connected client: */
%      char	szError [ 256 ];
%      sprintf ( szError, szFormatNoServer, __procedure__ );
%      RPC_CLIENT_CERROR ( szContNoServer, szError );
%    }
%  }
%#endif	/* CLIENT_CREATE_BY_USER */
%
%  /* Copy in the oShortObjIdHeap argument: */
%  InArguments.oShortObjIdHeap	= oShortObjIdHeap;
%  /* Copy in the oShortObjIdInstance argument: */
%  InArguments.oShortObjIdInstance	= oShortObjIdInstance;
%  /* Copy in the oShortObjIdClassDescr argument: */
%  InArguments.oShortObjIdClassDescr	= oShortObjIdClassDescr;
%
%  pResult	=
%#ifdef MULTITHREAD
%    (
%#else
%    (fnServerInstanceWriteWrapper_rets *)
%#endif
%    fnrpc_fnserverinstancewritewrapper_1 (
%	&InArguments,
%#ifdef MULTITHREAD
%	&Result,
%#endif
%	__pClient__ )
%#ifdef MULTITHREAD
%	== RPC_SUCCESS ) ? &Result : NULL
%#endif
%	;
%
%  if ( pResult == NULL ) {
%    /* Error handling for a failed RPC call, */
%    /* i.e. the server did not respond: */
%    char	szError [ 256 ];
%    sprintf ( szError, szFormatRpcFailed, __procedure__,
%              clnt_sperror ( __pClient__, __szHost__ ) );
%    __pClient__	= RPC_CLIENT_DESTROY ( __pClient__ );
%    RPC_CLIENT_CERROR ( szContRpcFailed, szError );
%    Result	= ZeroResult;
%    return Result.ReturnValue;
%  }
%#ifndef MULTITHREAD
%  Result	= * pResult;
%#endif
%
%
%  if ( pResult && pResult->nErrorLvl ) {
%    /* Server returned a user error message: */
%    char	szErrorMsg [ 1024 ];
%    strncpy ( szErrorMsg,
%              ( pResult->pszErrorMsg && pResult->pszErrorMsg [ 0 ] ) ?
%              (LPCSTR) pResult->pszErrorMsg : (LPCSTR) szEmpty,
%              sizeof ( szErrorMsg ) );
%    szErrorMsg [ sizeof ( szErrorMsg ) - 1 ]	= (char) 0;
%    xdr_free ( (xdrproc_t) xdr_fnServerInstanceWriteWrapper_rets, (char *) pResult );
%    RPC_CLIENT_SERROR ( pResult->nErrorLvl, __procedure__,
%                        szErrorMsg );
%  } else {
%    xdr_free ( (xdrproc_t) xdr_fnServerInstanceWriteWrapper_rets, (char *) pResult );
%  }
%
%  return Result.ReturnValue;
%
%} /* fnServerInstanceWriteWrapper */
#endif	/* RPC_CLNT */
%
  fnServerInstanceWriteData_rets fnRpc_fnServerInstanceWriteData ( fnServerInstanceWriteData_args ) =  50 ;
%
#if RPC_SVC
%
%extern SHLOCK fnServerInstanceWriteData
%	(SHORTOBJID oShortObjIdHeap ,
%	  SHORTOBJID oShortObjIdInstance ,
%	  SHORTOBJID oShortObjIdData);
%
%#ifdef MULTITHREAD
%bool_t
%#else
%fnServerInstanceWriteData_rets *
%#endif
%	PASTE2(fnrpc_fnserverinstancewritedata_1,_SVCSUFFIX)
%		( fnServerInstanceWriteData_args * pArguments,
%#ifdef MULTITHREAD
%		  fnServerInstanceWriteData_rets * pResult,
%#endif
%		  struct svc_req * pRequest )
%{
%  static const char	__procedure__[]	= "server:fnrpc_fnserverinstancewritedata_1";
%#ifdef MULTITHREAD
%  typedef bool_t RESULTTYPE;
%#else
%  typedef fnServerInstanceWriteData_rets * RESULTTYPE;
%#endif
%#ifndef MULTITHREAD
%  static fnServerInstanceWriteData_rets	Result;
%  RESULTTYPE			pResult = &Result;
%#endif
%  LPCSTR	pszErrorMsg;
%
%  __pRequest__	= pRequest;
%
%  RPC_SERVER_ENTRY();
%
%#ifndef MULTITHREAD
%  if ( pResult->pszErrorMsg == szEmpty ) {
%    pResult->pszErrorMsg	= NULL;
%  }
%  xdr_free ( (xdrproc_t) xdr_fnServerInstanceWriteData_rets, (char *) pResult );
%#endif
%  pResult->nErrorLvl		= 0;
%
%  Reply.bAnswered		= FALSE;
%  Reply.pfnCalled		= (void(*)()) fnServerInstanceWriteData;
%  Reply.pfnXdrResult		= (bool_t(*)()) xdr_fnServerInstanceWriteData_rets;
%  Reply.pnErrorLvl		= &pResult->nErrorLvl;
%  Reply.ppszErrorMsg		= (LPCSTR *) &pResult->pszErrorMsg;
%  Reply.pResult		= pResult;
%  Reply.pReturnValue		= &pResult->ReturnValue;
%  Reply.nReturnValueSize	= sizeof ( pResult->ReturnValue );
%
%  pResult->ReturnValue		=
%  fnServerInstanceWriteData (
%	pArguments->oShortObjIdHeap,
%	pArguments->oShortObjIdInstance,
%	pArguments->oShortObjIdData );
%
%  if ( Reply.bAnswered ) {
%    __pRequest__	= NULL;
%    return (RESULTTYPE) NULL;
%  }
%
%  pResult->nErrorLvl	= RPC_SERVER_ERRLVL();
%  if ( pResult->nErrorLvl > 0 ) {
%    pszErrorMsg		= RPC_SERVER_ERRMSG();
%    if ( pszErrorMsg && *pszErrorMsg ) {
%      pResult->pszErrorMsg	= strdup ( pszErrorMsg );
%    }
%  }
%  if ( pResult->pszErrorMsg == NULL ) {
%#ifdef MULTITHREAD
%    pResult->pszErrorMsg	= strdup ( szEmpty );
%#else
%    pResult->pszErrorMsg	= (LPSTR) szEmpty;
%#endif
%  }
%  __pRequest__	= NULL;
%  return (RESULTTYPE) pResult;
%} /* fnrpc_fnserverinstancewritedata_1 */
#endif	/* RPC_SVC */
%
#if RPC_CLNT
%SHLOCK DLLEXPORT fnServerInstanceWriteData
%	(SHORTOBJID oShortObjIdHeap ,
%	  SHORTOBJID oShortObjIdInstance ,
%	  SHORTOBJID oShortObjIdData)
%{
%  static const char	__procedure__[]	= "client:fnServerInstanceWriteData";
%  static fnServerInstanceWriteData_rets	ZeroResult;
%  fnServerInstanceWriteData_rets		* pResult = NULL;
%  fnServerInstanceWriteData_rets		Result = ZeroResult;
%  fnServerInstanceWriteData_args	InArguments;
%
%  /* Client initialization: */
%  if ( __bClientInitialize__ ) {
%    __bClientInitialize__	= FALSE;
%    RPC_CLIENT_INITIALIZE();
%  }
%
%#if	CLIENT_CREATE_BY_USER
%  if ( __pClient__ == NULL ) {
%    __pClient__	= RPC_CLIENT_CREATE ( __szHost__, __szTransport__ );
%    if ( __pClient__ == NULL ) {
%      /* Error handling for a not connected client: */
%      char	szError [ 256 ];
%      sprintf ( szError, szFormatNoServer, __procedure__ );
%      RPC_CLIENT_ERROR ( szError );
%      return Result.ReturnValue;
%    }
%  }
%#else
%  while ( __pClient__ == NULL ) {
%    __pClient__	= RPC_CLIENT_CREATE ( __szHost__, __szTransport__ );
%    if ( __pClient__ == NULL ) {
%      /* Error handling for a not connected client: */
%      char	szError [ 256 ];
%      sprintf ( szError, szFormatNoServer, __procedure__ );
%      RPC_CLIENT_CERROR ( szContNoServer, szError );
%    }
%  }
%#endif	/* CLIENT_CREATE_BY_USER */
%
%  /* Copy in the oShortObjIdHeap argument: */
%  InArguments.oShortObjIdHeap	= oShortObjIdHeap;
%  /* Copy in the oShortObjIdInstance argument: */
%  InArguments.oShortObjIdInstance	= oShortObjIdInstance;
%  /* Copy in the oShortObjIdData argument: */
%  InArguments.oShortObjIdData	= oShortObjIdData;
%
%  pResult	=
%#ifdef MULTITHREAD
%    (
%#else
%    (fnServerInstanceWriteData_rets *)
%#endif
%    fnrpc_fnserverinstancewritedata_1 (
%	&InArguments,
%#ifdef MULTITHREAD
%	&Result,
%#endif
%	__pClient__ )
%#ifdef MULTITHREAD
%	== RPC_SUCCESS ) ? &Result : NULL
%#endif
%	;
%
%  if ( pResult == NULL ) {
%    /* Error handling for a failed RPC call, */
%    /* i.e. the server did not respond: */
%    char	szError [ 256 ];
%    sprintf ( szError, szFormatRpcFailed, __procedure__,
%              clnt_sperror ( __pClient__, __szHost__ ) );
%    __pClient__	= RPC_CLIENT_DESTROY ( __pClient__ );
%    RPC_CLIENT_CERROR ( szContRpcFailed, szError );
%    Result	= ZeroResult;
%    return Result.ReturnValue;
%  }
%#ifndef MULTITHREAD
%  Result	= * pResult;
%#endif
%
%
%  if ( pResult && pResult->nErrorLvl ) {
%    /* Server returned a user error message: */
%    char	szErrorMsg [ 1024 ];
%    strncpy ( szErrorMsg,
%              ( pResult->pszErrorMsg && pResult->pszErrorMsg [ 0 ] ) ?
%              (LPCSTR) pResult->pszErrorMsg : (LPCSTR) szEmpty,
%              sizeof ( szErrorMsg ) );
%    szErrorMsg [ sizeof ( szErrorMsg ) - 1 ]	= (char) 0;
%    xdr_free ( (xdrproc_t) xdr_fnServerInstanceWriteData_rets, (char *) pResult );
%    RPC_CLIENT_SERROR ( pResult->nErrorLvl, __procedure__,
%                        szErrorMsg );
%  } else {
%    xdr_free ( (xdrproc_t) xdr_fnServerInstanceWriteData_rets, (char *) pResult );
%  }
%
%  return Result.ReturnValue;
%
%} /* fnServerInstanceWriteData */
#endif	/* RPC_CLNT */
%
  fnServerDbTypeTagName_rets fnRpc_fnServerDbTypeTagName ( SHTYPETAG ) =  51 ;
%
#if RPC_SVC
%
%extern string_t fnServerDbTypeTagName
%	(SHTYPETAG nTypeTag);
%
%#ifdef MULTITHREAD
%bool_t
%#else
%fnServerDbTypeTagName_rets *
%#endif
%	PASTE2(fnrpc_fnserverdbtypetagname_1,_SVCSUFFIX)
%		( SHTYPETAG * pArguments,
%#ifdef MULTITHREAD
%		  fnServerDbTypeTagName_rets * pResult,
%#endif
%		  struct svc_req * pRequest )
%{
%  static const char	__procedure__[]	= "server:fnrpc_fnserverdbtypetagname_1";
%#ifdef MULTITHREAD
%  typedef bool_t RESULTTYPE;
%#else
%  typedef fnServerDbTypeTagName_rets * RESULTTYPE;
%#endif
%#ifndef MULTITHREAD
%  static fnServerDbTypeTagName_rets	Result;
%  RESULTTYPE			pResult = &Result;
%#endif
%  LPCSTR	pszErrorMsg;
%
%  __pRequest__	= pRequest;
%
%  RPC_SERVER_ENTRY();
%
%#ifndef MULTITHREAD
%  if ( pResult->pszErrorMsg == szEmpty ) {
%    pResult->pszErrorMsg	= NULL;
%  }
%  xdr_free ( (xdrproc_t) xdr_fnServerDbTypeTagName_rets, (char *) pResult );
%#endif
%  pResult->nErrorLvl		= 0;
%
%  Reply.bAnswered		= FALSE;
%  Reply.pfnCalled		= (void(*)()) fnServerDbTypeTagName;
%  Reply.pfnXdrResult		= (bool_t(*)()) xdr_fnServerDbTypeTagName_rets;
%  Reply.pnErrorLvl		= &pResult->nErrorLvl;
%  Reply.ppszErrorMsg		= (LPCSTR *) &pResult->pszErrorMsg;
%  Reply.pResult		= pResult;
%  Reply.pReturnValue		= &pResult->ReturnValue;
%  Reply.nReturnValueSize	= sizeof ( pResult->ReturnValue );
%
%  pResult->ReturnValue		=
%  fnServerDbTypeTagName (
%	(*pArguments) );
%
%  if ( Reply.bAnswered ) {
%    __pRequest__	= NULL;
%    return (RESULTTYPE) NULL;
%  }
%
%  pResult->nErrorLvl	= RPC_SERVER_ERRLVL();
%  if ( pResult->nErrorLvl > 0 ) {
%    pszErrorMsg		= RPC_SERVER_ERRMSG();
%    if ( pszErrorMsg && *pszErrorMsg ) {
%      pResult->pszErrorMsg	= strdup ( pszErrorMsg );
%    }
%  }
%  if ( pResult->pszErrorMsg == NULL ) {
%#ifdef MULTITHREAD
%    pResult->pszErrorMsg	= strdup ( szEmpty );
%#else
%    pResult->pszErrorMsg	= (LPSTR) szEmpty;
%#endif
%  }
%  __pRequest__	= NULL;
%  return (RESULTTYPE) pResult;
%} /* fnrpc_fnserverdbtypetagname_1 */
#endif	/* RPC_SVC */
%
#if RPC_CLNT
%string_t DLLEXPORT fnServerDbTypeTagName
%	(SHTYPETAG nTypeTag)
%{
%  static const char	__procedure__[]	= "client:fnServerDbTypeTagName";
%  static fnServerDbTypeTagName_rets	ZeroResult;
%  fnServerDbTypeTagName_rets		* pResult = NULL;
%  fnServerDbTypeTagName_rets		Result = ZeroResult;
%
%  /* Client initialization: */
%  if ( __bClientInitialize__ ) {
%    __bClientInitialize__	= FALSE;
%    RPC_CLIENT_INITIALIZE();
%  }
%
%#if	CLIENT_CREATE_BY_USER
%  if ( __pClient__ == NULL ) {
%    __pClient__	= RPC_CLIENT_CREATE ( __szHost__, __szTransport__ );
%    if ( __pClient__ == NULL ) {
%      /* Error handling for a not connected client: */
%      char	szError [ 256 ];
%      sprintf ( szError, szFormatNoServer, __procedure__ );
%      RPC_CLIENT_ERROR ( szError );
%      return Result.ReturnValue;
%    }
%  }
%#else
%  while ( __pClient__ == NULL ) {
%    __pClient__	= RPC_CLIENT_CREATE ( __szHost__, __szTransport__ );
%    if ( __pClient__ == NULL ) {
%      /* Error handling for a not connected client: */
%      char	szError [ 256 ];
%      sprintf ( szError, szFormatNoServer, __procedure__ );
%      RPC_CLIENT_CERROR ( szContNoServer, szError );
%    }
%  }
%#endif	/* CLIENT_CREATE_BY_USER */
%
%  pResult	=
%#ifdef MULTITHREAD
%    (
%#else
%    (fnServerDbTypeTagName_rets *)
%#endif
%    fnrpc_fnserverdbtypetagname_1 (
%	&nTypeTag,
%#ifdef MULTITHREAD
%	&Result,
%#endif
%	__pClient__ )
%#ifdef MULTITHREAD
%	== RPC_SUCCESS ) ? &Result : NULL
%#endif
%	;
%
%  if ( pResult == NULL ) {
%    /* Error handling for a failed RPC call, */
%    /* i.e. the server did not respond: */
%    char	szError [ 256 ];
%    sprintf ( szError, szFormatRpcFailed, __procedure__,
%              clnt_sperror ( __pClient__, __szHost__ ) );
%    __pClient__	= RPC_CLIENT_DESTROY ( __pClient__ );
%    RPC_CLIENT_CERROR ( szContRpcFailed, szError );
%    Result	= ZeroResult;
%    return Result.ReturnValue;
%  }
%#ifndef MULTITHREAD
%  Result	= * pResult;
%#endif
%
%
%  if ( pResult && pResult->nErrorLvl ) {
%    /* Server returned a user error message: */
%    char	szErrorMsg [ 1024 ];
%    strncpy ( szErrorMsg,
%              ( pResult->pszErrorMsg && pResult->pszErrorMsg [ 0 ] ) ?
%              (LPCSTR) pResult->pszErrorMsg : (LPCSTR) szEmpty,
%              sizeof ( szErrorMsg ) );
%    szErrorMsg [ sizeof ( szErrorMsg ) - 1 ]	= (char) 0;
%    xdr_free ( (xdrproc_t) xdr_fnServerDbTypeTagName_rets, (char *) pResult );
%    RPC_CLIENT_SERROR ( pResult->nErrorLvl, __procedure__,
%                        szErrorMsg );
%  } else {
%    xdr_free ( (xdrproc_t) xdr_fnServerDbTypeTagName_rets, (char *) pResult );
%  }
%
%  return Result.ReturnValue;
%
%} /* fnServerDbTypeTagName */
#endif	/* RPC_CLNT */
%
  fnServerObjectPrettyPrint_rets fnRpc_fnServerObjectPrettyPrint ( fnServerObjectPrettyPrint_args ) =  52 ;
%
#if RPC_SVC
%
%extern int fnServerObjectPrettyPrint
%	(SHORTOBJID oShortObjIdHeap ,
%	  SHORTOBJID oShortObjId ,
%	  SHTYPETAG nTypeTag ,
%	  string_t /* string_t<nBuffer> */  lpszBuffer ,
%	  int nBuffer);
%
%#ifdef MULTITHREAD
%bool_t
%#else
%fnServerObjectPrettyPrint_rets *
%#endif
%	PASTE2(fnrpc_fnserverobjectprettyprint_1,_SVCSUFFIX)
%		( fnServerObjectPrettyPrint_args * pArguments,
%#ifdef MULTITHREAD
%		  fnServerObjectPrettyPrint_rets * pResult,
%#endif
%		  struct svc_req * pRequest )
%{
%  static const char	__procedure__[]	= "server:fnrpc_fnserverobjectprettyprint_1";
%#ifdef MULTITHREAD
%  typedef bool_t RESULTTYPE;
%#else
%  typedef fnServerObjectPrettyPrint_rets * RESULTTYPE;
%#endif
%#ifndef MULTITHREAD
%  static fnServerObjectPrettyPrint_rets	Result;
%  RESULTTYPE			pResult = &Result;
%#endif
%  LPCSTR	pszErrorMsg;
%
%  __pRequest__	= pRequest;
%
%  RPC_SERVER_ENTRY();
%
%#ifndef MULTITHREAD
%  if ( pResult->pszErrorMsg == szEmpty ) {
%    pResult->pszErrorMsg	= NULL;
%  }
%  xdr_free ( (xdrproc_t) xdr_fnServerObjectPrettyPrint_rets, (char *) pResult );
%#endif
%  pResult->nErrorLvl		= 0;
%
%  if ( pArguments->lpszBufferSize == 0 ) {
%    pResult->lpszBuffer	= NULL;
%  } else {
%    pResult->lpszBuffer	=
%    (string_t) malloc ( pArguments->lpszBufferSize );
%    if ( pResult->lpszBuffer == NULL ) {
%      char	szError [ 256 ];
%      sprintf ( szError, szFormatMallocFailed,
%                __procedure__, pArguments->lpszBufferSize );
%      RPC_SERVER_ERROR ( szError );
%      return (RESULTTYPE) NULL;
%    }
%  }
%  Reply.bAnswered		= FALSE;
%  Reply.pfnCalled		= (void(*)()) fnServerObjectPrettyPrint;
%  Reply.pfnXdrResult		= (bool_t(*)()) xdr_fnServerObjectPrettyPrint_rets;
%  Reply.pnErrorLvl		= &pResult->nErrorLvl;
%  Reply.ppszErrorMsg		= (LPCSTR *) &pResult->pszErrorMsg;
%  Reply.pResult		= pResult;
%  Reply.pReturnValue		= &pResult->ReturnValue;
%  Reply.nReturnValueSize	= sizeof ( pResult->ReturnValue );
%
%  pResult->ReturnValue		=
%  fnServerObjectPrettyPrint (
%	pArguments->oShortObjIdHeap,
%	pArguments->oShortObjId,
%	pArguments->nTypeTag,
%	pResult->lpszBuffer,
%	pArguments->nBuffer );
%
%  if ( Reply.bAnswered ) {
%    __pRequest__	= NULL;
%    return (RESULTTYPE) NULL;
%  }
%
%  pResult->nErrorLvl	= RPC_SERVER_ERRLVL();
%  if ( pResult->nErrorLvl > 0 ) {
%    pszErrorMsg		= RPC_SERVER_ERRMSG();
%    if ( pszErrorMsg && *pszErrorMsg ) {
%      pResult->pszErrorMsg	= strdup ( pszErrorMsg );
%    }
%  }
%  if ( pResult->pszErrorMsg == NULL ) {
%#ifdef MULTITHREAD
%    pResult->pszErrorMsg	= strdup ( szEmpty );
%#else
%    pResult->pszErrorMsg	= (LPSTR) szEmpty;
%#endif
%  }
%  __pRequest__	= NULL;
%  return (RESULTTYPE) pResult;
%} /* fnrpc_fnserverobjectprettyprint_1 */
#endif	/* RPC_SVC */
%
#if RPC_CLNT
%int DLLEXPORT fnServerObjectPrettyPrint
%	(SHORTOBJID oShortObjIdHeap ,
%	  SHORTOBJID oShortObjId ,
%	  SHTYPETAG nTypeTag ,
%	  string_t /* string_t<nBuffer> */  lpszBuffer ,
%	  int nBuffer)
%{
%  static const char	__procedure__[]	= "client:fnServerObjectPrettyPrint";
%  static fnServerObjectPrettyPrint_rets	ZeroResult;
%  fnServerObjectPrettyPrint_rets		* pResult = NULL;
%  fnServerObjectPrettyPrint_rets		Result = ZeroResult;
%  fnServerObjectPrettyPrint_args	InArguments;
%
%  /* Client initialization: */
%  if ( __bClientInitialize__ ) {
%    __bClientInitialize__	= FALSE;
%    RPC_CLIENT_INITIALIZE();
%  }
%
%#if	CLIENT_CREATE_BY_USER
%  if ( __pClient__ == NULL ) {
%    __pClient__	= RPC_CLIENT_CREATE ( __szHost__, __szTransport__ );
%    if ( __pClient__ == NULL ) {
%      /* Error handling for a not connected client: */
%      char	szError [ 256 ];
%      sprintf ( szError, szFormatNoServer, __procedure__ );
%      RPC_CLIENT_ERROR ( szError );
%      return Result.ReturnValue;
%    }
%  }
%#else
%  while ( __pClient__ == NULL ) {
%    __pClient__	= RPC_CLIENT_CREATE ( __szHost__, __szTransport__ );
%    if ( __pClient__ == NULL ) {
%      /* Error handling for a not connected client: */
%      char	szError [ 256 ];
%      sprintf ( szError, szFormatNoServer, __procedure__ );
%      RPC_CLIENT_CERROR ( szContNoServer, szError );
%    }
%  }
%#endif	/* CLIENT_CREATE_BY_USER */
%
%  /* Copy in the oShortObjIdHeap argument: */
%  InArguments.oShortObjIdHeap	= oShortObjIdHeap;
%  /* Copy in the oShortObjId argument: */
%  InArguments.oShortObjId	= oShortObjId;
%  /* Copy in the nTypeTag argument: */
%  InArguments.nTypeTag	= nTypeTag;
%  /* Copy in the nBuffer argument: */
%  InArguments.nBuffer	= nBuffer;
%  InArguments.lpszBufferSize	= nBuffer;
%
%  pResult	=
%#ifdef MULTITHREAD
%    (
%#else
%    (fnServerObjectPrettyPrint_rets *)
%#endif
%    fnrpc_fnserverobjectprettyprint_1 (
%	&InArguments,
%#ifdef MULTITHREAD
%	&Result,
%#endif
%	__pClient__ )
%#ifdef MULTITHREAD
%	== RPC_SUCCESS ) ? &Result : NULL
%#endif
%	;
%
%  if ( pResult == NULL ) {
%    /* Error handling for a failed RPC call, */
%    /* i.e. the server did not respond: */
%    char	szError [ 256 ];
%    sprintf ( szError, szFormatRpcFailed, __procedure__,
%              clnt_sperror ( __pClient__, __szHost__ ) );
%    __pClient__	= RPC_CLIENT_DESTROY ( __pClient__ );
%    RPC_CLIENT_CERROR ( szContRpcFailed, szError );
%    Result	= ZeroResult;
%    return Result.ReturnValue;
%  }
%#ifndef MULTITHREAD
%  Result	= * pResult;
%#endif
%
%  /* Copy out the lpszBuffer argument: */
%  if ( ! ( 
%       pResult->lpszBuffer
%       && *(pResult->lpszBuffer) &&
%       lpszBuffer == NULL ) ) {
%    if ( lpszBuffer != NULL ) {
%      if ( pResult->lpszBuffer != NULL ) {
%        strncpy ( lpszBuffer, pResult->lpszBuffer, nBuffer );
%      } else {
%        *lpszBuffer	= (char) 0;
%      }
%    }
%  }
%
%  if ( pResult && pResult->nErrorLvl ) {
%    /* Server returned a user error message: */
%    char	szErrorMsg [ 1024 ];
%    strncpy ( szErrorMsg,
%              ( pResult->pszErrorMsg && pResult->pszErrorMsg [ 0 ] ) ?
%              (LPCSTR) pResult->pszErrorMsg : (LPCSTR) szEmpty,
%              sizeof ( szErrorMsg ) );
%    szErrorMsg [ sizeof ( szErrorMsg ) - 1 ]	= (char) 0;
%    xdr_free ( (xdrproc_t) xdr_fnServerObjectPrettyPrint_rets, (char *) pResult );
%    RPC_CLIENT_SERROR ( pResult->nErrorLvl, __procedure__,
%                        szErrorMsg );
%  } else {
%    xdr_free ( (xdrproc_t) xdr_fnServerObjectPrettyPrint_rets, (char *) pResult );
%  }
%  if ( 
%       Result.lpszBuffer
%       && *(Result.lpszBuffer) &&
%       lpszBuffer == NULL ) {
%    /* Error handling for passing a NULL pointer on */
%    /* out argument: */
%    char	szError [ 256 ];
%    sprintf ( szError, szFormatNullPassed,
%              __procedure__, "lpszBuffer" );
%    RPC_CLIENT_CERROR ( szContNullOutPassed, szError );
%  }
%
%  return Result.ReturnValue;
%
%} /* fnServerObjectPrettyPrint */
#endif	/* RPC_CLNT */
%
  fnShortPrintSymbol_rets fnRpc_fnShortPrintSymbol ( fnShortPrintSymbol_args ) =  53 ;
%
#if RPC_SVC
%
%extern int fnShortPrintSymbol
%	(SHORTOBJID oShortObjIdHeap ,
%	  SHORTOBJID oShortSymbol ,
%	  string_t /* string_t<nBuffer> */  lpszBuffer ,
%	  int nBuffer);
%
%#ifdef MULTITHREAD
%bool_t
%#else
%fnShortPrintSymbol_rets *
%#endif
%	PASTE2(fnrpc_fnshortprintsymbol_1,_SVCSUFFIX)
%		( fnShortPrintSymbol_args * pArguments,
%#ifdef MULTITHREAD
%		  fnShortPrintSymbol_rets * pResult,
%#endif
%		  struct svc_req * pRequest )
%{
%  static const char	__procedure__[]	= "server:fnrpc_fnshortprintsymbol_1";
%#ifdef MULTITHREAD
%  typedef bool_t RESULTTYPE;
%#else
%  typedef fnShortPrintSymbol_rets * RESULTTYPE;
%#endif
%#ifndef MULTITHREAD
%  static fnShortPrintSymbol_rets	Result;
%  RESULTTYPE			pResult = &Result;
%#endif
%  LPCSTR	pszErrorMsg;
%
%  __pRequest__	= pRequest;
%
%  RPC_SERVER_ENTRY();
%
%#ifndef MULTITHREAD
%  if ( pResult->pszErrorMsg == szEmpty ) {
%    pResult->pszErrorMsg	= NULL;
%  }
%  xdr_free ( (xdrproc_t) xdr_fnShortPrintSymbol_rets, (char *) pResult );
%#endif
%  pResult->nErrorLvl		= 0;
%
%  if ( pArguments->lpszBufferSize == 0 ) {
%    pResult->lpszBuffer	= NULL;
%  } else {
%    pResult->lpszBuffer	=
%    (string_t) malloc ( pArguments->lpszBufferSize );
%    if ( pResult->lpszBuffer == NULL ) {
%      char	szError [ 256 ];
%      sprintf ( szError, szFormatMallocFailed,
%                __procedure__, pArguments->lpszBufferSize );
%      RPC_SERVER_ERROR ( szError );
%      return (RESULTTYPE) NULL;
%    }
%  }
%  Reply.bAnswered		= FALSE;
%  Reply.pfnCalled		= (void(*)()) fnShortPrintSymbol;
%  Reply.pfnXdrResult		= (bool_t(*)()) xdr_fnShortPrintSymbol_rets;
%  Reply.pnErrorLvl		= &pResult->nErrorLvl;
%  Reply.ppszErrorMsg		= (LPCSTR *) &pResult->pszErrorMsg;
%  Reply.pResult		= pResult;
%  Reply.pReturnValue		= &pResult->ReturnValue;
%  Reply.nReturnValueSize	= sizeof ( pResult->ReturnValue );
%
%  pResult->ReturnValue		=
%  fnShortPrintSymbol (
%	pArguments->oShortObjIdHeap,
%	pArguments->oShortSymbol,
%	pResult->lpszBuffer,
%	pArguments->nBuffer );
%
%  if ( Reply.bAnswered ) {
%    __pRequest__	= NULL;
%    return (RESULTTYPE) NULL;
%  }
%
%  pResult->nErrorLvl	= RPC_SERVER_ERRLVL();
%  if ( pResult->nErrorLvl > 0 ) {
%    pszErrorMsg		= RPC_SERVER_ERRMSG();
%    if ( pszErrorMsg && *pszErrorMsg ) {
%      pResult->pszErrorMsg	= strdup ( pszErrorMsg );
%    }
%  }
%  if ( pResult->pszErrorMsg == NULL ) {
%#ifdef MULTITHREAD
%    pResult->pszErrorMsg	= strdup ( szEmpty );
%#else
%    pResult->pszErrorMsg	= (LPSTR) szEmpty;
%#endif
%  }
%  __pRequest__	= NULL;
%  return (RESULTTYPE) pResult;
%} /* fnrpc_fnshortprintsymbol_1 */
#endif	/* RPC_SVC */
%
#if RPC_CLNT
%int DLLEXPORT fnShortPrintSymbol
%	(SHORTOBJID oShortObjIdHeap ,
%	  SHORTOBJID oShortSymbol ,
%	  string_t /* string_t<nBuffer> */  lpszBuffer ,
%	  int nBuffer)
%{
%  static const char	__procedure__[]	= "client:fnShortPrintSymbol";
%  static fnShortPrintSymbol_rets	ZeroResult;
%  fnShortPrintSymbol_rets		* pResult = NULL;
%  fnShortPrintSymbol_rets		Result = ZeroResult;
%  fnShortPrintSymbol_args	InArguments;
%
%  /* Client initialization: */
%  if ( __bClientInitialize__ ) {
%    __bClientInitialize__	= FALSE;
%    RPC_CLIENT_INITIALIZE();
%  }
%
%#if	CLIENT_CREATE_BY_USER
%  if ( __pClient__ == NULL ) {
%    __pClient__	= RPC_CLIENT_CREATE ( __szHost__, __szTransport__ );
%    if ( __pClient__ == NULL ) {
%      /* Error handling for a not connected client: */
%      char	szError [ 256 ];
%      sprintf ( szError, szFormatNoServer, __procedure__ );
%      RPC_CLIENT_ERROR ( szError );
%      return Result.ReturnValue;
%    }
%  }
%#else
%  while ( __pClient__ == NULL ) {
%    __pClient__	= RPC_CLIENT_CREATE ( __szHost__, __szTransport__ );
%    if ( __pClient__ == NULL ) {
%      /* Error handling for a not connected client: */
%      char	szError [ 256 ];
%      sprintf ( szError, szFormatNoServer, __procedure__ );
%      RPC_CLIENT_CERROR ( szContNoServer, szError );
%    }
%  }
%#endif	/* CLIENT_CREATE_BY_USER */
%
%  /* Copy in the oShortObjIdHeap argument: */
%  InArguments.oShortObjIdHeap	= oShortObjIdHeap;
%  /* Copy in the oShortSymbol argument: */
%  InArguments.oShortSymbol	= oShortSymbol;
%  /* Copy in the nBuffer argument: */
%  InArguments.nBuffer	= nBuffer;
%  InArguments.lpszBufferSize	= nBuffer;
%
%  pResult	=
%#ifdef MULTITHREAD
%    (
%#else
%    (fnShortPrintSymbol_rets *)
%#endif
%    fnrpc_fnshortprintsymbol_1 (
%	&InArguments,
%#ifdef MULTITHREAD
%	&Result,
%#endif
%	__pClient__ )
%#ifdef MULTITHREAD
%	== RPC_SUCCESS ) ? &Result : NULL
%#endif
%	;
%
%  if ( pResult == NULL ) {
%    /* Error handling for a failed RPC call, */
%    /* i.e. the server did not respond: */
%    char	szError [ 256 ];
%    sprintf ( szError, szFormatRpcFailed, __procedure__,
%              clnt_sperror ( __pClient__, __szHost__ ) );
%    __pClient__	= RPC_CLIENT_DESTROY ( __pClient__ );
%    RPC_CLIENT_CERROR ( szContRpcFailed, szError );
%    Result	= ZeroResult;
%    return Result.ReturnValue;
%  }
%#ifndef MULTITHREAD
%  Result	= * pResult;
%#endif
%
%  /* Copy out the lpszBuffer argument: */
%  if ( ! ( 
%       pResult->lpszBuffer
%       && *(pResult->lpszBuffer) &&
%       lpszBuffer == NULL ) ) {
%    if ( lpszBuffer != NULL ) {
%      if ( pResult->lpszBuffer != NULL ) {
%        strncpy ( lpszBuffer, pResult->lpszBuffer, nBuffer );
%      } else {
%        *lpszBuffer	= (char) 0;
%      }
%    }
%  }
%
%  if ( pResult && pResult->nErrorLvl ) {
%    /* Server returned a user error message: */
%    char	szErrorMsg [ 1024 ];
%    strncpy ( szErrorMsg,
%              ( pResult->pszErrorMsg && pResult->pszErrorMsg [ 0 ] ) ?
%              (LPCSTR) pResult->pszErrorMsg : (LPCSTR) szEmpty,
%              sizeof ( szErrorMsg ) );
%    szErrorMsg [ sizeof ( szErrorMsg ) - 1 ]	= (char) 0;
%    xdr_free ( (xdrproc_t) xdr_fnShortPrintSymbol_rets, (char *) pResult );
%    RPC_CLIENT_SERROR ( pResult->nErrorLvl, __procedure__,
%                        szErrorMsg );
%  } else {
%    xdr_free ( (xdrproc_t) xdr_fnShortPrintSymbol_rets, (char *) pResult );
%  }
%  if ( 
%       Result.lpszBuffer
%       && *(Result.lpszBuffer) &&
%       lpszBuffer == NULL ) {
%    /* Error handling for passing a NULL pointer on */
%    /* out argument: */
%    char	szError [ 256 ];
%    sprintf ( szError, szFormatNullPassed,
%              __procedure__, "lpszBuffer" );
%    RPC_CLIENT_CERROR ( szContNullOutPassed, szError );
%  }
%
%  return Result.ReturnValue;
%
%} /* fnShortPrintSymbol */
#endif	/* RPC_CLNT */
%
  fnShortMakeSingleFloat_rets fnRpc_fnShortMakeSingleFloat ( fnShortMakeSingleFloat_args ) =  54 ;
%
#if RPC_SVC
%
%extern SHORTOBJID fnShortMakeSingleFloat
%	(SHORTOBJID oShortObjIdHeap ,
%	  float fFrom);
%
%#ifdef MULTITHREAD
%bool_t
%#else
%fnShortMakeSingleFloat_rets *
%#endif
%	PASTE2(fnrpc_fnshortmakesinglefloat_1,_SVCSUFFIX)
%		( fnShortMakeSingleFloat_args * pArguments,
%#ifdef MULTITHREAD
%		  fnShortMakeSingleFloat_rets * pResult,
%#endif
%		  struct svc_req * pRequest )
%{
%  static const char	__procedure__[]	= "server:fnrpc_fnshortmakesinglefloat_1";
%#ifdef MULTITHREAD
%  typedef bool_t RESULTTYPE;
%#else
%  typedef fnShortMakeSingleFloat_rets * RESULTTYPE;
%#endif
%#ifndef MULTITHREAD
%  static fnShortMakeSingleFloat_rets	Result;
%  RESULTTYPE			pResult = &Result;
%#endif
%  LPCSTR	pszErrorMsg;
%
%  __pRequest__	= pRequest;
%
%  RPC_SERVER_ENTRY();
%
%#ifndef MULTITHREAD
%  if ( pResult->pszErrorMsg == szEmpty ) {
%    pResult->pszErrorMsg	= NULL;
%  }
%  xdr_free ( (xdrproc_t) xdr_fnShortMakeSingleFloat_rets, (char *) pResult );
%#endif
%  pResult->nErrorLvl		= 0;
%
%  Reply.bAnswered		= FALSE;
%  Reply.pfnCalled		= (void(*)()) fnShortMakeSingleFloat;
%  Reply.pfnXdrResult		= (bool_t(*)()) xdr_fnShortMakeSingleFloat_rets;
%  Reply.pnErrorLvl		= &pResult->nErrorLvl;
%  Reply.ppszErrorMsg		= (LPCSTR *) &pResult->pszErrorMsg;
%  Reply.pResult		= pResult;
%  Reply.pReturnValue		= &pResult->ReturnValue;
%  Reply.nReturnValueSize	= sizeof ( pResult->ReturnValue );
%
%  pResult->ReturnValue		=
%  fnShortMakeSingleFloat (
%	pArguments->oShortObjIdHeap,
%	pArguments->fFrom );
%
%  if ( Reply.bAnswered ) {
%    __pRequest__	= NULL;
%    return (RESULTTYPE) NULL;
%  }
%
%  pResult->nErrorLvl	= RPC_SERVER_ERRLVL();
%  if ( pResult->nErrorLvl > 0 ) {
%    pszErrorMsg		= RPC_SERVER_ERRMSG();
%    if ( pszErrorMsg && *pszErrorMsg ) {
%      pResult->pszErrorMsg	= strdup ( pszErrorMsg );
%    }
%  }
%  if ( pResult->pszErrorMsg == NULL ) {
%#ifdef MULTITHREAD
%    pResult->pszErrorMsg	= strdup ( szEmpty );
%#else
%    pResult->pszErrorMsg	= (LPSTR) szEmpty;
%#endif
%  }
%  __pRequest__	= NULL;
%  return (RESULTTYPE) pResult;
%} /* fnrpc_fnshortmakesinglefloat_1 */
#endif	/* RPC_SVC */
%
#if RPC_CLNT
%SHORTOBJID DLLEXPORT fnShortMakeSingleFloat
%	(SHORTOBJID oShortObjIdHeap ,
%	  float fFrom)
%{
%  static const char	__procedure__[]	= "client:fnShortMakeSingleFloat";
%  static fnShortMakeSingleFloat_rets	ZeroResult;
%  fnShortMakeSingleFloat_rets		* pResult = NULL;
%  fnShortMakeSingleFloat_rets		Result = ZeroResult;
%  fnShortMakeSingleFloat_args	InArguments;
%
%  /* Client initialization: */
%  if ( __bClientInitialize__ ) {
%    __bClientInitialize__	= FALSE;
%    RPC_CLIENT_INITIALIZE();
%  }
%
%#if	CLIENT_CREATE_BY_USER
%  if ( __pClient__ == NULL ) {
%    __pClient__	= RPC_CLIENT_CREATE ( __szHost__, __szTransport__ );
%    if ( __pClient__ == NULL ) {
%      /* Error handling for a not connected client: */
%      char	szError [ 256 ];
%      sprintf ( szError, szFormatNoServer, __procedure__ );
%      RPC_CLIENT_ERROR ( szError );
%      return Result.ReturnValue;
%    }
%  }
%#else
%  while ( __pClient__ == NULL ) {
%    __pClient__	= RPC_CLIENT_CREATE ( __szHost__, __szTransport__ );
%    if ( __pClient__ == NULL ) {
%      /* Error handling for a not connected client: */
%      char	szError [ 256 ];
%      sprintf ( szError, szFormatNoServer, __procedure__ );
%      RPC_CLIENT_CERROR ( szContNoServer, szError );
%    }
%  }
%#endif	/* CLIENT_CREATE_BY_USER */
%
%  /* Copy in the oShortObjIdHeap argument: */
%  InArguments.oShortObjIdHeap	= oShortObjIdHeap;
%  /* Copy in the fFrom argument: */
%  InArguments.fFrom	= fFrom;
%
%  pResult	=
%#ifdef MULTITHREAD
%    (
%#else
%    (fnShortMakeSingleFloat_rets *)
%#endif
%    fnrpc_fnshortmakesinglefloat_1 (
%	&InArguments,
%#ifdef MULTITHREAD
%	&Result,
%#endif
%	__pClient__ )
%#ifdef MULTITHREAD
%	== RPC_SUCCESS ) ? &Result : NULL
%#endif
%	;
%
%  if ( pResult == NULL ) {
%    /* Error handling for a failed RPC call, */
%    /* i.e. the server did not respond: */
%    char	szError [ 256 ];
%    sprintf ( szError, szFormatRpcFailed, __procedure__,
%              clnt_sperror ( __pClient__, __szHost__ ) );
%    __pClient__	= RPC_CLIENT_DESTROY ( __pClient__ );
%    RPC_CLIENT_CERROR ( szContRpcFailed, szError );
%    Result	= ZeroResult;
%    return Result.ReturnValue;
%  }
%#ifndef MULTITHREAD
%  Result	= * pResult;
%#endif
%
%
%  if ( pResult && pResult->nErrorLvl ) {
%    /* Server returned a user error message: */
%    char	szErrorMsg [ 1024 ];
%    strncpy ( szErrorMsg,
%              ( pResult->pszErrorMsg && pResult->pszErrorMsg [ 0 ] ) ?
%              (LPCSTR) pResult->pszErrorMsg : (LPCSTR) szEmpty,
%              sizeof ( szErrorMsg ) );
%    szErrorMsg [ sizeof ( szErrorMsg ) - 1 ]	= (char) 0;
%    xdr_free ( (xdrproc_t) xdr_fnShortMakeSingleFloat_rets, (char *) pResult );
%    RPC_CLIENT_SERROR ( pResult->nErrorLvl, __procedure__,
%                        szErrorMsg );
%  } else {
%    xdr_free ( (xdrproc_t) xdr_fnShortMakeSingleFloat_rets, (char *) pResult );
%  }
%
%  return Result.ReturnValue;
%
%} /* fnShortMakeSingleFloat */
#endif	/* RPC_CLNT */
%
  fnShortMakeDoubleFloat_rets fnRpc_fnShortMakeDoubleFloat ( fnShortMakeDoubleFloat_args ) =  55 ;
%
#if RPC_SVC
%
%extern SHORTOBJID fnShortMakeDoubleFloat
%	(SHORTOBJID oShortObjIdHeap ,
%	  double fFrom);
%
%#ifdef MULTITHREAD
%bool_t
%#else
%fnShortMakeDoubleFloat_rets *
%#endif
%	PASTE2(fnrpc_fnshortmakedoublefloat_1,_SVCSUFFIX)
%		( fnShortMakeDoubleFloat_args * pArguments,
%#ifdef MULTITHREAD
%		  fnShortMakeDoubleFloat_rets * pResult,
%#endif
%		  struct svc_req * pRequest )
%{
%  static const char	__procedure__[]	= "server:fnrpc_fnshortmakedoublefloat_1";
%#ifdef MULTITHREAD
%  typedef bool_t RESULTTYPE;
%#else
%  typedef fnShortMakeDoubleFloat_rets * RESULTTYPE;
%#endif
%#ifndef MULTITHREAD
%  static fnShortMakeDoubleFloat_rets	Result;
%  RESULTTYPE			pResult = &Result;
%#endif
%  LPCSTR	pszErrorMsg;
%
%  __pRequest__	= pRequest;
%
%  RPC_SERVER_ENTRY();
%
%#ifndef MULTITHREAD
%  if ( pResult->pszErrorMsg == szEmpty ) {
%    pResult->pszErrorMsg	= NULL;
%  }
%  xdr_free ( (xdrproc_t) xdr_fnShortMakeDoubleFloat_rets, (char *) pResult );
%#endif
%  pResult->nErrorLvl		= 0;
%
%  Reply.bAnswered		= FALSE;
%  Reply.pfnCalled		= (void(*)()) fnShortMakeDoubleFloat;
%  Reply.pfnXdrResult		= (bool_t(*)()) xdr_fnShortMakeDoubleFloat_rets;
%  Reply.pnErrorLvl		= &pResult->nErrorLvl;
%  Reply.ppszErrorMsg		= (LPCSTR *) &pResult->pszErrorMsg;
%  Reply.pResult		= pResult;
%  Reply.pReturnValue		= &pResult->ReturnValue;
%  Reply.nReturnValueSize	= sizeof ( pResult->ReturnValue );
%
%  pResult->ReturnValue		=
%  fnShortMakeDoubleFloat (
%	pArguments->oShortObjIdHeap,
%	pArguments->fFrom );
%
%  if ( Reply.bAnswered ) {
%    __pRequest__	= NULL;
%    return (RESULTTYPE) NULL;
%  }
%
%  pResult->nErrorLvl	= RPC_SERVER_ERRLVL();
%  if ( pResult->nErrorLvl > 0 ) {
%    pszErrorMsg		= RPC_SERVER_ERRMSG();
%    if ( pszErrorMsg && *pszErrorMsg ) {
%      pResult->pszErrorMsg	= strdup ( pszErrorMsg );
%    }
%  }
%  if ( pResult->pszErrorMsg == NULL ) {
%#ifdef MULTITHREAD
%    pResult->pszErrorMsg	= strdup ( szEmpty );
%#else
%    pResult->pszErrorMsg	= (LPSTR) szEmpty;
%#endif
%  }
%  __pRequest__	= NULL;
%  return (RESULTTYPE) pResult;
%} /* fnrpc_fnshortmakedoublefloat_1 */
#endif	/* RPC_SVC */
%
#if RPC_CLNT
%SHORTOBJID DLLEXPORT fnShortMakeDoubleFloat
%	(SHORTOBJID oShortObjIdHeap ,
%	  double fFrom)
%{
%  static const char	__procedure__[]	= "client:fnShortMakeDoubleFloat";
%  static fnShortMakeDoubleFloat_rets	ZeroResult;
%  fnShortMakeDoubleFloat_rets		* pResult = NULL;
%  fnShortMakeDoubleFloat_rets		Result = ZeroResult;
%  fnShortMakeDoubleFloat_args	InArguments;
%
%  /* Client initialization: */
%  if ( __bClientInitialize__ ) {
%    __bClientInitialize__	= FALSE;
%    RPC_CLIENT_INITIALIZE();
%  }
%
%#if	CLIENT_CREATE_BY_USER
%  if ( __pClient__ == NULL ) {
%    __pClient__	= RPC_CLIENT_CREATE ( __szHost__, __szTransport__ );
%    if ( __pClient__ == NULL ) {
%      /* Error handling for a not connected client: */
%      char	szError [ 256 ];
%      sprintf ( szError, szFormatNoServer, __procedure__ );
%      RPC_CLIENT_ERROR ( szError );
%      return Result.ReturnValue;
%    }
%  }
%#else
%  while ( __pClient__ == NULL ) {
%    __pClient__	= RPC_CLIENT_CREATE ( __szHost__, __szTransport__ );
%    if ( __pClient__ == NULL ) {
%      /* Error handling for a not connected client: */
%      char	szError [ 256 ];
%      sprintf ( szError, szFormatNoServer, __procedure__ );
%      RPC_CLIENT_CERROR ( szContNoServer, szError );
%    }
%  }
%#endif	/* CLIENT_CREATE_BY_USER */
%
%  /* Copy in the oShortObjIdHeap argument: */
%  InArguments.oShortObjIdHeap	= oShortObjIdHeap;
%  /* Copy in the fFrom argument: */
%  InArguments.fFrom	= fFrom;
%
%  pResult	=
%#ifdef MULTITHREAD
%    (
%#else
%    (fnShortMakeDoubleFloat_rets *)
%#endif
%    fnrpc_fnshortmakedoublefloat_1 (
%	&InArguments,
%#ifdef MULTITHREAD
%	&Result,
%#endif
%	__pClient__ )
%#ifdef MULTITHREAD
%	== RPC_SUCCESS ) ? &Result : NULL
%#endif
%	;
%
%  if ( pResult == NULL ) {
%    /* Error handling for a failed RPC call, */
%    /* i.e. the server did not respond: */
%    char	szError [ 256 ];
%    sprintf ( szError, szFormatRpcFailed, __procedure__,
%              clnt_sperror ( __pClient__, __szHost__ ) );
%    __pClient__	= RPC_CLIENT_DESTROY ( __pClient__ );
%    RPC_CLIENT_CERROR ( szContRpcFailed, szError );
%    Result	= ZeroResult;
%    return Result.ReturnValue;
%  }
%#ifndef MULTITHREAD
%  Result	= * pResult;
%#endif
%
%
%  if ( pResult && pResult->nErrorLvl ) {
%    /* Server returned a user error message: */
%    char	szErrorMsg [ 1024 ];
%    strncpy ( szErrorMsg,
%              ( pResult->pszErrorMsg && pResult->pszErrorMsg [ 0 ] ) ?
%              (LPCSTR) pResult->pszErrorMsg : (LPCSTR) szEmpty,
%              sizeof ( szErrorMsg ) );
%    szErrorMsg [ sizeof ( szErrorMsg ) - 1 ]	= (char) 0;
%    xdr_free ( (xdrproc_t) xdr_fnShortMakeDoubleFloat_rets, (char *) pResult );
%    RPC_CLIENT_SERROR ( pResult->nErrorLvl, __procedure__,
%                        szErrorMsg );
%  } else {
%    xdr_free ( (xdrproc_t) xdr_fnShortMakeDoubleFloat_rets, (char *) pResult );
%  }
%
%  return Result.ReturnValue;
%
%} /* fnShortMakeDoubleFloat */
#endif	/* RPC_CLNT */
%
  fnServerDbMakeBignum_rets fnRpc_fnServerDbMakeBignum ( fnServerDbMakeBignum_args ) =  56 ;
%
#if RPC_SVC
%
%extern SHORTOBJID fnServerDbMakeBignum
%	(SHORTOBJID oShortObjIdHeap ,
%	  SHORTOBJID oShortObjIdFormat ,
%	  int nSizeInBits ,
%	  as_is * /* _vector_t<((( AlignBitsToWords ( ABS ( nSizeInBits ) ) )*( sizeof(int) )) )> */ pnBignum);
%
%#ifdef MULTITHREAD
%bool_t
%#else
%fnServerDbMakeBignum_rets *
%#endif
%	PASTE2(fnrpc_fnserverdbmakebignum_1,_SVCSUFFIX)
%		( fnServerDbMakeBignum_args * pArguments,
%#ifdef MULTITHREAD
%		  fnServerDbMakeBignum_rets * pResult,
%#endif
%		  struct svc_req * pRequest )
%{
%  static const char	__procedure__[]	= "server:fnrpc_fnserverdbmakebignum_1";
%#ifdef MULTITHREAD
%  typedef bool_t RESULTTYPE;
%#else
%  typedef fnServerDbMakeBignum_rets * RESULTTYPE;
%#endif
%#ifndef MULTITHREAD
%  static fnServerDbMakeBignum_rets	Result;
%  RESULTTYPE			pResult = &Result;
%#endif
%  LPCSTR	pszErrorMsg;
%
%  __pRequest__	= pRequest;
%
%  RPC_SERVER_ENTRY();
%
%#ifndef MULTITHREAD
%  if ( pResult->pszErrorMsg == szEmpty ) {
%    pResult->pszErrorMsg	= NULL;
%  }
%  xdr_free ( (xdrproc_t) xdr_fnServerDbMakeBignum_rets, (char *) pResult );
%#endif
%  pResult->nErrorLvl		= 0;
%
%  Reply.bAnswered		= FALSE;
%  Reply.pfnCalled		= (void(*)()) fnServerDbMakeBignum;
%  Reply.pfnXdrResult		= (bool_t(*)()) xdr_fnServerDbMakeBignum_rets;
%  Reply.pnErrorLvl		= &pResult->nErrorLvl;
%  Reply.ppszErrorMsg		= (LPCSTR *) &pResult->pszErrorMsg;
%  Reply.pResult		= pResult;
%  Reply.pReturnValue		= &pResult->ReturnValue;
%  Reply.nReturnValueSize	= sizeof ( pResult->ReturnValue );
%
%  pResult->ReturnValue		=
%  fnServerDbMakeBignum (
%	pArguments->oShortObjIdHeap,
%	pArguments->oShortObjIdFormat,
%	pArguments->nSizeInBits,
%	pArguments->pnBignum.as_is_vector_t_val );
%
%  if ( Reply.bAnswered ) {
%    __pRequest__	= NULL;
%    return (RESULTTYPE) NULL;
%  }
%
%  pResult->nErrorLvl	= RPC_SERVER_ERRLVL();
%  if ( pResult->nErrorLvl > 0 ) {
%    pszErrorMsg		= RPC_SERVER_ERRMSG();
%    if ( pszErrorMsg && *pszErrorMsg ) {
%      pResult->pszErrorMsg	= strdup ( pszErrorMsg );
%    }
%  }
%  if ( pResult->pszErrorMsg == NULL ) {
%#ifdef MULTITHREAD
%    pResult->pszErrorMsg	= strdup ( szEmpty );
%#else
%    pResult->pszErrorMsg	= (LPSTR) szEmpty;
%#endif
%  }
%  __pRequest__	= NULL;
%  return (RESULTTYPE) pResult;
%} /* fnrpc_fnserverdbmakebignum_1 */
#endif	/* RPC_SVC */
%
#if RPC_CLNT
%SHORTOBJID DLLEXPORT fnServerDbMakeBignum
%	(SHORTOBJID oShortObjIdHeap ,
%	  SHORTOBJID oShortObjIdFormat ,
%	  int nSizeInBits ,
%	  as_is * /* _vector_t<((( AlignBitsToWords ( ABS ( nSizeInBits ) ) )*( sizeof(int) )) )> */ pnBignum)
%{
%  static const char	__procedure__[]	= "client:fnServerDbMakeBignum";
%  static fnServerDbMakeBignum_rets	ZeroResult;
%  fnServerDbMakeBignum_rets		* pResult = NULL;
%  fnServerDbMakeBignum_rets		Result = ZeroResult;
%  fnServerDbMakeBignum_args	InArguments;
%
%  /* Client initialization: */
%  if ( __bClientInitialize__ ) {
%    __bClientInitialize__	= FALSE;
%    RPC_CLIENT_INITIALIZE();
%  }
%
%#if	CLIENT_CREATE_BY_USER
%  if ( __pClient__ == NULL ) {
%    __pClient__	= RPC_CLIENT_CREATE ( __szHost__, __szTransport__ );
%    if ( __pClient__ == NULL ) {
%      /* Error handling for a not connected client: */
%      char	szError [ 256 ];
%      sprintf ( szError, szFormatNoServer, __procedure__ );
%      RPC_CLIENT_ERROR ( szError );
%      return Result.ReturnValue;
%    }
%  }
%#else
%  while ( __pClient__ == NULL ) {
%    __pClient__	= RPC_CLIENT_CREATE ( __szHost__, __szTransport__ );
%    if ( __pClient__ == NULL ) {
%      /* Error handling for a not connected client: */
%      char	szError [ 256 ];
%      sprintf ( szError, szFormatNoServer, __procedure__ );
%      RPC_CLIENT_CERROR ( szContNoServer, szError );
%    }
%  }
%#endif	/* CLIENT_CREATE_BY_USER */
%
%  /* Copy in the oShortObjIdHeap argument: */
%  InArguments.oShortObjIdHeap	= oShortObjIdHeap;
%  /* Copy in the oShortObjIdFormat argument: */
%  InArguments.oShortObjIdFormat	= oShortObjIdFormat;
%  /* Copy in the nSizeInBits argument: */
%  InArguments.nSizeInBits	= nSizeInBits;
%  /* Copy in the pnBignum argument: */
%  InArguments.pnBignum.as_is_vector_t_len	= ((( AlignBitsToWords ( ABS ( nSizeInBits ) ) )*( sizeof(int) )) );
%  InArguments.pnBignum.as_is_vector_t_val	= pnBignum;
%  if ( InArguments.pnBignum.as_is_vector_t_len != 0 && pnBignum == NULL ) {
%    /* Error handling for passing a NULL pointer on */
%    /* VECTOR declared in argument: */
%    char	szError [ 256 ];
%    InArguments.pnBignum.as_is_vector_t_len	= 0;
%    sprintf ( szError, szFormatNullPassed,
%              __procedure__, "pnBignum" );
%    RPC_CLIENT_CERROR ( szContNullPassed, szError );
%  }
%
%  pResult	=
%#ifdef MULTITHREAD
%    (
%#else
%    (fnServerDbMakeBignum_rets *)
%#endif
%    fnrpc_fnserverdbmakebignum_1 (
%	&InArguments,
%#ifdef MULTITHREAD
%	&Result,
%#endif
%	__pClient__ )
%#ifdef MULTITHREAD
%	== RPC_SUCCESS ) ? &Result : NULL
%#endif
%	;
%
%  if ( pResult == NULL ) {
%    /* Error handling for a failed RPC call, */
%    /* i.e. the server did not respond: */
%    char	szError [ 256 ];
%    sprintf ( szError, szFormatRpcFailed, __procedure__,
%              clnt_sperror ( __pClient__, __szHost__ ) );
%    __pClient__	= RPC_CLIENT_DESTROY ( __pClient__ );
%    RPC_CLIENT_CERROR ( szContRpcFailed, szError );
%    Result	= ZeroResult;
%    return Result.ReturnValue;
%  }
%#ifndef MULTITHREAD
%  Result	= * pResult;
%#endif
%
%
%  if ( pResult && pResult->nErrorLvl ) {
%    /* Server returned a user error message: */
%    char	szErrorMsg [ 1024 ];
%    strncpy ( szErrorMsg,
%              ( pResult->pszErrorMsg && pResult->pszErrorMsg [ 0 ] ) ?
%              (LPCSTR) pResult->pszErrorMsg : (LPCSTR) szEmpty,
%              sizeof ( szErrorMsg ) );
%    szErrorMsg [ sizeof ( szErrorMsg ) - 1 ]	= (char) 0;
%    xdr_free ( (xdrproc_t) xdr_fnServerDbMakeBignum_rets, (char *) pResult );
%    RPC_CLIENT_SERROR ( pResult->nErrorLvl, __procedure__,
%                        szErrorMsg );
%  } else {
%    xdr_free ( (xdrproc_t) xdr_fnServerDbMakeBignum_rets, (char *) pResult );
%  }
%
%  return Result.ReturnValue;
%
%} /* fnServerDbMakeBignum */
#endif	/* RPC_CLNT */
%
  fnServerObjectReadBignum_rets fnRpc_fnServerObjectReadBignum ( fnServerObjectReadBignum_args ) =  57 ;
%
#if RPC_SVC
%
%extern SHLOCK fnServerObjectReadBignum
%	(SHORTOBJID oShortObjIdHeap ,
%	  SHORTOBJID oShortObjIdFormat ,
%	  SHORTOBJID oShortObjId ,
%	  int nSizeInBits ,
%	  as_is * /* _vector_t<((( AlignBitsToWords ( ABS ( nSizeInBits ) ) )*( sizeof(int) )) )> */  pnBignum);
%
%#ifdef MULTITHREAD
%bool_t
%#else
%fnServerObjectReadBignum_rets *
%#endif
%	PASTE2(fnrpc_fnserverobjectreadbignum_1,_SVCSUFFIX)
%		( fnServerObjectReadBignum_args * pArguments,
%#ifdef MULTITHREAD
%		  fnServerObjectReadBignum_rets * pResult,
%#endif
%		  struct svc_req * pRequest )
%{
%  static const char	__procedure__[]	= "server:fnrpc_fnserverobjectreadbignum_1";
%#ifdef MULTITHREAD
%  typedef bool_t RESULTTYPE;
%#else
%  typedef fnServerObjectReadBignum_rets * RESULTTYPE;
%#endif
%#ifndef MULTITHREAD
%  static fnServerObjectReadBignum_rets	Result;
%  RESULTTYPE			pResult = &Result;
%#endif
%  LPCSTR	pszErrorMsg;
%
%  __pRequest__	= pRequest;
%
%  RPC_SERVER_ENTRY();
%
%#ifndef MULTITHREAD
%  if ( pResult->pszErrorMsg == szEmpty ) {
%    pResult->pszErrorMsg	= NULL;
%  }
%  xdr_free ( (xdrproc_t) xdr_fnServerObjectReadBignum_rets, (char *) pResult );
%#endif
%  pResult->nErrorLvl		= 0;
%
%  pResult->pnBignum.as_is_vector_t_len	= pArguments->pnBignumSize;
%  if ( pArguments->pnBignumSize == 0 ) {
%    pResult->pnBignum.as_is_vector_t_val	= NULL;
%  } else {
%    pResult->pnBignum.as_is_vector_t_val	=
%      (char*) malloc ( pArguments->pnBignumSize *
%               SIZEOF ( *(pResult->pnBignum.as_is_vector_t_val) ) );
%    if ( pResult->pnBignum.as_is_vector_t_val == NULL ) {
%      char	szError [ 256 ];
%      sprintf ( szError, szFormatMallocFailed,
%                __procedure__, pArguments->pnBignumSize,
%                "pnBignum" );
%      RPC_SERVER_ERROR ( szError );
%      return (RESULTTYPE) NULL;
%    }
%  }
%  Reply.bAnswered		= FALSE;
%  Reply.pfnCalled		= (void(*)()) fnServerObjectReadBignum;
%  Reply.pfnXdrResult		= (bool_t(*)()) xdr_fnServerObjectReadBignum_rets;
%  Reply.pnErrorLvl		= &pResult->nErrorLvl;
%  Reply.ppszErrorMsg		= (LPCSTR *) &pResult->pszErrorMsg;
%  Reply.pResult		= pResult;
%  Reply.pReturnValue		= &pResult->ReturnValue;
%  Reply.nReturnValueSize	= sizeof ( pResult->ReturnValue );
%
%  pResult->ReturnValue		=
%  fnServerObjectReadBignum (
%	pArguments->oShortObjIdHeap,
%	pArguments->oShortObjIdFormat,
%	pArguments->oShortObjId,
%	pArguments->nSizeInBits,
%	pResult->pnBignum.as_is_vector_t_val );
%
%  if ( Reply.bAnswered ) {
%    __pRequest__	= NULL;
%    return (RESULTTYPE) NULL;
%  }
%
%  pResult->nErrorLvl	= RPC_SERVER_ERRLVL();
%  if ( pResult->nErrorLvl > 0 ) {
%    pszErrorMsg		= RPC_SERVER_ERRMSG();
%    if ( pszErrorMsg && *pszErrorMsg ) {
%      pResult->pszErrorMsg	= strdup ( pszErrorMsg );
%    }
%  }
%  if ( pResult->pszErrorMsg == NULL ) {
%#ifdef MULTITHREAD
%    pResult->pszErrorMsg	= strdup ( szEmpty );
%#else
%    pResult->pszErrorMsg	= (LPSTR) szEmpty;
%#endif
%  }
%  __pRequest__	= NULL;
%  return (RESULTTYPE) pResult;
%} /* fnrpc_fnserverobjectreadbignum_1 */
#endif	/* RPC_SVC */
%
#if RPC_CLNT
%SHLOCK DLLEXPORT fnServerObjectReadBignum
%	(SHORTOBJID oShortObjIdHeap ,
%	  SHORTOBJID oShortObjIdFormat ,
%	  SHORTOBJID oShortObjId ,
%	  int nSizeInBits ,
%	  as_is * /* _vector_t<((( AlignBitsToWords ( ABS ( nSizeInBits ) ) )*( sizeof(int) )) )> */  pnBignum)
%{
%  static const char	__procedure__[]	= "client:fnServerObjectReadBignum";
%  static fnServerObjectReadBignum_rets	ZeroResult;
%  fnServerObjectReadBignum_rets		* pResult = NULL;
%  fnServerObjectReadBignum_rets		Result = ZeroResult;
%  fnServerObjectReadBignum_args	InArguments;
%
%  /* Client initialization: */
%  if ( __bClientInitialize__ ) {
%    __bClientInitialize__	= FALSE;
%    RPC_CLIENT_INITIALIZE();
%  }
%
%#if	CLIENT_CREATE_BY_USER
%  if ( __pClient__ == NULL ) {
%    __pClient__	= RPC_CLIENT_CREATE ( __szHost__, __szTransport__ );
%    if ( __pClient__ == NULL ) {
%      /* Error handling for a not connected client: */
%      char	szError [ 256 ];
%      sprintf ( szError, szFormatNoServer, __procedure__ );
%      RPC_CLIENT_ERROR ( szError );
%      return Result.ReturnValue;
%    }
%  }
%#else
%  while ( __pClient__ == NULL ) {
%    __pClient__	= RPC_CLIENT_CREATE ( __szHost__, __szTransport__ );
%    if ( __pClient__ == NULL ) {
%      /* Error handling for a not connected client: */
%      char	szError [ 256 ];
%      sprintf ( szError, szFormatNoServer, __procedure__ );
%      RPC_CLIENT_CERROR ( szContNoServer, szError );
%    }
%  }
%#endif	/* CLIENT_CREATE_BY_USER */
%
%  /* Copy in the oShortObjIdHeap argument: */
%  InArguments.oShortObjIdHeap	= oShortObjIdHeap;
%  /* Copy in the oShortObjIdFormat argument: */
%  InArguments.oShortObjIdFormat	= oShortObjIdFormat;
%  /* Copy in the oShortObjId argument: */
%  InArguments.oShortObjId	= oShortObjId;
%  /* Copy in the nSizeInBits argument: */
%  InArguments.nSizeInBits	= nSizeInBits;
%  InArguments.pnBignumSize	= ((( AlignBitsToWords ( ABS ( nSizeInBits ) ) )*( sizeof(int) )) );
%
%  pResult	=
%#ifdef MULTITHREAD
%    (
%#else
%    (fnServerObjectReadBignum_rets *)
%#endif
%    fnrpc_fnserverobjectreadbignum_1 (
%	&InArguments,
%#ifdef MULTITHREAD
%	&Result,
%#endif
%	__pClient__ )
%#ifdef MULTITHREAD
%	== RPC_SUCCESS ) ? &Result : NULL
%#endif
%	;
%
%  if ( pResult == NULL ) {
%    /* Error handling for a failed RPC call, */
%    /* i.e. the server did not respond: */
%    char	szError [ 256 ];
%    sprintf ( szError, szFormatRpcFailed, __procedure__,
%              clnt_sperror ( __pClient__, __szHost__ ) );
%    __pClient__	= RPC_CLIENT_DESTROY ( __pClient__ );
%    RPC_CLIENT_CERROR ( szContRpcFailed, szError );
%    Result	= ZeroResult;
%    return Result.ReturnValue;
%  }
%#ifndef MULTITHREAD
%  Result	= * pResult;
%#endif
%
%  /* Copy out the pnBignum argument: */
%  if ( ! ( 
%       pResult->pnBignum.as_is_vector_t_len != 0 &&
%       pnBignum == NULL ) ) {
%    memcpy ( pnBignum,
%             pResult->pnBignum.as_is_vector_t_val,
%             MIN ( pResult->pnBignum.as_is_vector_t_len,
%                   ((( AlignBitsToWords ( ABS ( nSizeInBits ) ) )*( sizeof(int) )) ) ) *
%             SIZEOF ( *(pResult->pnBignum.as_is_vector_t_val) ) );
%  }
%
%  if ( pResult && pResult->nErrorLvl ) {
%    /* Server returned a user error message: */
%    char	szErrorMsg [ 1024 ];
%    strncpy ( szErrorMsg,
%              ( pResult->pszErrorMsg && pResult->pszErrorMsg [ 0 ] ) ?
%              (LPCSTR) pResult->pszErrorMsg : (LPCSTR) szEmpty,
%              sizeof ( szErrorMsg ) );
%    szErrorMsg [ sizeof ( szErrorMsg ) - 1 ]	= (char) 0;
%    xdr_free ( (xdrproc_t) xdr_fnServerObjectReadBignum_rets, (char *) pResult );
%    RPC_CLIENT_SERROR ( pResult->nErrorLvl, __procedure__,
%                        szErrorMsg );
%  } else {
%    xdr_free ( (xdrproc_t) xdr_fnServerObjectReadBignum_rets, (char *) pResult );
%  }
%  if ( 
%       pResult->pnBignum.as_is_vector_t_len != 0 &&
%       pnBignum == NULL ) {
%    /* Error handling for passing a NULL pointer on */
%    /* out argument: */
%    char	szError [ 256 ];
%    sprintf ( szError, szFormatNullPassed,
%              __procedure__, "pnBignum" );
%    RPC_CLIENT_CERROR ( szContNullOutPassed, szError );
%  } else if ( pResult->pnBignum.as_is_vector_t_len > ((( AlignBitsToWords ( ABS ( nSizeInBits ) ) )*( sizeof(int) )) ) ) {
%      /* Error handling for an output buffer overflow, */
%      /* i.e. the buffer size passed is too small: */
%      /* For example, signal a CERROR here ... */
%      char	szError [ 256 ];
%      sprintf ( szError, szFormatBufferOverflow,
%                __procedure__, "pnBignum", 
%                ((( AlignBitsToWords ( ABS ( nSizeInBits ) ) )*( sizeof(int) )) ), 
%                pResult->pnBignum.as_is_vector_t_len );
%      RPC_CLIENT_CERROR ( szContBufferOverflow, szError );
%  }
%
%  return Result.ReturnValue;
%
%} /* fnServerObjectReadBignum */
#endif	/* RPC_CLNT */
%
  fnServerObjectReadDoubleFloat_rets fnRpc_fnServerObjectReadDoubleFloat ( fnServerObjectReadDoubleFloat_args ) =  58 ;
%
#if RPC_SVC
%
%extern SHLOCK fnServerObjectReadDoubleFloat
%	(SHORTOBJID oShortObjIdHeap ,
%	  SHORTOBJID oShortObjId ,
%	  double * pfDoubleFloat);
%
%#ifdef MULTITHREAD
%bool_t
%#else
%fnServerObjectReadDoubleFloat_rets *
%#endif
%	PASTE2(fnrpc_fnserverobjectreaddoublefloat_1,_SVCSUFFIX)
%		( fnServerObjectReadDoubleFloat_args * pArguments,
%#ifdef MULTITHREAD
%		  fnServerObjectReadDoubleFloat_rets * pResult,
%#endif
%		  struct svc_req * pRequest )
%{
%  static const char	__procedure__[]	= "server:fnrpc_fnserverobjectreaddoublefloat_1";
%#ifdef MULTITHREAD
%  typedef bool_t RESULTTYPE;
%#else
%  typedef fnServerObjectReadDoubleFloat_rets * RESULTTYPE;
%#endif
%#ifndef MULTITHREAD
%  static fnServerObjectReadDoubleFloat_rets	Result;
%  RESULTTYPE			pResult = &Result;
%#endif
%  LPCSTR	pszErrorMsg;
%
%  __pRequest__	= pRequest;
%
%  RPC_SERVER_ENTRY();
%
%#ifndef MULTITHREAD
%  if ( pResult->pszErrorMsg == szEmpty ) {
%    pResult->pszErrorMsg	= NULL;
%  }
%  xdr_free ( (xdrproc_t) xdr_fnServerObjectReadDoubleFloat_rets, (char *) pResult );
%#endif
%  pResult->nErrorLvl		= 0;
%
%  Reply.bAnswered		= FALSE;
%  Reply.pfnCalled		= (void(*)()) fnServerObjectReadDoubleFloat;
%  Reply.pfnXdrResult		= (bool_t(*)()) xdr_fnServerObjectReadDoubleFloat_rets;
%  Reply.pnErrorLvl		= &pResult->nErrorLvl;
%  Reply.ppszErrorMsg		= (LPCSTR *) &pResult->pszErrorMsg;
%  Reply.pResult		= pResult;
%  Reply.pReturnValue		= &pResult->ReturnValue;
%  Reply.nReturnValueSize	= sizeof ( pResult->ReturnValue );
%
%  pResult->ReturnValue		=
%  fnServerObjectReadDoubleFloat (
%	pArguments->oShortObjIdHeap,
%	pArguments->oShortObjId,
%	&pResult->pfDoubleFloat );
%
%  if ( Reply.bAnswered ) {
%    __pRequest__	= NULL;
%    return (RESULTTYPE) NULL;
%  }
%
%  pResult->nErrorLvl	= RPC_SERVER_ERRLVL();
%  if ( pResult->nErrorLvl > 0 ) {
%    pszErrorMsg		= RPC_SERVER_ERRMSG();
%    if ( pszErrorMsg && *pszErrorMsg ) {
%      pResult->pszErrorMsg	= strdup ( pszErrorMsg );
%    }
%  }
%  if ( pResult->pszErrorMsg == NULL ) {
%#ifdef MULTITHREAD
%    pResult->pszErrorMsg	= strdup ( szEmpty );
%#else
%    pResult->pszErrorMsg	= (LPSTR) szEmpty;
%#endif
%  }
%  __pRequest__	= NULL;
%  return (RESULTTYPE) pResult;
%} /* fnrpc_fnserverobjectreaddoublefloat_1 */
#endif	/* RPC_SVC */
%
#if RPC_CLNT
%SHLOCK DLLEXPORT fnServerObjectReadDoubleFloat
%	(SHORTOBJID oShortObjIdHeap ,
%	  SHORTOBJID oShortObjId ,
%	  double * pfDoubleFloat)
%{
%  static const char	__procedure__[]	= "client:fnServerObjectReadDoubleFloat";
%  static fnServerObjectReadDoubleFloat_rets	ZeroResult;
%  fnServerObjectReadDoubleFloat_rets		* pResult = NULL;
%  fnServerObjectReadDoubleFloat_rets		Result = ZeroResult;
%  fnServerObjectReadDoubleFloat_args	InArguments;
%
%  /* Client initialization: */
%  if ( __bClientInitialize__ ) {
%    __bClientInitialize__	= FALSE;
%    RPC_CLIENT_INITIALIZE();
%  }
%
%#if	CLIENT_CREATE_BY_USER
%  if ( __pClient__ == NULL ) {
%    __pClient__	= RPC_CLIENT_CREATE ( __szHost__, __szTransport__ );
%    if ( __pClient__ == NULL ) {
%      /* Error handling for a not connected client: */
%      char	szError [ 256 ];
%      sprintf ( szError, szFormatNoServer, __procedure__ );
%      RPC_CLIENT_ERROR ( szError );
%      return Result.ReturnValue;
%    }
%  }
%#else
%  while ( __pClient__ == NULL ) {
%    __pClient__	= RPC_CLIENT_CREATE ( __szHost__, __szTransport__ );
%    if ( __pClient__ == NULL ) {
%      /* Error handling for a not connected client: */
%      char	szError [ 256 ];
%      sprintf ( szError, szFormatNoServer, __procedure__ );
%      RPC_CLIENT_CERROR ( szContNoServer, szError );
%    }
%  }
%#endif	/* CLIENT_CREATE_BY_USER */
%
%  /* Copy in the oShortObjIdHeap argument: */
%  InArguments.oShortObjIdHeap	= oShortObjIdHeap;
%  /* Copy in the oShortObjId argument: */
%  InArguments.oShortObjId	= oShortObjId;
%
%  pResult	=
%#ifdef MULTITHREAD
%    (
%#else
%    (fnServerObjectReadDoubleFloat_rets *)
%#endif
%    fnrpc_fnserverobjectreaddoublefloat_1 (
%	&InArguments,
%#ifdef MULTITHREAD
%	&Result,
%#endif
%	__pClient__ )
%#ifdef MULTITHREAD
%	== RPC_SUCCESS ) ? &Result : NULL
%#endif
%	;
%
%  if ( pResult == NULL ) {
%    /* Error handling for a failed RPC call, */
%    /* i.e. the server did not respond: */
%    char	szError [ 256 ];
%    sprintf ( szError, szFormatRpcFailed, __procedure__,
%              clnt_sperror ( __pClient__, __szHost__ ) );
%    __pClient__	= RPC_CLIENT_DESTROY ( __pClient__ );
%    RPC_CLIENT_CERROR ( szContRpcFailed, szError );
%    Result	= ZeroResult;
%    return Result.ReturnValue;
%  }
%#ifndef MULTITHREAD
%  Result	= * pResult;
%#endif
%
%  /* Copy out the pfDoubleFloat argument: */
%  if ( ! ( 
%       pfDoubleFloat == NULL ) ) {
%    *pfDoubleFloat	= pResult->pfDoubleFloat;
%  }
%
%  if ( pResult && pResult->nErrorLvl ) {
%    /* Server returned a user error message: */
%    char	szErrorMsg [ 1024 ];
%    strncpy ( szErrorMsg,
%              ( pResult->pszErrorMsg && pResult->pszErrorMsg [ 0 ] ) ?
%              (LPCSTR) pResult->pszErrorMsg : (LPCSTR) szEmpty,
%              sizeof ( szErrorMsg ) );
%    szErrorMsg [ sizeof ( szErrorMsg ) - 1 ]	= (char) 0;
%    xdr_free ( (xdrproc_t) xdr_fnServerObjectReadDoubleFloat_rets, (char *) pResult );
%    RPC_CLIENT_SERROR ( pResult->nErrorLvl, __procedure__,
%                        szErrorMsg );
%  } else {
%    xdr_free ( (xdrproc_t) xdr_fnServerObjectReadDoubleFloat_rets, (char *) pResult );
%  }
%  if ( 
%       pfDoubleFloat == NULL ) {
%    /* Error handling for passing a NULL pointer on */
%    /* out argument: */
%    char	szError [ 256 ];
%    sprintf ( szError, szFormatNullPassed,
%              __procedure__, "pfDoubleFloat" );
%    RPC_CLIENT_CERROR ( szContNullOutPassed, szError );
%  }
%
%  return Result.ReturnValue;
%
%} /* fnServerObjectReadDoubleFloat */
#endif	/* RPC_CLNT */
%
  fnServerObjectReadFixnum_rets fnRpc_fnServerObjectReadFixnum ( fnServerObjectReadFixnum_args ) =  59 ;
%
#if RPC_SVC
%
%extern SHLOCK fnServerObjectReadFixnum
%	(SHORTOBJID oShortObjIdHeap ,
%	  SHORTOBJID oShortObjId ,
%	  SHORTOBJID oExpectingClass ,
%	  SHTYPETAG nExpectingTypeTag ,
%	  int nIndex ,
%	  int * pnFixnum);
%
%#ifdef MULTITHREAD
%bool_t
%#else
%fnServerObjectReadFixnum_rets *
%#endif
%	PASTE2(fnrpc_fnserverobjectreadfixnum_1,_SVCSUFFIX)
%		( fnServerObjectReadFixnum_args * pArguments,
%#ifdef MULTITHREAD
%		  fnServerObjectReadFixnum_rets * pResult,
%#endif
%		  struct svc_req * pRequest )
%{
%  static const char	__procedure__[]	= "server:fnrpc_fnserverobjectreadfixnum_1";
%#ifdef MULTITHREAD
%  typedef bool_t RESULTTYPE;
%#else
%  typedef fnServerObjectReadFixnum_rets * RESULTTYPE;
%#endif
%#ifndef MULTITHREAD
%  static fnServerObjectReadFixnum_rets	Result;
%  RESULTTYPE			pResult = &Result;
%#endif
%  LPCSTR	pszErrorMsg;
%
%  __pRequest__	= pRequest;
%
%  RPC_SERVER_ENTRY();
%
%#ifndef MULTITHREAD
%  if ( pResult->pszErrorMsg == szEmpty ) {
%    pResult->pszErrorMsg	= NULL;
%  }
%  xdr_free ( (xdrproc_t) xdr_fnServerObjectReadFixnum_rets, (char *) pResult );
%#endif
%  pResult->nErrorLvl		= 0;
%
%  Reply.bAnswered		= FALSE;
%  Reply.pfnCalled		= (void(*)()) fnServerObjectReadFixnum;
%  Reply.pfnXdrResult		= (bool_t(*)()) xdr_fnServerObjectReadFixnum_rets;
%  Reply.pnErrorLvl		= &pResult->nErrorLvl;
%  Reply.ppszErrorMsg		= (LPCSTR *) &pResult->pszErrorMsg;
%  Reply.pResult		= pResult;
%  Reply.pReturnValue		= &pResult->ReturnValue;
%  Reply.nReturnValueSize	= sizeof ( pResult->ReturnValue );
%
%  pResult->ReturnValue		=
%  fnServerObjectReadFixnum (
%	pArguments->oShortObjIdHeap,
%	pArguments->oShortObjId,
%	pArguments->oExpectingClass,
%	pArguments->nExpectingTypeTag,
%	pArguments->nIndex,
%	&pResult->pnFixnum );
%
%  if ( Reply.bAnswered ) {
%    __pRequest__	= NULL;
%    return (RESULTTYPE) NULL;
%  }
%
%  pResult->nErrorLvl	= RPC_SERVER_ERRLVL();
%  if ( pResult->nErrorLvl > 0 ) {
%    pszErrorMsg		= RPC_SERVER_ERRMSG();
%    if ( pszErrorMsg && *pszErrorMsg ) {
%      pResult->pszErrorMsg	= strdup ( pszErrorMsg );
%    }
%  }
%  if ( pResult->pszErrorMsg == NULL ) {
%#ifdef MULTITHREAD
%    pResult->pszErrorMsg	= strdup ( szEmpty );
%#else
%    pResult->pszErrorMsg	= (LPSTR) szEmpty;
%#endif
%  }
%  __pRequest__	= NULL;
%  return (RESULTTYPE) pResult;
%} /* fnrpc_fnserverobjectreadfixnum_1 */
#endif	/* RPC_SVC */
%
#if RPC_CLNT
%SHLOCK DLLEXPORT fnServerObjectReadFixnum
%	(SHORTOBJID oShortObjIdHeap ,
%	  SHORTOBJID oShortObjId ,
%	  SHORTOBJID oExpectingClass ,
%	  SHTYPETAG nExpectingTypeTag ,
%	  int nIndex ,
%	  int * pnFixnum)
%{
%  static const char	__procedure__[]	= "client:fnServerObjectReadFixnum";
%  static fnServerObjectReadFixnum_rets	ZeroResult;
%  fnServerObjectReadFixnum_rets		* pResult = NULL;
%  fnServerObjectReadFixnum_rets		Result = ZeroResult;
%  fnServerObjectReadFixnum_args	InArguments;
%
%  /* Client initialization: */
%  if ( __bClientInitialize__ ) {
%    __bClientInitialize__	= FALSE;
%    RPC_CLIENT_INITIALIZE();
%  }
%
%#if	CLIENT_CREATE_BY_USER
%  if ( __pClient__ == NULL ) {
%    __pClient__	= RPC_CLIENT_CREATE ( __szHost__, __szTransport__ );
%    if ( __pClient__ == NULL ) {
%      /* Error handling for a not connected client: */
%      char	szError [ 256 ];
%      sprintf ( szError, szFormatNoServer, __procedure__ );
%      RPC_CLIENT_ERROR ( szError );
%      return Result.ReturnValue;
%    }
%  }
%#else
%  while ( __pClient__ == NULL ) {
%    __pClient__	= RPC_CLIENT_CREATE ( __szHost__, __szTransport__ );
%    if ( __pClient__ == NULL ) {
%      /* Error handling for a not connected client: */
%      char	szError [ 256 ];
%      sprintf ( szError, szFormatNoServer, __procedure__ );
%      RPC_CLIENT_CERROR ( szContNoServer, szError );
%    }
%  }
%#endif	/* CLIENT_CREATE_BY_USER */
%
%  /* Copy in the oShortObjIdHeap argument: */
%  InArguments.oShortObjIdHeap	= oShortObjIdHeap;
%  /* Copy in the oShortObjId argument: */
%  InArguments.oShortObjId	= oShortObjId;
%  /* Copy in the oExpectingClass argument: */
%  InArguments.oExpectingClass	= oExpectingClass;
%  /* Copy in the nExpectingTypeTag argument: */
%  InArguments.nExpectingTypeTag	= nExpectingTypeTag;
%  /* Copy in the nIndex argument: */
%  InArguments.nIndex	= nIndex;
%
%  pResult	=
%#ifdef MULTITHREAD
%    (
%#else
%    (fnServerObjectReadFixnum_rets *)
%#endif
%    fnrpc_fnserverobjectreadfixnum_1 (
%	&InArguments,
%#ifdef MULTITHREAD
%	&Result,
%#endif
%	__pClient__ )
%#ifdef MULTITHREAD
%	== RPC_SUCCESS ) ? &Result : NULL
%#endif
%	;
%
%  if ( pResult == NULL ) {
%    /* Error handling for a failed RPC call, */
%    /* i.e. the server did not respond: */
%    char	szError [ 256 ];
%    sprintf ( szError, szFormatRpcFailed, __procedure__,
%              clnt_sperror ( __pClient__, __szHost__ ) );
%    __pClient__	= RPC_CLIENT_DESTROY ( __pClient__ );
%    RPC_CLIENT_CERROR ( szContRpcFailed, szError );
%    Result	= ZeroResult;
%    return Result.ReturnValue;
%  }
%#ifndef MULTITHREAD
%  Result	= * pResult;
%#endif
%
%  /* Copy out the pnFixnum argument: */
%  if ( ! ( 
%       pnFixnum == NULL ) ) {
%    *pnFixnum	= pResult->pnFixnum;
%  }
%
%  if ( pResult && pResult->nErrorLvl ) {
%    /* Server returned a user error message: */
%    char	szErrorMsg [ 1024 ];
%    strncpy ( szErrorMsg,
%              ( pResult->pszErrorMsg && pResult->pszErrorMsg [ 0 ] ) ?
%              (LPCSTR) pResult->pszErrorMsg : (LPCSTR) szEmpty,
%              sizeof ( szErrorMsg ) );
%    szErrorMsg [ sizeof ( szErrorMsg ) - 1 ]	= (char) 0;
%    xdr_free ( (xdrproc_t) xdr_fnServerObjectReadFixnum_rets, (char *) pResult );
%    RPC_CLIENT_SERROR ( pResult->nErrorLvl, __procedure__,
%                        szErrorMsg );
%  } else {
%    xdr_free ( (xdrproc_t) xdr_fnServerObjectReadFixnum_rets, (char *) pResult );
%  }
%  if ( 
%       pnFixnum == NULL ) {
%    /* Error handling for passing a NULL pointer on */
%    /* out argument: */
%    char	szError [ 256 ];
%    sprintf ( szError, szFormatNullPassed,
%              __procedure__, "pnFixnum" );
%    RPC_CLIENT_CERROR ( szContNullOutPassed, szError );
%  }
%
%  return Result.ReturnValue;
%
%} /* fnServerObjectReadFixnum */
#endif	/* RPC_CLNT */
%
  fnServerObjectReadSingleFloat_rets fnRpc_fnServerObjectReadSingleFloat ( fnServerObjectReadSingleFloat_args ) =  60 ;
%
#if RPC_SVC
%
%extern SHLOCK fnServerObjectReadSingleFloat
%	(SHORTOBJID oShortObjIdHeap ,
%	  SHORTOBJID oShortObjId ,
%	  float * pfSingleFloat);
%
%#ifdef MULTITHREAD
%bool_t
%#else
%fnServerObjectReadSingleFloat_rets *
%#endif
%	PASTE2(fnrpc_fnserverobjectreadsinglefloat_1,_SVCSUFFIX)
%		( fnServerObjectReadSingleFloat_args * pArguments,
%#ifdef MULTITHREAD
%		  fnServerObjectReadSingleFloat_rets * pResult,
%#endif
%		  struct svc_req * pRequest )
%{
%  static const char	__procedure__[]	= "server:fnrpc_fnserverobjectreadsinglefloat_1";
%#ifdef MULTITHREAD
%  typedef bool_t RESULTTYPE;
%#else
%  typedef fnServerObjectReadSingleFloat_rets * RESULTTYPE;
%#endif
%#ifndef MULTITHREAD
%  static fnServerObjectReadSingleFloat_rets	Result;
%  RESULTTYPE			pResult = &Result;
%#endif
%  LPCSTR	pszErrorMsg;
%
%  __pRequest__	= pRequest;
%
%  RPC_SERVER_ENTRY();
%
%#ifndef MULTITHREAD
%  if ( pResult->pszErrorMsg == szEmpty ) {
%    pResult->pszErrorMsg	= NULL;
%  }
%  xdr_free ( (xdrproc_t) xdr_fnServerObjectReadSingleFloat_rets, (char *) pResult );
%#endif
%  pResult->nErrorLvl		= 0;
%
%  Reply.bAnswered		= FALSE;
%  Reply.pfnCalled		= (void(*)()) fnServerObjectReadSingleFloat;
%  Reply.pfnXdrResult		= (bool_t(*)()) xdr_fnServerObjectReadSingleFloat_rets;
%  Reply.pnErrorLvl		= &pResult->nErrorLvl;
%  Reply.ppszErrorMsg		= (LPCSTR *) &pResult->pszErrorMsg;
%  Reply.pResult		= pResult;
%  Reply.pReturnValue		= &pResult->ReturnValue;
%  Reply.nReturnValueSize	= sizeof ( pResult->ReturnValue );
%
%  pResult->ReturnValue		=
%  fnServerObjectReadSingleFloat (
%	pArguments->oShortObjIdHeap,
%	pArguments->oShortObjId,
%	&pResult->pfSingleFloat );
%
%  if ( Reply.bAnswered ) {
%    __pRequest__	= NULL;
%    return (RESULTTYPE) NULL;
%  }
%
%  pResult->nErrorLvl	= RPC_SERVER_ERRLVL();
%  if ( pResult->nErrorLvl > 0 ) {
%    pszErrorMsg		= RPC_SERVER_ERRMSG();
%    if ( pszErrorMsg && *pszErrorMsg ) {
%      pResult->pszErrorMsg	= strdup ( pszErrorMsg );
%    }
%  }
%  if ( pResult->pszErrorMsg == NULL ) {
%#ifdef MULTITHREAD
%    pResult->pszErrorMsg	= strdup ( szEmpty );
%#else
%    pResult->pszErrorMsg	= (LPSTR) szEmpty;
%#endif
%  }
%  __pRequest__	= NULL;
%  return (RESULTTYPE) pResult;
%} /* fnrpc_fnserverobjectreadsinglefloat_1 */
#endif	/* RPC_SVC */
%
#if RPC_CLNT
%SHLOCK DLLEXPORT fnServerObjectReadSingleFloat
%	(SHORTOBJID oShortObjIdHeap ,
%	  SHORTOBJID oShortObjId ,
%	  float * pfSingleFloat)
%{
%  static const char	__procedure__[]	= "client:fnServerObjectReadSingleFloat";
%  static fnServerObjectReadSingleFloat_rets	ZeroResult;
%  fnServerObjectReadSingleFloat_rets		* pResult = NULL;
%  fnServerObjectReadSingleFloat_rets		Result = ZeroResult;
%  fnServerObjectReadSingleFloat_args	InArguments;
%
%  /* Client initialization: */
%  if ( __bClientInitialize__ ) {
%    __bClientInitialize__	= FALSE;
%    RPC_CLIENT_INITIALIZE();
%  }
%
%#if	CLIENT_CREATE_BY_USER
%  if ( __pClient__ == NULL ) {
%    __pClient__	= RPC_CLIENT_CREATE ( __szHost__, __szTransport__ );
%    if ( __pClient__ == NULL ) {
%      /* Error handling for a not connected client: */
%      char	szError [ 256 ];
%      sprintf ( szError, szFormatNoServer, __procedure__ );
%      RPC_CLIENT_ERROR ( szError );
%      return Result.ReturnValue;
%    }
%  }
%#else
%  while ( __pClient__ == NULL ) {
%    __pClient__	= RPC_CLIENT_CREATE ( __szHost__, __szTransport__ );
%    if ( __pClient__ == NULL ) {
%      /* Error handling for a not connected client: */
%      char	szError [ 256 ];
%      sprintf ( szError, szFormatNoServer, __procedure__ );
%      RPC_CLIENT_CERROR ( szContNoServer, szError );
%    }
%  }
%#endif	/* CLIENT_CREATE_BY_USER */
%
%  /* Copy in the oShortObjIdHeap argument: */
%  InArguments.oShortObjIdHeap	= oShortObjIdHeap;
%  /* Copy in the oShortObjId argument: */
%  InArguments.oShortObjId	= oShortObjId;
%
%  pResult	=
%#ifdef MULTITHREAD
%    (
%#else
%    (fnServerObjectReadSingleFloat_rets *)
%#endif
%    fnrpc_fnserverobjectreadsinglefloat_1 (
%	&InArguments,
%#ifdef MULTITHREAD
%	&Result,
%#endif
%	__pClient__ )
%#ifdef MULTITHREAD
%	== RPC_SUCCESS ) ? &Result : NULL
%#endif
%	;
%
%  if ( pResult == NULL ) {
%    /* Error handling for a failed RPC call, */
%    /* i.e. the server did not respond: */
%    char	szError [ 256 ];
%    sprintf ( szError, szFormatRpcFailed, __procedure__,
%              clnt_sperror ( __pClient__, __szHost__ ) );
%    __pClient__	= RPC_CLIENT_DESTROY ( __pClient__ );
%    RPC_CLIENT_CERROR ( szContRpcFailed, szError );
%    Result	= ZeroResult;
%    return Result.ReturnValue;
%  }
%#ifndef MULTITHREAD
%  Result	= * pResult;
%#endif
%
%  /* Copy out the pfSingleFloat argument: */
%  if ( ! ( 
%       pfSingleFloat == NULL ) ) {
%    *pfSingleFloat	= pResult->pfSingleFloat;
%  }
%
%  if ( pResult && pResult->nErrorLvl ) {
%    /* Server returned a user error message: */
%    char	szErrorMsg [ 1024 ];
%    strncpy ( szErrorMsg,
%              ( pResult->pszErrorMsg && pResult->pszErrorMsg [ 0 ] ) ?
%              (LPCSTR) pResult->pszErrorMsg : (LPCSTR) szEmpty,
%              sizeof ( szErrorMsg ) );
%    szErrorMsg [ sizeof ( szErrorMsg ) - 1 ]	= (char) 0;
%    xdr_free ( (xdrproc_t) xdr_fnServerObjectReadSingleFloat_rets, (char *) pResult );
%    RPC_CLIENT_SERROR ( pResult->nErrorLvl, __procedure__,
%                        szErrorMsg );
%  } else {
%    xdr_free ( (xdrproc_t) xdr_fnServerObjectReadSingleFloat_rets, (char *) pResult );
%  }
%  if ( 
%       pfSingleFloat == NULL ) {
%    /* Error handling for passing a NULL pointer on */
%    /* out argument: */
%    char	szError [ 256 ];
%    sprintf ( szError, szFormatNullPassed,
%              __procedure__, "pfSingleFloat" );
%    RPC_CLIENT_CERROR ( szContNullOutPassed, szError );
%  }
%
%  return Result.ReturnValue;
%
%} /* fnServerObjectReadSingleFloat */
#endif	/* RPC_CLNT */
%
  fnServerObjectWriteBignum_rets fnRpc_fnServerObjectWriteBignum ( fnServerObjectWriteBignum_args ) =  61 ;
%
#if RPC_SVC
%
%extern SHLOCK fnServerObjectWriteBignum
%	(SHORTOBJID oShortObjIdHeap ,
%	  SHORTOBJID oShortObjIdFormat ,
%	  SHORTOBJID oShortObjId ,
%	  int nSizeInBits ,
%	  as_is * /* _vector_t<((( AlignBitsToWords ( ABS ( nSizeInBits ) ) )*( sizeof(int) )) )> */ pnBignum);
%
%#ifdef MULTITHREAD
%bool_t
%#else
%fnServerObjectWriteBignum_rets *
%#endif
%	PASTE2(fnrpc_fnserverobjectwritebignum_1,_SVCSUFFIX)
%		( fnServerObjectWriteBignum_args * pArguments,
%#ifdef MULTITHREAD
%		  fnServerObjectWriteBignum_rets * pResult,
%#endif
%		  struct svc_req * pRequest )
%{
%  static const char	__procedure__[]	= "server:fnrpc_fnserverobjectwritebignum_1";
%#ifdef MULTITHREAD
%  typedef bool_t RESULTTYPE;
%#else
%  typedef fnServerObjectWriteBignum_rets * RESULTTYPE;
%#endif
%#ifndef MULTITHREAD
%  static fnServerObjectWriteBignum_rets	Result;
%  RESULTTYPE			pResult = &Result;
%#endif
%  LPCSTR	pszErrorMsg;
%
%  __pRequest__	= pRequest;
%
%  RPC_SERVER_ENTRY();
%
%#ifndef MULTITHREAD
%  if ( pResult->pszErrorMsg == szEmpty ) {
%    pResult->pszErrorMsg	= NULL;
%  }
%  xdr_free ( (xdrproc_t) xdr_fnServerObjectWriteBignum_rets, (char *) pResult );
%#endif
%  pResult->nErrorLvl		= 0;
%
%  Reply.bAnswered		= FALSE;
%  Reply.pfnCalled		= (void(*)()) fnServerObjectWriteBignum;
%  Reply.pfnXdrResult		= (bool_t(*)()) xdr_fnServerObjectWriteBignum_rets;
%  Reply.pnErrorLvl		= &pResult->nErrorLvl;
%  Reply.ppszErrorMsg		= (LPCSTR *) &pResult->pszErrorMsg;
%  Reply.pResult		= pResult;
%  Reply.pReturnValue		= &pResult->ReturnValue;
%  Reply.nReturnValueSize	= sizeof ( pResult->ReturnValue );
%
%  pResult->ReturnValue		=
%  fnServerObjectWriteBignum (
%	pArguments->oShortObjIdHeap,
%	pArguments->oShortObjIdFormat,
%	pArguments->oShortObjId,
%	pArguments->nSizeInBits,
%	pArguments->pnBignum.as_is_vector_t_val );
%
%  if ( Reply.bAnswered ) {
%    __pRequest__	= NULL;
%    return (RESULTTYPE) NULL;
%  }
%
%  pResult->nErrorLvl	= RPC_SERVER_ERRLVL();
%  if ( pResult->nErrorLvl > 0 ) {
%    pszErrorMsg		= RPC_SERVER_ERRMSG();
%    if ( pszErrorMsg && *pszErrorMsg ) {
%      pResult->pszErrorMsg	= strdup ( pszErrorMsg );
%    }
%  }
%  if ( pResult->pszErrorMsg == NULL ) {
%#ifdef MULTITHREAD
%    pResult->pszErrorMsg	= strdup ( szEmpty );
%#else
%    pResult->pszErrorMsg	= (LPSTR) szEmpty;
%#endif
%  }
%  __pRequest__	= NULL;
%  return (RESULTTYPE) pResult;
%} /* fnrpc_fnserverobjectwritebignum_1 */
#endif	/* RPC_SVC */
%
#if RPC_CLNT
%SHLOCK DLLEXPORT fnServerObjectWriteBignum
%	(SHORTOBJID oShortObjIdHeap ,
%	  SHORTOBJID oShortObjIdFormat ,
%	  SHORTOBJID oShortObjId ,
%	  int nSizeInBits ,
%	  as_is * /* _vector_t<((( AlignBitsToWords ( ABS ( nSizeInBits ) ) )*( sizeof(int) )) )> */ pnBignum)
%{
%  static const char	__procedure__[]	= "client:fnServerObjectWriteBignum";
%  static fnServerObjectWriteBignum_rets	ZeroResult;
%  fnServerObjectWriteBignum_rets		* pResult = NULL;
%  fnServerObjectWriteBignum_rets		Result = ZeroResult;
%  fnServerObjectWriteBignum_args	InArguments;
%
%  /* Client initialization: */
%  if ( __bClientInitialize__ ) {
%    __bClientInitialize__	= FALSE;
%    RPC_CLIENT_INITIALIZE();
%  }
%
%#if	CLIENT_CREATE_BY_USER
%  if ( __pClient__ == NULL ) {
%    __pClient__	= RPC_CLIENT_CREATE ( __szHost__, __szTransport__ );
%    if ( __pClient__ == NULL ) {
%      /* Error handling for a not connected client: */
%      char	szError [ 256 ];
%      sprintf ( szError, szFormatNoServer, __procedure__ );
%      RPC_CLIENT_ERROR ( szError );
%      return Result.ReturnValue;
%    }
%  }
%#else
%  while ( __pClient__ == NULL ) {
%    __pClient__	= RPC_CLIENT_CREATE ( __szHost__, __szTransport__ );
%    if ( __pClient__ == NULL ) {
%      /* Error handling for a not connected client: */
%      char	szError [ 256 ];
%      sprintf ( szError, szFormatNoServer, __procedure__ );
%      RPC_CLIENT_CERROR ( szContNoServer, szError );
%    }
%  }
%#endif	/* CLIENT_CREATE_BY_USER */
%
%  /* Copy in the oShortObjIdHeap argument: */
%  InArguments.oShortObjIdHeap	= oShortObjIdHeap;
%  /* Copy in the oShortObjIdFormat argument: */
%  InArguments.oShortObjIdFormat	= oShortObjIdFormat;
%  /* Copy in the oShortObjId argument: */
%  InArguments.oShortObjId	= oShortObjId;
%  /* Copy in the nSizeInBits argument: */
%  InArguments.nSizeInBits	= nSizeInBits;
%  /* Copy in the pnBignum argument: */
%  InArguments.pnBignum.as_is_vector_t_len	= ((( AlignBitsToWords ( ABS ( nSizeInBits ) ) )*( sizeof(int) )) );
%  InArguments.pnBignum.as_is_vector_t_val	= pnBignum;
%  if ( InArguments.pnBignum.as_is_vector_t_len != 0 && pnBignum == NULL ) {
%    /* Error handling for passing a NULL pointer on */
%    /* VECTOR declared in argument: */
%    char	szError [ 256 ];
%    InArguments.pnBignum.as_is_vector_t_len	= 0;
%    sprintf ( szError, szFormatNullPassed,
%              __procedure__, "pnBignum" );
%    RPC_CLIENT_CERROR ( szContNullPassed, szError );
%  }
%
%  pResult	=
%#ifdef MULTITHREAD
%    (
%#else
%    (fnServerObjectWriteBignum_rets *)
%#endif
%    fnrpc_fnserverobjectwritebignum_1 (
%	&InArguments,
%#ifdef MULTITHREAD
%	&Result,
%#endif
%	__pClient__ )
%#ifdef MULTITHREAD
%	== RPC_SUCCESS ) ? &Result : NULL
%#endif
%	;
%
%  if ( pResult == NULL ) {
%    /* Error handling for a failed RPC call, */
%    /* i.e. the server did not respond: */
%    char	szError [ 256 ];
%    sprintf ( szError, szFormatRpcFailed, __procedure__,
%              clnt_sperror ( __pClient__, __szHost__ ) );
%    __pClient__	= RPC_CLIENT_DESTROY ( __pClient__ );
%    RPC_CLIENT_CERROR ( szContRpcFailed, szError );
%    Result	= ZeroResult;
%    return Result.ReturnValue;
%  }
%#ifndef MULTITHREAD
%  Result	= * pResult;
%#endif
%
%
%  if ( pResult && pResult->nErrorLvl ) {
%    /* Server returned a user error message: */
%    char	szErrorMsg [ 1024 ];
%    strncpy ( szErrorMsg,
%              ( pResult->pszErrorMsg && pResult->pszErrorMsg [ 0 ] ) ?
%              (LPCSTR) pResult->pszErrorMsg : (LPCSTR) szEmpty,
%              sizeof ( szErrorMsg ) );
%    szErrorMsg [ sizeof ( szErrorMsg ) - 1 ]	= (char) 0;
%    xdr_free ( (xdrproc_t) xdr_fnServerObjectWriteBignum_rets, (char *) pResult );
%    RPC_CLIENT_SERROR ( pResult->nErrorLvl, __procedure__,
%                        szErrorMsg );
%  } else {
%    xdr_free ( (xdrproc_t) xdr_fnServerObjectWriteBignum_rets, (char *) pResult );
%  }
%
%  return Result.ReturnValue;
%
%} /* fnServerObjectWriteBignum */
#endif	/* RPC_CLNT */
%
  fnServerObjectWriteDoubleFloat_rets fnRpc_fnServerObjectWriteDoubleFloat ( fnServerObjectWriteDoubleFloat_args ) =  62 ;
%
#if RPC_SVC
%
%extern SHLOCK fnServerObjectWriteDoubleFloat
%	(SHORTOBJID oShortObjIdHeap ,
%	  SHORTOBJID oShortObjId ,
%	  double fDoubleFloat);
%
%#ifdef MULTITHREAD
%bool_t
%#else
%fnServerObjectWriteDoubleFloat_rets *
%#endif
%	PASTE2(fnrpc_fnserverobjectwritedoublefloat_1,_SVCSUFFIX)
%		( fnServerObjectWriteDoubleFloat_args * pArguments,
%#ifdef MULTITHREAD
%		  fnServerObjectWriteDoubleFloat_rets * pResult,
%#endif
%		  struct svc_req * pRequest )
%{
%  static const char	__procedure__[]	= "server:fnrpc_fnserverobjectwritedoublefloat_1";
%#ifdef MULTITHREAD
%  typedef bool_t RESULTTYPE;
%#else
%  typedef fnServerObjectWriteDoubleFloat_rets * RESULTTYPE;
%#endif
%#ifndef MULTITHREAD
%  static fnServerObjectWriteDoubleFloat_rets	Result;
%  RESULTTYPE			pResult = &Result;
%#endif
%  LPCSTR	pszErrorMsg;
%
%  __pRequest__	= pRequest;
%
%  RPC_SERVER_ENTRY();
%
%#ifndef MULTITHREAD
%  if ( pResult->pszErrorMsg == szEmpty ) {
%    pResult->pszErrorMsg	= NULL;
%  }
%  xdr_free ( (xdrproc_t) xdr_fnServerObjectWriteDoubleFloat_rets, (char *) pResult );
%#endif
%  pResult->nErrorLvl		= 0;
%
%  Reply.bAnswered		= FALSE;
%  Reply.pfnCalled		= (void(*)()) fnServerObjectWriteDoubleFloat;
%  Reply.pfnXdrResult		= (bool_t(*)()) xdr_fnServerObjectWriteDoubleFloat_rets;
%  Reply.pnErrorLvl		= &pResult->nErrorLvl;
%  Reply.ppszErrorMsg		= (LPCSTR *) &pResult->pszErrorMsg;
%  Reply.pResult		= pResult;
%  Reply.pReturnValue		= &pResult->ReturnValue;
%  Reply.nReturnValueSize	= sizeof ( pResult->ReturnValue );
%
%  pResult->ReturnValue		=
%  fnServerObjectWriteDoubleFloat (
%	pArguments->oShortObjIdHeap,
%	pArguments->oShortObjId,
%	pArguments->fDoubleFloat );
%
%  if ( Reply.bAnswered ) {
%    __pRequest__	= NULL;
%    return (RESULTTYPE) NULL;
%  }
%
%  pResult->nErrorLvl	= RPC_SERVER_ERRLVL();
%  if ( pResult->nErrorLvl > 0 ) {
%    pszErrorMsg		= RPC_SERVER_ERRMSG();
%    if ( pszErrorMsg && *pszErrorMsg ) {
%      pResult->pszErrorMsg	= strdup ( pszErrorMsg );
%    }
%  }
%  if ( pResult->pszErrorMsg == NULL ) {
%#ifdef MULTITHREAD
%    pResult->pszErrorMsg	= strdup ( szEmpty );
%#else
%    pResult->pszErrorMsg	= (LPSTR) szEmpty;
%#endif
%  }
%  __pRequest__	= NULL;
%  return (RESULTTYPE) pResult;
%} /* fnrpc_fnserverobjectwritedoublefloat_1 */
#endif	/* RPC_SVC */
%
#if RPC_CLNT
%SHLOCK DLLEXPORT fnServerObjectWriteDoubleFloat
%	(SHORTOBJID oShortObjIdHeap ,
%	  SHORTOBJID oShortObjId ,
%	  double fDoubleFloat)
%{
%  static const char	__procedure__[]	= "client:fnServerObjectWriteDoubleFloat";
%  static fnServerObjectWriteDoubleFloat_rets	ZeroResult;
%  fnServerObjectWriteDoubleFloat_rets		* pResult = NULL;
%  fnServerObjectWriteDoubleFloat_rets		Result = ZeroResult;
%  fnServerObjectWriteDoubleFloat_args	InArguments;
%
%  /* Client initialization: */
%  if ( __bClientInitialize__ ) {
%    __bClientInitialize__	= FALSE;
%    RPC_CLIENT_INITIALIZE();
%  }
%
%#if	CLIENT_CREATE_BY_USER
%  if ( __pClient__ == NULL ) {
%    __pClient__	= RPC_CLIENT_CREATE ( __szHost__, __szTransport__ );
%    if ( __pClient__ == NULL ) {
%      /* Error handling for a not connected client: */
%      char	szError [ 256 ];
%      sprintf ( szError, szFormatNoServer, __procedure__ );
%      RPC_CLIENT_ERROR ( szError );
%      return Result.ReturnValue;
%    }
%  }
%#else
%  while ( __pClient__ == NULL ) {
%    __pClient__	= RPC_CLIENT_CREATE ( __szHost__, __szTransport__ );
%    if ( __pClient__ == NULL ) {
%      /* Error handling for a not connected client: */
%      char	szError [ 256 ];
%      sprintf ( szError, szFormatNoServer, __procedure__ );
%      RPC_CLIENT_CERROR ( szContNoServer, szError );
%    }
%  }
%#endif	/* CLIENT_CREATE_BY_USER */
%
%  /* Copy in the oShortObjIdHeap argument: */
%  InArguments.oShortObjIdHeap	= oShortObjIdHeap;
%  /* Copy in the oShortObjId argument: */
%  InArguments.oShortObjId	= oShortObjId;
%  /* Copy in the fDoubleFloat argument: */
%  InArguments.fDoubleFloat	= fDoubleFloat;
%
%  pResult	=
%#ifdef MULTITHREAD
%    (
%#else
%    (fnServerObjectWriteDoubleFloat_rets *)
%#endif
%    fnrpc_fnserverobjectwritedoublefloat_1 (
%	&InArguments,
%#ifdef MULTITHREAD
%	&Result,
%#endif
%	__pClient__ )
%#ifdef MULTITHREAD
%	== RPC_SUCCESS ) ? &Result : NULL
%#endif
%	;
%
%  if ( pResult == NULL ) {
%    /* Error handling for a failed RPC call, */
%    /* i.e. the server did not respond: */
%    char	szError [ 256 ];
%    sprintf ( szError, szFormatRpcFailed, __procedure__,
%              clnt_sperror ( __pClient__, __szHost__ ) );
%    __pClient__	= RPC_CLIENT_DESTROY ( __pClient__ );
%    RPC_CLIENT_CERROR ( szContRpcFailed, szError );
%    Result	= ZeroResult;
%    return Result.ReturnValue;
%  }
%#ifndef MULTITHREAD
%  Result	= * pResult;
%#endif
%
%
%  if ( pResult && pResult->nErrorLvl ) {
%    /* Server returned a user error message: */
%    char	szErrorMsg [ 1024 ];
%    strncpy ( szErrorMsg,
%              ( pResult->pszErrorMsg && pResult->pszErrorMsg [ 0 ] ) ?
%              (LPCSTR) pResult->pszErrorMsg : (LPCSTR) szEmpty,
%              sizeof ( szErrorMsg ) );
%    szErrorMsg [ sizeof ( szErrorMsg ) - 1 ]	= (char) 0;
%    xdr_free ( (xdrproc_t) xdr_fnServerObjectWriteDoubleFloat_rets, (char *) pResult );
%    RPC_CLIENT_SERROR ( pResult->nErrorLvl, __procedure__,
%                        szErrorMsg );
%  } else {
%    xdr_free ( (xdrproc_t) xdr_fnServerObjectWriteDoubleFloat_rets, (char *) pResult );
%  }
%
%  return Result.ReturnValue;
%
%} /* fnServerObjectWriteDoubleFloat */
#endif	/* RPC_CLNT */
%
  fnServerObjectWriteFixnum_rets fnRpc_fnServerObjectWriteFixnum ( fnServerObjectWriteFixnum_args ) =  63 ;
%
#if RPC_SVC
%
%extern SHLOCK fnServerObjectWriteFixnum
%	(SHORTOBJID oShortObjIdHeap ,
%	  SHORTOBJID oShortObjId ,
%	  SHORTOBJID oExpectingClass ,
%	  SHTYPETAG nExpectingTypeTag ,
%	  int nIndex ,
%	  int nFixnumWrite);
%
%#ifdef MULTITHREAD
%bool_t
%#else
%fnServerObjectWriteFixnum_rets *
%#endif
%	PASTE2(fnrpc_fnserverobjectwritefixnum_1,_SVCSUFFIX)
%		( fnServerObjectWriteFixnum_args * pArguments,
%#ifdef MULTITHREAD
%		  fnServerObjectWriteFixnum_rets * pResult,
%#endif
%		  struct svc_req * pRequest )
%{
%  static const char	__procedure__[]	= "server:fnrpc_fnserverobjectwritefixnum_1";
%#ifdef MULTITHREAD
%  typedef bool_t RESULTTYPE;
%#else
%  typedef fnServerObjectWriteFixnum_rets * RESULTTYPE;
%#endif
%#ifndef MULTITHREAD
%  static fnServerObjectWriteFixnum_rets	Result;
%  RESULTTYPE			pResult = &Result;
%#endif
%  LPCSTR	pszErrorMsg;
%
%  __pRequest__	= pRequest;
%
%  RPC_SERVER_ENTRY();
%
%#ifndef MULTITHREAD
%  if ( pResult->pszErrorMsg == szEmpty ) {
%    pResult->pszErrorMsg	= NULL;
%  }
%  xdr_free ( (xdrproc_t) xdr_fnServerObjectWriteFixnum_rets, (char *) pResult );
%#endif
%  pResult->nErrorLvl		= 0;
%
%  Reply.bAnswered		= FALSE;
%  Reply.pfnCalled		= (void(*)()) fnServerObjectWriteFixnum;
%  Reply.pfnXdrResult		= (bool_t(*)()) xdr_fnServerObjectWriteFixnum_rets;
%  Reply.pnErrorLvl		= &pResult->nErrorLvl;
%  Reply.ppszErrorMsg		= (LPCSTR *) &pResult->pszErrorMsg;
%  Reply.pResult		= pResult;
%  Reply.pReturnValue		= &pResult->ReturnValue;
%  Reply.nReturnValueSize	= sizeof ( pResult->ReturnValue );
%
%  pResult->ReturnValue		=
%  fnServerObjectWriteFixnum (
%	pArguments->oShortObjIdHeap,
%	pArguments->oShortObjId,
%	pArguments->oExpectingClass,
%	pArguments->nExpectingTypeTag,
%	pArguments->nIndex,
%	pArguments->nFixnumWrite );
%
%  if ( Reply.bAnswered ) {
%    __pRequest__	= NULL;
%    return (RESULTTYPE) NULL;
%  }
%
%  pResult->nErrorLvl	= RPC_SERVER_ERRLVL();
%  if ( pResult->nErrorLvl > 0 ) {
%    pszErrorMsg		= RPC_SERVER_ERRMSG();
%    if ( pszErrorMsg && *pszErrorMsg ) {
%      pResult->pszErrorMsg	= strdup ( pszErrorMsg );
%    }
%  }
%  if ( pResult->pszErrorMsg == NULL ) {
%#ifdef MULTITHREAD
%    pResult->pszErrorMsg	= strdup ( szEmpty );
%#else
%    pResult->pszErrorMsg	= (LPSTR) szEmpty;
%#endif
%  }
%  __pRequest__	= NULL;
%  return (RESULTTYPE) pResult;
%} /* fnrpc_fnserverobjectwritefixnum_1 */
#endif	/* RPC_SVC */
%
#if RPC_CLNT
%SHLOCK DLLEXPORT fnServerObjectWriteFixnum
%	(SHORTOBJID oShortObjIdHeap ,
%	  SHORTOBJID oShortObjId ,
%	  SHORTOBJID oExpectingClass ,
%	  SHTYPETAG nExpectingTypeTag ,
%	  int nIndex ,
%	  int nFixnumWrite)
%{
%  static const char	__procedure__[]	= "client:fnServerObjectWriteFixnum";
%  static fnServerObjectWriteFixnum_rets	ZeroResult;
%  fnServerObjectWriteFixnum_rets		* pResult = NULL;
%  fnServerObjectWriteFixnum_rets		Result = ZeroResult;
%  fnServerObjectWriteFixnum_args	InArguments;
%
%  /* Client initialization: */
%  if ( __bClientInitialize__ ) {
%    __bClientInitialize__	= FALSE;
%    RPC_CLIENT_INITIALIZE();
%  }
%
%#if	CLIENT_CREATE_BY_USER
%  if ( __pClient__ == NULL ) {
%    __pClient__	= RPC_CLIENT_CREATE ( __szHost__, __szTransport__ );
%    if ( __pClient__ == NULL ) {
%      /* Error handling for a not connected client: */
%      char	szError [ 256 ];
%      sprintf ( szError, szFormatNoServer, __procedure__ );
%      RPC_CLIENT_ERROR ( szError );
%      return Result.ReturnValue;
%    }
%  }
%#else
%  while ( __pClient__ == NULL ) {
%    __pClient__	= RPC_CLIENT_CREATE ( __szHost__, __szTransport__ );
%    if ( __pClient__ == NULL ) {
%      /* Error handling for a not connected client: */
%      char	szError [ 256 ];
%      sprintf ( szError, szFormatNoServer, __procedure__ );
%      RPC_CLIENT_CERROR ( szContNoServer, szError );
%    }
%  }
%#endif	/* CLIENT_CREATE_BY_USER */
%
%  /* Copy in the oShortObjIdHeap argument: */
%  InArguments.oShortObjIdHeap	= oShortObjIdHeap;
%  /* Copy in the oShortObjId argument: */
%  InArguments.oShortObjId	= oShortObjId;
%  /* Copy in the oExpectingClass argument: */
%  InArguments.oExpectingClass	= oExpectingClass;
%  /* Copy in the nExpectingTypeTag argument: */
%  InArguments.nExpectingTypeTag	= nExpectingTypeTag;
%  /* Copy in the nIndex argument: */
%  InArguments.nIndex	= nIndex;
%  /* Copy in the nFixnumWrite argument: */
%  InArguments.nFixnumWrite	= nFixnumWrite;
%
%  pResult	=
%#ifdef MULTITHREAD
%    (
%#else
%    (fnServerObjectWriteFixnum_rets *)
%#endif
%    fnrpc_fnserverobjectwritefixnum_1 (
%	&InArguments,
%#ifdef MULTITHREAD
%	&Result,
%#endif
%	__pClient__ )
%#ifdef MULTITHREAD
%	== RPC_SUCCESS ) ? &Result : NULL
%#endif
%	;
%
%  if ( pResult == NULL ) {
%    /* Error handling for a failed RPC call, */
%    /* i.e. the server did not respond: */
%    char	szError [ 256 ];
%    sprintf ( szError, szFormatRpcFailed, __procedure__,
%              clnt_sperror ( __pClient__, __szHost__ ) );
%    __pClient__	= RPC_CLIENT_DESTROY ( __pClient__ );
%    RPC_CLIENT_CERROR ( szContRpcFailed, szError );
%    Result	= ZeroResult;
%    return Result.ReturnValue;
%  }
%#ifndef MULTITHREAD
%  Result	= * pResult;
%#endif
%
%
%  if ( pResult && pResult->nErrorLvl ) {
%    /* Server returned a user error message: */
%    char	szErrorMsg [ 1024 ];
%    strncpy ( szErrorMsg,
%              ( pResult->pszErrorMsg && pResult->pszErrorMsg [ 0 ] ) ?
%              (LPCSTR) pResult->pszErrorMsg : (LPCSTR) szEmpty,
%              sizeof ( szErrorMsg ) );
%    szErrorMsg [ sizeof ( szErrorMsg ) - 1 ]	= (char) 0;
%    xdr_free ( (xdrproc_t) xdr_fnServerObjectWriteFixnum_rets, (char *) pResult );
%    RPC_CLIENT_SERROR ( pResult->nErrorLvl, __procedure__,
%                        szErrorMsg );
%  } else {
%    xdr_free ( (xdrproc_t) xdr_fnServerObjectWriteFixnum_rets, (char *) pResult );
%  }
%
%  return Result.ReturnValue;
%
%} /* fnServerObjectWriteFixnum */
#endif	/* RPC_CLNT */
%
  fnServerObjectWriteSingleFloat_rets fnRpc_fnServerObjectWriteSingleFloat ( fnServerObjectWriteSingleFloat_args ) =  64 ;
%
#if RPC_SVC
%
%extern SHLOCK fnServerObjectWriteSingleFloat
%	(SHORTOBJID oShortObjIdHeap ,
%	  SHORTOBJID oShortObjId ,
%	  float fSingleFloat);
%
%#ifdef MULTITHREAD
%bool_t
%#else
%fnServerObjectWriteSingleFloat_rets *
%#endif
%	PASTE2(fnrpc_fnserverobjectwritesinglefloat_1,_SVCSUFFIX)
%		( fnServerObjectWriteSingleFloat_args * pArguments,
%#ifdef MULTITHREAD
%		  fnServerObjectWriteSingleFloat_rets * pResult,
%#endif
%		  struct svc_req * pRequest )
%{
%  static const char	__procedure__[]	= "server:fnrpc_fnserverobjectwritesinglefloat_1";
%#ifdef MULTITHREAD
%  typedef bool_t RESULTTYPE;
%#else
%  typedef fnServerObjectWriteSingleFloat_rets * RESULTTYPE;
%#endif
%#ifndef MULTITHREAD
%  static fnServerObjectWriteSingleFloat_rets	Result;
%  RESULTTYPE			pResult = &Result;
%#endif
%  LPCSTR	pszErrorMsg;
%
%  __pRequest__	= pRequest;
%
%  RPC_SERVER_ENTRY();
%
%#ifndef MULTITHREAD
%  if ( pResult->pszErrorMsg == szEmpty ) {
%    pResult->pszErrorMsg	= NULL;
%  }
%  xdr_free ( (xdrproc_t) xdr_fnServerObjectWriteSingleFloat_rets, (char *) pResult );
%#endif
%  pResult->nErrorLvl		= 0;
%
%  Reply.bAnswered		= FALSE;
%  Reply.pfnCalled		= (void(*)()) fnServerObjectWriteSingleFloat;
%  Reply.pfnXdrResult		= (bool_t(*)()) xdr_fnServerObjectWriteSingleFloat_rets;
%  Reply.pnErrorLvl		= &pResult->nErrorLvl;
%  Reply.ppszErrorMsg		= (LPCSTR *) &pResult->pszErrorMsg;
%  Reply.pResult		= pResult;
%  Reply.pReturnValue		= &pResult->ReturnValue;
%  Reply.nReturnValueSize	= sizeof ( pResult->ReturnValue );
%
%  pResult->ReturnValue		=
%  fnServerObjectWriteSingleFloat (
%	pArguments->oShortObjIdHeap,
%	pArguments->oShortObjId,
%	pArguments->fSingleFloat );
%
%  if ( Reply.bAnswered ) {
%    __pRequest__	= NULL;
%    return (RESULTTYPE) NULL;
%  }
%
%  pResult->nErrorLvl	= RPC_SERVER_ERRLVL();
%  if ( pResult->nErrorLvl > 0 ) {
%    pszErrorMsg		= RPC_SERVER_ERRMSG();
%    if ( pszErrorMsg && *pszErrorMsg ) {
%      pResult->pszErrorMsg	= strdup ( pszErrorMsg );
%    }
%  }
%  if ( pResult->pszErrorMsg == NULL ) {
%#ifdef MULTITHREAD
%    pResult->pszErrorMsg	= strdup ( szEmpty );
%#else
%    pResult->pszErrorMsg	= (LPSTR) szEmpty;
%#endif
%  }
%  __pRequest__	= NULL;
%  return (RESULTTYPE) pResult;
%} /* fnrpc_fnserverobjectwritesinglefloat_1 */
#endif	/* RPC_SVC */
%
#if RPC_CLNT
%SHLOCK DLLEXPORT fnServerObjectWriteSingleFloat
%	(SHORTOBJID oShortObjIdHeap ,
%	  SHORTOBJID oShortObjId ,
%	  float fSingleFloat)
%{
%  static const char	__procedure__[]	= "client:fnServerObjectWriteSingleFloat";
%  static fnServerObjectWriteSingleFloat_rets	ZeroResult;
%  fnServerObjectWriteSingleFloat_rets		* pResult = NULL;
%  fnServerObjectWriteSingleFloat_rets		Result = ZeroResult;
%  fnServerObjectWriteSingleFloat_args	InArguments;
%
%  /* Client initialization: */
%  if ( __bClientInitialize__ ) {
%    __bClientInitialize__	= FALSE;
%    RPC_CLIENT_INITIALIZE();
%  }
%
%#if	CLIENT_CREATE_BY_USER
%  if ( __pClient__ == NULL ) {
%    __pClient__	= RPC_CLIENT_CREATE ( __szHost__, __szTransport__ );
%    if ( __pClient__ == NULL ) {
%      /* Error handling for a not connected client: */
%      char	szError [ 256 ];
%      sprintf ( szError, szFormatNoServer, __procedure__ );
%      RPC_CLIENT_ERROR ( szError );
%      return Result.ReturnValue;
%    }
%  }
%#else
%  while ( __pClient__ == NULL ) {
%    __pClient__	= RPC_CLIENT_CREATE ( __szHost__, __szTransport__ );
%    if ( __pClient__ == NULL ) {
%      /* Error handling for a not connected client: */
%      char	szError [ 256 ];
%      sprintf ( szError, szFormatNoServer, __procedure__ );
%      RPC_CLIENT_CERROR ( szContNoServer, szError );
%    }
%  }
%#endif	/* CLIENT_CREATE_BY_USER */
%
%  /* Copy in the oShortObjIdHeap argument: */
%  InArguments.oShortObjIdHeap	= oShortObjIdHeap;
%  /* Copy in the oShortObjId argument: */
%  InArguments.oShortObjId	= oShortObjId;
%  /* Copy in the fSingleFloat argument: */
%  InArguments.fSingleFloat	= fSingleFloat;
%
%  pResult	=
%#ifdef MULTITHREAD
%    (
%#else
%    (fnServerObjectWriteSingleFloat_rets *)
%#endif
%    fnrpc_fnserverobjectwritesinglefloat_1 (
%	&InArguments,
%#ifdef MULTITHREAD
%	&Result,
%#endif
%	__pClient__ )
%#ifdef MULTITHREAD
%	== RPC_SUCCESS ) ? &Result : NULL
%#endif
%	;
%
%  if ( pResult == NULL ) {
%    /* Error handling for a failed RPC call, */
%    /* i.e. the server did not respond: */
%    char	szError [ 256 ];
%    sprintf ( szError, szFormatRpcFailed, __procedure__,
%              clnt_sperror ( __pClient__, __szHost__ ) );
%    __pClient__	= RPC_CLIENT_DESTROY ( __pClient__ );
%    RPC_CLIENT_CERROR ( szContRpcFailed, szError );
%    Result	= ZeroResult;
%    return Result.ReturnValue;
%  }
%#ifndef MULTITHREAD
%  Result	= * pResult;
%#endif
%
%
%  if ( pResult && pResult->nErrorLvl ) {
%    /* Server returned a user error message: */
%    char	szErrorMsg [ 1024 ];
%    strncpy ( szErrorMsg,
%              ( pResult->pszErrorMsg && pResult->pszErrorMsg [ 0 ] ) ?
%              (LPCSTR) pResult->pszErrorMsg : (LPCSTR) szEmpty,
%              sizeof ( szErrorMsg ) );
%    szErrorMsg [ sizeof ( szErrorMsg ) - 1 ]	= (char) 0;
%    xdr_free ( (xdrproc_t) xdr_fnServerObjectWriteSingleFloat_rets, (char *) pResult );
%    RPC_CLIENT_SERROR ( pResult->nErrorLvl, __procedure__,
%                        szErrorMsg );
%  } else {
%    xdr_free ( (xdrproc_t) xdr_fnServerObjectWriteSingleFloat_rets, (char *) pResult );
%  }
%
%  return Result.ReturnValue;
%
%} /* fnServerObjectWriteSingleFloat */
#endif	/* RPC_CLNT */
%
  fnClientLockPrint_rets fnRpc_fnClientLockPrint ( fnClientLockPrint_args ) =  65 ;
%
#if RPC_SVC
%
%extern int fnClientLockPrint
%	(SHORTOBJID oShortObjIdHeap ,
%	  SHORTOBJID oShortSelf ,
%	  SHLOCK nLevel ,
%	  NUMERICSTDSTREAM nStdStream);
%
%#ifdef MULTITHREAD
%bool_t
%#else
%fnClientLockPrint_rets *
%#endif
%	PASTE2(fnrpc_fnclientlockprint_1,_SVCSUFFIX)
%		( fnClientLockPrint_args * pArguments,
%#ifdef MULTITHREAD
%		  fnClientLockPrint_rets * pResult,
%#endif
%		  struct svc_req * pRequest )
%{
%  static const char	__procedure__[]	= "server:fnrpc_fnclientlockprint_1";
%#ifdef MULTITHREAD
%  typedef bool_t RESULTTYPE;
%#else
%  typedef fnClientLockPrint_rets * RESULTTYPE;
%#endif
%#ifndef MULTITHREAD
%  static fnClientLockPrint_rets	Result;
%  RESULTTYPE			pResult = &Result;
%#endif
%  LPCSTR	pszErrorMsg;
%
%  __pRequest__	= pRequest;
%
%  RPC_SERVER_ENTRY();
%
%#ifndef MULTITHREAD
%  if ( pResult->pszErrorMsg == szEmpty ) {
%    pResult->pszErrorMsg	= NULL;
%  }
%  xdr_free ( (xdrproc_t) xdr_fnClientLockPrint_rets, (char *) pResult );
%#endif
%  pResult->nErrorLvl		= 0;
%
%  Reply.bAnswered		= FALSE;
%  Reply.pfnCalled		= (void(*)()) fnClientLockPrint;
%  Reply.pfnXdrResult		= (bool_t(*)()) xdr_fnClientLockPrint_rets;
%  Reply.pnErrorLvl		= &pResult->nErrorLvl;
%  Reply.ppszErrorMsg		= (LPCSTR *) &pResult->pszErrorMsg;
%  Reply.pResult		= pResult;
%  Reply.pReturnValue		= &pResult->ReturnValue;
%  Reply.nReturnValueSize	= sizeof ( pResult->ReturnValue );
%
%  pResult->ReturnValue		=
%  fnClientLockPrint (
%	pArguments->oShortObjIdHeap,
%	pArguments->oShortSelf,
%	pArguments->nLevel,
%	pArguments->nStdStream );
%
%  if ( Reply.bAnswered ) {
%    __pRequest__	= NULL;
%    return (RESULTTYPE) NULL;
%  }
%
%  pResult->nErrorLvl	= RPC_SERVER_ERRLVL();
%  if ( pResult->nErrorLvl > 0 ) {
%    pszErrorMsg		= RPC_SERVER_ERRMSG();
%    if ( pszErrorMsg && *pszErrorMsg ) {
%      pResult->pszErrorMsg	= strdup ( pszErrorMsg );
%    }
%  }
%  if ( pResult->pszErrorMsg == NULL ) {
%#ifdef MULTITHREAD
%    pResult->pszErrorMsg	= strdup ( szEmpty );
%#else
%    pResult->pszErrorMsg	= (LPSTR) szEmpty;
%#endif
%  }
%  __pRequest__	= NULL;
%  return (RESULTTYPE) pResult;
%} /* fnrpc_fnclientlockprint_1 */
#endif	/* RPC_SVC */
%
#if RPC_CLNT
%int DLLEXPORT fnClientLockPrint
%	(SHORTOBJID oShortObjIdHeap ,
%	  SHORTOBJID oShortSelf ,
%	  SHLOCK nLevel ,
%	  NUMERICSTDSTREAM nStdStream)
%{
%  static const char	__procedure__[]	= "client:fnClientLockPrint";
%  static fnClientLockPrint_rets	ZeroResult;
%  fnClientLockPrint_rets		* pResult = NULL;
%  fnClientLockPrint_rets		Result = ZeroResult;
%  fnClientLockPrint_args	InArguments;
%
%  /* Client initialization: */
%  if ( __bClientInitialize__ ) {
%    __bClientInitialize__	= FALSE;
%    RPC_CLIENT_INITIALIZE();
%  }
%
%#if	CLIENT_CREATE_BY_USER
%  if ( __pClient__ == NULL ) {
%    __pClient__	= RPC_CLIENT_CREATE ( __szHost__, __szTransport__ );
%    if ( __pClient__ == NULL ) {
%      /* Error handling for a not connected client: */
%      char	szError [ 256 ];
%      sprintf ( szError, szFormatNoServer, __procedure__ );
%      RPC_CLIENT_ERROR ( szError );
%      return Result.ReturnValue;
%    }
%  }
%#else
%  while ( __pClient__ == NULL ) {
%    __pClient__	= RPC_CLIENT_CREATE ( __szHost__, __szTransport__ );
%    if ( __pClient__ == NULL ) {
%      /* Error handling for a not connected client: */
%      char	szError [ 256 ];
%      sprintf ( szError, szFormatNoServer, __procedure__ );
%      RPC_CLIENT_CERROR ( szContNoServer, szError );
%    }
%  }
%#endif	/* CLIENT_CREATE_BY_USER */
%
%  /* Copy in the oShortObjIdHeap argument: */
%  InArguments.oShortObjIdHeap	= oShortObjIdHeap;
%  /* Copy in the oShortSelf argument: */
%  InArguments.oShortSelf	= oShortSelf;
%  /* Copy in the nLevel argument: */
%  InArguments.nLevel	= nLevel;
%  /* Copy in the nStdStream argument: */
%  InArguments.nStdStream	= nStdStream;
%
%  pResult	=
%#ifdef MULTITHREAD
%    (
%#else
%    (fnClientLockPrint_rets *)
%#endif
%    fnrpc_fnclientlockprint_1 (
%	&InArguments,
%#ifdef MULTITHREAD
%	&Result,
%#endif
%	__pClient__ )
%#ifdef MULTITHREAD
%	== RPC_SUCCESS ) ? &Result : NULL
%#endif
%	;
%
%  if ( pResult == NULL ) {
%    /* Error handling for a failed RPC call, */
%    /* i.e. the server did not respond: */
%    char	szError [ 256 ];
%    sprintf ( szError, szFormatRpcFailed, __procedure__,
%              clnt_sperror ( __pClient__, __szHost__ ) );
%    __pClient__	= RPC_CLIENT_DESTROY ( __pClient__ );
%    RPC_CLIENT_CERROR ( szContRpcFailed, szError );
%    Result	= ZeroResult;
%    return Result.ReturnValue;
%  }
%#ifndef MULTITHREAD
%  Result	= * pResult;
%#endif
%
%
%  if ( pResult && pResult->nErrorLvl ) {
%    /* Server returned a user error message: */
%    char	szErrorMsg [ 1024 ];
%    strncpy ( szErrorMsg,
%              ( pResult->pszErrorMsg && pResult->pszErrorMsg [ 0 ] ) ?
%              (LPCSTR) pResult->pszErrorMsg : (LPCSTR) szEmpty,
%              sizeof ( szErrorMsg ) );
%    szErrorMsg [ sizeof ( szErrorMsg ) - 1 ]	= (char) 0;
%    xdr_free ( (xdrproc_t) xdr_fnClientLockPrint_rets, (char *) pResult );
%    RPC_CLIENT_SERROR ( pResult->nErrorLvl, __procedure__,
%                        szErrorMsg );
%  } else {
%    xdr_free ( (xdrproc_t) xdr_fnClientLockPrint_rets, (char *) pResult );
%  }
%
%  return Result.ReturnValue;
%
%} /* fnClientLockPrint */
#endif	/* RPC_CLNT */
%
  fnClientTransactionLockGet_rets fnRpc_fnClientTransactionLockGet ( fnClientTransactionLockGet_args ) =  66 ;
%
#if RPC_SVC
%
%extern SHLOCK fnClientTransactionLockGet
%	(SHORTOBJID oShortObjIdHeap ,
%	  SHORTOBJID oShortObjIdLockedByP ,
%	  SHLOCK nLevelP ,
%	  SHORTOBJID oShortLockedP ,
%	  SHTYPETAG nTypeTagLockedP ,
%	  int nIndexP);
%
%#ifdef MULTITHREAD
%bool_t
%#else
%fnClientTransactionLockGet_rets *
%#endif
%	PASTE2(fnrpc_fnclienttransactionlockget_1,_SVCSUFFIX)
%		( fnClientTransactionLockGet_args * pArguments,
%#ifdef MULTITHREAD
%		  fnClientTransactionLockGet_rets * pResult,
%#endif
%		  struct svc_req * pRequest )
%{
%  static const char	__procedure__[]	= "server:fnrpc_fnclienttransactionlockget_1";
%#ifdef MULTITHREAD
%  typedef bool_t RESULTTYPE;
%#else
%  typedef fnClientTransactionLockGet_rets * RESULTTYPE;
%#endif
%#ifndef MULTITHREAD
%  static fnClientTransactionLockGet_rets	Result;
%  RESULTTYPE			pResult = &Result;
%#endif
%  LPCSTR	pszErrorMsg;
%
%  __pRequest__	= pRequest;
%
%  RPC_SERVER_ENTRY();
%
%#ifndef MULTITHREAD
%  if ( pResult->pszErrorMsg == szEmpty ) {
%    pResult->pszErrorMsg	= NULL;
%  }
%  xdr_free ( (xdrproc_t) xdr_fnClientTransactionLockGet_rets, (char *) pResult );
%#endif
%  pResult->nErrorLvl		= 0;
%
%  Reply.bAnswered		= FALSE;
%  Reply.pfnCalled		= (void(*)()) fnClientTransactionLockGet;
%  Reply.pfnXdrResult		= (bool_t(*)()) xdr_fnClientTransactionLockGet_rets;
%  Reply.pnErrorLvl		= &pResult->nErrorLvl;
%  Reply.ppszErrorMsg		= (LPCSTR *) &pResult->pszErrorMsg;
%  Reply.pResult		= pResult;
%  Reply.pReturnValue		= &pResult->ReturnValue;
%  Reply.nReturnValueSize	= sizeof ( pResult->ReturnValue );
%
%  pResult->ReturnValue		=
%  fnClientTransactionLockGet (
%	pArguments->oShortObjIdHeap,
%	pArguments->oShortObjIdLockedByP,
%	pArguments->nLevelP,
%	pArguments->oShortLockedP,
%	pArguments->nTypeTagLockedP,
%	pArguments->nIndexP );
%
%  if ( Reply.bAnswered ) {
%    __pRequest__	= NULL;
%    return (RESULTTYPE) NULL;
%  }
%
%  pResult->nErrorLvl	= RPC_SERVER_ERRLVL();
%  if ( pResult->nErrorLvl > 0 ) {
%    pszErrorMsg		= RPC_SERVER_ERRMSG();
%    if ( pszErrorMsg && *pszErrorMsg ) {
%      pResult->pszErrorMsg	= strdup ( pszErrorMsg );
%    }
%  }
%  if ( pResult->pszErrorMsg == NULL ) {
%#ifdef MULTITHREAD
%    pResult->pszErrorMsg	= strdup ( szEmpty );
%#else
%    pResult->pszErrorMsg	= (LPSTR) szEmpty;
%#endif
%  }
%  __pRequest__	= NULL;
%  return (RESULTTYPE) pResult;
%} /* fnrpc_fnclienttransactionlockget_1 */
#endif	/* RPC_SVC */
%
#if RPC_CLNT
%SHLOCK DLLEXPORT fnClientTransactionLockGet
%	(SHORTOBJID oShortObjIdHeap ,
%	  SHORTOBJID oShortObjIdLockedByP ,
%	  SHLOCK nLevelP ,
%	  SHORTOBJID oShortLockedP ,
%	  SHTYPETAG nTypeTagLockedP ,
%	  int nIndexP)
%{
%  static const char	__procedure__[]	= "client:fnClientTransactionLockGet";
%  static fnClientTransactionLockGet_rets	ZeroResult;
%  fnClientTransactionLockGet_rets		* pResult = NULL;
%  fnClientTransactionLockGet_rets		Result = ZeroResult;
%  fnClientTransactionLockGet_args	InArguments;
%
%  /* Client initialization: */
%  if ( __bClientInitialize__ ) {
%    __bClientInitialize__	= FALSE;
%    RPC_CLIENT_INITIALIZE();
%  }
%
%#if	CLIENT_CREATE_BY_USER
%  if ( __pClient__ == NULL ) {
%    __pClient__	= RPC_CLIENT_CREATE ( __szHost__, __szTransport__ );
%    if ( __pClient__ == NULL ) {
%      /* Error handling for a not connected client: */
%      char	szError [ 256 ];
%      sprintf ( szError, szFormatNoServer, __procedure__ );
%      RPC_CLIENT_ERROR ( szError );
%      return Result.ReturnValue;
%    }
%  }
%#else
%  while ( __pClient__ == NULL ) {
%    __pClient__	= RPC_CLIENT_CREATE ( __szHost__, __szTransport__ );
%    if ( __pClient__ == NULL ) {
%      /* Error handling for a not connected client: */
%      char	szError [ 256 ];
%      sprintf ( szError, szFormatNoServer, __procedure__ );
%      RPC_CLIENT_CERROR ( szContNoServer, szError );
%    }
%  }
%#endif	/* CLIENT_CREATE_BY_USER */
%
%  /* Copy in the oShortObjIdHeap argument: */
%  InArguments.oShortObjIdHeap	= oShortObjIdHeap;
%  /* Copy in the oShortObjIdLockedByP argument: */
%  InArguments.oShortObjIdLockedByP	= oShortObjIdLockedByP;
%  /* Copy in the nLevelP argument: */
%  InArguments.nLevelP	= nLevelP;
%  /* Copy in the oShortLockedP argument: */
%  InArguments.oShortLockedP	= oShortLockedP;
%  /* Copy in the nTypeTagLockedP argument: */
%  InArguments.nTypeTagLockedP	= nTypeTagLockedP;
%  /* Copy in the nIndexP argument: */
%  InArguments.nIndexP	= nIndexP;
%
%  pResult	=
%#ifdef MULTITHREAD
%    (
%#else
%    (fnClientTransactionLockGet_rets *)
%#endif
%    fnrpc_fnclienttransactionlockget_1 (
%	&InArguments,
%#ifdef MULTITHREAD
%	&Result,
%#endif
%	__pClient__ )
%#ifdef MULTITHREAD
%	== RPC_SUCCESS ) ? &Result : NULL
%#endif
%	;
%
%  if ( pResult == NULL ) {
%    /* Error handling for a failed RPC call, */
%    /* i.e. the server did not respond: */
%    char	szError [ 256 ];
%    sprintf ( szError, szFormatRpcFailed, __procedure__,
%              clnt_sperror ( __pClient__, __szHost__ ) );
%    __pClient__	= RPC_CLIENT_DESTROY ( __pClient__ );
%    RPC_CLIENT_CERROR ( szContRpcFailed, szError );
%    Result	= ZeroResult;
%    return Result.ReturnValue;
%  }
%#ifndef MULTITHREAD
%  Result	= * pResult;
%#endif
%
%
%  if ( pResult && pResult->nErrorLvl ) {
%    /* Server returned a user error message: */
%    char	szErrorMsg [ 1024 ];
%    strncpy ( szErrorMsg,
%              ( pResult->pszErrorMsg && pResult->pszErrorMsg [ 0 ] ) ?
%              (LPCSTR) pResult->pszErrorMsg : (LPCSTR) szEmpty,
%              sizeof ( szErrorMsg ) );
%    szErrorMsg [ sizeof ( szErrorMsg ) - 1 ]	= (char) 0;
%    xdr_free ( (xdrproc_t) xdr_fnClientTransactionLockGet_rets, (char *) pResult );
%    RPC_CLIENT_SERROR ( pResult->nErrorLvl, __procedure__,
%                        szErrorMsg );
%  } else {
%    xdr_free ( (xdrproc_t) xdr_fnClientTransactionLockGet_rets, (char *) pResult );
%  }
%
%  return Result.ReturnValue;
%
%} /* fnClientTransactionLockGet */
#endif	/* RPC_CLNT */
%
  fnServerTransactionLockInsert_rets fnRpc_fnServerTransactionLockInsert ( fnServerTransactionLockInsert_args ) =  67 ;
%
#if RPC_SVC
%
%extern SHLOCK fnServerTransactionLockInsert
%	(SHORTOBJID oShortObjIdHeap ,
%	  SHORTOBJID oShortObjIdLockBy ,
%	  SHLOCK nLock ,
%	  SHORTOBJID oShortToLock ,
%	  SHTYPETAG nTypeTagToLock ,
%	  int nIndex ,
%	  int * phPeek ,
%	  int * pnObjIdWords);
%
%#ifdef MULTITHREAD
%bool_t
%#else
%fnServerTransactionLockInsert_rets *
%#endif
%	PASTE2(fnrpc_fnservertransactionlockinsert_1,_SVCSUFFIX)
%		( fnServerTransactionLockInsert_args * pArguments,
%#ifdef MULTITHREAD
%		  fnServerTransactionLockInsert_rets * pResult,
%#endif
%		  struct svc_req * pRequest )
%{
%  static const char	__procedure__[]	= "server:fnrpc_fnservertransactionlockinsert_1";
%#ifdef MULTITHREAD
%  typedef bool_t RESULTTYPE;
%#else
%  typedef fnServerTransactionLockInsert_rets * RESULTTYPE;
%#endif
%#ifndef MULTITHREAD
%  static fnServerTransactionLockInsert_rets	Result;
%  RESULTTYPE			pResult = &Result;
%#endif
%  LPCSTR	pszErrorMsg;
%
%  __pRequest__	= pRequest;
%
%  RPC_SERVER_ENTRY();
%
%#ifndef MULTITHREAD
%  if ( pResult->pszErrorMsg == szEmpty ) {
%    pResult->pszErrorMsg	= NULL;
%  }
%  xdr_free ( (xdrproc_t) xdr_fnServerTransactionLockInsert_rets, (char *) pResult );
%#endif
%  pResult->nErrorLvl		= 0;
%
%  Reply.bAnswered		= FALSE;
%  Reply.pfnCalled		= (void(*)()) fnServerTransactionLockInsert;
%  Reply.pfnXdrResult		= (bool_t(*)()) xdr_fnServerTransactionLockInsert_rets;
%  Reply.pnErrorLvl		= &pResult->nErrorLvl;
%  Reply.ppszErrorMsg		= (LPCSTR *) &pResult->pszErrorMsg;
%  Reply.pResult		= pResult;
%  Reply.pReturnValue		= &pResult->ReturnValue;
%  Reply.nReturnValueSize	= sizeof ( pResult->ReturnValue );
%
%  pResult->ReturnValue		=
%  fnServerTransactionLockInsert (
%	pArguments->oShortObjIdHeap,
%	pArguments->oShortObjIdLockBy,
%	pArguments->nLock,
%	pArguments->oShortToLock,
%	pArguments->nTypeTagToLock,
%	pArguments->nIndex,
%	&pResult->phPeek,
%	&pResult->pnObjIdWords );
%
%  if ( Reply.bAnswered ) {
%    __pRequest__	= NULL;
%    return (RESULTTYPE) NULL;
%  }
%
%  pResult->nErrorLvl	= RPC_SERVER_ERRLVL();
%  if ( pResult->nErrorLvl > 0 ) {
%    pszErrorMsg		= RPC_SERVER_ERRMSG();
%    if ( pszErrorMsg && *pszErrorMsg ) {
%      pResult->pszErrorMsg	= strdup ( pszErrorMsg );
%    }
%  }
%  if ( pResult->pszErrorMsg == NULL ) {
%#ifdef MULTITHREAD
%    pResult->pszErrorMsg	= strdup ( szEmpty );
%#else
%    pResult->pszErrorMsg	= (LPSTR) szEmpty;
%#endif
%  }
%  __pRequest__	= NULL;
%  return (RESULTTYPE) pResult;
%} /* fnrpc_fnservertransactionlockinsert_1 */
#endif	/* RPC_SVC */
%
#if RPC_CLNT
%SHLOCK DLLEXPORT fnServerTransactionLockInsert
%	(SHORTOBJID oShortObjIdHeap ,
%	  SHORTOBJID oShortObjIdLockBy ,
%	  SHLOCK nLock ,
%	  SHORTOBJID oShortToLock ,
%	  SHTYPETAG nTypeTagToLock ,
%	  int nIndex ,
%	  int * phPeek ,
%	  int * pnObjIdWords)
%{
%  static const char	__procedure__[]	= "client:fnServerTransactionLockInsert";
%  static fnServerTransactionLockInsert_rets	ZeroResult;
%  fnServerTransactionLockInsert_rets		* pResult = NULL;
%  fnServerTransactionLockInsert_rets		Result = ZeroResult;
%  fnServerTransactionLockInsert_args	InArguments;
%
%  /* Client initialization: */
%  if ( __bClientInitialize__ ) {
%    __bClientInitialize__	= FALSE;
%    RPC_CLIENT_INITIALIZE();
%  }
%
%#if	CLIENT_CREATE_BY_USER
%  if ( __pClient__ == NULL ) {
%    __pClient__	= RPC_CLIENT_CREATE ( __szHost__, __szTransport__ );
%    if ( __pClient__ == NULL ) {
%      /* Error handling for a not connected client: */
%      char	szError [ 256 ];
%      sprintf ( szError, szFormatNoServer, __procedure__ );
%      RPC_CLIENT_ERROR ( szError );
%      return Result.ReturnValue;
%    }
%  }
%#else
%  while ( __pClient__ == NULL ) {
%    __pClient__	= RPC_CLIENT_CREATE ( __szHost__, __szTransport__ );
%    if ( __pClient__ == NULL ) {
%      /* Error handling for a not connected client: */
%      char	szError [ 256 ];
%      sprintf ( szError, szFormatNoServer, __procedure__ );
%      RPC_CLIENT_CERROR ( szContNoServer, szError );
%    }
%  }
%#endif	/* CLIENT_CREATE_BY_USER */
%
%  /* Copy in the oShortObjIdHeap argument: */
%  InArguments.oShortObjIdHeap	= oShortObjIdHeap;
%  /* Copy in the oShortObjIdLockBy argument: */
%  InArguments.oShortObjIdLockBy	= oShortObjIdLockBy;
%  /* Copy in the nLock argument: */
%  InArguments.nLock	= nLock;
%  /* Copy in the oShortToLock argument: */
%  InArguments.oShortToLock	= oShortToLock;
%  /* Copy in the nTypeTagToLock argument: */
%  InArguments.nTypeTagToLock	= nTypeTagToLock;
%  /* Copy in the nIndex argument: */
%  InArguments.nIndex	= nIndex;
%
%  pResult	=
%#ifdef MULTITHREAD
%    (
%#else
%    (fnServerTransactionLockInsert_rets *)
%#endif
%    fnrpc_fnservertransactionlockinsert_1 (
%	&InArguments,
%#ifdef MULTITHREAD
%	&Result,
%#endif
%	__pClient__ )
%#ifdef MULTITHREAD
%	== RPC_SUCCESS ) ? &Result : NULL
%#endif
%	;
%
%  if ( pResult == NULL ) {
%    /* Error handling for a failed RPC call, */
%    /* i.e. the server did not respond: */
%    char	szError [ 256 ];
%    sprintf ( szError, szFormatRpcFailed, __procedure__,
%              clnt_sperror ( __pClient__, __szHost__ ) );
%    __pClient__	= RPC_CLIENT_DESTROY ( __pClient__ );
%    RPC_CLIENT_CERROR ( szContRpcFailed, szError );
%    Result	= ZeroResult;
%    return Result.ReturnValue;
%  }
%#ifndef MULTITHREAD
%  Result	= * pResult;
%#endif
%
%  /* Copy out the phPeek argument: */
%  if ( ! ( 
%       phPeek == NULL ) ) {
%    *phPeek	= pResult->phPeek;
%  }
%  /* Copy out the pnObjIdWords argument: */
%  if ( ! ( 
%       pnObjIdWords == NULL ) ) {
%    *pnObjIdWords	= pResult->pnObjIdWords;
%  }
%
%  if ( pResult && pResult->nErrorLvl ) {
%    /* Server returned a user error message: */
%    char	szErrorMsg [ 1024 ];
%    strncpy ( szErrorMsg,
%              ( pResult->pszErrorMsg && pResult->pszErrorMsg [ 0 ] ) ?
%              (LPCSTR) pResult->pszErrorMsg : (LPCSTR) szEmpty,
%              sizeof ( szErrorMsg ) );
%    szErrorMsg [ sizeof ( szErrorMsg ) - 1 ]	= (char) 0;
%    xdr_free ( (xdrproc_t) xdr_fnServerTransactionLockInsert_rets, (char *) pResult );
%    RPC_CLIENT_SERROR ( pResult->nErrorLvl, __procedure__,
%                        szErrorMsg );
%  } else {
%    xdr_free ( (xdrproc_t) xdr_fnServerTransactionLockInsert_rets, (char *) pResult );
%  }
%  if ( 
%       phPeek == NULL ) {
%    /* Error handling for passing a NULL pointer on */
%    /* out argument: */
%    char	szError [ 256 ];
%    sprintf ( szError, szFormatNullPassed,
%              __procedure__, "phPeek" );
%    RPC_CLIENT_CERROR ( szContNullOutPassed, szError );
%  }
%  if ( 
%       pnObjIdWords == NULL ) {
%    /* Error handling for passing a NULL pointer on */
%    /* out argument: */
%    char	szError [ 256 ];
%    sprintf ( szError, szFormatNullPassed,
%              __procedure__, "pnObjIdWords" );
%    RPC_CLIENT_CERROR ( szContNullOutPassed, szError );
%  }
%
%  return Result.ReturnValue;
%
%} /* fnServerTransactionLockInsert */
#endif	/* RPC_CLNT */
%
  fnServerTransactionLockSet_rets fnRpc_fnServerTransactionLockSet ( fnServerTransactionLockSet_args ) =  68 ;
%
#if RPC_SVC
%
%extern SHLOCK fnServerTransactionLockSet
%	(SHORTOBJID oShortObjIdHeap ,
%	  SHORTOBJID oShortObjIdLockBy ,
%	  SHLOCK nLock ,
%	  SHORTOBJID oShortToLock ,
%	  SHTYPETAG nTypeTagToLock ,
%	  int nIndex ,
%	  int * phPeek ,
%	  int * pnObjIdWords);
%
%#ifdef MULTITHREAD
%bool_t
%#else
%fnServerTransactionLockSet_rets *
%#endif
%	PASTE2(fnrpc_fnservertransactionlockset_1,_SVCSUFFIX)
%		( fnServerTransactionLockSet_args * pArguments,
%#ifdef MULTITHREAD
%		  fnServerTransactionLockSet_rets * pResult,
%#endif
%		  struct svc_req * pRequest )
%{
%  static const char	__procedure__[]	= "server:fnrpc_fnservertransactionlockset_1";
%#ifdef MULTITHREAD
%  typedef bool_t RESULTTYPE;
%#else
%  typedef fnServerTransactionLockSet_rets * RESULTTYPE;
%#endif
%#ifndef MULTITHREAD
%  static fnServerTransactionLockSet_rets	Result;
%  RESULTTYPE			pResult = &Result;
%#endif
%  LPCSTR	pszErrorMsg;
%
%  __pRequest__	= pRequest;
%
%  RPC_SERVER_ENTRY();
%
%#ifndef MULTITHREAD
%  if ( pResult->pszErrorMsg == szEmpty ) {
%    pResult->pszErrorMsg	= NULL;
%  }
%  xdr_free ( (xdrproc_t) xdr_fnServerTransactionLockSet_rets, (char *) pResult );
%#endif
%  pResult->nErrorLvl		= 0;
%
%  Reply.bAnswered		= FALSE;
%  Reply.pfnCalled		= (void(*)()) fnServerTransactionLockSet;
%  Reply.pfnXdrResult		= (bool_t(*)()) xdr_fnServerTransactionLockSet_rets;
%  Reply.pnErrorLvl		= &pResult->nErrorLvl;
%  Reply.ppszErrorMsg		= (LPCSTR *) &pResult->pszErrorMsg;
%  Reply.pResult		= pResult;
%  Reply.pReturnValue		= &pResult->ReturnValue;
%  Reply.nReturnValueSize	= sizeof ( pResult->ReturnValue );
%
%  pResult->ReturnValue		=
%  fnServerTransactionLockSet (
%	pArguments->oShortObjIdHeap,
%	pArguments->oShortObjIdLockBy,
%	pArguments->nLock,
%	pArguments->oShortToLock,
%	pArguments->nTypeTagToLock,
%	pArguments->nIndex,
%	&pResult->phPeek,
%	&pResult->pnObjIdWords );
%
%  if ( Reply.bAnswered ) {
%    __pRequest__	= NULL;
%    return (RESULTTYPE) NULL;
%  }
%
%  pResult->nErrorLvl	= RPC_SERVER_ERRLVL();
%  if ( pResult->nErrorLvl > 0 ) {
%    pszErrorMsg		= RPC_SERVER_ERRMSG();
%    if ( pszErrorMsg && *pszErrorMsg ) {
%      pResult->pszErrorMsg	= strdup ( pszErrorMsg );
%    }
%  }
%  if ( pResult->pszErrorMsg == NULL ) {
%#ifdef MULTITHREAD
%    pResult->pszErrorMsg	= strdup ( szEmpty );
%#else
%    pResult->pszErrorMsg	= (LPSTR) szEmpty;
%#endif
%  }
%  __pRequest__	= NULL;
%  return (RESULTTYPE) pResult;
%} /* fnrpc_fnservertransactionlockset_1 */
#endif	/* RPC_SVC */
%
#if RPC_CLNT
%SHLOCK DLLEXPORT fnServerTransactionLockSet
%	(SHORTOBJID oShortObjIdHeap ,
%	  SHORTOBJID oShortObjIdLockBy ,
%	  SHLOCK nLock ,
%	  SHORTOBJID oShortToLock ,
%	  SHTYPETAG nTypeTagToLock ,
%	  int nIndex ,
%	  int * phPeek ,
%	  int * pnObjIdWords)
%{
%  static const char	__procedure__[]	= "client:fnServerTransactionLockSet";
%  static fnServerTransactionLockSet_rets	ZeroResult;
%  fnServerTransactionLockSet_rets		* pResult = NULL;
%  fnServerTransactionLockSet_rets		Result = ZeroResult;
%  fnServerTransactionLockSet_args	InArguments;
%
%  /* Client initialization: */
%  if ( __bClientInitialize__ ) {
%    __bClientInitialize__	= FALSE;
%    RPC_CLIENT_INITIALIZE();
%  }
%
%#if	CLIENT_CREATE_BY_USER
%  if ( __pClient__ == NULL ) {
%    __pClient__	= RPC_CLIENT_CREATE ( __szHost__, __szTransport__ );
%    if ( __pClient__ == NULL ) {
%      /* Error handling for a not connected client: */
%      char	szError [ 256 ];
%      sprintf ( szError, szFormatNoServer, __procedure__ );
%      RPC_CLIENT_ERROR ( szError );
%      return Result.ReturnValue;
%    }
%  }
%#else
%  while ( __pClient__ == NULL ) {
%    __pClient__	= RPC_CLIENT_CREATE ( __szHost__, __szTransport__ );
%    if ( __pClient__ == NULL ) {
%      /* Error handling for a not connected client: */
%      char	szError [ 256 ];
%      sprintf ( szError, szFormatNoServer, __procedure__ );
%      RPC_CLIENT_CERROR ( szContNoServer, szError );
%    }
%  }
%#endif	/* CLIENT_CREATE_BY_USER */
%
%  /* Copy in the oShortObjIdHeap argument: */
%  InArguments.oShortObjIdHeap	= oShortObjIdHeap;
%  /* Copy in the oShortObjIdLockBy argument: */
%  InArguments.oShortObjIdLockBy	= oShortObjIdLockBy;
%  /* Copy in the nLock argument: */
%  InArguments.nLock	= nLock;
%  /* Copy in the oShortToLock argument: */
%  InArguments.oShortToLock	= oShortToLock;
%  /* Copy in the nTypeTagToLock argument: */
%  InArguments.nTypeTagToLock	= nTypeTagToLock;
%  /* Copy in the nIndex argument: */
%  InArguments.nIndex	= nIndex;
%
%  pResult	=
%#ifdef MULTITHREAD
%    (
%#else
%    (fnServerTransactionLockSet_rets *)
%#endif
%    fnrpc_fnservertransactionlockset_1 (
%	&InArguments,
%#ifdef MULTITHREAD
%	&Result,
%#endif
%	__pClient__ )
%#ifdef MULTITHREAD
%	== RPC_SUCCESS ) ? &Result : NULL
%#endif
%	;
%
%  if ( pResult == NULL ) {
%    /* Error handling for a failed RPC call, */
%    /* i.e. the server did not respond: */
%    char	szError [ 256 ];
%    sprintf ( szError, szFormatRpcFailed, __procedure__,
%              clnt_sperror ( __pClient__, __szHost__ ) );
%    __pClient__	= RPC_CLIENT_DESTROY ( __pClient__ );
%    RPC_CLIENT_CERROR ( szContRpcFailed, szError );
%    Result	= ZeroResult;
%    return Result.ReturnValue;
%  }
%#ifndef MULTITHREAD
%  Result	= * pResult;
%#endif
%
%  /* Copy out the phPeek argument: */
%  if ( ! ( 
%       phPeek == NULL ) ) {
%    *phPeek	= pResult->phPeek;
%  }
%  /* Copy out the pnObjIdWords argument: */
%  if ( ! ( 
%       pnObjIdWords == NULL ) ) {
%    *pnObjIdWords	= pResult->pnObjIdWords;
%  }
%
%  if ( pResult && pResult->nErrorLvl ) {
%    /* Server returned a user error message: */
%    char	szErrorMsg [ 1024 ];
%    strncpy ( szErrorMsg,
%              ( pResult->pszErrorMsg && pResult->pszErrorMsg [ 0 ] ) ?
%              (LPCSTR) pResult->pszErrorMsg : (LPCSTR) szEmpty,
%              sizeof ( szErrorMsg ) );
%    szErrorMsg [ sizeof ( szErrorMsg ) - 1 ]	= (char) 0;
%    xdr_free ( (xdrproc_t) xdr_fnServerTransactionLockSet_rets, (char *) pResult );
%    RPC_CLIENT_SERROR ( pResult->nErrorLvl, __procedure__,
%                        szErrorMsg );
%  } else {
%    xdr_free ( (xdrproc_t) xdr_fnServerTransactionLockSet_rets, (char *) pResult );
%  }
%  if ( 
%       phPeek == NULL ) {
%    /* Error handling for passing a NULL pointer on */
%    /* out argument: */
%    char	szError [ 256 ];
%    sprintf ( szError, szFormatNullPassed,
%              __procedure__, "phPeek" );
%    RPC_CLIENT_CERROR ( szContNullOutPassed, szError );
%  }
%  if ( 
%       pnObjIdWords == NULL ) {
%    /* Error handling for passing a NULL pointer on */
%    /* out argument: */
%    char	szError [ 256 ];
%    sprintf ( szError, szFormatNullPassed,
%              __procedure__, "pnObjIdWords" );
%    RPC_CLIENT_CERROR ( szContNullOutPassed, szError );
%  }
%
%  return Result.ReturnValue;
%
%} /* fnServerTransactionLockSet */
#endif	/* RPC_CLNT */
%
  fnServerTransactionUnlock_rets fnRpc_fnServerTransactionUnlock ( fnServerTransactionUnlock_args ) =  69 ;
%
#if RPC_SVC
%
%extern SHLOCK fnServerTransactionUnlock
%	(SHORTOBJID oShortObjIdHeap ,
%	  SHORTOBJID oShortObjIdLockedBy ,
%	  SHLOCK nLock ,
%	  SHORTOBJID oShortToUnlock ,
%	  int nIndex ,
%	  SHLOCK * pnVectorLockNow);
%
%#ifdef MULTITHREAD
%bool_t
%#else
%fnServerTransactionUnlock_rets *
%#endif
%	PASTE2(fnrpc_fnservertransactionunlock_1,_SVCSUFFIX)
%		( fnServerTransactionUnlock_args * pArguments,
%#ifdef MULTITHREAD
%		  fnServerTransactionUnlock_rets * pResult,
%#endif
%		  struct svc_req * pRequest )
%{
%  static const char	__procedure__[]	= "server:fnrpc_fnservertransactionunlock_1";
%#ifdef MULTITHREAD
%  typedef bool_t RESULTTYPE;
%#else
%  typedef fnServerTransactionUnlock_rets * RESULTTYPE;
%#endif
%#ifndef MULTITHREAD
%  static fnServerTransactionUnlock_rets	Result;
%  RESULTTYPE			pResult = &Result;
%#endif
%  LPCSTR	pszErrorMsg;
%
%  __pRequest__	= pRequest;
%
%  RPC_SERVER_ENTRY();
%
%#ifndef MULTITHREAD
%  if ( pResult->pszErrorMsg == szEmpty ) {
%    pResult->pszErrorMsg	= NULL;
%  }
%  xdr_free ( (xdrproc_t) xdr_fnServerTransactionUnlock_rets, (char *) pResult );
%#endif
%  pResult->nErrorLvl		= 0;
%
%  Reply.bAnswered		= FALSE;
%  Reply.pfnCalled		= (void(*)()) fnServerTransactionUnlock;
%  Reply.pfnXdrResult		= (bool_t(*)()) xdr_fnServerTransactionUnlock_rets;
%  Reply.pnErrorLvl		= &pResult->nErrorLvl;
%  Reply.ppszErrorMsg		= (LPCSTR *) &pResult->pszErrorMsg;
%  Reply.pResult		= pResult;
%  Reply.pReturnValue		= &pResult->ReturnValue;
%  Reply.nReturnValueSize	= sizeof ( pResult->ReturnValue );
%
%  pResult->ReturnValue		=
%  fnServerTransactionUnlock (
%	pArguments->oShortObjIdHeap,
%	pArguments->oShortObjIdLockedBy,
%	pArguments->nLock,
%	pArguments->oShortToUnlock,
%	pArguments->nIndex,
%	&pResult->pnVectorLockNow );
%
%  if ( Reply.bAnswered ) {
%    __pRequest__	= NULL;
%    return (RESULTTYPE) NULL;
%  }
%
%  pResult->nErrorLvl	= RPC_SERVER_ERRLVL();
%  if ( pResult->nErrorLvl > 0 ) {
%    pszErrorMsg		= RPC_SERVER_ERRMSG();
%    if ( pszErrorMsg && *pszErrorMsg ) {
%      pResult->pszErrorMsg	= strdup ( pszErrorMsg );
%    }
%  }
%  if ( pResult->pszErrorMsg == NULL ) {
%#ifdef MULTITHREAD
%    pResult->pszErrorMsg	= strdup ( szEmpty );
%#else
%    pResult->pszErrorMsg	= (LPSTR) szEmpty;
%#endif
%  }
%  __pRequest__	= NULL;
%  return (RESULTTYPE) pResult;
%} /* fnrpc_fnservertransactionunlock_1 */
#endif	/* RPC_SVC */
%
#if RPC_CLNT
%SHLOCK DLLEXPORT fnServerTransactionUnlock
%	(SHORTOBJID oShortObjIdHeap ,
%	  SHORTOBJID oShortObjIdLockedBy ,
%	  SHLOCK nLock ,
%	  SHORTOBJID oShortToUnlock ,
%	  int nIndex ,
%	  SHLOCK * pnVectorLockNow)
%{
%  static const char	__procedure__[]	= "client:fnServerTransactionUnlock";
%  static fnServerTransactionUnlock_rets	ZeroResult;
%  fnServerTransactionUnlock_rets		* pResult = NULL;
%  fnServerTransactionUnlock_rets		Result = ZeroResult;
%  fnServerTransactionUnlock_args	InArguments;
%
%  /* Client initialization: */
%  if ( __bClientInitialize__ ) {
%    __bClientInitialize__	= FALSE;
%    RPC_CLIENT_INITIALIZE();
%  }
%
%#if	CLIENT_CREATE_BY_USER
%  if ( __pClient__ == NULL ) {
%    __pClient__	= RPC_CLIENT_CREATE ( __szHost__, __szTransport__ );
%    if ( __pClient__ == NULL ) {
%      /* Error handling for a not connected client: */
%      char	szError [ 256 ];
%      sprintf ( szError, szFormatNoServer, __procedure__ );
%      RPC_CLIENT_ERROR ( szError );
%      return Result.ReturnValue;
%    }
%  }
%#else
%  while ( __pClient__ == NULL ) {
%    __pClient__	= RPC_CLIENT_CREATE ( __szHost__, __szTransport__ );
%    if ( __pClient__ == NULL ) {
%      /* Error handling for a not connected client: */
%      char	szError [ 256 ];
%      sprintf ( szError, szFormatNoServer, __procedure__ );
%      RPC_CLIENT_CERROR ( szContNoServer, szError );
%    }
%  }
%#endif	/* CLIENT_CREATE_BY_USER */
%
%  /* Copy in the oShortObjIdHeap argument: */
%  InArguments.oShortObjIdHeap	= oShortObjIdHeap;
%  /* Copy in the oShortObjIdLockedBy argument: */
%  InArguments.oShortObjIdLockedBy	= oShortObjIdLockedBy;
%  /* Copy in the nLock argument: */
%  InArguments.nLock	= nLock;
%  /* Copy in the oShortToUnlock argument: */
%  InArguments.oShortToUnlock	= oShortToUnlock;
%  /* Copy in the nIndex argument: */
%  InArguments.nIndex	= nIndex;
%
%  pResult	=
%#ifdef MULTITHREAD
%    (
%#else
%    (fnServerTransactionUnlock_rets *)
%#endif
%    fnrpc_fnservertransactionunlock_1 (
%	&InArguments,
%#ifdef MULTITHREAD
%	&Result,
%#endif
%	__pClient__ )
%#ifdef MULTITHREAD
%	== RPC_SUCCESS ) ? &Result : NULL
%#endif
%	;
%
%  if ( pResult == NULL ) {
%    /* Error handling for a failed RPC call, */
%    /* i.e. the server did not respond: */
%    char	szError [ 256 ];
%    sprintf ( szError, szFormatRpcFailed, __procedure__,
%              clnt_sperror ( __pClient__, __szHost__ ) );
%    __pClient__	= RPC_CLIENT_DESTROY ( __pClient__ );
%    RPC_CLIENT_CERROR ( szContRpcFailed, szError );
%    Result	= ZeroResult;
%    return Result.ReturnValue;
%  }
%#ifndef MULTITHREAD
%  Result	= * pResult;
%#endif
%
%  /* Copy out the pnVectorLockNow argument: */
%  if ( ! ( 
%       pnVectorLockNow == NULL ) ) {
%    *pnVectorLockNow	= pResult->pnVectorLockNow;
%  }
%
%  if ( pResult && pResult->nErrorLvl ) {
%    /* Server returned a user error message: */
%    char	szErrorMsg [ 1024 ];
%    strncpy ( szErrorMsg,
%              ( pResult->pszErrorMsg && pResult->pszErrorMsg [ 0 ] ) ?
%              (LPCSTR) pResult->pszErrorMsg : (LPCSTR) szEmpty,
%              sizeof ( szErrorMsg ) );
%    szErrorMsg [ sizeof ( szErrorMsg ) - 1 ]	= (char) 0;
%    xdr_free ( (xdrproc_t) xdr_fnServerTransactionUnlock_rets, (char *) pResult );
%    RPC_CLIENT_SERROR ( pResult->nErrorLvl, __procedure__,
%                        szErrorMsg );
%  } else {
%    xdr_free ( (xdrproc_t) xdr_fnServerTransactionUnlock_rets, (char *) pResult );
%  }
%  if ( 
%       pnVectorLockNow == NULL ) {
%    /* Error handling for passing a NULL pointer on */
%    /* out argument: */
%    char	szError [ 256 ];
%    sprintf ( szError, szFormatNullPassed,
%              __procedure__, "pnVectorLockNow" );
%    RPC_CLIENT_CERROR ( szContNullOutPassed, szError );
%  }
%
%  return Result.ReturnValue;
%
%} /* fnServerTransactionUnlock */
#endif	/* RPC_CLNT */
%
  fnServerTransactionUnlockAll_rets fnRpc_fnServerTransactionUnlockAll ( fnServerTransactionUnlockAll_args ) =  70 ;
%
#if RPC_SVC
%
%extern int fnServerTransactionUnlockAll
%	(SHORTOBJID oShortObjIdHeap ,
%	  SHORTOBJID oShortObjIdLockedBy ,
%	  SHORTOBJID oShortToUnlock);
%
%#ifdef MULTITHREAD
%bool_t
%#else
%fnServerTransactionUnlockAll_rets *
%#endif
%	PASTE2(fnrpc_fnservertransactionunlockall_1,_SVCSUFFIX)
%		( fnServerTransactionUnlockAll_args * pArguments,
%#ifdef MULTITHREAD
%		  fnServerTransactionUnlockAll_rets * pResult,
%#endif
%		  struct svc_req * pRequest )
%{
%  static const char	__procedure__[]	= "server:fnrpc_fnservertransactionunlockall_1";
%#ifdef MULTITHREAD
%  typedef bool_t RESULTTYPE;
%#else
%  typedef fnServerTransactionUnlockAll_rets * RESULTTYPE;
%#endif
%#ifndef MULTITHREAD
%  static fnServerTransactionUnlockAll_rets	Result;
%  RESULTTYPE			pResult = &Result;
%#endif
%  LPCSTR	pszErrorMsg;
%
%  __pRequest__	= pRequest;
%
%  RPC_SERVER_ENTRY();
%
%#ifndef MULTITHREAD
%  if ( pResult->pszErrorMsg == szEmpty ) {
%    pResult->pszErrorMsg	= NULL;
%  }
%  xdr_free ( (xdrproc_t) xdr_fnServerTransactionUnlockAll_rets, (char *) pResult );
%#endif
%  pResult->nErrorLvl		= 0;
%
%  Reply.bAnswered		= FALSE;
%  Reply.pfnCalled		= (void(*)()) fnServerTransactionUnlockAll;
%  Reply.pfnXdrResult		= (bool_t(*)()) xdr_fnServerTransactionUnlockAll_rets;
%  Reply.pnErrorLvl		= &pResult->nErrorLvl;
%  Reply.ppszErrorMsg		= (LPCSTR *) &pResult->pszErrorMsg;
%  Reply.pResult		= pResult;
%  Reply.pReturnValue		= &pResult->ReturnValue;
%  Reply.nReturnValueSize	= sizeof ( pResult->ReturnValue );
%
%  pResult->ReturnValue		=
%  fnServerTransactionUnlockAll (
%	pArguments->oShortObjIdHeap,
%	pArguments->oShortObjIdLockedBy,
%	pArguments->oShortToUnlock );
%
%  if ( Reply.bAnswered ) {
%    __pRequest__	= NULL;
%    return (RESULTTYPE) NULL;
%  }
%
%  pResult->nErrorLvl	= RPC_SERVER_ERRLVL();
%  if ( pResult->nErrorLvl > 0 ) {
%    pszErrorMsg		= RPC_SERVER_ERRMSG();
%    if ( pszErrorMsg && *pszErrorMsg ) {
%      pResult->pszErrorMsg	= strdup ( pszErrorMsg );
%    }
%  }
%  if ( pResult->pszErrorMsg == NULL ) {
%#ifdef MULTITHREAD
%    pResult->pszErrorMsg	= strdup ( szEmpty );
%#else
%    pResult->pszErrorMsg	= (LPSTR) szEmpty;
%#endif
%  }
%  __pRequest__	= NULL;
%  return (RESULTTYPE) pResult;
%} /* fnrpc_fnservertransactionunlockall_1 */
#endif	/* RPC_SVC */
%
#if RPC_CLNT
%int DLLEXPORT fnServerTransactionUnlockAll
%	(SHORTOBJID oShortObjIdHeap ,
%	  SHORTOBJID oShortObjIdLockedBy ,
%	  SHORTOBJID oShortToUnlock)
%{
%  static const char	__procedure__[]	= "client:fnServerTransactionUnlockAll";
%  static fnServerTransactionUnlockAll_rets	ZeroResult;
%  fnServerTransactionUnlockAll_rets		* pResult = NULL;
%  fnServerTransactionUnlockAll_rets		Result = ZeroResult;
%  fnServerTransactionUnlockAll_args	InArguments;
%
%  /* Client initialization: */
%  if ( __bClientInitialize__ ) {
%    __bClientInitialize__	= FALSE;
%    RPC_CLIENT_INITIALIZE();
%  }
%
%#if	CLIENT_CREATE_BY_USER
%  if ( __pClient__ == NULL ) {
%    __pClient__	= RPC_CLIENT_CREATE ( __szHost__, __szTransport__ );
%    if ( __pClient__ == NULL ) {
%      /* Error handling for a not connected client: */
%      char	szError [ 256 ];
%      sprintf ( szError, szFormatNoServer, __procedure__ );
%      RPC_CLIENT_ERROR ( szError );
%      return Result.ReturnValue;
%    }
%  }
%#else
%  while ( __pClient__ == NULL ) {
%    __pClient__	= RPC_CLIENT_CREATE ( __szHost__, __szTransport__ );
%    if ( __pClient__ == NULL ) {
%      /* Error handling for a not connected client: */
%      char	szError [ 256 ];
%      sprintf ( szError, szFormatNoServer, __procedure__ );
%      RPC_CLIENT_CERROR ( szContNoServer, szError );
%    }
%  }
%#endif	/* CLIENT_CREATE_BY_USER */
%
%  /* Copy in the oShortObjIdHeap argument: */
%  InArguments.oShortObjIdHeap	= oShortObjIdHeap;
%  /* Copy in the oShortObjIdLockedBy argument: */
%  InArguments.oShortObjIdLockedBy	= oShortObjIdLockedBy;
%  /* Copy in the oShortToUnlock argument: */
%  InArguments.oShortToUnlock	= oShortToUnlock;
%
%  pResult	=
%#ifdef MULTITHREAD
%    (
%#else
%    (fnServerTransactionUnlockAll_rets *)
%#endif
%    fnrpc_fnservertransactionunlockall_1 (
%	&InArguments,
%#ifdef MULTITHREAD
%	&Result,
%#endif
%	__pClient__ )
%#ifdef MULTITHREAD
%	== RPC_SUCCESS ) ? &Result : NULL
%#endif
%	;
%
%  if ( pResult == NULL ) {
%    /* Error handling for a failed RPC call, */
%    /* i.e. the server did not respond: */
%    char	szError [ 256 ];
%    sprintf ( szError, szFormatRpcFailed, __procedure__,
%              clnt_sperror ( __pClient__, __szHost__ ) );
%    __pClient__	= RPC_CLIENT_DESTROY ( __pClient__ );
%    RPC_CLIENT_CERROR ( szContRpcFailed, szError );
%    Result	= ZeroResult;
%    return Result.ReturnValue;
%  }
%#ifndef MULTITHREAD
%  Result	= * pResult;
%#endif
%
%
%  if ( pResult && pResult->nErrorLvl ) {
%    /* Server returned a user error message: */
%    char	szErrorMsg [ 1024 ];
%    strncpy ( szErrorMsg,
%              ( pResult->pszErrorMsg && pResult->pszErrorMsg [ 0 ] ) ?
%              (LPCSTR) pResult->pszErrorMsg : (LPCSTR) szEmpty,
%              sizeof ( szErrorMsg ) );
%    szErrorMsg [ sizeof ( szErrorMsg ) - 1 ]	= (char) 0;
%    xdr_free ( (xdrproc_t) xdr_fnServerTransactionUnlockAll_rets, (char *) pResult );
%    RPC_CLIENT_SERROR ( pResult->nErrorLvl, __procedure__,
%                        szErrorMsg );
%  } else {
%    xdr_free ( (xdrproc_t) xdr_fnServerTransactionUnlockAll_rets, (char *) pResult );
%  }
%
%  return Result.ReturnValue;
%
%} /* fnServerTransactionUnlockAll */
#endif	/* RPC_CLNT */
%
  fnServerTransactionUnlockAllAll_rets fnRpc_fnServerTransactionUnlockAllAll ( fnServerTransactionUnlockAllAll_args ) =  71 ;
%
#if RPC_SVC
%
%extern int fnServerTransactionUnlockAllAll
%	(SHORTOBJID oShortObjIdHeap ,
%	  SHORTOBJID oShortObjIdLockedBy);
%
%#ifdef MULTITHREAD
%bool_t
%#else
%fnServerTransactionUnlockAllAll_rets *
%#endif
%	PASTE2(fnrpc_fnservertransactionunlockallall_1,_SVCSUFFIX)
%		( fnServerTransactionUnlockAllAll_args * pArguments,
%#ifdef MULTITHREAD
%		  fnServerTransactionUnlockAllAll_rets * pResult,
%#endif
%		  struct svc_req * pRequest )
%{
%  static const char	__procedure__[]	= "server:fnrpc_fnservertransactionunlockallall_1";
%#ifdef MULTITHREAD
%  typedef bool_t RESULTTYPE;
%#else
%  typedef fnServerTransactionUnlockAllAll_rets * RESULTTYPE;
%#endif
%#ifndef MULTITHREAD
%  static fnServerTransactionUnlockAllAll_rets	Result;
%  RESULTTYPE			pResult = &Result;
%#endif
%  LPCSTR	pszErrorMsg;
%
%  __pRequest__	= pRequest;
%
%  RPC_SERVER_ENTRY();
%
%#ifndef MULTITHREAD
%  if ( pResult->pszErrorMsg == szEmpty ) {
%    pResult->pszErrorMsg	= NULL;
%  }
%  xdr_free ( (xdrproc_t) xdr_fnServerTransactionUnlockAllAll_rets, (char *) pResult );
%#endif
%  pResult->nErrorLvl		= 0;
%
%  Reply.bAnswered		= FALSE;
%  Reply.pfnCalled		= (void(*)()) fnServerTransactionUnlockAllAll;
%  Reply.pfnXdrResult		= (bool_t(*)()) xdr_fnServerTransactionUnlockAllAll_rets;
%  Reply.pnErrorLvl		= &pResult->nErrorLvl;
%  Reply.ppszErrorMsg		= (LPCSTR *) &pResult->pszErrorMsg;
%  Reply.pResult		= pResult;
%  Reply.pReturnValue		= &pResult->ReturnValue;
%  Reply.nReturnValueSize	= sizeof ( pResult->ReturnValue );
%
%  pResult->ReturnValue		=
%  fnServerTransactionUnlockAllAll (
%	pArguments->oShortObjIdHeap,
%	pArguments->oShortObjIdLockedBy );
%
%  if ( Reply.bAnswered ) {
%    __pRequest__	= NULL;
%    return (RESULTTYPE) NULL;
%  }
%
%  pResult->nErrorLvl	= RPC_SERVER_ERRLVL();
%  if ( pResult->nErrorLvl > 0 ) {
%    pszErrorMsg		= RPC_SERVER_ERRMSG();
%    if ( pszErrorMsg && *pszErrorMsg ) {
%      pResult->pszErrorMsg	= strdup ( pszErrorMsg );
%    }
%  }
%  if ( pResult->pszErrorMsg == NULL ) {
%#ifdef MULTITHREAD
%    pResult->pszErrorMsg	= strdup ( szEmpty );
%#else
%    pResult->pszErrorMsg	= (LPSTR) szEmpty;
%#endif
%  }
%  __pRequest__	= NULL;
%  return (RESULTTYPE) pResult;
%} /* fnrpc_fnservertransactionunlockallall_1 */
#endif	/* RPC_SVC */
%
#if RPC_CLNT
%int DLLEXPORT fnServerTransactionUnlockAllAll
%	(SHORTOBJID oShortObjIdHeap ,
%	  SHORTOBJID oShortObjIdLockedBy)
%{
%  static const char	__procedure__[]	= "client:fnServerTransactionUnlockAllAll";
%  static fnServerTransactionUnlockAllAll_rets	ZeroResult;
%  fnServerTransactionUnlockAllAll_rets		* pResult = NULL;
%  fnServerTransactionUnlockAllAll_rets		Result = ZeroResult;
%  fnServerTransactionUnlockAllAll_args	InArguments;
%
%  /* Client initialization: */
%  if ( __bClientInitialize__ ) {
%    __bClientInitialize__	= FALSE;
%    RPC_CLIENT_INITIALIZE();
%  }
%
%#if	CLIENT_CREATE_BY_USER
%  if ( __pClient__ == NULL ) {
%    __pClient__	= RPC_CLIENT_CREATE ( __szHost__, __szTransport__ );
%    if ( __pClient__ == NULL ) {
%      /* Error handling for a not connected client: */
%      char	szError [ 256 ];
%      sprintf ( szError, szFormatNoServer, __procedure__ );
%      RPC_CLIENT_ERROR ( szError );
%      return Result.ReturnValue;
%    }
%  }
%#else
%  while ( __pClient__ == NULL ) {
%    __pClient__	= RPC_CLIENT_CREATE ( __szHost__, __szTransport__ );
%    if ( __pClient__ == NULL ) {
%      /* Error handling for a not connected client: */
%      char	szError [ 256 ];
%      sprintf ( szError, szFormatNoServer, __procedure__ );
%      RPC_CLIENT_CERROR ( szContNoServer, szError );
%    }
%  }
%#endif	/* CLIENT_CREATE_BY_USER */
%
%  /* Copy in the oShortObjIdHeap argument: */
%  InArguments.oShortObjIdHeap	= oShortObjIdHeap;
%  /* Copy in the oShortObjIdLockedBy argument: */
%  InArguments.oShortObjIdLockedBy	= oShortObjIdLockedBy;
%
%  pResult	=
%#ifdef MULTITHREAD
%    (
%#else
%    (fnServerTransactionUnlockAllAll_rets *)
%#endif
%    fnrpc_fnservertransactionunlockallall_1 (
%	&InArguments,
%#ifdef MULTITHREAD
%	&Result,
%#endif
%	__pClient__ )
%#ifdef MULTITHREAD
%	== RPC_SUCCESS ) ? &Result : NULL
%#endif
%	;
%
%  if ( pResult == NULL ) {
%    /* Error handling for a failed RPC call, */
%    /* i.e. the server did not respond: */
%    char	szError [ 256 ];
%    sprintf ( szError, szFormatRpcFailed, __procedure__,
%              clnt_sperror ( __pClient__, __szHost__ ) );
%    __pClient__	= RPC_CLIENT_DESTROY ( __pClient__ );
%    RPC_CLIENT_CERROR ( szContRpcFailed, szError );
%    Result	= ZeroResult;
%    return Result.ReturnValue;
%  }
%#ifndef MULTITHREAD
%  Result	= * pResult;
%#endif
%
%
%  if ( pResult && pResult->nErrorLvl ) {
%    /* Server returned a user error message: */
%    char	szErrorMsg [ 1024 ];
%    strncpy ( szErrorMsg,
%              ( pResult->pszErrorMsg && pResult->pszErrorMsg [ 0 ] ) ?
%              (LPCSTR) pResult->pszErrorMsg : (LPCSTR) szEmpty,
%              sizeof ( szErrorMsg ) );
%    szErrorMsg [ sizeof ( szErrorMsg ) - 1 ]	= (char) 0;
%    xdr_free ( (xdrproc_t) xdr_fnServerTransactionUnlockAllAll_rets, (char *) pResult );
%    RPC_CLIENT_SERROR ( pResult->nErrorLvl, __procedure__,
%                        szErrorMsg );
%  } else {
%    xdr_free ( (xdrproc_t) xdr_fnServerTransactionUnlockAllAll_rets, (char *) pResult );
%  }
%
%  return Result.ReturnValue;
%
%} /* fnServerTransactionUnlockAllAll */
#endif	/* RPC_CLNT */
%
  fnShortMakeReadOnly_rets fnRpc_fnShortMakeReadOnly ( fnShortMakeReadOnly_args ) =  72 ;
%
#if RPC_SVC
%
%extern bool_t fnShortMakeReadOnly
%	(SHORTOBJID oShortObjIdHeap ,
%	  SHORTOBJID oShortSelf ,
%	  READONLYMODE nReadOnlyP);
%
%#ifdef MULTITHREAD
%bool_t
%#else
%fnShortMakeReadOnly_rets *
%#endif
%	PASTE2(fnrpc_fnshortmakereadonly_1,_SVCSUFFIX)
%		( fnShortMakeReadOnly_args * pArguments,
%#ifdef MULTITHREAD
%		  fnShortMakeReadOnly_rets * pResult,
%#endif
%		  struct svc_req * pRequest )
%{
%  static const char	__procedure__[]	= "server:fnrpc_fnshortmakereadonly_1";
%#ifdef MULTITHREAD
%  typedef bool_t RESULTTYPE;
%#else
%  typedef fnShortMakeReadOnly_rets * RESULTTYPE;
%#endif
%#ifndef MULTITHREAD
%  static fnShortMakeReadOnly_rets	Result;
%  RESULTTYPE			pResult = &Result;
%#endif
%  LPCSTR	pszErrorMsg;
%
%  __pRequest__	= pRequest;
%
%  RPC_SERVER_ENTRY();
%
%#ifndef MULTITHREAD
%  if ( pResult->pszErrorMsg == szEmpty ) {
%    pResult->pszErrorMsg	= NULL;
%  }
%  xdr_free ( (xdrproc_t) xdr_fnShortMakeReadOnly_rets, (char *) pResult );
%#endif
%  pResult->nErrorLvl		= 0;
%
%  Reply.bAnswered		= FALSE;
%  Reply.pfnCalled		= (void(*)()) fnShortMakeReadOnly;
%  Reply.pfnXdrResult		= (bool_t(*)()) xdr_fnShortMakeReadOnly_rets;
%  Reply.pnErrorLvl		= &pResult->nErrorLvl;
%  Reply.ppszErrorMsg		= (LPCSTR *) &pResult->pszErrorMsg;
%  Reply.pResult		= pResult;
%  Reply.pReturnValue		= &pResult->ReturnValue;
%  Reply.nReturnValueSize	= sizeof ( pResult->ReturnValue );
%
%  pResult->ReturnValue		=
%  fnShortMakeReadOnly (
%	pArguments->oShortObjIdHeap,
%	pArguments->oShortSelf,
%	pArguments->nReadOnlyP );
%
%  if ( Reply.bAnswered ) {
%    __pRequest__	= NULL;
%    return (RESULTTYPE) NULL;
%  }
%
%  pResult->nErrorLvl	= RPC_SERVER_ERRLVL();
%  if ( pResult->nErrorLvl > 0 ) {
%    pszErrorMsg		= RPC_SERVER_ERRMSG();
%    if ( pszErrorMsg && *pszErrorMsg ) {
%      pResult->pszErrorMsg	= strdup ( pszErrorMsg );
%    }
%  }
%  if ( pResult->pszErrorMsg == NULL ) {
%#ifdef MULTITHREAD
%    pResult->pszErrorMsg	= strdup ( szEmpty );
%#else
%    pResult->pszErrorMsg	= (LPSTR) szEmpty;
%#endif
%  }
%  __pRequest__	= NULL;
%  return (RESULTTYPE) pResult;
%} /* fnrpc_fnshortmakereadonly_1 */
#endif	/* RPC_SVC */
%
#if RPC_CLNT
%bool_t DLLEXPORT fnShortMakeReadOnly
%	(SHORTOBJID oShortObjIdHeap ,
%	  SHORTOBJID oShortSelf ,
%	  READONLYMODE nReadOnlyP)
%{
%  static const char	__procedure__[]	= "client:fnShortMakeReadOnly";
%  static fnShortMakeReadOnly_rets	ZeroResult;
%  fnShortMakeReadOnly_rets		* pResult = NULL;
%  fnShortMakeReadOnly_rets		Result = ZeroResult;
%  fnShortMakeReadOnly_args	InArguments;
%
%  /* Client initialization: */
%  if ( __bClientInitialize__ ) {
%    __bClientInitialize__	= FALSE;
%    RPC_CLIENT_INITIALIZE();
%  }
%
%#if	CLIENT_CREATE_BY_USER
%  if ( __pClient__ == NULL ) {
%    __pClient__	= RPC_CLIENT_CREATE ( __szHost__, __szTransport__ );
%    if ( __pClient__ == NULL ) {
%      /* Error handling for a not connected client: */
%      char	szError [ 256 ];
%      sprintf ( szError, szFormatNoServer, __procedure__ );
%      RPC_CLIENT_ERROR ( szError );
%      return Result.ReturnValue;
%    }
%  }
%#else
%  while ( __pClient__ == NULL ) {
%    __pClient__	= RPC_CLIENT_CREATE ( __szHost__, __szTransport__ );
%    if ( __pClient__ == NULL ) {
%      /* Error handling for a not connected client: */
%      char	szError [ 256 ];
%      sprintf ( szError, szFormatNoServer, __procedure__ );
%      RPC_CLIENT_CERROR ( szContNoServer, szError );
%    }
%  }
%#endif	/* CLIENT_CREATE_BY_USER */
%
%  /* Copy in the oShortObjIdHeap argument: */
%  InArguments.oShortObjIdHeap	= oShortObjIdHeap;
%  /* Copy in the oShortSelf argument: */
%  InArguments.oShortSelf	= oShortSelf;
%  /* Copy in the nReadOnlyP argument: */
%  InArguments.nReadOnlyP	= nReadOnlyP;
%
%  pResult	=
%#ifdef MULTITHREAD
%    (
%#else
%    (fnShortMakeReadOnly_rets *)
%#endif
%    fnrpc_fnshortmakereadonly_1 (
%	&InArguments,
%#ifdef MULTITHREAD
%	&Result,
%#endif
%	__pClient__ )
%#ifdef MULTITHREAD
%	== RPC_SUCCESS ) ? &Result : NULL
%#endif
%	;
%
%  if ( pResult == NULL ) {
%    /* Error handling for a failed RPC call, */
%    /* i.e. the server did not respond: */
%    char	szError [ 256 ];
%    sprintf ( szError, szFormatRpcFailed, __procedure__,
%              clnt_sperror ( __pClient__, __szHost__ ) );
%    __pClient__	= RPC_CLIENT_DESTROY ( __pClient__ );
%    RPC_CLIENT_CERROR ( szContRpcFailed, szError );
%    Result	= ZeroResult;
%    return Result.ReturnValue;
%  }
%#ifndef MULTITHREAD
%  Result	= * pResult;
%#endif
%
%
%  if ( pResult && pResult->nErrorLvl ) {
%    /* Server returned a user error message: */
%    char	szErrorMsg [ 1024 ];
%    strncpy ( szErrorMsg,
%              ( pResult->pszErrorMsg && pResult->pszErrorMsg [ 0 ] ) ?
%              (LPCSTR) pResult->pszErrorMsg : (LPCSTR) szEmpty,
%              sizeof ( szErrorMsg ) );
%    szErrorMsg [ sizeof ( szErrorMsg ) - 1 ]	= (char) 0;
%    xdr_free ( (xdrproc_t) xdr_fnShortMakeReadOnly_rets, (char *) pResult );
%    RPC_CLIENT_SERROR ( pResult->nErrorLvl, __procedure__,
%                        szErrorMsg );
%  } else {
%    xdr_free ( (xdrproc_t) xdr_fnShortMakeReadOnly_rets, (char *) pResult );
%  }
%
%  return Result.ReturnValue;
%
%} /* fnShortMakeReadOnly */
#endif	/* RPC_CLNT */
%
  fnServerTransactionBegin_rets fnRpc_fnServerTransactionBegin ( fnServerTransactionBegin_args ) =  73 ;
%
#if RPC_SVC
%
%extern TRACTID fnServerTransactionBegin
%	(SHORTOBJID oShortObjIdHeap ,
%	  bool_t bIgnoreError);
%
%#ifdef MULTITHREAD
%bool_t
%#else
%fnServerTransactionBegin_rets *
%#endif
%	PASTE2(fnrpc_fnservertransactionbegin_1,_SVCSUFFIX)
%		( fnServerTransactionBegin_args * pArguments,
%#ifdef MULTITHREAD
%		  fnServerTransactionBegin_rets * pResult,
%#endif
%		  struct svc_req * pRequest )
%{
%  static const char	__procedure__[]	= "server:fnrpc_fnservertransactionbegin_1";
%#ifdef MULTITHREAD
%  typedef bool_t RESULTTYPE;
%#else
%  typedef fnServerTransactionBegin_rets * RESULTTYPE;
%#endif
%#ifndef MULTITHREAD
%  static fnServerTransactionBegin_rets	Result;
%  RESULTTYPE			pResult = &Result;
%#endif
%  LPCSTR	pszErrorMsg;
%
%  __pRequest__	= pRequest;
%
%  RPC_SERVER_ENTRY();
%
%#ifndef MULTITHREAD
%  if ( pResult->pszErrorMsg == szEmpty ) {
%    pResult->pszErrorMsg	= NULL;
%  }
%  xdr_free ( (xdrproc_t) xdr_fnServerTransactionBegin_rets, (char *) pResult );
%#endif
%  pResult->nErrorLvl		= 0;
%
%  Reply.bAnswered		= FALSE;
%  Reply.pfnCalled		= (void(*)()) fnServerTransactionBegin;
%  Reply.pfnXdrResult		= (bool_t(*)()) xdr_fnServerTransactionBegin_rets;
%  Reply.pnErrorLvl		= &pResult->nErrorLvl;
%  Reply.ppszErrorMsg		= (LPCSTR *) &pResult->pszErrorMsg;
%  Reply.pResult		= pResult;
%  Reply.pReturnValue		= &pResult->ReturnValue;
%  Reply.nReturnValueSize	= sizeof ( pResult->ReturnValue );
%
%  pResult->ReturnValue		=
%  fnServerTransactionBegin (
%	pArguments->oShortObjIdHeap,
%	pArguments->bIgnoreError );
%
%  if ( Reply.bAnswered ) {
%    __pRequest__	= NULL;
%    return (RESULTTYPE) NULL;
%  }
%
%  pResult->nErrorLvl	= RPC_SERVER_ERRLVL();
%  if ( pResult->nErrorLvl > 0 ) {
%    pszErrorMsg		= RPC_SERVER_ERRMSG();
%    if ( pszErrorMsg && *pszErrorMsg ) {
%      pResult->pszErrorMsg	= strdup ( pszErrorMsg );
%    }
%  }
%  if ( pResult->pszErrorMsg == NULL ) {
%#ifdef MULTITHREAD
%    pResult->pszErrorMsg	= strdup ( szEmpty );
%#else
%    pResult->pszErrorMsg	= (LPSTR) szEmpty;
%#endif
%  }
%  __pRequest__	= NULL;
%  return (RESULTTYPE) pResult;
%} /* fnrpc_fnservertransactionbegin_1 */
#endif	/* RPC_SVC */
%
#if RPC_CLNT
%TRACTID DLLEXPORT fnServerTransactionBegin
%	(SHORTOBJID oShortObjIdHeap ,
%	  bool_t bIgnoreError)
%{
%  static const char	__procedure__[]	= "client:fnServerTransactionBegin";
%  static fnServerTransactionBegin_rets	ZeroResult;
%  fnServerTransactionBegin_rets		* pResult = NULL;
%  fnServerTransactionBegin_rets		Result = ZeroResult;
%  fnServerTransactionBegin_args	InArguments;
%
%  /* Client initialization: */
%  if ( __bClientInitialize__ ) {
%    __bClientInitialize__	= FALSE;
%    RPC_CLIENT_INITIALIZE();
%  }
%
%#if	CLIENT_CREATE_BY_USER
%  if ( __pClient__ == NULL ) {
%    __pClient__	= RPC_CLIENT_CREATE ( __szHost__, __szTransport__ );
%    if ( __pClient__ == NULL ) {
%      /* Error handling for a not connected client: */
%      char	szError [ 256 ];
%      sprintf ( szError, szFormatNoServer, __procedure__ );
%      RPC_CLIENT_ERROR ( szError );
%      return Result.ReturnValue;
%    }
%  }
%#else
%  while ( __pClient__ == NULL ) {
%    __pClient__	= RPC_CLIENT_CREATE ( __szHost__, __szTransport__ );
%    if ( __pClient__ == NULL ) {
%      /* Error handling for a not connected client: */
%      char	szError [ 256 ];
%      sprintf ( szError, szFormatNoServer, __procedure__ );
%      RPC_CLIENT_CERROR ( szContNoServer, szError );
%    }
%  }
%#endif	/* CLIENT_CREATE_BY_USER */
%
%  /* Copy in the oShortObjIdHeap argument: */
%  InArguments.oShortObjIdHeap	= oShortObjIdHeap;
%  /* Copy in the bIgnoreError argument: */
%  InArguments.bIgnoreError	= bIgnoreError;
%
%  pResult	=
%#ifdef MULTITHREAD
%    (
%#else
%    (fnServerTransactionBegin_rets *)
%#endif
%    fnrpc_fnservertransactionbegin_1 (
%	&InArguments,
%#ifdef MULTITHREAD
%	&Result,
%#endif
%	__pClient__ )
%#ifdef MULTITHREAD
%	== RPC_SUCCESS ) ? &Result : NULL
%#endif
%	;
%
%  if ( pResult == NULL ) {
%    /* Error handling for a failed RPC call, */
%    /* i.e. the server did not respond: */
%    char	szError [ 256 ];
%    sprintf ( szError, szFormatRpcFailed, __procedure__,
%              clnt_sperror ( __pClient__, __szHost__ ) );
%    __pClient__	= RPC_CLIENT_DESTROY ( __pClient__ );
%    RPC_CLIENT_CERROR ( szContRpcFailed, szError );
%    Result	= ZeroResult;
%    return Result.ReturnValue;
%  }
%#ifndef MULTITHREAD
%  Result	= * pResult;
%#endif
%
%
%  if ( pResult && pResult->nErrorLvl ) {
%    /* Server returned a user error message: */
%    char	szErrorMsg [ 1024 ];
%    strncpy ( szErrorMsg,
%              ( pResult->pszErrorMsg && pResult->pszErrorMsg [ 0 ] ) ?
%              (LPCSTR) pResult->pszErrorMsg : (LPCSTR) szEmpty,
%              sizeof ( szErrorMsg ) );
%    szErrorMsg [ sizeof ( szErrorMsg ) - 1 ]	= (char) 0;
%    xdr_free ( (xdrproc_t) xdr_fnServerTransactionBegin_rets, (char *) pResult );
%    RPC_CLIENT_SERROR ( pResult->nErrorLvl, __procedure__,
%                        szErrorMsg );
%  } else {
%    xdr_free ( (xdrproc_t) xdr_fnServerTransactionBegin_rets, (char *) pResult );
%  }
%
%  return Result.ReturnValue;
%
%} /* fnServerTransactionBegin */
#endif	/* RPC_CLNT */
%
  fnServerTransactionCancel_rets fnRpc_fnServerTransactionCancel ( fnServerTransactionCancel_args ) =  74 ;
%
#if RPC_SVC
%
%extern TRACTID fnServerTransactionCancel
%	(SHORTOBJID oShortObjIdHeap ,
%	  bool_t bIgnoreError);
%
%#ifdef MULTITHREAD
%bool_t
%#else
%fnServerTransactionCancel_rets *
%#endif
%	PASTE2(fnrpc_fnservertransactioncancel_1,_SVCSUFFIX)
%		( fnServerTransactionCancel_args * pArguments,
%#ifdef MULTITHREAD
%		  fnServerTransactionCancel_rets * pResult,
%#endif
%		  struct svc_req * pRequest )
%{
%  static const char	__procedure__[]	= "server:fnrpc_fnservertransactioncancel_1";
%#ifdef MULTITHREAD
%  typedef bool_t RESULTTYPE;
%#else
%  typedef fnServerTransactionCancel_rets * RESULTTYPE;
%#endif
%#ifndef MULTITHREAD
%  static fnServerTransactionCancel_rets	Result;
%  RESULTTYPE			pResult = &Result;
%#endif
%  LPCSTR	pszErrorMsg;
%
%  __pRequest__	= pRequest;
%
%  RPC_SERVER_ENTRY();
%
%#ifndef MULTITHREAD
%  if ( pResult->pszErrorMsg == szEmpty ) {
%    pResult->pszErrorMsg	= NULL;
%  }
%  xdr_free ( (xdrproc_t) xdr_fnServerTransactionCancel_rets, (char *) pResult );
%#endif
%  pResult->nErrorLvl		= 0;
%
%  Reply.bAnswered		= FALSE;
%  Reply.pfnCalled		= (void(*)()) fnServerTransactionCancel;
%  Reply.pfnXdrResult		= (bool_t(*)()) xdr_fnServerTransactionCancel_rets;
%  Reply.pnErrorLvl		= &pResult->nErrorLvl;
%  Reply.ppszErrorMsg		= (LPCSTR *) &pResult->pszErrorMsg;
%  Reply.pResult		= pResult;
%  Reply.pReturnValue		= &pResult->ReturnValue;
%  Reply.nReturnValueSize	= sizeof ( pResult->ReturnValue );
%
%  pResult->ReturnValue		=
%  fnServerTransactionCancel (
%	pArguments->oShortObjIdHeap,
%	pArguments->bIgnoreError );
%
%  if ( Reply.bAnswered ) {
%    __pRequest__	= NULL;
%    return (RESULTTYPE) NULL;
%  }
%
%  pResult->nErrorLvl	= RPC_SERVER_ERRLVL();
%  if ( pResult->nErrorLvl > 0 ) {
%    pszErrorMsg		= RPC_SERVER_ERRMSG();
%    if ( pszErrorMsg && *pszErrorMsg ) {
%      pResult->pszErrorMsg	= strdup ( pszErrorMsg );
%    }
%  }
%  if ( pResult->pszErrorMsg == NULL ) {
%#ifdef MULTITHREAD
%    pResult->pszErrorMsg	= strdup ( szEmpty );
%#else
%    pResult->pszErrorMsg	= (LPSTR) szEmpty;
%#endif
%  }
%  __pRequest__	= NULL;
%  return (RESULTTYPE) pResult;
%} /* fnrpc_fnservertransactioncancel_1 */
#endif	/* RPC_SVC */
%
#if RPC_CLNT
%TRACTID DLLEXPORT fnServerTransactionCancel
%	(SHORTOBJID oShortObjIdHeap ,
%	  bool_t bIgnoreError)
%{
%  static const char	__procedure__[]	= "client:fnServerTransactionCancel";
%  static fnServerTransactionCancel_rets	ZeroResult;
%  fnServerTransactionCancel_rets		* pResult = NULL;
%  fnServerTransactionCancel_rets		Result = ZeroResult;
%  fnServerTransactionCancel_args	InArguments;
%
%  /* Client initialization: */
%  if ( __bClientInitialize__ ) {
%    __bClientInitialize__	= FALSE;
%    RPC_CLIENT_INITIALIZE();
%  }
%
%#if	CLIENT_CREATE_BY_USER
%  if ( __pClient__ == NULL ) {
%    __pClient__	= RPC_CLIENT_CREATE ( __szHost__, __szTransport__ );
%    if ( __pClient__ == NULL ) {
%      /* Error handling for a not connected client: */
%      char	szError [ 256 ];
%      sprintf ( szError, szFormatNoServer, __procedure__ );
%      RPC_CLIENT_ERROR ( szError );
%      return Result.ReturnValue;
%    }
%  }
%#else
%  while ( __pClient__ == NULL ) {
%    __pClient__	= RPC_CLIENT_CREATE ( __szHost__, __szTransport__ );
%    if ( __pClient__ == NULL ) {
%      /* Error handling for a not connected client: */
%      char	szError [ 256 ];
%      sprintf ( szError, szFormatNoServer, __procedure__ );
%      RPC_CLIENT_CERROR ( szContNoServer, szError );
%    }
%  }
%#endif	/* CLIENT_CREATE_BY_USER */
%
%  /* Copy in the oShortObjIdHeap argument: */
%  InArguments.oShortObjIdHeap	= oShortObjIdHeap;
%  /* Copy in the bIgnoreError argument: */
%  InArguments.bIgnoreError	= bIgnoreError;
%
%  pResult	=
%#ifdef MULTITHREAD
%    (
%#else
%    (fnServerTransactionCancel_rets *)
%#endif
%    fnrpc_fnservertransactioncancel_1 (
%	&InArguments,
%#ifdef MULTITHREAD
%	&Result,
%#endif
%	__pClient__ )
%#ifdef MULTITHREAD
%	== RPC_SUCCESS ) ? &Result : NULL
%#endif
%	;
%
%  if ( pResult == NULL ) {
%    /* Error handling for a failed RPC call, */
%    /* i.e. the server did not respond: */
%    char	szError [ 256 ];
%    sprintf ( szError, szFormatRpcFailed, __procedure__,
%              clnt_sperror ( __pClient__, __szHost__ ) );
%    __pClient__	= RPC_CLIENT_DESTROY ( __pClient__ );
%    RPC_CLIENT_CERROR ( szContRpcFailed, szError );
%    Result	= ZeroResult;
%    return Result.ReturnValue;
%  }
%#ifndef MULTITHREAD
%  Result	= * pResult;
%#endif
%
%
%  if ( pResult && pResult->nErrorLvl ) {
%    /* Server returned a user error message: */
%    char	szErrorMsg [ 1024 ];
%    strncpy ( szErrorMsg,
%              ( pResult->pszErrorMsg && pResult->pszErrorMsg [ 0 ] ) ?
%              (LPCSTR) pResult->pszErrorMsg : (LPCSTR) szEmpty,
%              sizeof ( szErrorMsg ) );
%    szErrorMsg [ sizeof ( szErrorMsg ) - 1 ]	= (char) 0;
%    xdr_free ( (xdrproc_t) xdr_fnServerTransactionCancel_rets, (char *) pResult );
%    RPC_CLIENT_SERROR ( pResult->nErrorLvl, __procedure__,
%                        szErrorMsg );
%  } else {
%    xdr_free ( (xdrproc_t) xdr_fnServerTransactionCancel_rets, (char *) pResult );
%  }
%
%  return Result.ReturnValue;
%
%} /* fnServerTransactionCancel */
#endif	/* RPC_CLNT */
%
  fnServerTransactionEnd_rets fnRpc_fnServerTransactionEnd ( fnServerTransactionEnd_args ) =  75 ;
%
#if RPC_SVC
%
%extern TRACTID fnServerTransactionEnd
%	(SHORTOBJID oShortObjIdHeap ,
%	  bool_t bIgnoreError);
%
%#ifdef MULTITHREAD
%bool_t
%#else
%fnServerTransactionEnd_rets *
%#endif
%	PASTE2(fnrpc_fnservertransactionend_1,_SVCSUFFIX)
%		( fnServerTransactionEnd_args * pArguments,
%#ifdef MULTITHREAD
%		  fnServerTransactionEnd_rets * pResult,
%#endif
%		  struct svc_req * pRequest )
%{
%  static const char	__procedure__[]	= "server:fnrpc_fnservertransactionend_1";
%#ifdef MULTITHREAD
%  typedef bool_t RESULTTYPE;
%#else
%  typedef fnServerTransactionEnd_rets * RESULTTYPE;
%#endif
%#ifndef MULTITHREAD
%  static fnServerTransactionEnd_rets	Result;
%  RESULTTYPE			pResult = &Result;
%#endif
%  LPCSTR	pszErrorMsg;
%
%  __pRequest__	= pRequest;
%
%  RPC_SERVER_ENTRY();
%
%#ifndef MULTITHREAD
%  if ( pResult->pszErrorMsg == szEmpty ) {
%    pResult->pszErrorMsg	= NULL;
%  }
%  xdr_free ( (xdrproc_t) xdr_fnServerTransactionEnd_rets, (char *) pResult );
%#endif
%  pResult->nErrorLvl		= 0;
%
%  Reply.bAnswered		= FALSE;
%  Reply.pfnCalled		= (void(*)()) fnServerTransactionEnd;
%  Reply.pfnXdrResult		= (bool_t(*)()) xdr_fnServerTransactionEnd_rets;
%  Reply.pnErrorLvl		= &pResult->nErrorLvl;
%  Reply.ppszErrorMsg		= (LPCSTR *) &pResult->pszErrorMsg;
%  Reply.pResult		= pResult;
%  Reply.pReturnValue		= &pResult->ReturnValue;
%  Reply.nReturnValueSize	= sizeof ( pResult->ReturnValue );
%
%  pResult->ReturnValue		=
%  fnServerTransactionEnd (
%	pArguments->oShortObjIdHeap,
%	pArguments->bIgnoreError );
%
%  if ( Reply.bAnswered ) {
%    __pRequest__	= NULL;
%    return (RESULTTYPE) NULL;
%  }
%
%  pResult->nErrorLvl	= RPC_SERVER_ERRLVL();
%  if ( pResult->nErrorLvl > 0 ) {
%    pszErrorMsg		= RPC_SERVER_ERRMSG();
%    if ( pszErrorMsg && *pszErrorMsg ) {
%      pResult->pszErrorMsg	= strdup ( pszErrorMsg );
%    }
%  }
%  if ( pResult->pszErrorMsg == NULL ) {
%#ifdef MULTITHREAD
%    pResult->pszErrorMsg	= strdup ( szEmpty );
%#else
%    pResult->pszErrorMsg	= (LPSTR) szEmpty;
%#endif
%  }
%  __pRequest__	= NULL;
%  return (RESULTTYPE) pResult;
%} /* fnrpc_fnservertransactionend_1 */
#endif	/* RPC_SVC */
%
#if RPC_CLNT
%TRACTID DLLEXPORT fnServerTransactionEnd
%	(SHORTOBJID oShortObjIdHeap ,
%	  bool_t bIgnoreError)
%{
%  static const char	__procedure__[]	= "client:fnServerTransactionEnd";
%  static fnServerTransactionEnd_rets	ZeroResult;
%  fnServerTransactionEnd_rets		* pResult = NULL;
%  fnServerTransactionEnd_rets		Result = ZeroResult;
%  fnServerTransactionEnd_args	InArguments;
%
%  /* Client initialization: */
%  if ( __bClientInitialize__ ) {
%    __bClientInitialize__	= FALSE;
%    RPC_CLIENT_INITIALIZE();
%  }
%
%#if	CLIENT_CREATE_BY_USER
%  if ( __pClient__ == NULL ) {
%    __pClient__	= RPC_CLIENT_CREATE ( __szHost__, __szTransport__ );
%    if ( __pClient__ == NULL ) {
%      /* Error handling for a not connected client: */
%      char	szError [ 256 ];
%      sprintf ( szError, szFormatNoServer, __procedure__ );
%      RPC_CLIENT_ERROR ( szError );
%      return Result.ReturnValue;
%    }
%  }
%#else
%  while ( __pClient__ == NULL ) {
%    __pClient__	= RPC_CLIENT_CREATE ( __szHost__, __szTransport__ );
%    if ( __pClient__ == NULL ) {
%      /* Error handling for a not connected client: */
%      char	szError [ 256 ];
%      sprintf ( szError, szFormatNoServer, __procedure__ );
%      RPC_CLIENT_CERROR ( szContNoServer, szError );
%    }
%  }
%#endif	/* CLIENT_CREATE_BY_USER */
%
%  /* Copy in the oShortObjIdHeap argument: */
%  InArguments.oShortObjIdHeap	= oShortObjIdHeap;
%  /* Copy in the bIgnoreError argument: */
%  InArguments.bIgnoreError	= bIgnoreError;
%
%  pResult	=
%#ifdef MULTITHREAD
%    (
%#else
%    (fnServerTransactionEnd_rets *)
%#endif
%    fnrpc_fnservertransactionend_1 (
%	&InArguments,
%#ifdef MULTITHREAD
%	&Result,
%#endif
%	__pClient__ )
%#ifdef MULTITHREAD
%	== RPC_SUCCESS ) ? &Result : NULL
%#endif
%	;
%
%  if ( pResult == NULL ) {
%    /* Error handling for a failed RPC call, */
%    /* i.e. the server did not respond: */
%    char	szError [ 256 ];
%    sprintf ( szError, szFormatRpcFailed, __procedure__,
%              clnt_sperror ( __pClient__, __szHost__ ) );
%    __pClient__	= RPC_CLIENT_DESTROY ( __pClient__ );
%    RPC_CLIENT_CERROR ( szContRpcFailed, szError );
%    Result	= ZeroResult;
%    return Result.ReturnValue;
%  }
%#ifndef MULTITHREAD
%  Result	= * pResult;
%#endif
%
%
%  if ( pResult && pResult->nErrorLvl ) {
%    /* Server returned a user error message: */
%    char	szErrorMsg [ 1024 ];
%    strncpy ( szErrorMsg,
%              ( pResult->pszErrorMsg && pResult->pszErrorMsg [ 0 ] ) ?
%              (LPCSTR) pResult->pszErrorMsg : (LPCSTR) szEmpty,
%              sizeof ( szErrorMsg ) );
%    szErrorMsg [ sizeof ( szErrorMsg ) - 1 ]	= (char) 0;
%    xdr_free ( (xdrproc_t) xdr_fnServerTransactionEnd_rets, (char *) pResult );
%    RPC_CLIENT_SERROR ( pResult->nErrorLvl, __procedure__,
%                        szErrorMsg );
%  } else {
%    xdr_free ( (xdrproc_t) xdr_fnServerTransactionEnd_rets, (char *) pResult );
%  }
%
%  return Result.ReturnValue;
%
%} /* fnServerTransactionEnd */
#endif	/* RPC_CLNT */
%
  void fnRpc_fnServerTransactionFlush_batch ( SHORTOBJID ) =  76 ;
%
#if RPC_SVC
%
%extern void fnServerTransactionFlush
%	(SHORTOBJID oShortObjIdHeap);
%
%#ifdef MULTITHREAD
%bool_t
%#else
%void *
%#endif
%	PASTE2(fnrpc_fnservertransactionflush_batch_1,_SVCSUFFIX)
%		( SHORTOBJID * pArguments,
%#ifdef MULTITHREAD
%		  void * pResult,
%#endif
%		  struct svc_req * pRequest )
%{
%  static const char	__procedure__[]	= "server:fnrpc_fnservertransactionflush_batch_1";
%#ifdef MULTITHREAD
%  typedef bool_t RESULTTYPE;
%#else
%  typedef void * RESULTTYPE;
%#endif
%
%  __pRequest__	= pRequest;
%
%  RPC_SERVER_ENTRY();
%
%  Reply.bAnswered		= TRUE;
%  Reply.pfnCalled		= (void(*)()) fnServerTransactionFlush;
%  Reply.pfnXdrResult		= (bool_t(*)()) xdr_void;
%  Reply.pnErrorLvl		= NULL;
%  Reply.ppszErrorMsg		= NULL;
%  Reply.pResult			= NULL;
%  Reply.pReturnValue		= NULL;
%  Reply.nReturnValueSize	= 0;
%  fnServerTransactionFlush (
%	(*pArguments) );
%  __pRequest__	= NULL;
%  return (RESULTTYPE) NULL;
%} /* fnrpc_fnservertransactionflush_batch_1 */
#endif	/* RPC_SVC */
%
#if RPC_CLNT
%void DLLEXPORT fnServerTransactionFlush
%	(SHORTOBJID oShortObjIdHeap)
%{
%  static const char	__procedure__[]	= "client:fnServerTransactionFlush";
%  static char	ZeroResult;
%  void		* pResult = NULL;
%#ifdef MULTITHREAD
%  char		Result = ZeroResult;
%#endif
%
%  /* Client initialization: */
%  if ( __bClientInitialize__ ) {
%    __bClientInitialize__	= FALSE;
%    RPC_CLIENT_INITIALIZE();
%  }
%
%#if	CLIENT_CREATE_BY_USER
%  if ( __pClient__ == NULL ) {
%    __pClient__	= RPC_CLIENT_CREATE ( __szHost__, __szTransport__ );
%    if ( __pClient__ == NULL ) {
%      /* Error handling for a not connected client: */
%      char	szError [ 256 ];
%      sprintf ( szError, szFormatNoServer, __procedure__ );
%      RPC_CLIENT_ERROR ( szError );
%      return;
%    }
%  }
%#else
%  while ( __pClient__ == NULL ) {
%    __pClient__	= RPC_CLIENT_CREATE ( __szHost__, __szTransport__ );
%    if ( __pClient__ == NULL ) {
%      /* Error handling for a not connected client: */
%      char	szError [ 256 ];
%      sprintf ( szError, szFormatNoServer, __procedure__ );
%      RPC_CLIENT_CERROR ( szContNoServer, szError );
%    }
%  }
%#endif	/* CLIENT_CREATE_BY_USER */
%
%  pResult	=
%#ifdef MULTITHREAD
%    (
%#else
%    (void *)
%#endif
%    fnrpc_fnservertransactionflush_batch_1 (
%	&oShortObjIdHeap,
%#ifdef MULTITHREAD
%	&Result,
%#endif
%	__pClient__ )
%#ifdef MULTITHREAD
%	== RPC_SUCCESS ) ? &Result : NULL
%#endif
%	;
%
%  if ( pResult == NULL ) {
%    /* Error handling for a failed RPC call, */
%    /* i.e. the server did not respond: */
%    char	szError [ 256 ];
%    sprintf ( szError, szFormatRpcFailed, __procedure__,
%              clnt_sperror ( __pClient__, __szHost__ ) );
%    __pClient__	= RPC_CLIENT_DESTROY ( __pClient__ );
%    RPC_CLIENT_CERROR ( szContRpcFailed, szError );
%    return;
%  }
%} /* fnServerTransactionFlush */
%
%#ifdef MULTITHREAD
%enum clnt_stat
%#else
%void *
%#endif
%fnrpc_fnservertransactionflush_batch_1
%	( SHORTOBJID * pArguments,
%#ifdef MULTITHREAD
%	  void * clnt_res,
%#endif
%	  PCLIENT pClient )
%{
%#ifdef MULTITHREAD
%  return clnt_call ( pClient, fnRpc_fnServerTransactionFlush_batch,
%                     (xdrproc_t) xdr_SHORTOBJID,
%                     (caddr_t) pArguments,
%                     (xdrproc_t) NULL, (caddr_t) NULL,
%                     NullTimeout );
%#else
%  if ( clnt_call ( pClient, fnRpc_fnServerTransactionFlush_batch,
%                   (xdrproc_t) xdr_SHORTOBJID,
%                   (caddr_t) pArguments,
%                   (xdrproc_t) NULL, (caddr_t) NULL,
%                   NullTimeout ) != RPC_SUCCESS ) {
%    return NULL;
%  }
%  return (void *) TRUE;
%#endif
%} /* fnrpc_fnservertransactionflush_batch_1 */
%#define	fnrpc_fnservertransactionflush_batch_1	fnrpc_fnservertransactionflush_1
#endif	/* RPC_CLNT */
%
  fnServerDbTransactionP_rets fnRpc_fnServerDbTransactionP ( fnServerDbTransactionP_args ) =  77 ;
%
#if RPC_SVC
%
%extern TRACTID fnServerDbTransactionP
%	(SHORTOBJID oShortObjIdHeap ,
%	  TRACTID nTractId);
%
%#ifdef MULTITHREAD
%bool_t
%#else
%fnServerDbTransactionP_rets *
%#endif
%	PASTE2(fnrpc_fnserverdbtransactionp_1,_SVCSUFFIX)
%		( fnServerDbTransactionP_args * pArguments,
%#ifdef MULTITHREAD
%		  fnServerDbTransactionP_rets * pResult,
%#endif
%		  struct svc_req * pRequest )
%{
%  static const char	__procedure__[]	= "server:fnrpc_fnserverdbtransactionp_1";
%#ifdef MULTITHREAD
%  typedef bool_t RESULTTYPE;
%#else
%  typedef fnServerDbTransactionP_rets * RESULTTYPE;
%#endif
%#ifndef MULTITHREAD
%  static fnServerDbTransactionP_rets	Result;
%  RESULTTYPE			pResult = &Result;
%#endif
%  LPCSTR	pszErrorMsg;
%
%  __pRequest__	= pRequest;
%
%  RPC_SERVER_ENTRY();
%
%#ifndef MULTITHREAD
%  if ( pResult->pszErrorMsg == szEmpty ) {
%    pResult->pszErrorMsg	= NULL;
%  }
%  xdr_free ( (xdrproc_t) xdr_fnServerDbTransactionP_rets, (char *) pResult );
%#endif
%  pResult->nErrorLvl		= 0;
%
%  Reply.bAnswered		= FALSE;
%  Reply.pfnCalled		= (void(*)()) fnServerDbTransactionP;
%  Reply.pfnXdrResult		= (bool_t(*)()) xdr_fnServerDbTransactionP_rets;
%  Reply.pnErrorLvl		= &pResult->nErrorLvl;
%  Reply.ppszErrorMsg		= (LPCSTR *) &pResult->pszErrorMsg;
%  Reply.pResult		= pResult;
%  Reply.pReturnValue		= &pResult->ReturnValue;
%  Reply.nReturnValueSize	= sizeof ( pResult->ReturnValue );
%
%  pResult->ReturnValue		=
%  fnServerDbTransactionP (
%	pArguments->oShortObjIdHeap,
%	pArguments->nTractId );
%
%  if ( Reply.bAnswered ) {
%    __pRequest__	= NULL;
%    return (RESULTTYPE) NULL;
%  }
%
%  pResult->nErrorLvl	= RPC_SERVER_ERRLVL();
%  if ( pResult->nErrorLvl > 0 ) {
%    pszErrorMsg		= RPC_SERVER_ERRMSG();
%    if ( pszErrorMsg && *pszErrorMsg ) {
%      pResult->pszErrorMsg	= strdup ( pszErrorMsg );
%    }
%  }
%  if ( pResult->pszErrorMsg == NULL ) {
%#ifdef MULTITHREAD
%    pResult->pszErrorMsg	= strdup ( szEmpty );
%#else
%    pResult->pszErrorMsg	= (LPSTR) szEmpty;
%#endif
%  }
%  __pRequest__	= NULL;
%  return (RESULTTYPE) pResult;
%} /* fnrpc_fnserverdbtransactionp_1 */
#endif	/* RPC_SVC */
%
#if RPC_CLNT
%TRACTID DLLEXPORT fnServerDbTransactionP
%	(SHORTOBJID oShortObjIdHeap ,
%	  TRACTID nTractId)
%{
%  static const char	__procedure__[]	= "client:fnServerDbTransactionP";
%  static fnServerDbTransactionP_rets	ZeroResult;
%  fnServerDbTransactionP_rets		* pResult = NULL;
%  fnServerDbTransactionP_rets		Result = ZeroResult;
%  fnServerDbTransactionP_args	InArguments;
%
%  /* Client initialization: */
%  if ( __bClientInitialize__ ) {
%    __bClientInitialize__	= FALSE;
%    RPC_CLIENT_INITIALIZE();
%  }
%
%#if	CLIENT_CREATE_BY_USER
%  if ( __pClient__ == NULL ) {
%    __pClient__	= RPC_CLIENT_CREATE ( __szHost__, __szTransport__ );
%    if ( __pClient__ == NULL ) {
%      /* Error handling for a not connected client: */
%      char	szError [ 256 ];
%      sprintf ( szError, szFormatNoServer, __procedure__ );
%      RPC_CLIENT_ERROR ( szError );
%      return Result.ReturnValue;
%    }
%  }
%#else
%  while ( __pClient__ == NULL ) {
%    __pClient__	= RPC_CLIENT_CREATE ( __szHost__, __szTransport__ );
%    if ( __pClient__ == NULL ) {
%      /* Error handling for a not connected client: */
%      char	szError [ 256 ];
%      sprintf ( szError, szFormatNoServer, __procedure__ );
%      RPC_CLIENT_CERROR ( szContNoServer, szError );
%    }
%  }
%#endif	/* CLIENT_CREATE_BY_USER */
%
%  /* Copy in the oShortObjIdHeap argument: */
%  InArguments.oShortObjIdHeap	= oShortObjIdHeap;
%  /* Copy in the nTractId argument: */
%  InArguments.nTractId	= nTractId;
%
%  pResult	=
%#ifdef MULTITHREAD
%    (
%#else
%    (fnServerDbTransactionP_rets *)
%#endif
%    fnrpc_fnserverdbtransactionp_1 (
%	&InArguments,
%#ifdef MULTITHREAD
%	&Result,
%#endif
%	__pClient__ )
%#ifdef MULTITHREAD
%	== RPC_SUCCESS ) ? &Result : NULL
%#endif
%	;
%
%  if ( pResult == NULL ) {
%    /* Error handling for a failed RPC call, */
%    /* i.e. the server did not respond: */
%    char	szError [ 256 ];
%    sprintf ( szError, szFormatRpcFailed, __procedure__,
%              clnt_sperror ( __pClient__, __szHost__ ) );
%    __pClient__	= RPC_CLIENT_DESTROY ( __pClient__ );
%    RPC_CLIENT_CERROR ( szContRpcFailed, szError );
%    Result	= ZeroResult;
%    return Result.ReturnValue;
%  }
%#ifndef MULTITHREAD
%  Result	= * pResult;
%#endif
%
%
%  if ( pResult && pResult->nErrorLvl ) {
%    /* Server returned a user error message: */
%    char	szErrorMsg [ 1024 ];
%    strncpy ( szErrorMsg,
%              ( pResult->pszErrorMsg && pResult->pszErrorMsg [ 0 ] ) ?
%              (LPCSTR) pResult->pszErrorMsg : (LPCSTR) szEmpty,
%              sizeof ( szErrorMsg ) );
%    szErrorMsg [ sizeof ( szErrorMsg ) - 1 ]	= (char) 0;
%    xdr_free ( (xdrproc_t) xdr_fnServerDbTransactionP_rets, (char *) pResult );
%    RPC_CLIENT_SERROR ( pResult->nErrorLvl, __procedure__,
%                        szErrorMsg );
%  } else {
%    xdr_free ( (xdrproc_t) xdr_fnServerDbTransactionP_rets, (char *) pResult );
%  }
%
%  return Result.ReturnValue;
%
%} /* fnServerDbTransactionP */
#endif	/* RPC_CLNT */
%
  fnClientBtreeClear_rets fnRpc_fnClientBtreeClear ( fnClientBtreeClear_args ) =  78 ;
%
#if RPC_SVC
%
%extern BTREERESULT fnClientBtreeClear
%	(SHORTOBJID oShortObjIdHeap ,
%	  SHORTOBJID oShortObjIdBTree);
%
%#ifdef MULTITHREAD
%bool_t
%#else
%fnClientBtreeClear_rets *
%#endif
%	PASTE2(fnrpc_fnclientbtreeclear_1,_SVCSUFFIX)
%		( fnClientBtreeClear_args * pArguments,
%#ifdef MULTITHREAD
%		  fnClientBtreeClear_rets * pResult,
%#endif
%		  struct svc_req * pRequest )
%{
%  static const char	__procedure__[]	= "server:fnrpc_fnclientbtreeclear_1";
%#ifdef MULTITHREAD
%  typedef bool_t RESULTTYPE;
%#else
%  typedef fnClientBtreeClear_rets * RESULTTYPE;
%#endif
%#ifndef MULTITHREAD
%  static fnClientBtreeClear_rets	Result;
%  RESULTTYPE			pResult = &Result;
%#endif
%  LPCSTR	pszErrorMsg;
%
%  __pRequest__	= pRequest;
%
%  RPC_SERVER_ENTRY();
%
%#ifndef MULTITHREAD
%  if ( pResult->pszErrorMsg == szEmpty ) {
%    pResult->pszErrorMsg	= NULL;
%  }
%  xdr_free ( (xdrproc_t) xdr_fnClientBtreeClear_rets, (char *) pResult );
%#endif
%  pResult->nErrorLvl		= 0;
%
%  Reply.bAnswered		= FALSE;
%  Reply.pfnCalled		= (void(*)()) fnClientBtreeClear;
%  Reply.pfnXdrResult		= (bool_t(*)()) xdr_fnClientBtreeClear_rets;
%  Reply.pnErrorLvl		= &pResult->nErrorLvl;
%  Reply.ppszErrorMsg		= (LPCSTR *) &pResult->pszErrorMsg;
%  Reply.pResult		= pResult;
%  Reply.pReturnValue		= &pResult->ReturnValue;
%  Reply.nReturnValueSize	= sizeof ( pResult->ReturnValue );
%
%  pResult->ReturnValue		=
%  fnClientBtreeClear (
%	pArguments->oShortObjIdHeap,
%	pArguments->oShortObjIdBTree );
%
%  if ( Reply.bAnswered ) {
%    __pRequest__	= NULL;
%    return (RESULTTYPE) NULL;
%  }
%
%  pResult->nErrorLvl	= RPC_SERVER_ERRLVL();
%  if ( pResult->nErrorLvl > 0 ) {
%    pszErrorMsg		= RPC_SERVER_ERRMSG();
%    if ( pszErrorMsg && *pszErrorMsg ) {
%      pResult->pszErrorMsg	= strdup ( pszErrorMsg );
%    }
%  }
%  if ( pResult->pszErrorMsg == NULL ) {
%#ifdef MULTITHREAD
%    pResult->pszErrorMsg	= strdup ( szEmpty );
%#else
%    pResult->pszErrorMsg	= (LPSTR) szEmpty;
%#endif
%  }
%  __pRequest__	= NULL;
%  return (RESULTTYPE) pResult;
%} /* fnrpc_fnclientbtreeclear_1 */
#endif	/* RPC_SVC */
%
#if RPC_CLNT
%BTREERESULT DLLEXPORT fnClientBtreeClear
%	(SHORTOBJID oShortObjIdHeap ,
%	  SHORTOBJID oShortObjIdBTree)
%{
%  static const char	__procedure__[]	= "client:fnClientBtreeClear";
%  static fnClientBtreeClear_rets	ZeroResult;
%  fnClientBtreeClear_rets		* pResult = NULL;
%  fnClientBtreeClear_rets		Result = ZeroResult;
%  fnClientBtreeClear_args	InArguments;
%
%  /* Client initialization: */
%  if ( __bClientInitialize__ ) {
%    __bClientInitialize__	= FALSE;
%    RPC_CLIENT_INITIALIZE();
%  }
%
%#if	CLIENT_CREATE_BY_USER
%  if ( __pClient__ == NULL ) {
%    __pClient__	= RPC_CLIENT_CREATE ( __szHost__, __szTransport__ );
%    if ( __pClient__ == NULL ) {
%      /* Error handling for a not connected client: */
%      char	szError [ 256 ];
%      sprintf ( szError, szFormatNoServer, __procedure__ );
%      RPC_CLIENT_ERROR ( szError );
%      return Result.ReturnValue;
%    }
%  }
%#else
%  while ( __pClient__ == NULL ) {
%    __pClient__	= RPC_CLIENT_CREATE ( __szHost__, __szTransport__ );
%    if ( __pClient__ == NULL ) {
%      /* Error handling for a not connected client: */
%      char	szError [ 256 ];
%      sprintf ( szError, szFormatNoServer, __procedure__ );
%      RPC_CLIENT_CERROR ( szContNoServer, szError );
%    }
%  }
%#endif	/* CLIENT_CREATE_BY_USER */
%
%  /* Copy in the oShortObjIdHeap argument: */
%  InArguments.oShortObjIdHeap	= oShortObjIdHeap;
%  /* Copy in the oShortObjIdBTree argument: */
%  InArguments.oShortObjIdBTree	= oShortObjIdBTree;
%
%  pResult	=
%#ifdef MULTITHREAD
%    (
%#else
%    (fnClientBtreeClear_rets *)
%#endif
%    fnrpc_fnclientbtreeclear_1 (
%	&InArguments,
%#ifdef MULTITHREAD
%	&Result,
%#endif
%	__pClient__ )
%#ifdef MULTITHREAD
%	== RPC_SUCCESS ) ? &Result : NULL
%#endif
%	;
%
%  if ( pResult == NULL ) {
%    /* Error handling for a failed RPC call, */
%    /* i.e. the server did not respond: */
%    char	szError [ 256 ];
%    sprintf ( szError, szFormatRpcFailed, __procedure__,
%              clnt_sperror ( __pClient__, __szHost__ ) );
%    __pClient__	= RPC_CLIENT_DESTROY ( __pClient__ );
%    RPC_CLIENT_CERROR ( szContRpcFailed, szError );
%    Result	= ZeroResult;
%    return Result.ReturnValue;
%  }
%#ifndef MULTITHREAD
%  Result	= * pResult;
%#endif
%
%
%  if ( pResult && pResult->nErrorLvl ) {
%    /* Server returned a user error message: */
%    char	szErrorMsg [ 1024 ];
%    strncpy ( szErrorMsg,
%              ( pResult->pszErrorMsg && pResult->pszErrorMsg [ 0 ] ) ?
%              (LPCSTR) pResult->pszErrorMsg : (LPCSTR) szEmpty,
%              sizeof ( szErrorMsg ) );
%    szErrorMsg [ sizeof ( szErrorMsg ) - 1 ]	= (char) 0;
%    xdr_free ( (xdrproc_t) xdr_fnClientBtreeClear_rets, (char *) pResult );
%    RPC_CLIENT_SERROR ( pResult->nErrorLvl, __procedure__,
%                        szErrorMsg );
%  } else {
%    xdr_free ( (xdrproc_t) xdr_fnClientBtreeClear_rets, (char *) pResult );
%  }
%
%  return Result.ReturnValue;
%
%} /* fnClientBtreeClear */
#endif	/* RPC_CLNT */
%
  fnClientBtreeCount_rets fnRpc_fnClientBtreeCount ( fnClientBtreeCount_args ) =  79 ;
%
#if RPC_SVC
%
%extern int fnClientBtreeCount
%	(SHORTOBJID oShortObjIdHeap ,
%	  SHORTOBJID oShortObjIdBTree);
%
%#ifdef MULTITHREAD
%bool_t
%#else
%fnClientBtreeCount_rets *
%#endif
%	PASTE2(fnrpc_fnclientbtreecount_1,_SVCSUFFIX)
%		( fnClientBtreeCount_args * pArguments,
%#ifdef MULTITHREAD
%		  fnClientBtreeCount_rets * pResult,
%#endif
%		  struct svc_req * pRequest )
%{
%  static const char	__procedure__[]	= "server:fnrpc_fnclientbtreecount_1";
%#ifdef MULTITHREAD
%  typedef bool_t RESULTTYPE;
%#else
%  typedef fnClientBtreeCount_rets * RESULTTYPE;
%#endif
%#ifndef MULTITHREAD
%  static fnClientBtreeCount_rets	Result;
%  RESULTTYPE			pResult = &Result;
%#endif
%  LPCSTR	pszErrorMsg;
%
%  __pRequest__	= pRequest;
%
%  RPC_SERVER_ENTRY();
%
%#ifndef MULTITHREAD
%  if ( pResult->pszErrorMsg == szEmpty ) {
%    pResult->pszErrorMsg	= NULL;
%  }
%  xdr_free ( (xdrproc_t) xdr_fnClientBtreeCount_rets, (char *) pResult );
%#endif
%  pResult->nErrorLvl		= 0;
%
%  Reply.bAnswered		= FALSE;
%  Reply.pfnCalled		= (void(*)()) fnClientBtreeCount;
%  Reply.pfnXdrResult		= (bool_t(*)()) xdr_fnClientBtreeCount_rets;
%  Reply.pnErrorLvl		= &pResult->nErrorLvl;
%  Reply.ppszErrorMsg		= (LPCSTR *) &pResult->pszErrorMsg;
%  Reply.pResult		= pResult;
%  Reply.pReturnValue		= &pResult->ReturnValue;
%  Reply.nReturnValueSize	= sizeof ( pResult->ReturnValue );
%
%  pResult->ReturnValue		=
%  fnClientBtreeCount (
%	pArguments->oShortObjIdHeap,
%	pArguments->oShortObjIdBTree );
%
%  if ( Reply.bAnswered ) {
%    __pRequest__	= NULL;
%    return (RESULTTYPE) NULL;
%  }
%
%  pResult->nErrorLvl	= RPC_SERVER_ERRLVL();
%  if ( pResult->nErrorLvl > 0 ) {
%    pszErrorMsg		= RPC_SERVER_ERRMSG();
%    if ( pszErrorMsg && *pszErrorMsg ) {
%      pResult->pszErrorMsg	= strdup ( pszErrorMsg );
%    }
%  }
%  if ( pResult->pszErrorMsg == NULL ) {
%#ifdef MULTITHREAD
%    pResult->pszErrorMsg	= strdup ( szEmpty );
%#else
%    pResult->pszErrorMsg	= (LPSTR) szEmpty;
%#endif
%  }
%  __pRequest__	= NULL;
%  return (RESULTTYPE) pResult;
%} /* fnrpc_fnclientbtreecount_1 */
#endif	/* RPC_SVC */
%
#if RPC_CLNT
%int DLLEXPORT fnClientBtreeCount
%	(SHORTOBJID oShortObjIdHeap ,
%	  SHORTOBJID oShortObjIdBTree)
%{
%  static const char	__procedure__[]	= "client:fnClientBtreeCount";
%  static fnClientBtreeCount_rets	ZeroResult;
%  fnClientBtreeCount_rets		* pResult = NULL;
%  fnClientBtreeCount_rets		Result = ZeroResult;
%  fnClientBtreeCount_args	InArguments;
%
%  /* Client initialization: */
%  if ( __bClientInitialize__ ) {
%    __bClientInitialize__	= FALSE;
%    RPC_CLIENT_INITIALIZE();
%  }
%
%#if	CLIENT_CREATE_BY_USER
%  if ( __pClient__ == NULL ) {
%    __pClient__	= RPC_CLIENT_CREATE ( __szHost__, __szTransport__ );
%    if ( __pClient__ == NULL ) {
%      /* Error handling for a not connected client: */
%      char	szError [ 256 ];
%      sprintf ( szError, szFormatNoServer, __procedure__ );
%      RPC_CLIENT_ERROR ( szError );
%      return Result.ReturnValue;
%    }
%  }
%#else
%  while ( __pClient__ == NULL ) {
%    __pClient__	= RPC_CLIENT_CREATE ( __szHost__, __szTransport__ );
%    if ( __pClient__ == NULL ) {
%      /* Error handling for a not connected client: */
%      char	szError [ 256 ];
%      sprintf ( szError, szFormatNoServer, __procedure__ );
%      RPC_CLIENT_CERROR ( szContNoServer, szError );
%    }
%  }
%#endif	/* CLIENT_CREATE_BY_USER */
%
%  /* Copy in the oShortObjIdHeap argument: */
%  InArguments.oShortObjIdHeap	= oShortObjIdHeap;
%  /* Copy in the oShortObjIdBTree argument: */
%  InArguments.oShortObjIdBTree	= oShortObjIdBTree;
%
%  pResult	=
%#ifdef MULTITHREAD
%    (
%#else
%    (fnClientBtreeCount_rets *)
%#endif
%    fnrpc_fnclientbtreecount_1 (
%	&InArguments,
%#ifdef MULTITHREAD
%	&Result,
%#endif
%	__pClient__ )
%#ifdef MULTITHREAD
%	== RPC_SUCCESS ) ? &Result : NULL
%#endif
%	;
%
%  if ( pResult == NULL ) {
%    /* Error handling for a failed RPC call, */
%    /* i.e. the server did not respond: */
%    char	szError [ 256 ];
%    sprintf ( szError, szFormatRpcFailed, __procedure__,
%              clnt_sperror ( __pClient__, __szHost__ ) );
%    __pClient__	= RPC_CLIENT_DESTROY ( __pClient__ );
%    RPC_CLIENT_CERROR ( szContRpcFailed, szError );
%    Result	= ZeroResult;
%    return Result.ReturnValue;
%  }
%#ifndef MULTITHREAD
%  Result	= * pResult;
%#endif
%
%
%  if ( pResult && pResult->nErrorLvl ) {
%    /* Server returned a user error message: */
%    char	szErrorMsg [ 1024 ];
%    strncpy ( szErrorMsg,
%              ( pResult->pszErrorMsg && pResult->pszErrorMsg [ 0 ] ) ?
%              (LPCSTR) pResult->pszErrorMsg : (LPCSTR) szEmpty,
%              sizeof ( szErrorMsg ) );
%    szErrorMsg [ sizeof ( szErrorMsg ) - 1 ]	= (char) 0;
%    xdr_free ( (xdrproc_t) xdr_fnClientBtreeCount_rets, (char *) pResult );
%    RPC_CLIENT_SERROR ( pResult->nErrorLvl, __procedure__,
%                        szErrorMsg );
%  } else {
%    xdr_free ( (xdrproc_t) xdr_fnClientBtreeCount_rets, (char *) pResult );
%  }
%
%  return Result.ReturnValue;
%
%} /* fnClientBtreeCount */
#endif	/* RPC_CLNT */
%
  fnServerBtreeDelete_rets fnRpc_fnServerBtreeDelete ( fnServerBtreeDelete_args ) =  80 ;
%
#if RPC_SVC
%
%extern BTREERESULT fnServerBtreeDelete
%	(SHORTOBJID oShortObjIdHeap ,
%	  SHORTOBJID oShortObjIdBTree ,
%	  int nValueKey ,
%	  SHTYPETAG nTypeTagKey);
%
%#ifdef MULTITHREAD
%bool_t
%#else
%fnServerBtreeDelete_rets *
%#endif
%	PASTE2(fnrpc_fnserverbtreedelete_1,_SVCSUFFIX)
%		( fnServerBtreeDelete_args * pArguments,
%#ifdef MULTITHREAD
%		  fnServerBtreeDelete_rets * pResult,
%#endif
%		  struct svc_req * pRequest )
%{
%  static const char	__procedure__[]	= "server:fnrpc_fnserverbtreedelete_1";
%#ifdef MULTITHREAD
%  typedef bool_t RESULTTYPE;
%#else
%  typedef fnServerBtreeDelete_rets * RESULTTYPE;
%#endif
%#ifndef MULTITHREAD
%  static fnServerBtreeDelete_rets	Result;
%  RESULTTYPE			pResult = &Result;
%#endif
%  LPCSTR	pszErrorMsg;
%
%  __pRequest__	= pRequest;
%
%  RPC_SERVER_ENTRY();
%
%#ifndef MULTITHREAD
%  if ( pResult->pszErrorMsg == szEmpty ) {
%    pResult->pszErrorMsg	= NULL;
%  }
%  xdr_free ( (xdrproc_t) xdr_fnServerBtreeDelete_rets, (char *) pResult );
%#endif
%  pResult->nErrorLvl		= 0;
%
%  Reply.bAnswered		= FALSE;
%  Reply.pfnCalled		= (void(*)()) fnServerBtreeDelete;
%  Reply.pfnXdrResult		= (bool_t(*)()) xdr_fnServerBtreeDelete_rets;
%  Reply.pnErrorLvl		= &pResult->nErrorLvl;
%  Reply.ppszErrorMsg		= (LPCSTR *) &pResult->pszErrorMsg;
%  Reply.pResult		= pResult;
%  Reply.pReturnValue		= &pResult->ReturnValue;
%  Reply.nReturnValueSize	= sizeof ( pResult->ReturnValue );
%
%  pResult->ReturnValue		=
%  fnServerBtreeDelete (
%	pArguments->oShortObjIdHeap,
%	pArguments->oShortObjIdBTree,
%	pArguments->nValueKey,
%	pArguments->nTypeTagKey );
%
%  if ( Reply.bAnswered ) {
%    __pRequest__	= NULL;
%    return (RESULTTYPE) NULL;
%  }
%
%  pResult->nErrorLvl	= RPC_SERVER_ERRLVL();
%  if ( pResult->nErrorLvl > 0 ) {
%    pszErrorMsg		= RPC_SERVER_ERRMSG();
%    if ( pszErrorMsg && *pszErrorMsg ) {
%      pResult->pszErrorMsg	= strdup ( pszErrorMsg );
%    }
%  }
%  if ( pResult->pszErrorMsg == NULL ) {
%#ifdef MULTITHREAD
%    pResult->pszErrorMsg	= strdup ( szEmpty );
%#else
%    pResult->pszErrorMsg	= (LPSTR) szEmpty;
%#endif
%  }
%  __pRequest__	= NULL;
%  return (RESULTTYPE) pResult;
%} /* fnrpc_fnserverbtreedelete_1 */
#endif	/* RPC_SVC */
%
#if RPC_CLNT
%BTREERESULT DLLEXPORT fnServerBtreeDelete
%	(SHORTOBJID oShortObjIdHeap ,
%	  SHORTOBJID oShortObjIdBTree ,
%	  int nValueKey ,
%	  SHTYPETAG nTypeTagKey)
%{
%  static const char	__procedure__[]	= "client:fnServerBtreeDelete";
%  static fnServerBtreeDelete_rets	ZeroResult;
%  fnServerBtreeDelete_rets		* pResult = NULL;
%  fnServerBtreeDelete_rets		Result = ZeroResult;
%  fnServerBtreeDelete_args	InArguments;
%
%  /* Client initialization: */
%  if ( __bClientInitialize__ ) {
%    __bClientInitialize__	= FALSE;
%    RPC_CLIENT_INITIALIZE();
%  }
%
%#if	CLIENT_CREATE_BY_USER
%  if ( __pClient__ == NULL ) {
%    __pClient__	= RPC_CLIENT_CREATE ( __szHost__, __szTransport__ );
%    if ( __pClient__ == NULL ) {
%      /* Error handling for a not connected client: */
%      char	szError [ 256 ];
%      sprintf ( szError, szFormatNoServer, __procedure__ );
%      RPC_CLIENT_ERROR ( szError );
%      return Result.ReturnValue;
%    }
%  }
%#else
%  while ( __pClient__ == NULL ) {
%    __pClient__	= RPC_CLIENT_CREATE ( __szHost__, __szTransport__ );
%    if ( __pClient__ == NULL ) {
%      /* Error handling for a not connected client: */
%      char	szError [ 256 ];
%      sprintf ( szError, szFormatNoServer, __procedure__ );
%      RPC_CLIENT_CERROR ( szContNoServer, szError );
%    }
%  }
%#endif	/* CLIENT_CREATE_BY_USER */
%
%  /* Copy in the oShortObjIdHeap argument: */
%  InArguments.oShortObjIdHeap	= oShortObjIdHeap;
%  /* Copy in the oShortObjIdBTree argument: */
%  InArguments.oShortObjIdBTree	= oShortObjIdBTree;
%  /* Copy in the nValueKey argument: */
%  InArguments.nValueKey	= nValueKey;
%  /* Copy in the nTypeTagKey argument: */
%  InArguments.nTypeTagKey	= nTypeTagKey;
%
%  pResult	=
%#ifdef MULTITHREAD
%    (
%#else
%    (fnServerBtreeDelete_rets *)
%#endif
%    fnrpc_fnserverbtreedelete_1 (
%	&InArguments,
%#ifdef MULTITHREAD
%	&Result,
%#endif
%	__pClient__ )
%#ifdef MULTITHREAD
%	== RPC_SUCCESS ) ? &Result : NULL
%#endif
%	;
%
%  if ( pResult == NULL ) {
%    /* Error handling for a failed RPC call, */
%    /* i.e. the server did not respond: */
%    char	szError [ 256 ];
%    sprintf ( szError, szFormatRpcFailed, __procedure__,
%              clnt_sperror ( __pClient__, __szHost__ ) );
%    __pClient__	= RPC_CLIENT_DESTROY ( __pClient__ );
%    RPC_CLIENT_CERROR ( szContRpcFailed, szError );
%    Result	= ZeroResult;
%    return Result.ReturnValue;
%  }
%#ifndef MULTITHREAD
%  Result	= * pResult;
%#endif
%
%
%  if ( pResult && pResult->nErrorLvl ) {
%    /* Server returned a user error message: */
%    char	szErrorMsg [ 1024 ];
%    strncpy ( szErrorMsg,
%              ( pResult->pszErrorMsg && pResult->pszErrorMsg [ 0 ] ) ?
%              (LPCSTR) pResult->pszErrorMsg : (LPCSTR) szEmpty,
%              sizeof ( szErrorMsg ) );
%    szErrorMsg [ sizeof ( szErrorMsg ) - 1 ]	= (char) 0;
%    xdr_free ( (xdrproc_t) xdr_fnServerBtreeDelete_rets, (char *) pResult );
%    RPC_CLIENT_SERROR ( pResult->nErrorLvl, __procedure__,
%                        szErrorMsg );
%  } else {
%    xdr_free ( (xdrproc_t) xdr_fnServerBtreeDelete_rets, (char *) pResult );
%  }
%
%  return Result.ReturnValue;
%
%} /* fnServerBtreeDelete */
#endif	/* RPC_CLNT */
%
  fnServerBtreeDeleteByFloat_rets fnRpc_fnServerBtreeDeleteByFloat ( fnServerBtreeDeleteByFloat_args ) =  81 ;
%
#if RPC_SVC
%
%extern BTREERESULT fnServerBtreeDeleteByFloat
%	(SHORTOBJID oShortObjIdHeap ,
%	  SHORTOBJID oShortObjIdBTree ,
%	  float fKey);
%
%#ifdef MULTITHREAD
%bool_t
%#else
%fnServerBtreeDeleteByFloat_rets *
%#endif
%	PASTE2(fnrpc_fnserverbtreedeletebyfloat_1,_SVCSUFFIX)
%		( fnServerBtreeDeleteByFloat_args * pArguments,
%#ifdef MULTITHREAD
%		  fnServerBtreeDeleteByFloat_rets * pResult,
%#endif
%		  struct svc_req * pRequest )
%{
%  static const char	__procedure__[]	= "server:fnrpc_fnserverbtreedeletebyfloat_1";
%#ifdef MULTITHREAD
%  typedef bool_t RESULTTYPE;
%#else
%  typedef fnServerBtreeDeleteByFloat_rets * RESULTTYPE;
%#endif
%#ifndef MULTITHREAD
%  static fnServerBtreeDeleteByFloat_rets	Result;
%  RESULTTYPE			pResult = &Result;
%#endif
%  LPCSTR	pszErrorMsg;
%
%  __pRequest__	= pRequest;
%
%  RPC_SERVER_ENTRY();
%
%#ifndef MULTITHREAD
%  if ( pResult->pszErrorMsg == szEmpty ) {
%    pResult->pszErrorMsg	= NULL;
%  }
%  xdr_free ( (xdrproc_t) xdr_fnServerBtreeDeleteByFloat_rets, (char *) pResult );
%#endif
%  pResult->nErrorLvl		= 0;
%
%  Reply.bAnswered		= FALSE;
%  Reply.pfnCalled		= (void(*)()) fnServerBtreeDeleteByFloat;
%  Reply.pfnXdrResult		= (bool_t(*)()) xdr_fnServerBtreeDeleteByFloat_rets;
%  Reply.pnErrorLvl		= &pResult->nErrorLvl;
%  Reply.ppszErrorMsg		= (LPCSTR *) &pResult->pszErrorMsg;
%  Reply.pResult		= pResult;
%  Reply.pReturnValue		= &pResult->ReturnValue;
%  Reply.nReturnValueSize	= sizeof ( pResult->ReturnValue );
%
%  pResult->ReturnValue		=
%  fnServerBtreeDeleteByFloat (
%	pArguments->oShortObjIdHeap,
%	pArguments->oShortObjIdBTree,
%	pArguments->fKey );
%
%  if ( Reply.bAnswered ) {
%    __pRequest__	= NULL;
%    return (RESULTTYPE) NULL;
%  }
%
%  pResult->nErrorLvl	= RPC_SERVER_ERRLVL();
%  if ( pResult->nErrorLvl > 0 ) {
%    pszErrorMsg		= RPC_SERVER_ERRMSG();
%    if ( pszErrorMsg && *pszErrorMsg ) {
%      pResult->pszErrorMsg	= strdup ( pszErrorMsg );
%    }
%  }
%  if ( pResult->pszErrorMsg == NULL ) {
%#ifdef MULTITHREAD
%    pResult->pszErrorMsg	= strdup ( szEmpty );
%#else
%    pResult->pszErrorMsg	= (LPSTR) szEmpty;
%#endif
%  }
%  __pRequest__	= NULL;
%  return (RESULTTYPE) pResult;
%} /* fnrpc_fnserverbtreedeletebyfloat_1 */
#endif	/* RPC_SVC */
%
#if RPC_CLNT
%BTREERESULT DLLEXPORT fnServerBtreeDeleteByFloat
%	(SHORTOBJID oShortObjIdHeap ,
%	  SHORTOBJID oShortObjIdBTree ,
%	  float fKey)
%{
%  static const char	__procedure__[]	= "client:fnServerBtreeDeleteByFloat";
%  static fnServerBtreeDeleteByFloat_rets	ZeroResult;
%  fnServerBtreeDeleteByFloat_rets		* pResult = NULL;
%  fnServerBtreeDeleteByFloat_rets		Result = ZeroResult;
%  fnServerBtreeDeleteByFloat_args	InArguments;
%
%  /* Client initialization: */
%  if ( __bClientInitialize__ ) {
%    __bClientInitialize__	= FALSE;
%    RPC_CLIENT_INITIALIZE();
%  }
%
%#if	CLIENT_CREATE_BY_USER
%  if ( __pClient__ == NULL ) {
%    __pClient__	= RPC_CLIENT_CREATE ( __szHost__, __szTransport__ );
%    if ( __pClient__ == NULL ) {
%      /* Error handling for a not connected client: */
%      char	szError [ 256 ];
%      sprintf ( szError, szFormatNoServer, __procedure__ );
%      RPC_CLIENT_ERROR ( szError );
%      return Result.ReturnValue;
%    }
%  }
%#else
%  while ( __pClient__ == NULL ) {
%    __pClient__	= RPC_CLIENT_CREATE ( __szHost__, __szTransport__ );
%    if ( __pClient__ == NULL ) {
%      /* Error handling for a not connected client: */
%      char	szError [ 256 ];
%      sprintf ( szError, szFormatNoServer, __procedure__ );
%      RPC_CLIENT_CERROR ( szContNoServer, szError );
%    }
%  }
%#endif	/* CLIENT_CREATE_BY_USER */
%
%  /* Copy in the oShortObjIdHeap argument: */
%  InArguments.oShortObjIdHeap	= oShortObjIdHeap;
%  /* Copy in the oShortObjIdBTree argument: */
%  InArguments.oShortObjIdBTree	= oShortObjIdBTree;
%  /* Copy in the fKey argument: */
%  InArguments.fKey	= fKey;
%
%  pResult	=
%#ifdef MULTITHREAD
%    (
%#else
%    (fnServerBtreeDeleteByFloat_rets *)
%#endif
%    fnrpc_fnserverbtreedeletebyfloat_1 (
%	&InArguments,
%#ifdef MULTITHREAD
%	&Result,
%#endif
%	__pClient__ )
%#ifdef MULTITHREAD
%	== RPC_SUCCESS ) ? &Result : NULL
%#endif
%	;
%
%  if ( pResult == NULL ) {
%    /* Error handling for a failed RPC call, */
%    /* i.e. the server did not respond: */
%    char	szError [ 256 ];
%    sprintf ( szError, szFormatRpcFailed, __procedure__,
%              clnt_sperror ( __pClient__, __szHost__ ) );
%    __pClient__	= RPC_CLIENT_DESTROY ( __pClient__ );
%    RPC_CLIENT_CERROR ( szContRpcFailed, szError );
%    Result	= ZeroResult;
%    return Result.ReturnValue;
%  }
%#ifndef MULTITHREAD
%  Result	= * pResult;
%#endif
%
%
%  if ( pResult && pResult->nErrorLvl ) {
%    /* Server returned a user error message: */
%    char	szErrorMsg [ 1024 ];
%    strncpy ( szErrorMsg,
%              ( pResult->pszErrorMsg && pResult->pszErrorMsg [ 0 ] ) ?
%              (LPCSTR) pResult->pszErrorMsg : (LPCSTR) szEmpty,
%              sizeof ( szErrorMsg ) );
%    szErrorMsg [ sizeof ( szErrorMsg ) - 1 ]	= (char) 0;
%    xdr_free ( (xdrproc_t) xdr_fnServerBtreeDeleteByFloat_rets, (char *) pResult );
%    RPC_CLIENT_SERROR ( pResult->nErrorLvl, __procedure__,
%                        szErrorMsg );
%  } else {
%    xdr_free ( (xdrproc_t) xdr_fnServerBtreeDeleteByFloat_rets, (char *) pResult );
%  }
%
%  return Result.ReturnValue;
%
%} /* fnServerBtreeDeleteByFloat */
#endif	/* RPC_CLNT */
%
  fnServerBtreeDeleteByDouble_rets fnRpc_fnServerBtreeDeleteByDouble ( fnServerBtreeDeleteByDouble_args ) =  82 ;
%
#if RPC_SVC
%
%extern BTREERESULT fnServerBtreeDeleteByDouble
%	(SHORTOBJID oShortObjIdHeap ,
%	  SHORTOBJID oShortObjIdBTree ,
%	  double fKey);
%
%#ifdef MULTITHREAD
%bool_t
%#else
%fnServerBtreeDeleteByDouble_rets *
%#endif
%	PASTE2(fnrpc_fnserverbtreedeletebydouble_1,_SVCSUFFIX)
%		( fnServerBtreeDeleteByDouble_args * pArguments,
%#ifdef MULTITHREAD
%		  fnServerBtreeDeleteByDouble_rets * pResult,
%#endif
%		  struct svc_req * pRequest )
%{
%  static const char	__procedure__[]	= "server:fnrpc_fnserverbtreedeletebydouble_1";
%#ifdef MULTITHREAD
%  typedef bool_t RESULTTYPE;
%#else
%  typedef fnServerBtreeDeleteByDouble_rets * RESULTTYPE;
%#endif
%#ifndef MULTITHREAD
%  static fnServerBtreeDeleteByDouble_rets	Result;
%  RESULTTYPE			pResult = &Result;
%#endif
%  LPCSTR	pszErrorMsg;
%
%  __pRequest__	= pRequest;
%
%  RPC_SERVER_ENTRY();
%
%#ifndef MULTITHREAD
%  if ( pResult->pszErrorMsg == szEmpty ) {
%    pResult->pszErrorMsg	= NULL;
%  }
%  xdr_free ( (xdrproc_t) xdr_fnServerBtreeDeleteByDouble_rets, (char *) pResult );
%#endif
%  pResult->nErrorLvl		= 0;
%
%  Reply.bAnswered		= FALSE;
%  Reply.pfnCalled		= (void(*)()) fnServerBtreeDeleteByDouble;
%  Reply.pfnXdrResult		= (bool_t(*)()) xdr_fnServerBtreeDeleteByDouble_rets;
%  Reply.pnErrorLvl		= &pResult->nErrorLvl;
%  Reply.ppszErrorMsg		= (LPCSTR *) &pResult->pszErrorMsg;
%  Reply.pResult		= pResult;
%  Reply.pReturnValue		= &pResult->ReturnValue;
%  Reply.nReturnValueSize	= sizeof ( pResult->ReturnValue );
%
%  pResult->ReturnValue		=
%  fnServerBtreeDeleteByDouble (
%	pArguments->oShortObjIdHeap,
%	pArguments->oShortObjIdBTree,
%	pArguments->fKey );
%
%  if ( Reply.bAnswered ) {
%    __pRequest__	= NULL;
%    return (RESULTTYPE) NULL;
%  }
%
%  pResult->nErrorLvl	= RPC_SERVER_ERRLVL();
%  if ( pResult->nErrorLvl > 0 ) {
%    pszErrorMsg		= RPC_SERVER_ERRMSG();
%    if ( pszErrorMsg && *pszErrorMsg ) {
%      pResult->pszErrorMsg	= strdup ( pszErrorMsg );
%    }
%  }
%  if ( pResult->pszErrorMsg == NULL ) {
%#ifdef MULTITHREAD
%    pResult->pszErrorMsg	= strdup ( szEmpty );
%#else
%    pResult->pszErrorMsg	= (LPSTR) szEmpty;
%#endif
%  }
%  __pRequest__	= NULL;
%  return (RESULTTYPE) pResult;
%} /* fnrpc_fnserverbtreedeletebydouble_1 */
#endif	/* RPC_SVC */
%
#if RPC_CLNT
%BTREERESULT DLLEXPORT fnServerBtreeDeleteByDouble
%	(SHORTOBJID oShortObjIdHeap ,
%	  SHORTOBJID oShortObjIdBTree ,
%	  double fKey)
%{
%  static const char	__procedure__[]	= "client:fnServerBtreeDeleteByDouble";
%  static fnServerBtreeDeleteByDouble_rets	ZeroResult;
%  fnServerBtreeDeleteByDouble_rets		* pResult = NULL;
%  fnServerBtreeDeleteByDouble_rets		Result = ZeroResult;
%  fnServerBtreeDeleteByDouble_args	InArguments;
%
%  /* Client initialization: */
%  if ( __bClientInitialize__ ) {
%    __bClientInitialize__	= FALSE;
%    RPC_CLIENT_INITIALIZE();
%  }
%
%#if	CLIENT_CREATE_BY_USER
%  if ( __pClient__ == NULL ) {
%    __pClient__	= RPC_CLIENT_CREATE ( __szHost__, __szTransport__ );
%    if ( __pClient__ == NULL ) {
%      /* Error handling for a not connected client: */
%      char	szError [ 256 ];
%      sprintf ( szError, szFormatNoServer, __procedure__ );
%      RPC_CLIENT_ERROR ( szError );
%      return Result.ReturnValue;
%    }
%  }
%#else
%  while ( __pClient__ == NULL ) {
%    __pClient__	= RPC_CLIENT_CREATE ( __szHost__, __szTransport__ );
%    if ( __pClient__ == NULL ) {
%      /* Error handling for a not connected client: */
%      char	szError [ 256 ];
%      sprintf ( szError, szFormatNoServer, __procedure__ );
%      RPC_CLIENT_CERROR ( szContNoServer, szError );
%    }
%  }
%#endif	/* CLIENT_CREATE_BY_USER */
%
%  /* Copy in the oShortObjIdHeap argument: */
%  InArguments.oShortObjIdHeap	= oShortObjIdHeap;
%  /* Copy in the oShortObjIdBTree argument: */
%  InArguments.oShortObjIdBTree	= oShortObjIdBTree;
%  /* Copy in the fKey argument: */
%  InArguments.fKey	= fKey;
%
%  pResult	=
%#ifdef MULTITHREAD
%    (
%#else
%    (fnServerBtreeDeleteByDouble_rets *)
%#endif
%    fnrpc_fnserverbtreedeletebydouble_1 (
%	&InArguments,
%#ifdef MULTITHREAD
%	&Result,
%#endif
%	__pClient__ )
%#ifdef MULTITHREAD
%	== RPC_SUCCESS ) ? &Result : NULL
%#endif
%	;
%
%  if ( pResult == NULL ) {
%    /* Error handling for a failed RPC call, */
%    /* i.e. the server did not respond: */
%    char	szError [ 256 ];
%    sprintf ( szError, szFormatRpcFailed, __procedure__,
%              clnt_sperror ( __pClient__, __szHost__ ) );
%    __pClient__	= RPC_CLIENT_DESTROY ( __pClient__ );
%    RPC_CLIENT_CERROR ( szContRpcFailed, szError );
%    Result	= ZeroResult;
%    return Result.ReturnValue;
%  }
%#ifndef MULTITHREAD
%  Result	= * pResult;
%#endif
%
%
%  if ( pResult && pResult->nErrorLvl ) {
%    /* Server returned a user error message: */
%    char	szErrorMsg [ 1024 ];
%    strncpy ( szErrorMsg,
%              ( pResult->pszErrorMsg && pResult->pszErrorMsg [ 0 ] ) ?
%              (LPCSTR) pResult->pszErrorMsg : (LPCSTR) szEmpty,
%              sizeof ( szErrorMsg ) );
%    szErrorMsg [ sizeof ( szErrorMsg ) - 1 ]	= (char) 0;
%    xdr_free ( (xdrproc_t) xdr_fnServerBtreeDeleteByDouble_rets, (char *) pResult );
%    RPC_CLIENT_SERROR ( pResult->nErrorLvl, __procedure__,
%                        szErrorMsg );
%  } else {
%    xdr_free ( (xdrproc_t) xdr_fnServerBtreeDeleteByDouble_rets, (char *) pResult );
%  }
%
%  return Result.ReturnValue;
%
%} /* fnServerBtreeDeleteByDouble */
#endif	/* RPC_CLNT */
%
  fnServerBtreeDeleteByString_rets fnRpc_fnServerBtreeDeleteByString ( fnServerBtreeDeleteByString_args ) =  83 ;
%
#if RPC_SVC
%
%extern BTREERESULT fnServerBtreeDeleteByString
%	(SHORTOBJID oShortObjIdHeap ,
%	  SHORTOBJID oShortObjIdBTree ,
%	  string_t /* string_t<@conststring@> */ szKey);
%
%#ifdef MULTITHREAD
%bool_t
%#else
%fnServerBtreeDeleteByString_rets *
%#endif
%	PASTE2(fnrpc_fnserverbtreedeletebystring_1,_SVCSUFFIX)
%		( fnServerBtreeDeleteByString_args * pArguments,
%#ifdef MULTITHREAD
%		  fnServerBtreeDeleteByString_rets * pResult,
%#endif
%		  struct svc_req * pRequest )
%{
%  static const char	__procedure__[]	= "server:fnrpc_fnserverbtreedeletebystring_1";
%#ifdef MULTITHREAD
%  typedef bool_t RESULTTYPE;
%#else
%  typedef fnServerBtreeDeleteByString_rets * RESULTTYPE;
%#endif
%#ifndef MULTITHREAD
%  static fnServerBtreeDeleteByString_rets	Result;
%  RESULTTYPE			pResult = &Result;
%#endif
%  LPCSTR	pszErrorMsg;
%
%  __pRequest__	= pRequest;
%
%  RPC_SERVER_ENTRY();
%
%#ifndef MULTITHREAD
%  if ( pResult->pszErrorMsg == szEmpty ) {
%    pResult->pszErrorMsg	= NULL;
%  }
%  xdr_free ( (xdrproc_t) xdr_fnServerBtreeDeleteByString_rets, (char *) pResult );
%#endif
%  pResult->nErrorLvl		= 0;
%
%  Reply.bAnswered		= FALSE;
%  Reply.pfnCalled		= (void(*)()) fnServerBtreeDeleteByString;
%  Reply.pfnXdrResult		= (bool_t(*)()) xdr_fnServerBtreeDeleteByString_rets;
%  Reply.pnErrorLvl		= &pResult->nErrorLvl;
%  Reply.ppszErrorMsg		= (LPCSTR *) &pResult->pszErrorMsg;
%  Reply.pResult		= pResult;
%  Reply.pReturnValue		= &pResult->ReturnValue;
%  Reply.nReturnValueSize	= sizeof ( pResult->ReturnValue );
%
%  pResult->ReturnValue		=
%  fnServerBtreeDeleteByString (
%	pArguments->oShortObjIdHeap,
%	pArguments->oShortObjIdBTree,
%	pArguments->szKey );
%
%  if ( Reply.bAnswered ) {
%    __pRequest__	= NULL;
%    return (RESULTTYPE) NULL;
%  }
%
%  pResult->nErrorLvl	= RPC_SERVER_ERRLVL();
%  if ( pResult->nErrorLvl > 0 ) {
%    pszErrorMsg		= RPC_SERVER_ERRMSG();
%    if ( pszErrorMsg && *pszErrorMsg ) {
%      pResult->pszErrorMsg	= strdup ( pszErrorMsg );
%    }
%  }
%  if ( pResult->pszErrorMsg == NULL ) {
%#ifdef MULTITHREAD
%    pResult->pszErrorMsg	= strdup ( szEmpty );
%#else
%    pResult->pszErrorMsg	= (LPSTR) szEmpty;
%#endif
%  }
%  __pRequest__	= NULL;
%  return (RESULTTYPE) pResult;
%} /* fnrpc_fnserverbtreedeletebystring_1 */
#endif	/* RPC_SVC */
%
#if RPC_CLNT
%BTREERESULT DLLEXPORT fnServerBtreeDeleteByString
%	(SHORTOBJID oShortObjIdHeap ,
%	  SHORTOBJID oShortObjIdBTree ,
%	  string_t /* string_t<@conststring@> */ szKey)
%{
%  static const char	__procedure__[]	= "client:fnServerBtreeDeleteByString";
%  static fnServerBtreeDeleteByString_rets	ZeroResult;
%  fnServerBtreeDeleteByString_rets		* pResult = NULL;
%  fnServerBtreeDeleteByString_rets		Result = ZeroResult;
%  fnServerBtreeDeleteByString_args	InArguments;
%
%  /* Client initialization: */
%  if ( __bClientInitialize__ ) {
%    __bClientInitialize__	= FALSE;
%    RPC_CLIENT_INITIALIZE();
%  }
%
%#if	CLIENT_CREATE_BY_USER
%  if ( __pClient__ == NULL ) {
%    __pClient__	= RPC_CLIENT_CREATE ( __szHost__, __szTransport__ );
%    if ( __pClient__ == NULL ) {
%      /* Error handling for a not connected client: */
%      char	szError [ 256 ];
%      sprintf ( szError, szFormatNoServer, __procedure__ );
%      RPC_CLIENT_ERROR ( szError );
%      return Result.ReturnValue;
%    }
%  }
%#else
%  while ( __pClient__ == NULL ) {
%    __pClient__	= RPC_CLIENT_CREATE ( __szHost__, __szTransport__ );
%    if ( __pClient__ == NULL ) {
%      /* Error handling for a not connected client: */
%      char	szError [ 256 ];
%      sprintf ( szError, szFormatNoServer, __procedure__ );
%      RPC_CLIENT_CERROR ( szContNoServer, szError );
%    }
%  }
%#endif	/* CLIENT_CREATE_BY_USER */
%
%  /* Copy in the oShortObjIdHeap argument: */
%  InArguments.oShortObjIdHeap	= oShortObjIdHeap;
%  /* Copy in the oShortObjIdBTree argument: */
%  InArguments.oShortObjIdBTree	= oShortObjIdBTree;
%  /* Copy in the szKey argument: */
%  InArguments.szKey	= szKey;
%  if ( szKey == NULL ) {
%    /* Error handling for passing a NULL string pointer: */
%    char	szError [ 256 ];
%    InArguments.szKey	= (LPSTR) szEmpty;
%    sprintf ( szError, szFormatNullString,
%              __procedure__, "szKey" );
%    RPC_CLIENT_CERROR ( szContNullString, szError );
%  }
%
%  pResult	=
%#ifdef MULTITHREAD
%    (
%#else
%    (fnServerBtreeDeleteByString_rets *)
%#endif
%    fnrpc_fnserverbtreedeletebystring_1 (
%	&InArguments,
%#ifdef MULTITHREAD
%	&Result,
%#endif
%	__pClient__ )
%#ifdef MULTITHREAD
%	== RPC_SUCCESS ) ? &Result : NULL
%#endif
%	;
%
%  if ( pResult == NULL ) {
%    /* Error handling for a failed RPC call, */
%    /* i.e. the server did not respond: */
%    char	szError [ 256 ];
%    sprintf ( szError, szFormatRpcFailed, __procedure__,
%              clnt_sperror ( __pClient__, __szHost__ ) );
%    __pClient__	= RPC_CLIENT_DESTROY ( __pClient__ );
%    RPC_CLIENT_CERROR ( szContRpcFailed, szError );
%    Result	= ZeroResult;
%    return Result.ReturnValue;
%  }
%#ifndef MULTITHREAD
%  Result	= * pResult;
%#endif
%
%
%  if ( pResult && pResult->nErrorLvl ) {
%    /* Server returned a user error message: */
%    char	szErrorMsg [ 1024 ];
%    strncpy ( szErrorMsg,
%              ( pResult->pszErrorMsg && pResult->pszErrorMsg [ 0 ] ) ?
%              (LPCSTR) pResult->pszErrorMsg : (LPCSTR) szEmpty,
%              sizeof ( szErrorMsg ) );
%    szErrorMsg [ sizeof ( szErrorMsg ) - 1 ]	= (char) 0;
%    xdr_free ( (xdrproc_t) xdr_fnServerBtreeDeleteByString_rets, (char *) pResult );
%    RPC_CLIENT_SERROR ( pResult->nErrorLvl, __procedure__,
%                        szErrorMsg );
%  } else {
%    xdr_free ( (xdrproc_t) xdr_fnServerBtreeDeleteByString_rets, (char *) pResult );
%  }
%
%  return Result.ReturnValue;
%
%} /* fnServerBtreeDeleteByString */
#endif	/* RPC_CLNT */
%
  fnServerBtreeInsert_rets fnRpc_fnServerBtreeInsert ( fnServerBtreeInsert_args ) =  84 ;
%
#if RPC_SVC
%
%extern BTREERESULT fnServerBtreeInsert
%	(SHORTOBJID oShortObjIdHeap ,
%	  SHORTOBJID oShortObjIdBTree ,
%	  int nValueKey ,
%	  SHTYPETAG nTypeTagKey ,
%	  int nValueData ,
%	  SHTYPETAG nTypeTagData);
%
%#ifdef MULTITHREAD
%bool_t
%#else
%fnServerBtreeInsert_rets *
%#endif
%	PASTE2(fnrpc_fnserverbtreeinsert_1,_SVCSUFFIX)
%		( fnServerBtreeInsert_args * pArguments,
%#ifdef MULTITHREAD
%		  fnServerBtreeInsert_rets * pResult,
%#endif
%		  struct svc_req * pRequest )
%{
%  static const char	__procedure__[]	= "server:fnrpc_fnserverbtreeinsert_1";
%#ifdef MULTITHREAD
%  typedef bool_t RESULTTYPE;
%#else
%  typedef fnServerBtreeInsert_rets * RESULTTYPE;
%#endif
%#ifndef MULTITHREAD
%  static fnServerBtreeInsert_rets	Result;
%  RESULTTYPE			pResult = &Result;
%#endif
%  LPCSTR	pszErrorMsg;
%
%  __pRequest__	= pRequest;
%
%  RPC_SERVER_ENTRY();
%
%#ifndef MULTITHREAD
%  if ( pResult->pszErrorMsg == szEmpty ) {
%    pResult->pszErrorMsg	= NULL;
%  }
%  xdr_free ( (xdrproc_t) xdr_fnServerBtreeInsert_rets, (char *) pResult );
%#endif
%  pResult->nErrorLvl		= 0;
%
%  Reply.bAnswered		= FALSE;
%  Reply.pfnCalled		= (void(*)()) fnServerBtreeInsert;
%  Reply.pfnXdrResult		= (bool_t(*)()) xdr_fnServerBtreeInsert_rets;
%  Reply.pnErrorLvl		= &pResult->nErrorLvl;
%  Reply.ppszErrorMsg		= (LPCSTR *) &pResult->pszErrorMsg;
%  Reply.pResult		= pResult;
%  Reply.pReturnValue		= &pResult->ReturnValue;
%  Reply.nReturnValueSize	= sizeof ( pResult->ReturnValue );
%
%  pResult->ReturnValue		=
%  fnServerBtreeInsert (
%	pArguments->oShortObjIdHeap,
%	pArguments->oShortObjIdBTree,
%	pArguments->nValueKey,
%	pArguments->nTypeTagKey,
%	pArguments->nValueData,
%	pArguments->nTypeTagData );
%
%  if ( Reply.bAnswered ) {
%    __pRequest__	= NULL;
%    return (RESULTTYPE) NULL;
%  }
%
%  pResult->nErrorLvl	= RPC_SERVER_ERRLVL();
%  if ( pResult->nErrorLvl > 0 ) {
%    pszErrorMsg		= RPC_SERVER_ERRMSG();
%    if ( pszErrorMsg && *pszErrorMsg ) {
%      pResult->pszErrorMsg	= strdup ( pszErrorMsg );
%    }
%  }
%  if ( pResult->pszErrorMsg == NULL ) {
%#ifdef MULTITHREAD
%    pResult->pszErrorMsg	= strdup ( szEmpty );
%#else
%    pResult->pszErrorMsg	= (LPSTR) szEmpty;
%#endif
%  }
%  __pRequest__	= NULL;
%  return (RESULTTYPE) pResult;
%} /* fnrpc_fnserverbtreeinsert_1 */
#endif	/* RPC_SVC */
%
#if RPC_CLNT
%BTREERESULT DLLEXPORT fnServerBtreeInsert
%	(SHORTOBJID oShortObjIdHeap ,
%	  SHORTOBJID oShortObjIdBTree ,
%	  int nValueKey ,
%	  SHTYPETAG nTypeTagKey ,
%	  int nValueData ,
%	  SHTYPETAG nTypeTagData)
%{
%  static const char	__procedure__[]	= "client:fnServerBtreeInsert";
%  static fnServerBtreeInsert_rets	ZeroResult;
%  fnServerBtreeInsert_rets		* pResult = NULL;
%  fnServerBtreeInsert_rets		Result = ZeroResult;
%  fnServerBtreeInsert_args	InArguments;
%
%  /* Client initialization: */
%  if ( __bClientInitialize__ ) {
%    __bClientInitialize__	= FALSE;
%    RPC_CLIENT_INITIALIZE();
%  }
%
%#if	CLIENT_CREATE_BY_USER
%  if ( __pClient__ == NULL ) {
%    __pClient__	= RPC_CLIENT_CREATE ( __szHost__, __szTransport__ );
%    if ( __pClient__ == NULL ) {
%      /* Error handling for a not connected client: */
%      char	szError [ 256 ];
%      sprintf ( szError, szFormatNoServer, __procedure__ );
%      RPC_CLIENT_ERROR ( szError );
%      return Result.ReturnValue;
%    }
%  }
%#else
%  while ( __pClient__ == NULL ) {
%    __pClient__	= RPC_CLIENT_CREATE ( __szHost__, __szTransport__ );
%    if ( __pClient__ == NULL ) {
%      /* Error handling for a not connected client: */
%      char	szError [ 256 ];
%      sprintf ( szError, szFormatNoServer, __procedure__ );
%      RPC_CLIENT_CERROR ( szContNoServer, szError );
%    }
%  }
%#endif	/* CLIENT_CREATE_BY_USER */
%
%  /* Copy in the oShortObjIdHeap argument: */
%  InArguments.oShortObjIdHeap	= oShortObjIdHeap;
%  /* Copy in the oShortObjIdBTree argument: */
%  InArguments.oShortObjIdBTree	= oShortObjIdBTree;
%  /* Copy in the nValueKey argument: */
%  InArguments.nValueKey	= nValueKey;
%  /* Copy in the nTypeTagKey argument: */
%  InArguments.nTypeTagKey	= nTypeTagKey;
%  /* Copy in the nValueData argument: */
%  InArguments.nValueData	= nValueData;
%  /* Copy in the nTypeTagData argument: */
%  InArguments.nTypeTagData	= nTypeTagData;
%
%  pResult	=
%#ifdef MULTITHREAD
%    (
%#else
%    (fnServerBtreeInsert_rets *)
%#endif
%    fnrpc_fnserverbtreeinsert_1 (
%	&InArguments,
%#ifdef MULTITHREAD
%	&Result,
%#endif
%	__pClient__ )
%#ifdef MULTITHREAD
%	== RPC_SUCCESS ) ? &Result : NULL
%#endif
%	;
%
%  if ( pResult == NULL ) {
%    /* Error handling for a failed RPC call, */
%    /* i.e. the server did not respond: */
%    char	szError [ 256 ];
%    sprintf ( szError, szFormatRpcFailed, __procedure__,
%              clnt_sperror ( __pClient__, __szHost__ ) );
%    __pClient__	= RPC_CLIENT_DESTROY ( __pClient__ );
%    RPC_CLIENT_CERROR ( szContRpcFailed, szError );
%    Result	= ZeroResult;
%    return Result.ReturnValue;
%  }
%#ifndef MULTITHREAD
%  Result	= * pResult;
%#endif
%
%
%  if ( pResult && pResult->nErrorLvl ) {
%    /* Server returned a user error message: */
%    char	szErrorMsg [ 1024 ];
%    strncpy ( szErrorMsg,
%              ( pResult->pszErrorMsg && pResult->pszErrorMsg [ 0 ] ) ?
%              (LPCSTR) pResult->pszErrorMsg : (LPCSTR) szEmpty,
%              sizeof ( szErrorMsg ) );
%    szErrorMsg [ sizeof ( szErrorMsg ) - 1 ]	= (char) 0;
%    xdr_free ( (xdrproc_t) xdr_fnServerBtreeInsert_rets, (char *) pResult );
%    RPC_CLIENT_SERROR ( pResult->nErrorLvl, __procedure__,
%                        szErrorMsg );
%  } else {
%    xdr_free ( (xdrproc_t) xdr_fnServerBtreeInsert_rets, (char *) pResult );
%  }
%
%  return Result.ReturnValue;
%
%} /* fnServerBtreeInsert */
#endif	/* RPC_CLNT */
%
  fnServerBtreeInsertByFloat_rets fnRpc_fnServerBtreeInsertByFloat ( fnServerBtreeInsertByFloat_args ) =  85 ;
%
#if RPC_SVC
%
%extern BTREERESULT fnServerBtreeInsertByFloat
%	(SHORTOBJID oShortObjIdHeap ,
%	  SHORTOBJID oShortObjIdBTree ,
%	  float fKey ,
%	  int nValueData ,
%	  SHTYPETAG nTypeTagData);
%
%#ifdef MULTITHREAD
%bool_t
%#else
%fnServerBtreeInsertByFloat_rets *
%#endif
%	PASTE2(fnrpc_fnserverbtreeinsertbyfloat_1,_SVCSUFFIX)
%		( fnServerBtreeInsertByFloat_args * pArguments,
%#ifdef MULTITHREAD
%		  fnServerBtreeInsertByFloat_rets * pResult,
%#endif
%		  struct svc_req * pRequest )
%{
%  static const char	__procedure__[]	= "server:fnrpc_fnserverbtreeinsertbyfloat_1";
%#ifdef MULTITHREAD
%  typedef bool_t RESULTTYPE;
%#else
%  typedef fnServerBtreeInsertByFloat_rets * RESULTTYPE;
%#endif
%#ifndef MULTITHREAD
%  static fnServerBtreeInsertByFloat_rets	Result;
%  RESULTTYPE			pResult = &Result;
%#endif
%  LPCSTR	pszErrorMsg;
%
%  __pRequest__	= pRequest;
%
%  RPC_SERVER_ENTRY();
%
%#ifndef MULTITHREAD
%  if ( pResult->pszErrorMsg == szEmpty ) {
%    pResult->pszErrorMsg	= NULL;
%  }
%  xdr_free ( (xdrproc_t) xdr_fnServerBtreeInsertByFloat_rets, (char *) pResult );
%#endif
%  pResult->nErrorLvl		= 0;
%
%  Reply.bAnswered		= FALSE;
%  Reply.pfnCalled		= (void(*)()) fnServerBtreeInsertByFloat;
%  Reply.pfnXdrResult		= (bool_t(*)()) xdr_fnServerBtreeInsertByFloat_rets;
%  Reply.pnErrorLvl		= &pResult->nErrorLvl;
%  Reply.ppszErrorMsg		= (LPCSTR *) &pResult->pszErrorMsg;
%  Reply.pResult		= pResult;
%  Reply.pReturnValue		= &pResult->ReturnValue;
%  Reply.nReturnValueSize	= sizeof ( pResult->ReturnValue );
%
%  pResult->ReturnValue		=
%  fnServerBtreeInsertByFloat (
%	pArguments->oShortObjIdHeap,
%	pArguments->oShortObjIdBTree,
%	pArguments->fKey,
%	pArguments->nValueData,
%	pArguments->nTypeTagData );
%
%  if ( Reply.bAnswered ) {
%    __pRequest__	= NULL;
%    return (RESULTTYPE) NULL;
%  }
%
%  pResult->nErrorLvl	= RPC_SERVER_ERRLVL();
%  if ( pResult->nErrorLvl > 0 ) {
%    pszErrorMsg		= RPC_SERVER_ERRMSG();
%    if ( pszErrorMsg && *pszErrorMsg ) {
%      pResult->pszErrorMsg	= strdup ( pszErrorMsg );
%    }
%  }
%  if ( pResult->pszErrorMsg == NULL ) {
%#ifdef MULTITHREAD
%    pResult->pszErrorMsg	= strdup ( szEmpty );
%#else
%    pResult->pszErrorMsg	= (LPSTR) szEmpty;
%#endif
%  }
%  __pRequest__	= NULL;
%  return (RESULTTYPE) pResult;
%} /* fnrpc_fnserverbtreeinsertbyfloat_1 */
#endif	/* RPC_SVC */
%
#if RPC_CLNT
%BTREERESULT DLLEXPORT fnServerBtreeInsertByFloat
%	(SHORTOBJID oShortObjIdHeap ,
%	  SHORTOBJID oShortObjIdBTree ,
%	  float fKey ,
%	  int nValueData ,
%	  SHTYPETAG nTypeTagData)
%{
%  static const char	__procedure__[]	= "client:fnServerBtreeInsertByFloat";
%  static fnServerBtreeInsertByFloat_rets	ZeroResult;
%  fnServerBtreeInsertByFloat_rets		* pResult = NULL;
%  fnServerBtreeInsertByFloat_rets		Result = ZeroResult;
%  fnServerBtreeInsertByFloat_args	InArguments;
%
%  /* Client initialization: */
%  if ( __bClientInitialize__ ) {
%    __bClientInitialize__	= FALSE;
%    RPC_CLIENT_INITIALIZE();
%  }
%
%#if	CLIENT_CREATE_BY_USER
%  if ( __pClient__ == NULL ) {
%    __pClient__	= RPC_CLIENT_CREATE ( __szHost__, __szTransport__ );
%    if ( __pClient__ == NULL ) {
%      /* Error handling for a not connected client: */
%      char	szError [ 256 ];
%      sprintf ( szError, szFormatNoServer, __procedure__ );
%      RPC_CLIENT_ERROR ( szError );
%      return Result.ReturnValue;
%    }
%  }
%#else
%  while ( __pClient__ == NULL ) {
%    __pClient__	= RPC_CLIENT_CREATE ( __szHost__, __szTransport__ );
%    if ( __pClient__ == NULL ) {
%      /* Error handling for a not connected client: */
%      char	szError [ 256 ];
%      sprintf ( szError, szFormatNoServer, __procedure__ );
%      RPC_CLIENT_CERROR ( szContNoServer, szError );
%    }
%  }
%#endif	/* CLIENT_CREATE_BY_USER */
%
%  /* Copy in the oShortObjIdHeap argument: */
%  InArguments.oShortObjIdHeap	= oShortObjIdHeap;
%  /* Copy in the oShortObjIdBTree argument: */
%  InArguments.oShortObjIdBTree	= oShortObjIdBTree;
%  /* Copy in the fKey argument: */
%  InArguments.fKey	= fKey;
%  /* Copy in the nValueData argument: */
%  InArguments.nValueData	= nValueData;
%  /* Copy in the nTypeTagData argument: */
%  InArguments.nTypeTagData	= nTypeTagData;
%
%  pResult	=
%#ifdef MULTITHREAD
%    (
%#else
%    (fnServerBtreeInsertByFloat_rets *)
%#endif
%    fnrpc_fnserverbtreeinsertbyfloat_1 (
%	&InArguments,
%#ifdef MULTITHREAD
%	&Result,
%#endif
%	__pClient__ )
%#ifdef MULTITHREAD
%	== RPC_SUCCESS ) ? &Result : NULL
%#endif
%	;
%
%  if ( pResult == NULL ) {
%    /* Error handling for a failed RPC call, */
%    /* i.e. the server did not respond: */
%    char	szError [ 256 ];
%    sprintf ( szError, szFormatRpcFailed, __procedure__,
%              clnt_sperror ( __pClient__, __szHost__ ) );
%    __pClient__	= RPC_CLIENT_DESTROY ( __pClient__ );
%    RPC_CLIENT_CERROR ( szContRpcFailed, szError );
%    Result	= ZeroResult;
%    return Result.ReturnValue;
%  }
%#ifndef MULTITHREAD
%  Result	= * pResult;
%#endif
%
%
%  if ( pResult && pResult->nErrorLvl ) {
%    /* Server returned a user error message: */
%    char	szErrorMsg [ 1024 ];
%    strncpy ( szErrorMsg,
%              ( pResult->pszErrorMsg && pResult->pszErrorMsg [ 0 ] ) ?
%              (LPCSTR) pResult->pszErrorMsg : (LPCSTR) szEmpty,
%              sizeof ( szErrorMsg ) );
%    szErrorMsg [ sizeof ( szErrorMsg ) - 1 ]	= (char) 0;
%    xdr_free ( (xdrproc_t) xdr_fnServerBtreeInsertByFloat_rets, (char *) pResult );
%    RPC_CLIENT_SERROR ( pResult->nErrorLvl, __procedure__,
%                        szErrorMsg );
%  } else {
%    xdr_free ( (xdrproc_t) xdr_fnServerBtreeInsertByFloat_rets, (char *) pResult );
%  }
%
%  return Result.ReturnValue;
%
%} /* fnServerBtreeInsertByFloat */
#endif	/* RPC_CLNT */
%
  fnServerBtreeInsertByDouble_rets fnRpc_fnServerBtreeInsertByDouble ( fnServerBtreeInsertByDouble_args ) =  86 ;
%
#if RPC_SVC
%
%extern BTREERESULT fnServerBtreeInsertByDouble
%	(SHORTOBJID oShortObjIdHeap ,
%	  SHORTOBJID oShortObjIdBTree ,
%	  double fKey ,
%	  int nValueData ,
%	  SHTYPETAG nTypeTagData);
%
%#ifdef MULTITHREAD
%bool_t
%#else
%fnServerBtreeInsertByDouble_rets *
%#endif
%	PASTE2(fnrpc_fnserverbtreeinsertbydouble_1,_SVCSUFFIX)
%		( fnServerBtreeInsertByDouble_args * pArguments,
%#ifdef MULTITHREAD
%		  fnServerBtreeInsertByDouble_rets * pResult,
%#endif
%		  struct svc_req * pRequest )
%{
%  static const char	__procedure__[]	= "server:fnrpc_fnserverbtreeinsertbydouble_1";
%#ifdef MULTITHREAD
%  typedef bool_t RESULTTYPE;
%#else
%  typedef fnServerBtreeInsertByDouble_rets * RESULTTYPE;
%#endif
%#ifndef MULTITHREAD
%  static fnServerBtreeInsertByDouble_rets	Result;
%  RESULTTYPE			pResult = &Result;
%#endif
%  LPCSTR	pszErrorMsg;
%
%  __pRequest__	= pRequest;
%
%  RPC_SERVER_ENTRY();
%
%#ifndef MULTITHREAD
%  if ( pResult->pszErrorMsg == szEmpty ) {
%    pResult->pszErrorMsg	= NULL;
%  }
%  xdr_free ( (xdrproc_t) xdr_fnServerBtreeInsertByDouble_rets, (char *) pResult );
%#endif
%  pResult->nErrorLvl		= 0;
%
%  Reply.bAnswered		= FALSE;
%  Reply.pfnCalled		= (void(*)()) fnServerBtreeInsertByDouble;
%  Reply.pfnXdrResult		= (bool_t(*)()) xdr_fnServerBtreeInsertByDouble_rets;
%  Reply.pnErrorLvl		= &pResult->nErrorLvl;
%  Reply.ppszErrorMsg		= (LPCSTR *) &pResult->pszErrorMsg;
%  Reply.pResult		= pResult;
%  Reply.pReturnValue		= &pResult->ReturnValue;
%  Reply.nReturnValueSize	= sizeof ( pResult->ReturnValue );
%
%  pResult->ReturnValue		=
%  fnServerBtreeInsertByDouble (
%	pArguments->oShortObjIdHeap,
%	pArguments->oShortObjIdBTree,
%	pArguments->fKey,
%	pArguments->nValueData,
%	pArguments->nTypeTagData );
%
%  if ( Reply.bAnswered ) {
%    __pRequest__	= NULL;
%    return (RESULTTYPE) NULL;
%  }
%
%  pResult->nErrorLvl	= RPC_SERVER_ERRLVL();
%  if ( pResult->nErrorLvl > 0 ) {
%    pszErrorMsg		= RPC_SERVER_ERRMSG();
%    if ( pszErrorMsg && *pszErrorMsg ) {
%      pResult->pszErrorMsg	= strdup ( pszErrorMsg );
%    }
%  }
%  if ( pResult->pszErrorMsg == NULL ) {
%#ifdef MULTITHREAD
%    pResult->pszErrorMsg	= strdup ( szEmpty );
%#else
%    pResult->pszErrorMsg	= (LPSTR) szEmpty;
%#endif
%  }
%  __pRequest__	= NULL;
%  return (RESULTTYPE) pResult;
%} /* fnrpc_fnserverbtreeinsertbydouble_1 */
#endif	/* RPC_SVC */
%
#if RPC_CLNT
%BTREERESULT DLLEXPORT fnServerBtreeInsertByDouble
%	(SHORTOBJID oShortObjIdHeap ,
%	  SHORTOBJID oShortObjIdBTree ,
%	  double fKey ,
%	  int nValueData ,
%	  SHTYPETAG nTypeTagData)
%{
%  static const char	__procedure__[]	= "client:fnServerBtreeInsertByDouble";
%  static fnServerBtreeInsertByDouble_rets	ZeroResult;
%  fnServerBtreeInsertByDouble_rets		* pResult = NULL;
%  fnServerBtreeInsertByDouble_rets		Result = ZeroResult;
%  fnServerBtreeInsertByDouble_args	InArguments;
%
%  /* Client initialization: */
%  if ( __bClientInitialize__ ) {
%    __bClientInitialize__	= FALSE;
%    RPC_CLIENT_INITIALIZE();
%  }
%
%#if	CLIENT_CREATE_BY_USER
%  if ( __pClient__ == NULL ) {
%    __pClient__	= RPC_CLIENT_CREATE ( __szHost__, __szTransport__ );
%    if ( __pClient__ == NULL ) {
%      /* Error handling for a not connected client: */
%      char	szError [ 256 ];
%      sprintf ( szError, szFormatNoServer, __procedure__ );
%      RPC_CLIENT_ERROR ( szError );
%      return Result.ReturnValue;
%    }
%  }
%#else
%  while ( __pClient__ == NULL ) {
%    __pClient__	= RPC_CLIENT_CREATE ( __szHost__, __szTransport__ );
%    if ( __pClient__ == NULL ) {
%      /* Error handling for a not connected client: */
%      char	szError [ 256 ];
%      sprintf ( szError, szFormatNoServer, __procedure__ );
%      RPC_CLIENT_CERROR ( szContNoServer, szError );
%    }
%  }
%#endif	/* CLIENT_CREATE_BY_USER */
%
%  /* Copy in the oShortObjIdHeap argument: */
%  InArguments.oShortObjIdHeap	= oShortObjIdHeap;
%  /* Copy in the oShortObjIdBTree argument: */
%  InArguments.oShortObjIdBTree	= oShortObjIdBTree;
%  /* Copy in the fKey argument: */
%  InArguments.fKey	= fKey;
%  /* Copy in the nValueData argument: */
%  InArguments.nValueData	= nValueData;
%  /* Copy in the nTypeTagData argument: */
%  InArguments.nTypeTagData	= nTypeTagData;
%
%  pResult	=
%#ifdef MULTITHREAD
%    (
%#else
%    (fnServerBtreeInsertByDouble_rets *)
%#endif
%    fnrpc_fnserverbtreeinsertbydouble_1 (
%	&InArguments,
%#ifdef MULTITHREAD
%	&Result,
%#endif
%	__pClient__ )
%#ifdef MULTITHREAD
%	== RPC_SUCCESS ) ? &Result : NULL
%#endif
%	;
%
%  if ( pResult == NULL ) {
%    /* Error handling for a failed RPC call, */
%    /* i.e. the server did not respond: */
%    char	szError [ 256 ];
%    sprintf ( szError, szFormatRpcFailed, __procedure__,
%              clnt_sperror ( __pClient__, __szHost__ ) );
%    __pClient__	= RPC_CLIENT_DESTROY ( __pClient__ );
%    RPC_CLIENT_CERROR ( szContRpcFailed, szError );
%    Result	= ZeroResult;
%    return Result.ReturnValue;
%  }
%#ifndef MULTITHREAD
%  Result	= * pResult;
%#endif
%
%
%  if ( pResult && pResult->nErrorLvl ) {
%    /* Server returned a user error message: */
%    char	szErrorMsg [ 1024 ];
%    strncpy ( szErrorMsg,
%              ( pResult->pszErrorMsg && pResult->pszErrorMsg [ 0 ] ) ?
%              (LPCSTR) pResult->pszErrorMsg : (LPCSTR) szEmpty,
%              sizeof ( szErrorMsg ) );
%    szErrorMsg [ sizeof ( szErrorMsg ) - 1 ]	= (char) 0;
%    xdr_free ( (xdrproc_t) xdr_fnServerBtreeInsertByDouble_rets, (char *) pResult );
%    RPC_CLIENT_SERROR ( pResult->nErrorLvl, __procedure__,
%                        szErrorMsg );
%  } else {
%    xdr_free ( (xdrproc_t) xdr_fnServerBtreeInsertByDouble_rets, (char *) pResult );
%  }
%
%  return Result.ReturnValue;
%
%} /* fnServerBtreeInsertByDouble */
#endif	/* RPC_CLNT */
%
  fnServerBtreeInsertByString_rets fnRpc_fnServerBtreeInsertByString ( fnServerBtreeInsertByString_args ) =  87 ;
%
#if RPC_SVC
%
%extern BTREERESULT fnServerBtreeInsertByString
%	(SHORTOBJID oShortObjIdHeap ,
%	  SHORTOBJID oShortObjIdBTree ,
%	  string_t /* string_t<@conststring@> */ szKey ,
%	  int nValueData ,
%	  SHTYPETAG nTypeTagData);
%
%#ifdef MULTITHREAD
%bool_t
%#else
%fnServerBtreeInsertByString_rets *
%#endif
%	PASTE2(fnrpc_fnserverbtreeinsertbystring_1,_SVCSUFFIX)
%		( fnServerBtreeInsertByString_args * pArguments,
%#ifdef MULTITHREAD
%		  fnServerBtreeInsertByString_rets * pResult,
%#endif
%		  struct svc_req * pRequest )
%{
%  static const char	__procedure__[]	= "server:fnrpc_fnserverbtreeinsertbystring_1";
%#ifdef MULTITHREAD
%  typedef bool_t RESULTTYPE;
%#else
%  typedef fnServerBtreeInsertByString_rets * RESULTTYPE;
%#endif
%#ifndef MULTITHREAD
%  static fnServerBtreeInsertByString_rets	Result;
%  RESULTTYPE			pResult = &Result;
%#endif
%  LPCSTR	pszErrorMsg;
%
%  __pRequest__	= pRequest;
%
%  RPC_SERVER_ENTRY();
%
%#ifndef MULTITHREAD
%  if ( pResult->pszErrorMsg == szEmpty ) {
%    pResult->pszErrorMsg	= NULL;
%  }
%  xdr_free ( (xdrproc_t) xdr_fnServerBtreeInsertByString_rets, (char *) pResult );
%#endif
%  pResult->nErrorLvl		= 0;
%
%  Reply.bAnswered		= FALSE;
%  Reply.pfnCalled		= (void(*)()) fnServerBtreeInsertByString;
%  Reply.pfnXdrResult		= (bool_t(*)()) xdr_fnServerBtreeInsertByString_rets;
%  Reply.pnErrorLvl		= &pResult->nErrorLvl;
%  Reply.ppszErrorMsg		= (LPCSTR *) &pResult->pszErrorMsg;
%  Reply.pResult		= pResult;
%  Reply.pReturnValue		= &pResult->ReturnValue;
%  Reply.nReturnValueSize	= sizeof ( pResult->ReturnValue );
%
%  pResult->ReturnValue		=
%  fnServerBtreeInsertByString (
%	pArguments->oShortObjIdHeap,
%	pArguments->oShortObjIdBTree,
%	pArguments->szKey,
%	pArguments->nValueData,
%	pArguments->nTypeTagData );
%
%  if ( Reply.bAnswered ) {
%    __pRequest__	= NULL;
%    return (RESULTTYPE) NULL;
%  }
%
%  pResult->nErrorLvl	= RPC_SERVER_ERRLVL();
%  if ( pResult->nErrorLvl > 0 ) {
%    pszErrorMsg		= RPC_SERVER_ERRMSG();
%    if ( pszErrorMsg && *pszErrorMsg ) {
%      pResult->pszErrorMsg	= strdup ( pszErrorMsg );
%    }
%  }
%  if ( pResult->pszErrorMsg == NULL ) {
%#ifdef MULTITHREAD
%    pResult->pszErrorMsg	= strdup ( szEmpty );
%#else
%    pResult->pszErrorMsg	= (LPSTR) szEmpty;
%#endif
%  }
%  __pRequest__	= NULL;
%  return (RESULTTYPE) pResult;
%} /* fnrpc_fnserverbtreeinsertbystring_1 */
#endif	/* RPC_SVC */
%
#if RPC_CLNT
%BTREERESULT DLLEXPORT fnServerBtreeInsertByString
%	(SHORTOBJID oShortObjIdHeap ,
%	  SHORTOBJID oShortObjIdBTree ,
%	  string_t /* string_t<@conststring@> */ szKey ,
%	  int nValueData ,
%	  SHTYPETAG nTypeTagData)
%{
%  static const char	__procedure__[]	= "client:fnServerBtreeInsertByString";
%  static fnServerBtreeInsertByString_rets	ZeroResult;
%  fnServerBtreeInsertByString_rets		* pResult = NULL;
%  fnServerBtreeInsertByString_rets		Result = ZeroResult;
%  fnServerBtreeInsertByString_args	InArguments;
%
%  /* Client initialization: */
%  if ( __bClientInitialize__ ) {
%    __bClientInitialize__	= FALSE;
%    RPC_CLIENT_INITIALIZE();
%  }
%
%#if	CLIENT_CREATE_BY_USER
%  if ( __pClient__ == NULL ) {
%    __pClient__	= RPC_CLIENT_CREATE ( __szHost__, __szTransport__ );
%    if ( __pClient__ == NULL ) {
%      /* Error handling for a not connected client: */
%      char	szError [ 256 ];
%      sprintf ( szError, szFormatNoServer, __procedure__ );
%      RPC_CLIENT_ERROR ( szError );
%      return Result.ReturnValue;
%    }
%  }
%#else
%  while ( __pClient__ == NULL ) {
%    __pClient__	= RPC_CLIENT_CREATE ( __szHost__, __szTransport__ );
%    if ( __pClient__ == NULL ) {
%      /* Error handling for a not connected client: */
%      char	szError [ 256 ];
%      sprintf ( szError, szFormatNoServer, __procedure__ );
%      RPC_CLIENT_CERROR ( szContNoServer, szError );
%    }
%  }
%#endif	/* CLIENT_CREATE_BY_USER */
%
%  /* Copy in the oShortObjIdHeap argument: */
%  InArguments.oShortObjIdHeap	= oShortObjIdHeap;
%  /* Copy in the oShortObjIdBTree argument: */
%  InArguments.oShortObjIdBTree	= oShortObjIdBTree;
%  /* Copy in the szKey argument: */
%  InArguments.szKey	= szKey;
%  if ( szKey == NULL ) {
%    /* Error handling for passing a NULL string pointer: */
%    char	szError [ 256 ];
%    InArguments.szKey	= (LPSTR) szEmpty;
%    sprintf ( szError, szFormatNullString,
%              __procedure__, "szKey" );
%    RPC_CLIENT_CERROR ( szContNullString, szError );
%  }
%  /* Copy in the nValueData argument: */
%  InArguments.nValueData	= nValueData;
%  /* Copy in the nTypeTagData argument: */
%  InArguments.nTypeTagData	= nTypeTagData;
%
%  pResult	=
%#ifdef MULTITHREAD
%    (
%#else
%    (fnServerBtreeInsertByString_rets *)
%#endif
%    fnrpc_fnserverbtreeinsertbystring_1 (
%	&InArguments,
%#ifdef MULTITHREAD
%	&Result,
%#endif
%	__pClient__ )
%#ifdef MULTITHREAD
%	== RPC_SUCCESS ) ? &Result : NULL
%#endif
%	;
%
%  if ( pResult == NULL ) {
%    /* Error handling for a failed RPC call, */
%    /* i.e. the server did not respond: */
%    char	szError [ 256 ];
%    sprintf ( szError, szFormatRpcFailed, __procedure__,
%              clnt_sperror ( __pClient__, __szHost__ ) );
%    __pClient__	= RPC_CLIENT_DESTROY ( __pClient__ );
%    RPC_CLIENT_CERROR ( szContRpcFailed, szError );
%    Result	= ZeroResult;
%    return Result.ReturnValue;
%  }
%#ifndef MULTITHREAD
%  Result	= * pResult;
%#endif
%
%
%  if ( pResult && pResult->nErrorLvl ) {
%    /* Server returned a user error message: */
%    char	szErrorMsg [ 1024 ];
%    strncpy ( szErrorMsg,
%              ( pResult->pszErrorMsg && pResult->pszErrorMsg [ 0 ] ) ?
%              (LPCSTR) pResult->pszErrorMsg : (LPCSTR) szEmpty,
%              sizeof ( szErrorMsg ) );
%    szErrorMsg [ sizeof ( szErrorMsg ) - 1 ]	= (char) 0;
%    xdr_free ( (xdrproc_t) xdr_fnServerBtreeInsertByString_rets, (char *) pResult );
%    RPC_CLIENT_SERROR ( pResult->nErrorLvl, __procedure__,
%                        szErrorMsg );
%  } else {
%    xdr_free ( (xdrproc_t) xdr_fnServerBtreeInsertByString_rets, (char *) pResult );
%  }
%
%  return Result.ReturnValue;
%
%} /* fnServerBtreeInsertByString */
#endif	/* RPC_CLNT */
%
  fnServerBtreemapSearch_rets fnRpc_fnServerBtreemapSearch ( fnServerBtreemapSearch_args ) =  88 ;
%
#if RPC_SVC
%
%extern int fnServerBtreemapSearch
%	(SHORTOBJID oShortObjIdMapper ,
%	  SHORTOBJID oShortObjIdHeap ,
%	  SHORTOBJID oShortObjIdBTree ,
%	  int nValueKeyLower ,
%	  SHTYPETAG nTypeTagKeyLower ,
%	  COMPARETAG eCompareLower ,
%	  int nValueKeyUpper ,
%	  SHTYPETAG nTypeTagKeyUpper ,
%	  COMPARETAG eCompareUpper ,
%	  bool_t bDescending);
%
%#ifdef MULTITHREAD
%bool_t
%#else
%fnServerBtreemapSearch_rets *
%#endif
%	PASTE2(fnrpc_fnserverbtreemapsearch_1,_SVCSUFFIX)
%		( fnServerBtreemapSearch_args * pArguments,
%#ifdef MULTITHREAD
%		  fnServerBtreemapSearch_rets * pResult,
%#endif
%		  struct svc_req * pRequest )
%{
%  static const char	__procedure__[]	= "server:fnrpc_fnserverbtreemapsearch_1";
%#ifdef MULTITHREAD
%  typedef bool_t RESULTTYPE;
%#else
%  typedef fnServerBtreemapSearch_rets * RESULTTYPE;
%#endif
%#ifndef MULTITHREAD
%  static fnServerBtreemapSearch_rets	Result;
%  RESULTTYPE			pResult = &Result;
%#endif
%  LPCSTR	pszErrorMsg;
%
%  __pRequest__	= pRequest;
%
%  RPC_SERVER_ENTRY();
%
%#ifndef MULTITHREAD
%  if ( pResult->pszErrorMsg == szEmpty ) {
%    pResult->pszErrorMsg	= NULL;
%  }
%  xdr_free ( (xdrproc_t) xdr_fnServerBtreemapSearch_rets, (char *) pResult );
%#endif
%  pResult->nErrorLvl		= 0;
%
%  Reply.bAnswered		= FALSE;
%  Reply.pfnCalled		= (void(*)()) fnServerBtreemapSearch;
%  Reply.pfnXdrResult		= (bool_t(*)()) xdr_fnServerBtreemapSearch_rets;
%  Reply.pnErrorLvl		= &pResult->nErrorLvl;
%  Reply.ppszErrorMsg		= (LPCSTR *) &pResult->pszErrorMsg;
%  Reply.pResult		= pResult;
%  Reply.pReturnValue		= &pResult->ReturnValue;
%  Reply.nReturnValueSize	= sizeof ( pResult->ReturnValue );
%
%  pResult->ReturnValue		=
%  fnServerBtreemapSearch (
%	pArguments->oShortObjIdMapper,
%	pArguments->oShortObjIdHeap,
%	pArguments->oShortObjIdBTree,
%	pArguments->nValueKeyLower,
%	pArguments->nTypeTagKeyLower,
%	pArguments->eCompareLower,
%	pArguments->nValueKeyUpper,
%	pArguments->nTypeTagKeyUpper,
%	pArguments->eCompareUpper,
%	pArguments->bDescending );
%
%  if ( Reply.bAnswered ) {
%    __pRequest__	= NULL;
%    return (RESULTTYPE) NULL;
%  }
%
%  pResult->nErrorLvl	= RPC_SERVER_ERRLVL();
%  if ( pResult->nErrorLvl > 0 ) {
%    pszErrorMsg		= RPC_SERVER_ERRMSG();
%    if ( pszErrorMsg && *pszErrorMsg ) {
%      pResult->pszErrorMsg	= strdup ( pszErrorMsg );
%    }
%  }
%  if ( pResult->pszErrorMsg == NULL ) {
%#ifdef MULTITHREAD
%    pResult->pszErrorMsg	= strdup ( szEmpty );
%#else
%    pResult->pszErrorMsg	= (LPSTR) szEmpty;
%#endif
%  }
%  __pRequest__	= NULL;
%  return (RESULTTYPE) pResult;
%} /* fnrpc_fnserverbtreemapsearch_1 */
#endif	/* RPC_SVC */
%
#if RPC_CLNT
%int DLLEXPORT fnServerBtreemapSearch
%	(SHORTOBJID oShortObjIdMapper ,
%	  SHORTOBJID oShortObjIdHeap ,
%	  SHORTOBJID oShortObjIdBTree ,
%	  int nValueKeyLower ,
%	  SHTYPETAG nTypeTagKeyLower ,
%	  COMPARETAG eCompareLower ,
%	  int nValueKeyUpper ,
%	  SHTYPETAG nTypeTagKeyUpper ,
%	  COMPARETAG eCompareUpper ,
%	  bool_t bDescending)
%{
%  static const char	__procedure__[]	= "client:fnServerBtreemapSearch";
%  static fnServerBtreemapSearch_rets	ZeroResult;
%  fnServerBtreemapSearch_rets		* pResult = NULL;
%  fnServerBtreemapSearch_rets		Result = ZeroResult;
%  fnServerBtreemapSearch_args	InArguments;
%
%  /* Client initialization: */
%  if ( __bClientInitialize__ ) {
%    __bClientInitialize__	= FALSE;
%    RPC_CLIENT_INITIALIZE();
%  }
%
%#if	CLIENT_CREATE_BY_USER
%  if ( __pClient__ == NULL ) {
%    __pClient__	= RPC_CLIENT_CREATE ( __szHost__, __szTransport__ );
%    if ( __pClient__ == NULL ) {
%      /* Error handling for a not connected client: */
%      char	szError [ 256 ];
%      sprintf ( szError, szFormatNoServer, __procedure__ );
%      RPC_CLIENT_ERROR ( szError );
%      return Result.ReturnValue;
%    }
%  }
%#else
%  while ( __pClient__ == NULL ) {
%    __pClient__	= RPC_CLIENT_CREATE ( __szHost__, __szTransport__ );
%    if ( __pClient__ == NULL ) {
%      /* Error handling for a not connected client: */
%      char	szError [ 256 ];
%      sprintf ( szError, szFormatNoServer, __procedure__ );
%      RPC_CLIENT_CERROR ( szContNoServer, szError );
%    }
%  }
%#endif	/* CLIENT_CREATE_BY_USER */
%
%  /* Copy in the oShortObjIdMapper argument: */
%  InArguments.oShortObjIdMapper	= oShortObjIdMapper;
%  /* Copy in the oShortObjIdHeap argument: */
%  InArguments.oShortObjIdHeap	= oShortObjIdHeap;
%  /* Copy in the oShortObjIdBTree argument: */
%  InArguments.oShortObjIdBTree	= oShortObjIdBTree;
%  /* Copy in the nValueKeyLower argument: */
%  InArguments.nValueKeyLower	= nValueKeyLower;
%  /* Copy in the nTypeTagKeyLower argument: */
%  InArguments.nTypeTagKeyLower	= nTypeTagKeyLower;
%  /* Copy in the eCompareLower argument: */
%  InArguments.eCompareLower	= eCompareLower;
%  /* Copy in the nValueKeyUpper argument: */
%  InArguments.nValueKeyUpper	= nValueKeyUpper;
%  /* Copy in the nTypeTagKeyUpper argument: */
%  InArguments.nTypeTagKeyUpper	= nTypeTagKeyUpper;
%  /* Copy in the eCompareUpper argument: */
%  InArguments.eCompareUpper	= eCompareUpper;
%  /* Copy in the bDescending argument: */
%  InArguments.bDescending	= bDescending;
%
%  pResult	=
%#ifdef MULTITHREAD
%    (
%#else
%    (fnServerBtreemapSearch_rets *)
%#endif
%    fnrpc_fnserverbtreemapsearch_1 (
%	&InArguments,
%#ifdef MULTITHREAD
%	&Result,
%#endif
%	__pClient__ )
%#ifdef MULTITHREAD
%	== RPC_SUCCESS ) ? &Result : NULL
%#endif
%	;
%
%  if ( pResult == NULL ) {
%    /* Error handling for a failed RPC call, */
%    /* i.e. the server did not respond: */
%    char	szError [ 256 ];
%    sprintf ( szError, szFormatRpcFailed, __procedure__,
%              clnt_sperror ( __pClient__, __szHost__ ) );
%    __pClient__	= RPC_CLIENT_DESTROY ( __pClient__ );
%    RPC_CLIENT_CERROR ( szContRpcFailed, szError );
%    Result	= ZeroResult;
%    return Result.ReturnValue;
%  }
%#ifndef MULTITHREAD
%  Result	= * pResult;
%#endif
%
%
%  if ( pResult && pResult->nErrorLvl ) {
%    /* Server returned a user error message: */
%    char	szErrorMsg [ 1024 ];
%    strncpy ( szErrorMsg,
%              ( pResult->pszErrorMsg && pResult->pszErrorMsg [ 0 ] ) ?
%              (LPCSTR) pResult->pszErrorMsg : (LPCSTR) szEmpty,
%              sizeof ( szErrorMsg ) );
%    szErrorMsg [ sizeof ( szErrorMsg ) - 1 ]	= (char) 0;
%    xdr_free ( (xdrproc_t) xdr_fnServerBtreemapSearch_rets, (char *) pResult );
%    RPC_CLIENT_SERROR ( pResult->nErrorLvl, __procedure__,
%                        szErrorMsg );
%  } else {
%    xdr_free ( (xdrproc_t) xdr_fnServerBtreemapSearch_rets, (char *) pResult );
%  }
%
%  return Result.ReturnValue;
%
%} /* fnServerBtreemapSearch */
#endif	/* RPC_CLNT */
%
  fnServerBtreemapSearchByFloat_rets fnRpc_fnServerBtreemapSearchByFloat ( fnServerBtreemapSearchByFloat_args ) =  89 ;
%
#if RPC_SVC
%
%extern int fnServerBtreemapSearchByFloat
%	(SHORTOBJID oShortObjIdMapper ,
%	  SHORTOBJID oShortObjIdHeap ,
%	  SHORTOBJID oShortObjIdBTree ,
%	  float fKeyLower ,
%	  SHTYPETAG nTypeTagKeyLower ,
%	  COMPARETAG eCompareLower ,
%	  float fKeyUpper ,
%	  SHTYPETAG nTypeTagKeyUpper ,
%	  COMPARETAG eCompareUpper ,
%	  bool_t bDescending);
%
%#ifdef MULTITHREAD
%bool_t
%#else
%fnServerBtreemapSearchByFloat_rets *
%#endif
%	PASTE2(fnrpc_fnserverbtreemapsearchbyfloat_1,_SVCSUFFIX)
%		( fnServerBtreemapSearchByFloat_args * pArguments,
%#ifdef MULTITHREAD
%		  fnServerBtreemapSearchByFloat_rets * pResult,
%#endif
%		  struct svc_req * pRequest )
%{
%  static const char	__procedure__[]	= "server:fnrpc_fnserverbtreemapsearchbyfloat_1";
%#ifdef MULTITHREAD
%  typedef bool_t RESULTTYPE;
%#else
%  typedef fnServerBtreemapSearchByFloat_rets * RESULTTYPE;
%#endif
%#ifndef MULTITHREAD
%  static fnServerBtreemapSearchByFloat_rets	Result;
%  RESULTTYPE			pResult = &Result;
%#endif
%  LPCSTR	pszErrorMsg;
%
%  __pRequest__	= pRequest;
%
%  RPC_SERVER_ENTRY();
%
%#ifndef MULTITHREAD
%  if ( pResult->pszErrorMsg == szEmpty ) {
%    pResult->pszErrorMsg	= NULL;
%  }
%  xdr_free ( (xdrproc_t) xdr_fnServerBtreemapSearchByFloat_rets, (char *) pResult );
%#endif
%  pResult->nErrorLvl		= 0;
%
%  Reply.bAnswered		= FALSE;
%  Reply.pfnCalled		= (void(*)()) fnServerBtreemapSearchByFloat;
%  Reply.pfnXdrResult		= (bool_t(*)()) xdr_fnServerBtreemapSearchByFloat_rets;
%  Reply.pnErrorLvl		= &pResult->nErrorLvl;
%  Reply.ppszErrorMsg		= (LPCSTR *) &pResult->pszErrorMsg;
%  Reply.pResult		= pResult;
%  Reply.pReturnValue		= &pResult->ReturnValue;
%  Reply.nReturnValueSize	= sizeof ( pResult->ReturnValue );
%
%  pResult->ReturnValue		=
%  fnServerBtreemapSearchByFloat (
%	pArguments->oShortObjIdMapper,
%	pArguments->oShortObjIdHeap,
%	pArguments->oShortObjIdBTree,
%	pArguments->fKeyLower,
%	pArguments->nTypeTagKeyLower,
%	pArguments->eCompareLower,
%	pArguments->fKeyUpper,
%	pArguments->nTypeTagKeyUpper,
%	pArguments->eCompareUpper,
%	pArguments->bDescending );
%
%  if ( Reply.bAnswered ) {
%    __pRequest__	= NULL;
%    return (RESULTTYPE) NULL;
%  }
%
%  pResult->nErrorLvl	= RPC_SERVER_ERRLVL();
%  if ( pResult->nErrorLvl > 0 ) {
%    pszErrorMsg		= RPC_SERVER_ERRMSG();
%    if ( pszErrorMsg && *pszErrorMsg ) {
%      pResult->pszErrorMsg	= strdup ( pszErrorMsg );
%    }
%  }
%  if ( pResult->pszErrorMsg == NULL ) {
%#ifdef MULTITHREAD
%    pResult->pszErrorMsg	= strdup ( szEmpty );
%#else
%    pResult->pszErrorMsg	= (LPSTR) szEmpty;
%#endif
%  }
%  __pRequest__	= NULL;
%  return (RESULTTYPE) pResult;
%} /* fnrpc_fnserverbtreemapsearchbyfloat_1 */
#endif	/* RPC_SVC */
%
#if RPC_CLNT
%int DLLEXPORT fnServerBtreemapSearchByFloat
%	(SHORTOBJID oShortObjIdMapper ,
%	  SHORTOBJID oShortObjIdHeap ,
%	  SHORTOBJID oShortObjIdBTree ,
%	  float fKeyLower ,
%	  SHTYPETAG nTypeTagKeyLower ,
%	  COMPARETAG eCompareLower ,
%	  float fKeyUpper ,
%	  SHTYPETAG nTypeTagKeyUpper ,
%	  COMPARETAG eCompareUpper ,
%	  bool_t bDescending)
%{
%  static const char	__procedure__[]	= "client:fnServerBtreemapSearchByFloat";
%  static fnServerBtreemapSearchByFloat_rets	ZeroResult;
%  fnServerBtreemapSearchByFloat_rets		* pResult = NULL;
%  fnServerBtreemapSearchByFloat_rets		Result = ZeroResult;
%  fnServerBtreemapSearchByFloat_args	InArguments;
%
%  /* Client initialization: */
%  if ( __bClientInitialize__ ) {
%    __bClientInitialize__	= FALSE;
%    RPC_CLIENT_INITIALIZE();
%  }
%
%#if	CLIENT_CREATE_BY_USER
%  if ( __pClient__ == NULL ) {
%    __pClient__	= RPC_CLIENT_CREATE ( __szHost__, __szTransport__ );
%    if ( __pClient__ == NULL ) {
%      /* Error handling for a not connected client: */
%      char	szError [ 256 ];
%      sprintf ( szError, szFormatNoServer, __procedure__ );
%      RPC_CLIENT_ERROR ( szError );
%      return Result.ReturnValue;
%    }
%  }
%#else
%  while ( __pClient__ == NULL ) {
%    __pClient__	= RPC_CLIENT_CREATE ( __szHost__, __szTransport__ );
%    if ( __pClient__ == NULL ) {
%      /* Error handling for a not connected client: */
%      char	szError [ 256 ];
%      sprintf ( szError, szFormatNoServer, __procedure__ );
%      RPC_CLIENT_CERROR ( szContNoServer, szError );
%    }
%  }
%#endif	/* CLIENT_CREATE_BY_USER */
%
%  /* Copy in the oShortObjIdMapper argument: */
%  InArguments.oShortObjIdMapper	= oShortObjIdMapper;
%  /* Copy in the oShortObjIdHeap argument: */
%  InArguments.oShortObjIdHeap	= oShortObjIdHeap;
%  /* Copy in the oShortObjIdBTree argument: */
%  InArguments.oShortObjIdBTree	= oShortObjIdBTree;
%  /* Copy in the fKeyLower argument: */
%  InArguments.fKeyLower	= fKeyLower;
%  /* Copy in the nTypeTagKeyLower argument: */
%  InArguments.nTypeTagKeyLower	= nTypeTagKeyLower;
%  /* Copy in the eCompareLower argument: */
%  InArguments.eCompareLower	= eCompareLower;
%  /* Copy in the fKeyUpper argument: */
%  InArguments.fKeyUpper	= fKeyUpper;
%  /* Copy in the nTypeTagKeyUpper argument: */
%  InArguments.nTypeTagKeyUpper	= nTypeTagKeyUpper;
%  /* Copy in the eCompareUpper argument: */
%  InArguments.eCompareUpper	= eCompareUpper;
%  /* Copy in the bDescending argument: */
%  InArguments.bDescending	= bDescending;
%
%  pResult	=
%#ifdef MULTITHREAD
%    (
%#else
%    (fnServerBtreemapSearchByFloat_rets *)
%#endif
%    fnrpc_fnserverbtreemapsearchbyfloat_1 (
%	&InArguments,
%#ifdef MULTITHREAD
%	&Result,
%#endif
%	__pClient__ )
%#ifdef MULTITHREAD
%	== RPC_SUCCESS ) ? &Result : NULL
%#endif
%	;
%
%  if ( pResult == NULL ) {
%    /* Error handling for a failed RPC call, */
%    /* i.e. the server did not respond: */
%    char	szError [ 256 ];
%    sprintf ( szError, szFormatRpcFailed, __procedure__,
%              clnt_sperror ( __pClient__, __szHost__ ) );
%    __pClient__	= RPC_CLIENT_DESTROY ( __pClient__ );
%    RPC_CLIENT_CERROR ( szContRpcFailed, szError );
%    Result	= ZeroResult;
%    return Result.ReturnValue;
%  }
%#ifndef MULTITHREAD
%  Result	= * pResult;
%#endif
%
%
%  if ( pResult && pResult->nErrorLvl ) {
%    /* Server returned a user error message: */
%    char	szErrorMsg [ 1024 ];
%    strncpy ( szErrorMsg,
%              ( pResult->pszErrorMsg && pResult->pszErrorMsg [ 0 ] ) ?
%              (LPCSTR) pResult->pszErrorMsg : (LPCSTR) szEmpty,
%              sizeof ( szErrorMsg ) );
%    szErrorMsg [ sizeof ( szErrorMsg ) - 1 ]	= (char) 0;
%    xdr_free ( (xdrproc_t) xdr_fnServerBtreemapSearchByFloat_rets, (char *) pResult );
%    RPC_CLIENT_SERROR ( pResult->nErrorLvl, __procedure__,
%                        szErrorMsg );
%  } else {
%    xdr_free ( (xdrproc_t) xdr_fnServerBtreemapSearchByFloat_rets, (char *) pResult );
%  }
%
%  return Result.ReturnValue;
%
%} /* fnServerBtreemapSearchByFloat */
#endif	/* RPC_CLNT */
%
  fnServerBtreemapSearchByDouble_rets fnRpc_fnServerBtreemapSearchByDouble ( fnServerBtreemapSearchByDouble_args ) =  90 ;
%
#if RPC_SVC
%
%extern int fnServerBtreemapSearchByDouble
%	(SHORTOBJID oShortObjIdMapper ,
%	  SHORTOBJID oShortObjIdHeap ,
%	  SHORTOBJID oShortObjIdBTree ,
%	  double fKeyLower ,
%	  COMPARETAG eCompareLower ,
%	  SHTYPETAG nTypeTagKeyLower ,
%	  double fKeyUpper ,
%	  SHTYPETAG nTypeTagKeyUpper ,
%	  COMPARETAG eCompareUpper ,
%	  bool_t bDescending);
%
%#ifdef MULTITHREAD
%bool_t
%#else
%fnServerBtreemapSearchByDouble_rets *
%#endif
%	PASTE2(fnrpc_fnserverbtreemapsearchbydouble_1,_SVCSUFFIX)
%		( fnServerBtreemapSearchByDouble_args * pArguments,
%#ifdef MULTITHREAD
%		  fnServerBtreemapSearchByDouble_rets * pResult,
%#endif
%		  struct svc_req * pRequest )
%{
%  static const char	__procedure__[]	= "server:fnrpc_fnserverbtreemapsearchbydouble_1";
%#ifdef MULTITHREAD
%  typedef bool_t RESULTTYPE;
%#else
%  typedef fnServerBtreemapSearchByDouble_rets * RESULTTYPE;
%#endif
%#ifndef MULTITHREAD
%  static fnServerBtreemapSearchByDouble_rets	Result;
%  RESULTTYPE			pResult = &Result;
%#endif
%  LPCSTR	pszErrorMsg;
%
%  __pRequest__	= pRequest;
%
%  RPC_SERVER_ENTRY();
%
%#ifndef MULTITHREAD
%  if ( pResult->pszErrorMsg == szEmpty ) {
%    pResult->pszErrorMsg	= NULL;
%  }
%  xdr_free ( (xdrproc_t) xdr_fnServerBtreemapSearchByDouble_rets, (char *) pResult );
%#endif
%  pResult->nErrorLvl		= 0;
%
%  Reply.bAnswered		= FALSE;
%  Reply.pfnCalled		= (void(*)()) fnServerBtreemapSearchByDouble;
%  Reply.pfnXdrResult		= (bool_t(*)()) xdr_fnServerBtreemapSearchByDouble_rets;
%  Reply.pnErrorLvl		= &pResult->nErrorLvl;
%  Reply.ppszErrorMsg		= (LPCSTR *) &pResult->pszErrorMsg;
%  Reply.pResult		= pResult;
%  Reply.pReturnValue		= &pResult->ReturnValue;
%  Reply.nReturnValueSize	= sizeof ( pResult->ReturnValue );
%
%  pResult->ReturnValue		=
%  fnServerBtreemapSearchByDouble (
%	pArguments->oShortObjIdMapper,
%	pArguments->oShortObjIdHeap,
%	pArguments->oShortObjIdBTree,
%	pArguments->fKeyLower,
%	pArguments->eCompareLower,
%	pArguments->nTypeTagKeyLower,
%	pArguments->fKeyUpper,
%	pArguments->nTypeTagKeyUpper,
%	pArguments->eCompareUpper,
%	pArguments->bDescending );
%
%  if ( Reply.bAnswered ) {
%    __pRequest__	= NULL;
%    return (RESULTTYPE) NULL;
%  }
%
%  pResult->nErrorLvl	= RPC_SERVER_ERRLVL();
%  if ( pResult->nErrorLvl > 0 ) {
%    pszErrorMsg		= RPC_SERVER_ERRMSG();
%    if ( pszErrorMsg && *pszErrorMsg ) {
%      pResult->pszErrorMsg	= strdup ( pszErrorMsg );
%    }
%  }
%  if ( pResult->pszErrorMsg == NULL ) {
%#ifdef MULTITHREAD
%    pResult->pszErrorMsg	= strdup ( szEmpty );
%#else
%    pResult->pszErrorMsg	= (LPSTR) szEmpty;
%#endif
%  }
%  __pRequest__	= NULL;
%  return (RESULTTYPE) pResult;
%} /* fnrpc_fnserverbtreemapsearchbydouble_1 */
#endif	/* RPC_SVC */
%
#if RPC_CLNT
%int DLLEXPORT fnServerBtreemapSearchByDouble
%	(SHORTOBJID oShortObjIdMapper ,
%	  SHORTOBJID oShortObjIdHeap ,
%	  SHORTOBJID oShortObjIdBTree ,
%	  double fKeyLower ,
%	  COMPARETAG eCompareLower ,
%	  SHTYPETAG nTypeTagKeyLower ,
%	  double fKeyUpper ,
%	  SHTYPETAG nTypeTagKeyUpper ,
%	  COMPARETAG eCompareUpper ,
%	  bool_t bDescending)
%{
%  static const char	__procedure__[]	= "client:fnServerBtreemapSearchByDouble";
%  static fnServerBtreemapSearchByDouble_rets	ZeroResult;
%  fnServerBtreemapSearchByDouble_rets		* pResult = NULL;
%  fnServerBtreemapSearchByDouble_rets		Result = ZeroResult;
%  fnServerBtreemapSearchByDouble_args	InArguments;
%
%  /* Client initialization: */
%  if ( __bClientInitialize__ ) {
%    __bClientInitialize__	= FALSE;
%    RPC_CLIENT_INITIALIZE();
%  }
%
%#if	CLIENT_CREATE_BY_USER
%  if ( __pClient__ == NULL ) {
%    __pClient__	= RPC_CLIENT_CREATE ( __szHost__, __szTransport__ );
%    if ( __pClient__ == NULL ) {
%      /* Error handling for a not connected client: */
%      char	szError [ 256 ];
%      sprintf ( szError, szFormatNoServer, __procedure__ );
%      RPC_CLIENT_ERROR ( szError );
%      return Result.ReturnValue;
%    }
%  }
%#else
%  while ( __pClient__ == NULL ) {
%    __pClient__	= RPC_CLIENT_CREATE ( __szHost__, __szTransport__ );
%    if ( __pClient__ == NULL ) {
%      /* Error handling for a not connected client: */
%      char	szError [ 256 ];
%      sprintf ( szError, szFormatNoServer, __procedure__ );
%      RPC_CLIENT_CERROR ( szContNoServer, szError );
%    }
%  }
%#endif	/* CLIENT_CREATE_BY_USER */
%
%  /* Copy in the oShortObjIdMapper argument: */
%  InArguments.oShortObjIdMapper	= oShortObjIdMapper;
%  /* Copy in the oShortObjIdHeap argument: */
%  InArguments.oShortObjIdHeap	= oShortObjIdHeap;
%  /* Copy in the oShortObjIdBTree argument: */
%  InArguments.oShortObjIdBTree	= oShortObjIdBTree;
%  /* Copy in the fKeyLower argument: */
%  InArguments.fKeyLower	= fKeyLower;
%  /* Copy in the eCompareLower argument: */
%  InArguments.eCompareLower	= eCompareLower;
%  /* Copy in the nTypeTagKeyLower argument: */
%  InArguments.nTypeTagKeyLower	= nTypeTagKeyLower;
%  /* Copy in the fKeyUpper argument: */
%  InArguments.fKeyUpper	= fKeyUpper;
%  /* Copy in the nTypeTagKeyUpper argument: */
%  InArguments.nTypeTagKeyUpper	= nTypeTagKeyUpper;
%  /* Copy in the eCompareUpper argument: */
%  InArguments.eCompareUpper	= eCompareUpper;
%  /* Copy in the bDescending argument: */
%  InArguments.bDescending	= bDescending;
%
%  pResult	=
%#ifdef MULTITHREAD
%    (
%#else
%    (fnServerBtreemapSearchByDouble_rets *)
%#endif
%    fnrpc_fnserverbtreemapsearchbydouble_1 (
%	&InArguments,
%#ifdef MULTITHREAD
%	&Result,
%#endif
%	__pClient__ )
%#ifdef MULTITHREAD
%	== RPC_SUCCESS ) ? &Result : NULL
%#endif
%	;
%
%  if ( pResult == NULL ) {
%    /* Error handling for a failed RPC call, */
%    /* i.e. the server did not respond: */
%    char	szError [ 256 ];
%    sprintf ( szError, szFormatRpcFailed, __procedure__,
%              clnt_sperror ( __pClient__, __szHost__ ) );
%    __pClient__	= RPC_CLIENT_DESTROY ( __pClient__ );
%    RPC_CLIENT_CERROR ( szContRpcFailed, szError );
%    Result	= ZeroResult;
%    return Result.ReturnValue;
%  }
%#ifndef MULTITHREAD
%  Result	= * pResult;
%#endif
%
%
%  if ( pResult && pResult->nErrorLvl ) {
%    /* Server returned a user error message: */
%    char	szErrorMsg [ 1024 ];
%    strncpy ( szErrorMsg,
%              ( pResult->pszErrorMsg && pResult->pszErrorMsg [ 0 ] ) ?
%              (LPCSTR) pResult->pszErrorMsg : (LPCSTR) szEmpty,
%              sizeof ( szErrorMsg ) );
%    szErrorMsg [ sizeof ( szErrorMsg ) - 1 ]	= (char) 0;
%    xdr_free ( (xdrproc_t) xdr_fnServerBtreemapSearchByDouble_rets, (char *) pResult );
%    RPC_CLIENT_SERROR ( pResult->nErrorLvl, __procedure__,
%                        szErrorMsg );
%  } else {
%    xdr_free ( (xdrproc_t) xdr_fnServerBtreemapSearchByDouble_rets, (char *) pResult );
%  }
%
%  return Result.ReturnValue;
%
%} /* fnServerBtreemapSearchByDouble */
#endif	/* RPC_CLNT */
%
  fnServerBtreemapSearchByString_rets fnRpc_fnServerBtreemapSearchByString ( fnServerBtreemapSearchByString_args ) =  91 ;
%
#if RPC_SVC
%
%extern int fnServerBtreemapSearchByString
%	(SHORTOBJID oShortObjIdMapper ,
%	  SHORTOBJID oShortObjIdHeap ,
%	  SHORTOBJID oShortObjIdBTree ,
%	  string_t /* string_t<@conststring@> */ szKeyLower ,
%	  SHTYPETAG nTypeTagKeyLower ,
%	  COMPARETAG eCompareLower ,
%	  string_t /* string_t<@conststring@> */ szKeyUpper ,
%	  SHTYPETAG nTypeTagKeyUpper ,
%	  COMPARETAG eCompareUpper ,
%	  bool_t bDescending);
%
%#ifdef MULTITHREAD
%bool_t
%#else
%fnServerBtreemapSearchByString_rets *
%#endif
%	PASTE2(fnrpc_fnserverbtreemapsearchbystring_1,_SVCSUFFIX)
%		( fnServerBtreemapSearchByString_args * pArguments,
%#ifdef MULTITHREAD
%		  fnServerBtreemapSearchByString_rets * pResult,
%#endif
%		  struct svc_req * pRequest )
%{
%  static const char	__procedure__[]	= "server:fnrpc_fnserverbtreemapsearchbystring_1";
%#ifdef MULTITHREAD
%  typedef bool_t RESULTTYPE;
%#else
%  typedef fnServerBtreemapSearchByString_rets * RESULTTYPE;
%#endif
%#ifndef MULTITHREAD
%  static fnServerBtreemapSearchByString_rets	Result;
%  RESULTTYPE			pResult = &Result;
%#endif
%  LPCSTR	pszErrorMsg;
%
%  __pRequest__	= pRequest;
%
%  RPC_SERVER_ENTRY();
%
%#ifndef MULTITHREAD
%  if ( pResult->pszErrorMsg == szEmpty ) {
%    pResult->pszErrorMsg	= NULL;
%  }
%  xdr_free ( (xdrproc_t) xdr_fnServerBtreemapSearchByString_rets, (char *) pResult );
%#endif
%  pResult->nErrorLvl		= 0;
%
%  Reply.bAnswered		= FALSE;
%  Reply.pfnCalled		= (void(*)()) fnServerBtreemapSearchByString;
%  Reply.pfnXdrResult		= (bool_t(*)()) xdr_fnServerBtreemapSearchByString_rets;
%  Reply.pnErrorLvl		= &pResult->nErrorLvl;
%  Reply.ppszErrorMsg		= (LPCSTR *) &pResult->pszErrorMsg;
%  Reply.pResult		= pResult;
%  Reply.pReturnValue		= &pResult->ReturnValue;
%  Reply.nReturnValueSize	= sizeof ( pResult->ReturnValue );
%
%  pResult->ReturnValue		=
%  fnServerBtreemapSearchByString (
%	pArguments->oShortObjIdMapper,
%	pArguments->oShortObjIdHeap,
%	pArguments->oShortObjIdBTree,
%	pArguments->szKeyLower,
%	pArguments->nTypeTagKeyLower,
%	pArguments->eCompareLower,
%	pArguments->szKeyUpper,
%	pArguments->nTypeTagKeyUpper,
%	pArguments->eCompareUpper,
%	pArguments->bDescending );
%
%  if ( Reply.bAnswered ) {
%    __pRequest__	= NULL;
%    return (RESULTTYPE) NULL;
%  }
%
%  pResult->nErrorLvl	= RPC_SERVER_ERRLVL();
%  if ( pResult->nErrorLvl > 0 ) {
%    pszErrorMsg		= RPC_SERVER_ERRMSG();
%    if ( pszErrorMsg && *pszErrorMsg ) {
%      pResult->pszErrorMsg	= strdup ( pszErrorMsg );
%    }
%  }
%  if ( pResult->pszErrorMsg == NULL ) {
%#ifdef MULTITHREAD
%    pResult->pszErrorMsg	= strdup ( szEmpty );
%#else
%    pResult->pszErrorMsg	= (LPSTR) szEmpty;
%#endif
%  }
%  __pRequest__	= NULL;
%  return (RESULTTYPE) pResult;
%} /* fnrpc_fnserverbtreemapsearchbystring_1 */
#endif	/* RPC_SVC */
%
#if RPC_CLNT
%int DLLEXPORT fnServerBtreemapSearchByString
%	(SHORTOBJID oShortObjIdMapper ,
%	  SHORTOBJID oShortObjIdHeap ,
%	  SHORTOBJID oShortObjIdBTree ,
%	  string_t /* string_t<@conststring@> */ szKeyLower ,
%	  SHTYPETAG nTypeTagKeyLower ,
%	  COMPARETAG eCompareLower ,
%	  string_t /* string_t<@conststring@> */ szKeyUpper ,
%	  SHTYPETAG nTypeTagKeyUpper ,
%	  COMPARETAG eCompareUpper ,
%	  bool_t bDescending)
%{
%  static const char	__procedure__[]	= "client:fnServerBtreemapSearchByString";
%  static fnServerBtreemapSearchByString_rets	ZeroResult;
%  fnServerBtreemapSearchByString_rets		* pResult = NULL;
%  fnServerBtreemapSearchByString_rets		Result = ZeroResult;
%  fnServerBtreemapSearchByString_args	InArguments;
%
%  /* Client initialization: */
%  if ( __bClientInitialize__ ) {
%    __bClientInitialize__	= FALSE;
%    RPC_CLIENT_INITIALIZE();
%  }
%
%#if	CLIENT_CREATE_BY_USER
%  if ( __pClient__ == NULL ) {
%    __pClient__	= RPC_CLIENT_CREATE ( __szHost__, __szTransport__ );
%    if ( __pClient__ == NULL ) {
%      /* Error handling for a not connected client: */
%      char	szError [ 256 ];
%      sprintf ( szError, szFormatNoServer, __procedure__ );
%      RPC_CLIENT_ERROR ( szError );
%      return Result.ReturnValue;
%    }
%  }
%#else
%  while ( __pClient__ == NULL ) {
%    __pClient__	= RPC_CLIENT_CREATE ( __szHost__, __szTransport__ );
%    if ( __pClient__ == NULL ) {
%      /* Error handling for a not connected client: */
%      char	szError [ 256 ];
%      sprintf ( szError, szFormatNoServer, __procedure__ );
%      RPC_CLIENT_CERROR ( szContNoServer, szError );
%    }
%  }
%#endif	/* CLIENT_CREATE_BY_USER */
%
%  /* Copy in the oShortObjIdMapper argument: */
%  InArguments.oShortObjIdMapper	= oShortObjIdMapper;
%  /* Copy in the oShortObjIdHeap argument: */
%  InArguments.oShortObjIdHeap	= oShortObjIdHeap;
%  /* Copy in the oShortObjIdBTree argument: */
%  InArguments.oShortObjIdBTree	= oShortObjIdBTree;
%  /* Copy in the szKeyLower argument: */
%  InArguments.szKeyLower	= szKeyLower;
%  if ( szKeyLower == NULL ) {
%    /* Error handling for passing a NULL string pointer: */
%    char	szError [ 256 ];
%    InArguments.szKeyLower	= (LPSTR) szEmpty;
%    sprintf ( szError, szFormatNullString,
%              __procedure__, "szKeyLower" );
%    RPC_CLIENT_CERROR ( szContNullString, szError );
%  }
%  /* Copy in the nTypeTagKeyLower argument: */
%  InArguments.nTypeTagKeyLower	= nTypeTagKeyLower;
%  /* Copy in the eCompareLower argument: */
%  InArguments.eCompareLower	= eCompareLower;
%  /* Copy in the szKeyUpper argument: */
%  InArguments.szKeyUpper	= szKeyUpper;
%  if ( szKeyUpper == NULL ) {
%    /* Error handling for passing a NULL string pointer: */
%    char	szError [ 256 ];
%    InArguments.szKeyUpper	= (LPSTR) szEmpty;
%    sprintf ( szError, szFormatNullString,
%              __procedure__, "szKeyUpper" );
%    RPC_CLIENT_CERROR ( szContNullString, szError );
%  }
%  /* Copy in the nTypeTagKeyUpper argument: */
%  InArguments.nTypeTagKeyUpper	= nTypeTagKeyUpper;
%  /* Copy in the eCompareUpper argument: */
%  InArguments.eCompareUpper	= eCompareUpper;
%  /* Copy in the bDescending argument: */
%  InArguments.bDescending	= bDescending;
%
%  pResult	=
%#ifdef MULTITHREAD
%    (
%#else
%    (fnServerBtreemapSearchByString_rets *)
%#endif
%    fnrpc_fnserverbtreemapsearchbystring_1 (
%	&InArguments,
%#ifdef MULTITHREAD
%	&Result,
%#endif
%	__pClient__ )
%#ifdef MULTITHREAD
%	== RPC_SUCCESS ) ? &Result : NULL
%#endif
%	;
%
%  if ( pResult == NULL ) {
%    /* Error handling for a failed RPC call, */
%    /* i.e. the server did not respond: */
%    char	szError [ 256 ];
%    sprintf ( szError, szFormatRpcFailed, __procedure__,
%              clnt_sperror ( __pClient__, __szHost__ ) );
%    __pClient__	= RPC_CLIENT_DESTROY ( __pClient__ );
%    RPC_CLIENT_CERROR ( szContRpcFailed, szError );
%    Result	= ZeroResult;
%    return Result.ReturnValue;
%  }
%#ifndef MULTITHREAD
%  Result	= * pResult;
%#endif
%
%
%  if ( pResult && pResult->nErrorLvl ) {
%    /* Server returned a user error message: */
%    char	szErrorMsg [ 1024 ];
%    strncpy ( szErrorMsg,
%              ( pResult->pszErrorMsg && pResult->pszErrorMsg [ 0 ] ) ?
%              (LPCSTR) pResult->pszErrorMsg : (LPCSTR) szEmpty,
%              sizeof ( szErrorMsg ) );
%    szErrorMsg [ sizeof ( szErrorMsg ) - 1 ]	= (char) 0;
%    xdr_free ( (xdrproc_t) xdr_fnServerBtreemapSearchByString_rets, (char *) pResult );
%    RPC_CLIENT_SERROR ( pResult->nErrorLvl, __procedure__,
%                        szErrorMsg );
%  } else {
%    xdr_free ( (xdrproc_t) xdr_fnServerBtreemapSearchByString_rets, (char *) pResult );
%  }
%
%  return Result.ReturnValue;
%
%} /* fnServerBtreemapSearchByString */
#endif	/* RPC_CLNT */
%
  fnServerBtreemapSeek_rets fnRpc_fnServerBtreemapSeek ( fnServerBtreemapSeek_args ) =  92 ;
%
#if RPC_SVC
%
%extern int fnServerBtreemapSeek
%	(SHORTOBJID oShortObjIdHeap ,
%	  SHORTOBJID oShortObjIdMapper ,
%	  int nIncrement ,
%	  SEEK eOrigin ,
%	  int * pnValueKey ,
%	  SHTYPETAG * pnTypeTagKey ,
%	  int * pnValueData ,
%	  SHTYPETAG * pnTypeTagData);
%
%#ifdef MULTITHREAD
%bool_t
%#else
%fnServerBtreemapSeek_rets *
%#endif
%	PASTE2(fnrpc_fnserverbtreemapseek_1,_SVCSUFFIX)
%		( fnServerBtreemapSeek_args * pArguments,
%#ifdef MULTITHREAD
%		  fnServerBtreemapSeek_rets * pResult,
%#endif
%		  struct svc_req * pRequest )
%{
%  static const char	__procedure__[]	= "server:fnrpc_fnserverbtreemapseek_1";
%#ifdef MULTITHREAD
%  typedef bool_t RESULTTYPE;
%#else
%  typedef fnServerBtreemapSeek_rets * RESULTTYPE;
%#endif
%#ifndef MULTITHREAD
%  static fnServerBtreemapSeek_rets	Result;
%  RESULTTYPE			pResult = &Result;
%#endif
%  LPCSTR	pszErrorMsg;
%
%  __pRequest__	= pRequest;
%
%  RPC_SERVER_ENTRY();
%
%#ifndef MULTITHREAD
%  if ( pResult->pszErrorMsg == szEmpty ) {
%    pResult->pszErrorMsg	= NULL;
%  }
%  xdr_free ( (xdrproc_t) xdr_fnServerBtreemapSeek_rets, (char *) pResult );
%#endif
%  pResult->nErrorLvl		= 0;
%
%  Reply.bAnswered		= FALSE;
%  Reply.pfnCalled		= (void(*)()) fnServerBtreemapSeek;
%  Reply.pfnXdrResult		= (bool_t(*)()) xdr_fnServerBtreemapSeek_rets;
%  Reply.pnErrorLvl		= &pResult->nErrorLvl;
%  Reply.ppszErrorMsg		= (LPCSTR *) &pResult->pszErrorMsg;
%  Reply.pResult		= pResult;
%  Reply.pReturnValue		= &pResult->ReturnValue;
%  Reply.nReturnValueSize	= sizeof ( pResult->ReturnValue );
%
%  pResult->ReturnValue		=
%  fnServerBtreemapSeek (
%	pArguments->oShortObjIdHeap,
%	pArguments->oShortObjIdMapper,
%	pArguments->nIncrement,
%	pArguments->eOrigin,
%	&pResult->pnValueKey,
%	&pResult->pnTypeTagKey,
%	&pResult->pnValueData,
%	&pResult->pnTypeTagData );
%
%  if ( Reply.bAnswered ) {
%    __pRequest__	= NULL;
%    return (RESULTTYPE) NULL;
%  }
%
%  pResult->nErrorLvl	= RPC_SERVER_ERRLVL();
%  if ( pResult->nErrorLvl > 0 ) {
%    pszErrorMsg		= RPC_SERVER_ERRMSG();
%    if ( pszErrorMsg && *pszErrorMsg ) {
%      pResult->pszErrorMsg	= strdup ( pszErrorMsg );
%    }
%  }
%  if ( pResult->pszErrorMsg == NULL ) {
%#ifdef MULTITHREAD
%    pResult->pszErrorMsg	= strdup ( szEmpty );
%#else
%    pResult->pszErrorMsg	= (LPSTR) szEmpty;
%#endif
%  }
%  __pRequest__	= NULL;
%  return (RESULTTYPE) pResult;
%} /* fnrpc_fnserverbtreemapseek_1 */
#endif	/* RPC_SVC */
%
#if RPC_CLNT
%int DLLEXPORT fnServerBtreemapSeek
%	(SHORTOBJID oShortObjIdHeap ,
%	  SHORTOBJID oShortObjIdMapper ,
%	  int nIncrement ,
%	  SEEK eOrigin ,
%	  int * pnValueKey ,
%	  SHTYPETAG * pnTypeTagKey ,
%	  int * pnValueData ,
%	  SHTYPETAG * pnTypeTagData)
%{
%  static const char	__procedure__[]	= "client:fnServerBtreemapSeek";
%  static fnServerBtreemapSeek_rets	ZeroResult;
%  fnServerBtreemapSeek_rets		* pResult = NULL;
%  fnServerBtreemapSeek_rets		Result = ZeroResult;
%  fnServerBtreemapSeek_args	InArguments;
%
%  /* Client initialization: */
%  if ( __bClientInitialize__ ) {
%    __bClientInitialize__	= FALSE;
%    RPC_CLIENT_INITIALIZE();
%  }
%
%#if	CLIENT_CREATE_BY_USER
%  if ( __pClient__ == NULL ) {
%    __pClient__	= RPC_CLIENT_CREATE ( __szHost__, __szTransport__ );
%    if ( __pClient__ == NULL ) {
%      /* Error handling for a not connected client: */
%      char	szError [ 256 ];
%      sprintf ( szError, szFormatNoServer, __procedure__ );
%      RPC_CLIENT_ERROR ( szError );
%      return Result.ReturnValue;
%    }
%  }
%#else
%  while ( __pClient__ == NULL ) {
%    __pClient__	= RPC_CLIENT_CREATE ( __szHost__, __szTransport__ );
%    if ( __pClient__ == NULL ) {
%      /* Error handling for a not connected client: */
%      char	szError [ 256 ];
%      sprintf ( szError, szFormatNoServer, __procedure__ );
%      RPC_CLIENT_CERROR ( szContNoServer, szError );
%    }
%  }
%#endif	/* CLIENT_CREATE_BY_USER */
%
%  /* Copy in the oShortObjIdHeap argument: */
%  InArguments.oShortObjIdHeap	= oShortObjIdHeap;
%  /* Copy in the oShortObjIdMapper argument: */
%  InArguments.oShortObjIdMapper	= oShortObjIdMapper;
%  /* Copy in the nIncrement argument: */
%  InArguments.nIncrement	= nIncrement;
%  /* Copy in the eOrigin argument: */
%  InArguments.eOrigin	= eOrigin;
%
%  pResult	=
%#ifdef MULTITHREAD
%    (
%#else
%    (fnServerBtreemapSeek_rets *)
%#endif
%    fnrpc_fnserverbtreemapseek_1 (
%	&InArguments,
%#ifdef MULTITHREAD
%	&Result,
%#endif
%	__pClient__ )
%#ifdef MULTITHREAD
%	== RPC_SUCCESS ) ? &Result : NULL
%#endif
%	;
%
%  if ( pResult == NULL ) {
%    /* Error handling for a failed RPC call, */
%    /* i.e. the server did not respond: */
%    char	szError [ 256 ];
%    sprintf ( szError, szFormatRpcFailed, __procedure__,
%              clnt_sperror ( __pClient__, __szHost__ ) );
%    __pClient__	= RPC_CLIENT_DESTROY ( __pClient__ );
%    RPC_CLIENT_CERROR ( szContRpcFailed, szError );
%    Result	= ZeroResult;
%    return Result.ReturnValue;
%  }
%#ifndef MULTITHREAD
%  Result	= * pResult;
%#endif
%
%  /* Copy out the pnValueKey argument: */
%  if ( ! ( 
%       pnValueKey == NULL ) ) {
%    *pnValueKey	= pResult->pnValueKey;
%  }
%  /* Copy out the pnTypeTagKey argument: */
%  if ( ! ( 
%       pnTypeTagKey == NULL ) ) {
%    *pnTypeTagKey	= pResult->pnTypeTagKey;
%  }
%  /* Copy out the pnValueData argument: */
%  if ( ! ( 
%       pnValueData == NULL ) ) {
%    *pnValueData	= pResult->pnValueData;
%  }
%  /* Copy out the pnTypeTagData argument: */
%  if ( ! ( 
%       pnTypeTagData == NULL ) ) {
%    *pnTypeTagData	= pResult->pnTypeTagData;
%  }
%
%  if ( pResult && pResult->nErrorLvl ) {
%    /* Server returned a user error message: */
%    char	szErrorMsg [ 1024 ];
%    strncpy ( szErrorMsg,
%              ( pResult->pszErrorMsg && pResult->pszErrorMsg [ 0 ] ) ?
%              (LPCSTR) pResult->pszErrorMsg : (LPCSTR) szEmpty,
%              sizeof ( szErrorMsg ) );
%    szErrorMsg [ sizeof ( szErrorMsg ) - 1 ]	= (char) 0;
%    xdr_free ( (xdrproc_t) xdr_fnServerBtreemapSeek_rets, (char *) pResult );
%    RPC_CLIENT_SERROR ( pResult->nErrorLvl, __procedure__,
%                        szErrorMsg );
%  } else {
%    xdr_free ( (xdrproc_t) xdr_fnServerBtreemapSeek_rets, (char *) pResult );
%  }
%  if ( 
%       pnValueKey == NULL ) {
%    /* Error handling for passing a NULL pointer on */
%    /* out argument: */
%    char	szError [ 256 ];
%    sprintf ( szError, szFormatNullPassed,
%              __procedure__, "pnValueKey" );
%    RPC_CLIENT_CERROR ( szContNullOutPassed, szError );
%  }
%  if ( 
%       pnTypeTagKey == NULL ) {
%    /* Error handling for passing a NULL pointer on */
%    /* out argument: */
%    char	szError [ 256 ];
%    sprintf ( szError, szFormatNullPassed,
%              __procedure__, "pnTypeTagKey" );
%    RPC_CLIENT_CERROR ( szContNullOutPassed, szError );
%  }
%  if ( 
%       pnValueData == NULL ) {
%    /* Error handling for passing a NULL pointer on */
%    /* out argument: */
%    char	szError [ 256 ];
%    sprintf ( szError, szFormatNullPassed,
%              __procedure__, "pnValueData" );
%    RPC_CLIENT_CERROR ( szContNullOutPassed, szError );
%  }
%  if ( 
%       pnTypeTagData == NULL ) {
%    /* Error handling for passing a NULL pointer on */
%    /* out argument: */
%    char	szError [ 256 ];
%    sprintf ( szError, szFormatNullPassed,
%              __procedure__, "pnTypeTagData" );
%    RPC_CLIENT_CERROR ( szContNullOutPassed, szError );
%  }
%
%  return Result.ReturnValue;
%
%} /* fnServerBtreemapSeek */
#endif	/* RPC_CLNT */
%
  fnServerBtreemapSeekSet_rets fnRpc_fnServerBtreemapSeekSet ( fnServerBtreemapSeekSet_args ) =  93 ;
%
#if RPC_SVC
%
%extern int fnServerBtreemapSeekSet
%	(SHORTOBJID oShortObjIdHeap ,
%	  SHORTOBJID oShortObjIdMapper ,
%	  int nIncrement ,
%	  SEEK eOrigin ,
%	  int nValueData ,
%	  SHTYPETAG nTypeTagData);
%
%#ifdef MULTITHREAD
%bool_t
%#else
%fnServerBtreemapSeekSet_rets *
%#endif
%	PASTE2(fnrpc_fnserverbtreemapseekset_1,_SVCSUFFIX)
%		( fnServerBtreemapSeekSet_args * pArguments,
%#ifdef MULTITHREAD
%		  fnServerBtreemapSeekSet_rets * pResult,
%#endif
%		  struct svc_req * pRequest )
%{
%  static const char	__procedure__[]	= "server:fnrpc_fnserverbtreemapseekset_1";
%#ifdef MULTITHREAD
%  typedef bool_t RESULTTYPE;
%#else
%  typedef fnServerBtreemapSeekSet_rets * RESULTTYPE;
%#endif
%#ifndef MULTITHREAD
%  static fnServerBtreemapSeekSet_rets	Result;
%  RESULTTYPE			pResult = &Result;
%#endif
%  LPCSTR	pszErrorMsg;
%
%  __pRequest__	= pRequest;
%
%  RPC_SERVER_ENTRY();
%
%#ifndef MULTITHREAD
%  if ( pResult->pszErrorMsg == szEmpty ) {
%    pResult->pszErrorMsg	= NULL;
%  }
%  xdr_free ( (xdrproc_t) xdr_fnServerBtreemapSeekSet_rets, (char *) pResult );
%#endif
%  pResult->nErrorLvl		= 0;
%
%  Reply.bAnswered		= FALSE;
%  Reply.pfnCalled		= (void(*)()) fnServerBtreemapSeekSet;
%  Reply.pfnXdrResult		= (bool_t(*)()) xdr_fnServerBtreemapSeekSet_rets;
%  Reply.pnErrorLvl		= &pResult->nErrorLvl;
%  Reply.ppszErrorMsg		= (LPCSTR *) &pResult->pszErrorMsg;
%  Reply.pResult		= pResult;
%  Reply.pReturnValue		= &pResult->ReturnValue;
%  Reply.nReturnValueSize	= sizeof ( pResult->ReturnValue );
%
%  pResult->ReturnValue		=
%  fnServerBtreemapSeekSet (
%	pArguments->oShortObjIdHeap,
%	pArguments->oShortObjIdMapper,
%	pArguments->nIncrement,
%	pArguments->eOrigin,
%	pArguments->nValueData,
%	pArguments->nTypeTagData );
%
%  if ( Reply.bAnswered ) {
%    __pRequest__	= NULL;
%    return (RESULTTYPE) NULL;
%  }
%
%  pResult->nErrorLvl	= RPC_SERVER_ERRLVL();
%  if ( pResult->nErrorLvl > 0 ) {
%    pszErrorMsg		= RPC_SERVER_ERRMSG();
%    if ( pszErrorMsg && *pszErrorMsg ) {
%      pResult->pszErrorMsg	= strdup ( pszErrorMsg );
%    }
%  }
%  if ( pResult->pszErrorMsg == NULL ) {
%#ifdef MULTITHREAD
%    pResult->pszErrorMsg	= strdup ( szEmpty );
%#else
%    pResult->pszErrorMsg	= (LPSTR) szEmpty;
%#endif
%  }
%  __pRequest__	= NULL;
%  return (RESULTTYPE) pResult;
%} /* fnrpc_fnserverbtreemapseekset_1 */
#endif	/* RPC_SVC */
%
#if RPC_CLNT
%int DLLEXPORT fnServerBtreemapSeekSet
%	(SHORTOBJID oShortObjIdHeap ,
%	  SHORTOBJID oShortObjIdMapper ,
%	  int nIncrement ,
%	  SEEK eOrigin ,
%	  int nValueData ,
%	  SHTYPETAG nTypeTagData)
%{
%  static const char	__procedure__[]	= "client:fnServerBtreemapSeekSet";
%  static fnServerBtreemapSeekSet_rets	ZeroResult;
%  fnServerBtreemapSeekSet_rets		* pResult = NULL;
%  fnServerBtreemapSeekSet_rets		Result = ZeroResult;
%  fnServerBtreemapSeekSet_args	InArguments;
%
%  /* Client initialization: */
%  if ( __bClientInitialize__ ) {
%    __bClientInitialize__	= FALSE;
%    RPC_CLIENT_INITIALIZE();
%  }
%
%#if	CLIENT_CREATE_BY_USER
%  if ( __pClient__ == NULL ) {
%    __pClient__	= RPC_CLIENT_CREATE ( __szHost__, __szTransport__ );
%    if ( __pClient__ == NULL ) {
%      /* Error handling for a not connected client: */
%      char	szError [ 256 ];
%      sprintf ( szError, szFormatNoServer, __procedure__ );
%      RPC_CLIENT_ERROR ( szError );
%      return Result.ReturnValue;
%    }
%  }
%#else
%  while ( __pClient__ == NULL ) {
%    __pClient__	= RPC_CLIENT_CREATE ( __szHost__, __szTransport__ );
%    if ( __pClient__ == NULL ) {
%      /* Error handling for a not connected client: */
%      char	szError [ 256 ];
%      sprintf ( szError, szFormatNoServer, __procedure__ );
%      RPC_CLIENT_CERROR ( szContNoServer, szError );
%    }
%  }
%#endif	/* CLIENT_CREATE_BY_USER */
%
%  /* Copy in the oShortObjIdHeap argument: */
%  InArguments.oShortObjIdHeap	= oShortObjIdHeap;
%  /* Copy in the oShortObjIdMapper argument: */
%  InArguments.oShortObjIdMapper	= oShortObjIdMapper;
%  /* Copy in the nIncrement argument: */
%  InArguments.nIncrement	= nIncrement;
%  /* Copy in the eOrigin argument: */
%  InArguments.eOrigin	= eOrigin;
%  /* Copy in the nValueData argument: */
%  InArguments.nValueData	= nValueData;
%  /* Copy in the nTypeTagData argument: */
%  InArguments.nTypeTagData	= nTypeTagData;
%
%  pResult	=
%#ifdef MULTITHREAD
%    (
%#else
%    (fnServerBtreemapSeekSet_rets *)
%#endif
%    fnrpc_fnserverbtreemapseekset_1 (
%	&InArguments,
%#ifdef MULTITHREAD
%	&Result,
%#endif
%	__pClient__ )
%#ifdef MULTITHREAD
%	== RPC_SUCCESS ) ? &Result : NULL
%#endif
%	;
%
%  if ( pResult == NULL ) {
%    /* Error handling for a failed RPC call, */
%    /* i.e. the server did not respond: */
%    char	szError [ 256 ];
%    sprintf ( szError, szFormatRpcFailed, __procedure__,
%              clnt_sperror ( __pClient__, __szHost__ ) );
%    __pClient__	= RPC_CLIENT_DESTROY ( __pClient__ );
%    RPC_CLIENT_CERROR ( szContRpcFailed, szError );
%    Result	= ZeroResult;
%    return Result.ReturnValue;
%  }
%#ifndef MULTITHREAD
%  Result	= * pResult;
%#endif
%
%
%  if ( pResult && pResult->nErrorLvl ) {
%    /* Server returned a user error message: */
%    char	szErrorMsg [ 1024 ];
%    strncpy ( szErrorMsg,
%              ( pResult->pszErrorMsg && pResult->pszErrorMsg [ 0 ] ) ?
%              (LPCSTR) pResult->pszErrorMsg : (LPCSTR) szEmpty,
%              sizeof ( szErrorMsg ) );
%    szErrorMsg [ sizeof ( szErrorMsg ) - 1 ]	= (char) 0;
%    xdr_free ( (xdrproc_t) xdr_fnServerBtreemapSeekSet_rets, (char *) pResult );
%    RPC_CLIENT_SERROR ( pResult->nErrorLvl, __procedure__,
%                        szErrorMsg );
%  } else {
%    xdr_free ( (xdrproc_t) xdr_fnServerBtreemapSeekSet_rets, (char *) pResult );
%  }
%
%  return Result.ReturnValue;
%
%} /* fnServerBtreemapSeekSet */
#endif	/* RPC_CLNT */
%
  fnServerBtreemapFirst_rets fnRpc_fnServerBtreemapFirst ( fnServerBtreemapFirst_args ) =  94 ;
%
#if RPC_SVC
%
%extern int fnServerBtreemapFirst
%	(SHORTOBJID * lpoShortObjIdMapper ,
%	  SHORTOBJID oShortObjIdHeap ,
%	  SHORTOBJID oShortObjIdBTree ,
%	  int nValueKeyLower ,
%	  SHTYPETAG nTypeTagKeyLower ,
%	  COMPARETAG eCompareLower ,
%	  int nValueKeyUpper ,
%	  SHTYPETAG nTypeTagKeyUpper ,
%	  COMPARETAG eCompareUpper ,
%	  bool_t bDescending ,
%	  int nMap ,
%	  int * /* _vector_t<nMap> */  pnValueKey ,
%	  u_int * /* _vector_t<nMap> */  pnTypeTagKey ,
%	  int * /* _vector_t<nMap> */  pnValueData ,
%	  u_int * /* _vector_t<nMap> */  pnTypeTagData);
%
%#ifdef MULTITHREAD
%bool_t
%#else
%fnServerBtreemapFirst_rets *
%#endif
%	PASTE2(fnrpc_fnserverbtreemapfirst_1,_SVCSUFFIX)
%		( fnServerBtreemapFirst_args * pArguments,
%#ifdef MULTITHREAD
%		  fnServerBtreemapFirst_rets * pResult,
%#endif
%		  struct svc_req * pRequest )
%{
%  static const char	__procedure__[]	= "server:fnrpc_fnserverbtreemapfirst_1";
%#ifdef MULTITHREAD
%  typedef bool_t RESULTTYPE;
%#else
%  typedef fnServerBtreemapFirst_rets * RESULTTYPE;
%#endif
%#ifndef MULTITHREAD
%  static fnServerBtreemapFirst_rets	Result;
%  RESULTTYPE			pResult = &Result;
%#endif
%  LPCSTR	pszErrorMsg;
%
%  __pRequest__	= pRequest;
%
%  RPC_SERVER_ENTRY();
%
%#ifndef MULTITHREAD
%  if ( pResult->pszErrorMsg == szEmpty ) {
%    pResult->pszErrorMsg	= NULL;
%  }
%  xdr_free ( (xdrproc_t) xdr_fnServerBtreemapFirst_rets, (char *) pResult );
%#endif
%  pResult->nErrorLvl		= 0;
%
%  pResult->pnValueKey.int_vector_t_len	= pArguments->pnValueKeySize;
%  if ( pArguments->pnValueKeySize == 0 ) {
%    pResult->pnValueKey.int_vector_t_val	= NULL;
%  } else {
%    pResult->pnValueKey.int_vector_t_val	=
%      (int*) malloc ( pArguments->pnValueKeySize *
%               SIZEOF ( *(pResult->pnValueKey.int_vector_t_val) ) );
%    if ( pResult->pnValueKey.int_vector_t_val == NULL ) {
%      char	szError [ 256 ];
%      sprintf ( szError, szFormatMallocFailed,
%                __procedure__, pArguments->pnValueKeySize,
%                "pnValueKey" );
%      RPC_SERVER_ERROR ( szError );
%      return (RESULTTYPE) NULL;
%    }
%  }
%  pResult->pnTypeTagKey.u_int_vector_t_len	= pArguments->pnTypeTagKeySize;
%  if ( pArguments->pnTypeTagKeySize == 0 ) {
%    pResult->pnTypeTagKey.u_int_vector_t_val	= NULL;
%  } else {
%    pResult->pnTypeTagKey.u_int_vector_t_val	=
%      (u_int*) malloc ( pArguments->pnTypeTagKeySize *
%               SIZEOF ( *(pResult->pnTypeTagKey.u_int_vector_t_val) ) );
%    if ( pResult->pnTypeTagKey.u_int_vector_t_val == NULL ) {
%      char	szError [ 256 ];
%      sprintf ( szError, szFormatMallocFailed,
%                __procedure__, pArguments->pnTypeTagKeySize,
%                "pnTypeTagKey" );
%      RPC_SERVER_ERROR ( szError );
%      return (RESULTTYPE) NULL;
%    }
%  }
%  pResult->pnValueData.int_vector_t_len	= pArguments->pnValueDataSize;
%  if ( pArguments->pnValueDataSize == 0 ) {
%    pResult->pnValueData.int_vector_t_val	= NULL;
%  } else {
%    pResult->pnValueData.int_vector_t_val	=
%      (int*) malloc ( pArguments->pnValueDataSize *
%               SIZEOF ( *(pResult->pnValueData.int_vector_t_val) ) );
%    if ( pResult->pnValueData.int_vector_t_val == NULL ) {
%      char	szError [ 256 ];
%      sprintf ( szError, szFormatMallocFailed,
%                __procedure__, pArguments->pnValueDataSize,
%                "pnValueData" );
%      RPC_SERVER_ERROR ( szError );
%      return (RESULTTYPE) NULL;
%    }
%  }
%  pResult->pnTypeTagData.u_int_vector_t_len	= pArguments->pnTypeTagDataSize;
%  if ( pArguments->pnTypeTagDataSize == 0 ) {
%    pResult->pnTypeTagData.u_int_vector_t_val	= NULL;
%  } else {
%    pResult->pnTypeTagData.u_int_vector_t_val	=
%      (u_int*) malloc ( pArguments->pnTypeTagDataSize *
%               SIZEOF ( *(pResult->pnTypeTagData.u_int_vector_t_val) ) );
%    if ( pResult->pnTypeTagData.u_int_vector_t_val == NULL ) {
%      char	szError [ 256 ];
%      sprintf ( szError, szFormatMallocFailed,
%                __procedure__, pArguments->pnTypeTagDataSize,
%                "pnTypeTagData" );
%      RPC_SERVER_ERROR ( szError );
%      return (RESULTTYPE) NULL;
%    }
%  }
%  Reply.bAnswered		= FALSE;
%  Reply.pfnCalled		= (void(*)()) fnServerBtreemapFirst;
%  Reply.pfnXdrResult		= (bool_t(*)()) xdr_fnServerBtreemapFirst_rets;
%  Reply.pnErrorLvl		= &pResult->nErrorLvl;
%  Reply.ppszErrorMsg		= (LPCSTR *) &pResult->pszErrorMsg;
%  Reply.pResult		= pResult;
%  Reply.pReturnValue		= &pResult->ReturnValue;
%  Reply.nReturnValueSize	= sizeof ( pResult->ReturnValue );
%
%  pResult->ReturnValue		=
%  fnServerBtreemapFirst (
%	&pResult->lpoShortObjIdMapper,
%	pArguments->oShortObjIdHeap,
%	pArguments->oShortObjIdBTree,
%	pArguments->nValueKeyLower,
%	pArguments->nTypeTagKeyLower,
%	pArguments->eCompareLower,
%	pArguments->nValueKeyUpper,
%	pArguments->nTypeTagKeyUpper,
%	pArguments->eCompareUpper,
%	pArguments->bDescending,
%	pArguments->nMap,
%	pResult->pnValueKey.int_vector_t_val,
%	pResult->pnTypeTagKey.u_int_vector_t_val,
%	pResult->pnValueData.int_vector_t_val,
%	pResult->pnTypeTagData.u_int_vector_t_val );
%
%  if ( Reply.bAnswered ) {
%    __pRequest__	= NULL;
%    return (RESULTTYPE) NULL;
%  }
%
%  pResult->nErrorLvl	= RPC_SERVER_ERRLVL();
%  if ( pResult->nErrorLvl > 0 ) {
%    pszErrorMsg		= RPC_SERVER_ERRMSG();
%    if ( pszErrorMsg && *pszErrorMsg ) {
%      pResult->pszErrorMsg	= strdup ( pszErrorMsg );
%    }
%  }
%  if ( pResult->pszErrorMsg == NULL ) {
%#ifdef MULTITHREAD
%    pResult->pszErrorMsg	= strdup ( szEmpty );
%#else
%    pResult->pszErrorMsg	= (LPSTR) szEmpty;
%#endif
%  }
%  __pRequest__	= NULL;
%  return (RESULTTYPE) pResult;
%} /* fnrpc_fnserverbtreemapfirst_1 */
#endif	/* RPC_SVC */
%
#if RPC_CLNT
%int DLLEXPORT fnServerBtreemapFirst
%	(SHORTOBJID * lpoShortObjIdMapper ,
%	  SHORTOBJID oShortObjIdHeap ,
%	  SHORTOBJID oShortObjIdBTree ,
%	  int nValueKeyLower ,
%	  SHTYPETAG nTypeTagKeyLower ,
%	  COMPARETAG eCompareLower ,
%	  int nValueKeyUpper ,
%	  SHTYPETAG nTypeTagKeyUpper ,
%	  COMPARETAG eCompareUpper ,
%	  bool_t bDescending ,
%	  int nMap ,
%	  int * /* _vector_t<nMap> */  pnValueKey ,
%	  u_int * /* _vector_t<nMap> */  pnTypeTagKey ,
%	  int * /* _vector_t<nMap> */  pnValueData ,
%	  u_int * /* _vector_t<nMap> */  pnTypeTagData)
%{
%  static const char	__procedure__[]	= "client:fnServerBtreemapFirst";
%  static fnServerBtreemapFirst_rets	ZeroResult;
%  fnServerBtreemapFirst_rets		* pResult = NULL;
%  fnServerBtreemapFirst_rets		Result = ZeroResult;
%  fnServerBtreemapFirst_args	InArguments;
%
%  /* Client initialization: */
%  if ( __bClientInitialize__ ) {
%    __bClientInitialize__	= FALSE;
%    RPC_CLIENT_INITIALIZE();
%  }
%
%#if	CLIENT_CREATE_BY_USER
%  if ( __pClient__ == NULL ) {
%    __pClient__	= RPC_CLIENT_CREATE ( __szHost__, __szTransport__ );
%    if ( __pClient__ == NULL ) {
%      /* Error handling for a not connected client: */
%      char	szError [ 256 ];
%      sprintf ( szError, szFormatNoServer, __procedure__ );
%      RPC_CLIENT_ERROR ( szError );
%      return Result.ReturnValue;
%    }
%  }
%#else
%  while ( __pClient__ == NULL ) {
%    __pClient__	= RPC_CLIENT_CREATE ( __szHost__, __szTransport__ );
%    if ( __pClient__ == NULL ) {
%      /* Error handling for a not connected client: */
%      char	szError [ 256 ];
%      sprintf ( szError, szFormatNoServer, __procedure__ );
%      RPC_CLIENT_CERROR ( szContNoServer, szError );
%    }
%  }
%#endif	/* CLIENT_CREATE_BY_USER */
%
%  /* Copy in the oShortObjIdHeap argument: */
%  InArguments.oShortObjIdHeap	= oShortObjIdHeap;
%  /* Copy in the oShortObjIdBTree argument: */
%  InArguments.oShortObjIdBTree	= oShortObjIdBTree;
%  /* Copy in the nValueKeyLower argument: */
%  InArguments.nValueKeyLower	= nValueKeyLower;
%  /* Copy in the nTypeTagKeyLower argument: */
%  InArguments.nTypeTagKeyLower	= nTypeTagKeyLower;
%  /* Copy in the eCompareLower argument: */
%  InArguments.eCompareLower	= eCompareLower;
%  /* Copy in the nValueKeyUpper argument: */
%  InArguments.nValueKeyUpper	= nValueKeyUpper;
%  /* Copy in the nTypeTagKeyUpper argument: */
%  InArguments.nTypeTagKeyUpper	= nTypeTagKeyUpper;
%  /* Copy in the eCompareUpper argument: */
%  InArguments.eCompareUpper	= eCompareUpper;
%  /* Copy in the bDescending argument: */
%  InArguments.bDescending	= bDescending;
%  /* Copy in the nMap argument: */
%  InArguments.nMap	= nMap;
%  InArguments.pnValueKeySize	= nMap;
%  InArguments.pnTypeTagKeySize	= nMap;
%  InArguments.pnValueDataSize	= nMap;
%  InArguments.pnTypeTagDataSize	= nMap;
%
%  pResult	=
%#ifdef MULTITHREAD
%    (
%#else
%    (fnServerBtreemapFirst_rets *)
%#endif
%    fnrpc_fnserverbtreemapfirst_1 (
%	&InArguments,
%#ifdef MULTITHREAD
%	&Result,
%#endif
%	__pClient__ )
%#ifdef MULTITHREAD
%	== RPC_SUCCESS ) ? &Result : NULL
%#endif
%	;
%
%  if ( pResult == NULL ) {
%    /* Error handling for a failed RPC call, */
%    /* i.e. the server did not respond: */
%    char	szError [ 256 ];
%    sprintf ( szError, szFormatRpcFailed, __procedure__,
%              clnt_sperror ( __pClient__, __szHost__ ) );
%    __pClient__	= RPC_CLIENT_DESTROY ( __pClient__ );
%    RPC_CLIENT_CERROR ( szContRpcFailed, szError );
%    Result	= ZeroResult;
%    return Result.ReturnValue;
%  }
%#ifndef MULTITHREAD
%  Result	= * pResult;
%#endif
%
%  /* Copy out the lpoShortObjIdMapper argument: */
%  if ( ! ( 
%       lpoShortObjIdMapper == NULL ) ) {
%    *lpoShortObjIdMapper	= pResult->lpoShortObjIdMapper;
%  }
%  /* Copy out the pnValueKey argument: */
%  if ( ! ( 
%       pResult->pnValueKey.int_vector_t_len != 0 &&
%       pnValueKey == NULL ) ) {
%    memcpy ( pnValueKey,
%             pResult->pnValueKey.int_vector_t_val,
%             MIN ( pResult->pnValueKey.int_vector_t_len,
%                   nMap ) *
%             SIZEOF ( *(pResult->pnValueKey.int_vector_t_val) ) );
%  }
%  /* Copy out the pnTypeTagKey argument: */
%  if ( ! ( 
%       pResult->pnTypeTagKey.u_int_vector_t_len != 0 &&
%       pnTypeTagKey == NULL ) ) {
%    memcpy ( pnTypeTagKey,
%             pResult->pnTypeTagKey.u_int_vector_t_val,
%             MIN ( pResult->pnTypeTagKey.u_int_vector_t_len,
%                   nMap ) *
%             SIZEOF ( *(pResult->pnTypeTagKey.u_int_vector_t_val) ) );
%  }
%  /* Copy out the pnValueData argument: */
%  if ( ! ( 
%       pResult->pnValueData.int_vector_t_len != 0 &&
%       pnValueData == NULL ) ) {
%    memcpy ( pnValueData,
%             pResult->pnValueData.int_vector_t_val,
%             MIN ( pResult->pnValueData.int_vector_t_len,
%                   nMap ) *
%             SIZEOF ( *(pResult->pnValueData.int_vector_t_val) ) );
%  }
%  /* Copy out the pnTypeTagData argument: */
%  if ( ! ( 
%       pResult->pnTypeTagData.u_int_vector_t_len != 0 &&
%       pnTypeTagData == NULL ) ) {
%    memcpy ( pnTypeTagData,
%             pResult->pnTypeTagData.u_int_vector_t_val,
%             MIN ( pResult->pnTypeTagData.u_int_vector_t_len,
%                   nMap ) *
%             SIZEOF ( *(pResult->pnTypeTagData.u_int_vector_t_val) ) );
%  }
%
%  if ( pResult && pResult->nErrorLvl ) {
%    /* Server returned a user error message: */
%    char	szErrorMsg [ 1024 ];
%    strncpy ( szErrorMsg,
%              ( pResult->pszErrorMsg && pResult->pszErrorMsg [ 0 ] ) ?
%              (LPCSTR) pResult->pszErrorMsg : (LPCSTR) szEmpty,
%              sizeof ( szErrorMsg ) );
%    szErrorMsg [ sizeof ( szErrorMsg ) - 1 ]	= (char) 0;
%    xdr_free ( (xdrproc_t) xdr_fnServerBtreemapFirst_rets, (char *) pResult );
%    RPC_CLIENT_SERROR ( pResult->nErrorLvl, __procedure__,
%                        szErrorMsg );
%  } else {
%    xdr_free ( (xdrproc_t) xdr_fnServerBtreemapFirst_rets, (char *) pResult );
%  }
%  if ( 
%       lpoShortObjIdMapper == NULL ) {
%    /* Error handling for passing a NULL pointer on */
%    /* out argument: */
%    char	szError [ 256 ];
%    sprintf ( szError, szFormatNullPassed,
%              __procedure__, "lpoShortObjIdMapper" );
%    RPC_CLIENT_CERROR ( szContNullOutPassed, szError );
%  }
%  if ( 
%       pResult->pnValueKey.int_vector_t_len != 0 &&
%       pnValueKey == NULL ) {
%    /* Error handling for passing a NULL pointer on */
%    /* out argument: */
%    char	szError [ 256 ];
%    sprintf ( szError, szFormatNullPassed,
%              __procedure__, "pnValueKey" );
%    RPC_CLIENT_CERROR ( szContNullOutPassed, szError );
%  } else if ( pResult->pnValueKey.int_vector_t_len > nMap ) {
%      /* Error handling for an output buffer overflow, */
%      /* i.e. the buffer size passed is too small: */
%      /* For example, signal a CERROR here ... */
%      char	szError [ 256 ];
%      sprintf ( szError, szFormatBufferOverflow,
%                __procedure__, "pnValueKey", 
%                nMap, 
%                pResult->pnValueKey.int_vector_t_len );
%      RPC_CLIENT_CERROR ( szContBufferOverflow, szError );
%  }
%  if ( 
%       pResult->pnTypeTagKey.u_int_vector_t_len != 0 &&
%       pnTypeTagKey == NULL ) {
%    /* Error handling for passing a NULL pointer on */
%    /* out argument: */
%    char	szError [ 256 ];
%    sprintf ( szError, szFormatNullPassed,
%              __procedure__, "pnTypeTagKey" );
%    RPC_CLIENT_CERROR ( szContNullOutPassed, szError );
%  } else if ( pResult->pnTypeTagKey.u_int_vector_t_len > nMap ) {
%      /* Error handling for an output buffer overflow, */
%      /* i.e. the buffer size passed is too small: */
%      /* For example, signal a CERROR here ... */
%      char	szError [ 256 ];
%      sprintf ( szError, szFormatBufferOverflow,
%                __procedure__, "pnTypeTagKey", 
%                nMap, 
%                pResult->pnTypeTagKey.u_int_vector_t_len );
%      RPC_CLIENT_CERROR ( szContBufferOverflow, szError );
%  }
%  if ( 
%       pResult->pnValueData.int_vector_t_len != 0 &&
%       pnValueData == NULL ) {
%    /* Error handling for passing a NULL pointer on */
%    /* out argument: */
%    char	szError [ 256 ];
%    sprintf ( szError, szFormatNullPassed,
%              __procedure__, "pnValueData" );
%    RPC_CLIENT_CERROR ( szContNullOutPassed, szError );
%  } else if ( pResult->pnValueData.int_vector_t_len > nMap ) {
%      /* Error handling for an output buffer overflow, */
%      /* i.e. the buffer size passed is too small: */
%      /* For example, signal a CERROR here ... */
%      char	szError [ 256 ];
%      sprintf ( szError, szFormatBufferOverflow,
%                __procedure__, "pnValueData", 
%                nMap, 
%                pResult->pnValueData.int_vector_t_len );
%      RPC_CLIENT_CERROR ( szContBufferOverflow, szError );
%  }
%  if ( 
%       pResult->pnTypeTagData.u_int_vector_t_len != 0 &&
%       pnTypeTagData == NULL ) {
%    /* Error handling for passing a NULL pointer on */
%    /* out argument: */
%    char	szError [ 256 ];
%    sprintf ( szError, szFormatNullPassed,
%              __procedure__, "pnTypeTagData" );
%    RPC_CLIENT_CERROR ( szContNullOutPassed, szError );
%  } else if ( pResult->pnTypeTagData.u_int_vector_t_len > nMap ) {
%      /* Error handling for an output buffer overflow, */
%      /* i.e. the buffer size passed is too small: */
%      /* For example, signal a CERROR here ... */
%      char	szError [ 256 ];
%      sprintf ( szError, szFormatBufferOverflow,
%                __procedure__, "pnTypeTagData", 
%                nMap, 
%                pResult->pnTypeTagData.u_int_vector_t_len );
%      RPC_CLIENT_CERROR ( szContBufferOverflow, szError );
%  }
%
%  return Result.ReturnValue;
%
%} /* fnServerBtreemapFirst */
#endif	/* RPC_CLNT */
%
  fnServerBtreemapFirstByFloat_rets fnRpc_fnServerBtreemapFirstByFloat ( fnServerBtreemapFirstByFloat_args ) =  95 ;
%
#if RPC_SVC
%
%extern int fnServerBtreemapFirstByFloat
%	(SHORTOBJID * lpoShortObjIdMapper ,
%	  SHORTOBJID oShortObjIdHeap ,
%	  SHORTOBJID oShortObjIdBTree ,
%	  float fKeyLower ,
%	  SHTYPETAG nTypeTagKeyLower ,
%	  COMPARETAG eCompareLower ,
%	  float fKeyUpper ,
%	  SHTYPETAG nTypeTagKeyUpper ,
%	  COMPARETAG eCompareUpper ,
%	  bool_t bDescending ,
%	  int nMap ,
%	  int * /* _vector_t<nMap> */  pnValueKey ,
%	  u_int * /* _vector_t<nMap> */  pnTypeTagKey ,
%	  int * /* _vector_t<nMap> */  pnValueData ,
%	  u_int * /* _vector_t<nMap> */  pnTypeTagData);
%
%#ifdef MULTITHREAD
%bool_t
%#else
%fnServerBtreemapFirstByFloat_rets *
%#endif
%	PASTE2(fnrpc_fnserverbtreemapfirstbyfloat_1,_SVCSUFFIX)
%		( fnServerBtreemapFirstByFloat_args * pArguments,
%#ifdef MULTITHREAD
%		  fnServerBtreemapFirstByFloat_rets * pResult,
%#endif
%		  struct svc_req * pRequest )
%{
%  static const char	__procedure__[]	= "server:fnrpc_fnserverbtreemapfirstbyfloat_1";
%#ifdef MULTITHREAD
%  typedef bool_t RESULTTYPE;
%#else
%  typedef fnServerBtreemapFirstByFloat_rets * RESULTTYPE;
%#endif
%#ifndef MULTITHREAD
%  static fnServerBtreemapFirstByFloat_rets	Result;
%  RESULTTYPE			pResult = &Result;
%#endif
%  LPCSTR	pszErrorMsg;
%
%  __pRequest__	= pRequest;
%
%  RPC_SERVER_ENTRY();
%
%#ifndef MULTITHREAD
%  if ( pResult->pszErrorMsg == szEmpty ) {
%    pResult->pszErrorMsg	= NULL;
%  }
%  xdr_free ( (xdrproc_t) xdr_fnServerBtreemapFirstByFloat_rets, (char *) pResult );
%#endif
%  pResult->nErrorLvl		= 0;
%
%  pResult->pnValueKey.int_vector_t_len	= pArguments->pnValueKeySize;
%  if ( pArguments->pnValueKeySize == 0 ) {
%    pResult->pnValueKey.int_vector_t_val	= NULL;
%  } else {
%    pResult->pnValueKey.int_vector_t_val	=
%      (int*) malloc ( pArguments->pnValueKeySize *
%               SIZEOF ( *(pResult->pnValueKey.int_vector_t_val) ) );
%    if ( pResult->pnValueKey.int_vector_t_val == NULL ) {
%      char	szError [ 256 ];
%      sprintf ( szError, szFormatMallocFailed,
%                __procedure__, pArguments->pnValueKeySize,
%                "pnValueKey" );
%      RPC_SERVER_ERROR ( szError );
%      return (RESULTTYPE) NULL;
%    }
%  }
%  pResult->pnTypeTagKey.u_int_vector_t_len	= pArguments->pnTypeTagKeySize;
%  if ( pArguments->pnTypeTagKeySize == 0 ) {
%    pResult->pnTypeTagKey.u_int_vector_t_val	= NULL;
%  } else {
%    pResult->pnTypeTagKey.u_int_vector_t_val	=
%      (u_int*) malloc ( pArguments->pnTypeTagKeySize *
%               SIZEOF ( *(pResult->pnTypeTagKey.u_int_vector_t_val) ) );
%    if ( pResult->pnTypeTagKey.u_int_vector_t_val == NULL ) {
%      char	szError [ 256 ];
%      sprintf ( szError, szFormatMallocFailed,
%                __procedure__, pArguments->pnTypeTagKeySize,
%                "pnTypeTagKey" );
%      RPC_SERVER_ERROR ( szError );
%      return (RESULTTYPE) NULL;
%    }
%  }
%  pResult->pnValueData.int_vector_t_len	= pArguments->pnValueDataSize;
%  if ( pArguments->pnValueDataSize == 0 ) {
%    pResult->pnValueData.int_vector_t_val	= NULL;
%  } else {
%    pResult->pnValueData.int_vector_t_val	=
%      (int*) malloc ( pArguments->pnValueDataSize *
%               SIZEOF ( *(pResult->pnValueData.int_vector_t_val) ) );
%    if ( pResult->pnValueData.int_vector_t_val == NULL ) {
%      char	szError [ 256 ];
%      sprintf ( szError, szFormatMallocFailed,
%                __procedure__, pArguments->pnValueDataSize,
%                "pnValueData" );
%      RPC_SERVER_ERROR ( szError );
%      return (RESULTTYPE) NULL;
%    }
%  }
%  pResult->pnTypeTagData.u_int_vector_t_len	= pArguments->pnTypeTagDataSize;
%  if ( pArguments->pnTypeTagDataSize == 0 ) {
%    pResult->pnTypeTagData.u_int_vector_t_val	= NULL;
%  } else {
%    pResult->pnTypeTagData.u_int_vector_t_val	=
%      (u_int*) malloc ( pArguments->pnTypeTagDataSize *
%               SIZEOF ( *(pResult->pnTypeTagData.u_int_vector_t_val) ) );
%    if ( pResult->pnTypeTagData.u_int_vector_t_val == NULL ) {
%      char	szError [ 256 ];
%      sprintf ( szError, szFormatMallocFailed,
%                __procedure__, pArguments->pnTypeTagDataSize,
%                "pnTypeTagData" );
%      RPC_SERVER_ERROR ( szError );
%      return (RESULTTYPE) NULL;
%    }
%  }
%  Reply.bAnswered		= FALSE;
%  Reply.pfnCalled		= (void(*)()) fnServerBtreemapFirstByFloat;
%  Reply.pfnXdrResult		= (bool_t(*)()) xdr_fnServerBtreemapFirstByFloat_rets;
%  Reply.pnErrorLvl		= &pResult->nErrorLvl;
%  Reply.ppszErrorMsg		= (LPCSTR *) &pResult->pszErrorMsg;
%  Reply.pResult		= pResult;
%  Reply.pReturnValue		= &pResult->ReturnValue;
%  Reply.nReturnValueSize	= sizeof ( pResult->ReturnValue );
%
%  pResult->ReturnValue		=
%  fnServerBtreemapFirstByFloat (
%	&pResult->lpoShortObjIdMapper,
%	pArguments->oShortObjIdHeap,
%	pArguments->oShortObjIdBTree,
%	pArguments->fKeyLower,
%	pArguments->nTypeTagKeyLower,
%	pArguments->eCompareLower,
%	pArguments->fKeyUpper,
%	pArguments->nTypeTagKeyUpper,
%	pArguments->eCompareUpper,
%	pArguments->bDescending,
%	pArguments->nMap,
%	pResult->pnValueKey.int_vector_t_val,
%	pResult->pnTypeTagKey.u_int_vector_t_val,
%	pResult->pnValueData.int_vector_t_val,
%	pResult->pnTypeTagData.u_int_vector_t_val );
%
%  if ( Reply.bAnswered ) {
%    __pRequest__	= NULL;
%    return (RESULTTYPE) NULL;
%  }
%
%  pResult->nErrorLvl	= RPC_SERVER_ERRLVL();
%  if ( pResult->nErrorLvl > 0 ) {
%    pszErrorMsg		= RPC_SERVER_ERRMSG();
%    if ( pszErrorMsg && *pszErrorMsg ) {
%      pResult->pszErrorMsg	= strdup ( pszErrorMsg );
%    }
%  }
%  if ( pResult->pszErrorMsg == NULL ) {
%#ifdef MULTITHREAD
%    pResult->pszErrorMsg	= strdup ( szEmpty );
%#else
%    pResult->pszErrorMsg	= (LPSTR) szEmpty;
%#endif
%  }
%  __pRequest__	= NULL;
%  return (RESULTTYPE) pResult;
%} /* fnrpc_fnserverbtreemapfirstbyfloat_1 */
#endif	/* RPC_SVC */
%
#if RPC_CLNT
%int DLLEXPORT fnServerBtreemapFirstByFloat
%	(SHORTOBJID * lpoShortObjIdMapper ,
%	  SHORTOBJID oShortObjIdHeap ,
%	  SHORTOBJID oShortObjIdBTree ,
%	  float fKeyLower ,
%	  SHTYPETAG nTypeTagKeyLower ,
%	  COMPARETAG eCompareLower ,
%	  float fKeyUpper ,
%	  SHTYPETAG nTypeTagKeyUpper ,
%	  COMPARETAG eCompareUpper ,
%	  bool_t bDescending ,
%	  int nMap ,
%	  int * /* _vector_t<nMap> */  pnValueKey ,
%	  u_int * /* _vector_t<nMap> */  pnTypeTagKey ,
%	  int * /* _vector_t<nMap> */  pnValueData ,
%	  u_int * /* _vector_t<nMap> */  pnTypeTagData)
%{
%  static const char	__procedure__[]	= "client:fnServerBtreemapFirstByFloat";
%  static fnServerBtreemapFirstByFloat_rets	ZeroResult;
%  fnServerBtreemapFirstByFloat_rets		* pResult = NULL;
%  fnServerBtreemapFirstByFloat_rets		Result = ZeroResult;
%  fnServerBtreemapFirstByFloat_args	InArguments;
%
%  /* Client initialization: */
%  if ( __bClientInitialize__ ) {
%    __bClientInitialize__	= FALSE;
%    RPC_CLIENT_INITIALIZE();
%  }
%
%#if	CLIENT_CREATE_BY_USER
%  if ( __pClient__ == NULL ) {
%    __pClient__	= RPC_CLIENT_CREATE ( __szHost__, __szTransport__ );
%    if ( __pClient__ == NULL ) {
%      /* Error handling for a not connected client: */
%      char	szError [ 256 ];
%      sprintf ( szError, szFormatNoServer, __procedure__ );
%      RPC_CLIENT_ERROR ( szError );
%      return Result.ReturnValue;
%    }
%  }
%#else
%  while ( __pClient__ == NULL ) {
%    __pClient__	= RPC_CLIENT_CREATE ( __szHost__, __szTransport__ );
%    if ( __pClient__ == NULL ) {
%      /* Error handling for a not connected client: */
%      char	szError [ 256 ];
%      sprintf ( szError, szFormatNoServer, __procedure__ );
%      RPC_CLIENT_CERROR ( szContNoServer, szError );
%    }
%  }
%#endif	/* CLIENT_CREATE_BY_USER */
%
%  /* Copy in the oShortObjIdHeap argument: */
%  InArguments.oShortObjIdHeap	= oShortObjIdHeap;
%  /* Copy in the oShortObjIdBTree argument: */
%  InArguments.oShortObjIdBTree	= oShortObjIdBTree;
%  /* Copy in the fKeyLower argument: */
%  InArguments.fKeyLower	= fKeyLower;
%  /* Copy in the nTypeTagKeyLower argument: */
%  InArguments.nTypeTagKeyLower	= nTypeTagKeyLower;
%  /* Copy in the eCompareLower argument: */
%  InArguments.eCompareLower	= eCompareLower;
%  /* Copy in the fKeyUpper argument: */
%  InArguments.fKeyUpper	= fKeyUpper;
%  /* Copy in the nTypeTagKeyUpper argument: */
%  InArguments.nTypeTagKeyUpper	= nTypeTagKeyUpper;
%  /* Copy in the eCompareUpper argument: */
%  InArguments.eCompareUpper	= eCompareUpper;
%  /* Copy in the bDescending argument: */
%  InArguments.bDescending	= bDescending;
%  /* Copy in the nMap argument: */
%  InArguments.nMap	= nMap;
%  InArguments.pnValueKeySize	= nMap;
%  InArguments.pnTypeTagKeySize	= nMap;
%  InArguments.pnValueDataSize	= nMap;
%  InArguments.pnTypeTagDataSize	= nMap;
%
%  pResult	=
%#ifdef MULTITHREAD
%    (
%#else
%    (fnServerBtreemapFirstByFloat_rets *)
%#endif
%    fnrpc_fnserverbtreemapfirstbyfloat_1 (
%	&InArguments,
%#ifdef MULTITHREAD
%	&Result,
%#endif
%	__pClient__ )
%#ifdef MULTITHREAD
%	== RPC_SUCCESS ) ? &Result : NULL
%#endif
%	;
%
%  if ( pResult == NULL ) {
%    /* Error handling for a failed RPC call, */
%    /* i.e. the server did not respond: */
%    char	szError [ 256 ];
%    sprintf ( szError, szFormatRpcFailed, __procedure__,
%              clnt_sperror ( __pClient__, __szHost__ ) );
%    __pClient__	= RPC_CLIENT_DESTROY ( __pClient__ );
%    RPC_CLIENT_CERROR ( szContRpcFailed, szError );
%    Result	= ZeroResult;
%    return Result.ReturnValue;
%  }
%#ifndef MULTITHREAD
%  Result	= * pResult;
%#endif
%
%  /* Copy out the lpoShortObjIdMapper argument: */
%  if ( ! ( 
%       lpoShortObjIdMapper == NULL ) ) {
%    *lpoShortObjIdMapper	= pResult->lpoShortObjIdMapper;
%  }
%  /* Copy out the pnValueKey argument: */
%  if ( ! ( 
%       pResult->pnValueKey.int_vector_t_len != 0 &&
%       pnValueKey == NULL ) ) {
%    memcpy ( pnValueKey,
%             pResult->pnValueKey.int_vector_t_val,
%             MIN ( pResult->pnValueKey.int_vector_t_len,
%                   nMap ) *
%             SIZEOF ( *(pResult->pnValueKey.int_vector_t_val) ) );
%  }
%  /* Copy out the pnTypeTagKey argument: */
%  if ( ! ( 
%       pResult->pnTypeTagKey.u_int_vector_t_len != 0 &&
%       pnTypeTagKey == NULL ) ) {
%    memcpy ( pnTypeTagKey,
%             pResult->pnTypeTagKey.u_int_vector_t_val,
%             MIN ( pResult->pnTypeTagKey.u_int_vector_t_len,
%                   nMap ) *
%             SIZEOF ( *(pResult->pnTypeTagKey.u_int_vector_t_val) ) );
%  }
%  /* Copy out the pnValueData argument: */
%  if ( ! ( 
%       pResult->pnValueData.int_vector_t_len != 0 &&
%       pnValueData == NULL ) ) {
%    memcpy ( pnValueData,
%             pResult->pnValueData.int_vector_t_val,
%             MIN ( pResult->pnValueData.int_vector_t_len,
%                   nMap ) *
%             SIZEOF ( *(pResult->pnValueData.int_vector_t_val) ) );
%  }
%  /* Copy out the pnTypeTagData argument: */
%  if ( ! ( 
%       pResult->pnTypeTagData.u_int_vector_t_len != 0 &&
%       pnTypeTagData == NULL ) ) {
%    memcpy ( pnTypeTagData,
%             pResult->pnTypeTagData.u_int_vector_t_val,
%             MIN ( pResult->pnTypeTagData.u_int_vector_t_len,
%                   nMap ) *
%             SIZEOF ( *(pResult->pnTypeTagData.u_int_vector_t_val) ) );
%  }
%
%  if ( pResult && pResult->nErrorLvl ) {
%    /* Server returned a user error message: */
%    char	szErrorMsg [ 1024 ];
%    strncpy ( szErrorMsg,
%              ( pResult->pszErrorMsg && pResult->pszErrorMsg [ 0 ] ) ?
%              (LPCSTR) pResult->pszErrorMsg : (LPCSTR) szEmpty,
%              sizeof ( szErrorMsg ) );
%    szErrorMsg [ sizeof ( szErrorMsg ) - 1 ]	= (char) 0;
%    xdr_free ( (xdrproc_t) xdr_fnServerBtreemapFirstByFloat_rets, (char *) pResult );
%    RPC_CLIENT_SERROR ( pResult->nErrorLvl, __procedure__,
%                        szErrorMsg );
%  } else {
%    xdr_free ( (xdrproc_t) xdr_fnServerBtreemapFirstByFloat_rets, (char *) pResult );
%  }
%  if ( 
%       lpoShortObjIdMapper == NULL ) {
%    /* Error handling for passing a NULL pointer on */
%    /* out argument: */
%    char	szError [ 256 ];
%    sprintf ( szError, szFormatNullPassed,
%              __procedure__, "lpoShortObjIdMapper" );
%    RPC_CLIENT_CERROR ( szContNullOutPassed, szError );
%  }
%  if ( 
%       pResult->pnValueKey.int_vector_t_len != 0 &&
%       pnValueKey == NULL ) {
%    /* Error handling for passing a NULL pointer on */
%    /* out argument: */
%    char	szError [ 256 ];
%    sprintf ( szError, szFormatNullPassed,
%              __procedure__, "pnValueKey" );
%    RPC_CLIENT_CERROR ( szContNullOutPassed, szError );
%  } else if ( pResult->pnValueKey.int_vector_t_len > nMap ) {
%      /* Error handling for an output buffer overflow, */
%      /* i.e. the buffer size passed is too small: */
%      /* For example, signal a CERROR here ... */
%      char	szError [ 256 ];
%      sprintf ( szError, szFormatBufferOverflow,
%                __procedure__, "pnValueKey", 
%                nMap, 
%                pResult->pnValueKey.int_vector_t_len );
%      RPC_CLIENT_CERROR ( szContBufferOverflow, szError );
%  }
%  if ( 
%       pResult->pnTypeTagKey.u_int_vector_t_len != 0 &&
%       pnTypeTagKey == NULL ) {
%    /* Error handling for passing a NULL pointer on */
%    /* out argument: */
%    char	szError [ 256 ];
%    sprintf ( szError, szFormatNullPassed,
%              __procedure__, "pnTypeTagKey" );
%    RPC_CLIENT_CERROR ( szContNullOutPassed, szError );
%  } else if ( pResult->pnTypeTagKey.u_int_vector_t_len > nMap ) {
%      /* Error handling for an output buffer overflow, */
%      /* i.e. the buffer size passed is too small: */
%      /* For example, signal a CERROR here ... */
%      char	szError [ 256 ];
%      sprintf ( szError, szFormatBufferOverflow,
%                __procedure__, "pnTypeTagKey", 
%                nMap, 
%                pResult->pnTypeTagKey.u_int_vector_t_len );
%      RPC_CLIENT_CERROR ( szContBufferOverflow, szError );
%  }
%  if ( 
%       pResult->pnValueData.int_vector_t_len != 0 &&
%       pnValueData == NULL ) {
%    /* Error handling for passing a NULL pointer on */
%    /* out argument: */
%    char	szError [ 256 ];
%    sprintf ( szError, szFormatNullPassed,
%              __procedure__, "pnValueData" );
%    RPC_CLIENT_CERROR ( szContNullOutPassed, szError );
%  } else if ( pResult->pnValueData.int_vector_t_len > nMap ) {
%      /* Error handling for an output buffer overflow, */
%      /* i.e. the buffer size passed is too small: */
%      /* For example, signal a CERROR here ... */
%      char	szError [ 256 ];
%      sprintf ( szError, szFormatBufferOverflow,
%                __procedure__, "pnValueData", 
%                nMap, 
%                pResult->pnValueData.int_vector_t_len );
%      RPC_CLIENT_CERROR ( szContBufferOverflow, szError );
%  }
%  if ( 
%       pResult->pnTypeTagData.u_int_vector_t_len != 0 &&
%       pnTypeTagData == NULL ) {
%    /* Error handling for passing a NULL pointer on */
%    /* out argument: */
%    char	szError [ 256 ];
%    sprintf ( szError, szFormatNullPassed,
%              __procedure__, "pnTypeTagData" );
%    RPC_CLIENT_CERROR ( szContNullOutPassed, szError );
%  } else if ( pResult->pnTypeTagData.u_int_vector_t_len > nMap ) {
%      /* Error handling for an output buffer overflow, */
%      /* i.e. the buffer size passed is too small: */
%      /* For example, signal a CERROR here ... */
%      char	szError [ 256 ];
%      sprintf ( szError, szFormatBufferOverflow,
%                __procedure__, "pnTypeTagData", 
%                nMap, 
%                pResult->pnTypeTagData.u_int_vector_t_len );
%      RPC_CLIENT_CERROR ( szContBufferOverflow, szError );
%  }
%
%  return Result.ReturnValue;
%
%} /* fnServerBtreemapFirstByFloat */
#endif	/* RPC_CLNT */
%
  fnServerBtreemapFirstByDouble_rets fnRpc_fnServerBtreemapFirstByDouble ( fnServerBtreemapFirstByDouble_args ) =  96 ;
%
#if RPC_SVC
%
%extern int fnServerBtreemapFirstByDouble
%	(SHORTOBJID * lpoShortObjIdMapper ,
%	  SHORTOBJID oShortObjIdHeap ,
%	  SHORTOBJID oShortObjIdBTree ,
%	  double fKeyLower ,
%	  COMPARETAG eCompareLower ,
%	  SHTYPETAG nTypeTagKeyLower ,
%	  double fKeyUpper ,
%	  SHTYPETAG nTypeTagKeyUpper ,
%	  COMPARETAG eCompareUpper ,
%	  bool_t bDescending ,
%	  int nMap ,
%	  int * /* _vector_t<nMap> */  pnValueKey ,
%	  u_int * /* _vector_t<nMap> */  pnTypeTagKey ,
%	  int * /* _vector_t<nMap> */  pnValueData ,
%	  u_int * /* _vector_t<nMap> */  pnTypeTagData);
%
%#ifdef MULTITHREAD
%bool_t
%#else
%fnServerBtreemapFirstByDouble_rets *
%#endif
%	PASTE2(fnrpc_fnserverbtreemapfirstbydouble_1,_SVCSUFFIX)
%		( fnServerBtreemapFirstByDouble_args * pArguments,
%#ifdef MULTITHREAD
%		  fnServerBtreemapFirstByDouble_rets * pResult,
%#endif
%		  struct svc_req * pRequest )
%{
%  static const char	__procedure__[]	= "server:fnrpc_fnserverbtreemapfirstbydouble_1";
%#ifdef MULTITHREAD
%  typedef bool_t RESULTTYPE;
%#else
%  typedef fnServerBtreemapFirstByDouble_rets * RESULTTYPE;
%#endif
%#ifndef MULTITHREAD
%  static fnServerBtreemapFirstByDouble_rets	Result;
%  RESULTTYPE			pResult = &Result;
%#endif
%  LPCSTR	pszErrorMsg;
%
%  __pRequest__	= pRequest;
%
%  RPC_SERVER_ENTRY();
%
%#ifndef MULTITHREAD
%  if ( pResult->pszErrorMsg == szEmpty ) {
%    pResult->pszErrorMsg	= NULL;
%  }
%  xdr_free ( (xdrproc_t) xdr_fnServerBtreemapFirstByDouble_rets, (char *) pResult );
%#endif
%  pResult->nErrorLvl		= 0;
%
%  pResult->pnValueKey.int_vector_t_len	= pArguments->pnValueKeySize;
%  if ( pArguments->pnValueKeySize == 0 ) {
%    pResult->pnValueKey.int_vector_t_val	= NULL;
%  } else {
%    pResult->pnValueKey.int_vector_t_val	=
%      (int*) malloc ( pArguments->pnValueKeySize *
%               SIZEOF ( *(pResult->pnValueKey.int_vector_t_val) ) );
%    if ( pResult->pnValueKey.int_vector_t_val == NULL ) {
%      char	szError [ 256 ];
%      sprintf ( szError, szFormatMallocFailed,
%                __procedure__, pArguments->pnValueKeySize,
%                "pnValueKey" );
%      RPC_SERVER_ERROR ( szError );
%      return (RESULTTYPE) NULL;
%    }
%  }
%  pResult->pnTypeTagKey.u_int_vector_t_len	= pArguments->pnTypeTagKeySize;
%  if ( pArguments->pnTypeTagKeySize == 0 ) {
%    pResult->pnTypeTagKey.u_int_vector_t_val	= NULL;
%  } else {
%    pResult->pnTypeTagKey.u_int_vector_t_val	=
%      (u_int*) malloc ( pArguments->pnTypeTagKeySize *
%               SIZEOF ( *(pResult->pnTypeTagKey.u_int_vector_t_val) ) );
%    if ( pResult->pnTypeTagKey.u_int_vector_t_val == NULL ) {
%      char	szError [ 256 ];
%      sprintf ( szError, szFormatMallocFailed,
%                __procedure__, pArguments->pnTypeTagKeySize,
%                "pnTypeTagKey" );
%      RPC_SERVER_ERROR ( szError );
%      return (RESULTTYPE) NULL;
%    }
%  }
%  pResult->pnValueData.int_vector_t_len	= pArguments->pnValueDataSize;
%  if ( pArguments->pnValueDataSize == 0 ) {
%    pResult->pnValueData.int_vector_t_val	= NULL;
%  } else {
%    pResult->pnValueData.int_vector_t_val	=
%      (int*) malloc ( pArguments->pnValueDataSize *
%               SIZEOF ( *(pResult->pnValueData.int_vector_t_val) ) );
%    if ( pResult->pnValueData.int_vector_t_val == NULL ) {
%      char	szError [ 256 ];
%      sprintf ( szError, szFormatMallocFailed,
%                __procedure__, pArguments->pnValueDataSize,
%                "pnValueData" );
%      RPC_SERVER_ERROR ( szError );
%      return (RESULTTYPE) NULL;
%    }
%  }
%  pResult->pnTypeTagData.u_int_vector_t_len	= pArguments->pnTypeTagDataSize;
%  if ( pArguments->pnTypeTagDataSize == 0 ) {
%    pResult->pnTypeTagData.u_int_vector_t_val	= NULL;
%  } else {
%    pResult->pnTypeTagData.u_int_vector_t_val	=
%      (u_int*) malloc ( pArguments->pnTypeTagDataSize *
%               SIZEOF ( *(pResult->pnTypeTagData.u_int_vector_t_val) ) );
%    if ( pResult->pnTypeTagData.u_int_vector_t_val == NULL ) {
%      char	szError [ 256 ];
%      sprintf ( szError, szFormatMallocFailed,
%                __procedure__, pArguments->pnTypeTagDataSize,
%                "pnTypeTagData" );
%      RPC_SERVER_ERROR ( szError );
%      return (RESULTTYPE) NULL;
%    }
%  }
%  Reply.bAnswered		= FALSE;
%  Reply.pfnCalled		= (void(*)()) fnServerBtreemapFirstByDouble;
%  Reply.pfnXdrResult		= (bool_t(*)()) xdr_fnServerBtreemapFirstByDouble_rets;
%  Reply.pnErrorLvl		= &pResult->nErrorLvl;
%  Reply.ppszErrorMsg		= (LPCSTR *) &pResult->pszErrorMsg;
%  Reply.pResult		= pResult;
%  Reply.pReturnValue		= &pResult->ReturnValue;
%  Reply.nReturnValueSize	= sizeof ( pResult->ReturnValue );
%
%  pResult->ReturnValue		=
%  fnServerBtreemapFirstByDouble (
%	&pResult->lpoShortObjIdMapper,
%	pArguments->oShortObjIdHeap,
%	pArguments->oShortObjIdBTree,
%	pArguments->fKeyLower,
%	pArguments->eCompareLower,
%	pArguments->nTypeTagKeyLower,
%	pArguments->fKeyUpper,
%	pArguments->nTypeTagKeyUpper,
%	pArguments->eCompareUpper,
%	pArguments->bDescending,
%	pArguments->nMap,
%	pResult->pnValueKey.int_vector_t_val,
%	pResult->pnTypeTagKey.u_int_vector_t_val,
%	pResult->pnValueData.int_vector_t_val,
%	pResult->pnTypeTagData.u_int_vector_t_val );
%
%  if ( Reply.bAnswered ) {
%    __pRequest__	= NULL;
%    return (RESULTTYPE) NULL;
%  }
%
%  pResult->nErrorLvl	= RPC_SERVER_ERRLVL();
%  if ( pResult->nErrorLvl > 0 ) {
%    pszErrorMsg		= RPC_SERVER_ERRMSG();
%    if ( pszErrorMsg && *pszErrorMsg ) {
%      pResult->pszErrorMsg	= strdup ( pszErrorMsg );
%    }
%  }
%  if ( pResult->pszErrorMsg == NULL ) {
%#ifdef MULTITHREAD
%    pResult->pszErrorMsg	= strdup ( szEmpty );
%#else
%    pResult->pszErrorMsg	= (LPSTR) szEmpty;
%#endif
%  }
%  __pRequest__	= NULL;
%  return (RESULTTYPE) pResult;
%} /* fnrpc_fnserverbtreemapfirstbydouble_1 */
#endif	/* RPC_SVC */
%
#if RPC_CLNT
%int DLLEXPORT fnServerBtreemapFirstByDouble
%	(SHORTOBJID * lpoShortObjIdMapper ,
%	  SHORTOBJID oShortObjIdHeap ,
%	  SHORTOBJID oShortObjIdBTree ,
%	  double fKeyLower ,
%	  COMPARETAG eCompareLower ,
%	  SHTYPETAG nTypeTagKeyLower ,
%	  double fKeyUpper ,
%	  SHTYPETAG nTypeTagKeyUpper ,
%	  COMPARETAG eCompareUpper ,
%	  bool_t bDescending ,
%	  int nMap ,
%	  int * /* _vector_t<nMap> */  pnValueKey ,
%	  u_int * /* _vector_t<nMap> */  pnTypeTagKey ,
%	  int * /* _vector_t<nMap> */  pnValueData ,
%	  u_int * /* _vector_t<nMap> */  pnTypeTagData)
%{
%  static const char	__procedure__[]	= "client:fnServerBtreemapFirstByDouble";
%  static fnServerBtreemapFirstByDouble_rets	ZeroResult;
%  fnServerBtreemapFirstByDouble_rets		* pResult = NULL;
%  fnServerBtreemapFirstByDouble_rets		Result = ZeroResult;
%  fnServerBtreemapFirstByDouble_args	InArguments;
%
%  /* Client initialization: */
%  if ( __bClientInitialize__ ) {
%    __bClientInitialize__	= FALSE;
%    RPC_CLIENT_INITIALIZE();
%  }
%
%#if	CLIENT_CREATE_BY_USER
%  if ( __pClient__ == NULL ) {
%    __pClient__	= RPC_CLIENT_CREATE ( __szHost__, __szTransport__ );
%    if ( __pClient__ == NULL ) {
%      /* Error handling for a not connected client: */
%      char	szError [ 256 ];
%      sprintf ( szError, szFormatNoServer, __procedure__ );
%      RPC_CLIENT_ERROR ( szError );
%      return Result.ReturnValue;
%    }
%  }
%#else
%  while ( __pClient__ == NULL ) {
%    __pClient__	= RPC_CLIENT_CREATE ( __szHost__, __szTransport__ );
%    if ( __pClient__ == NULL ) {
%      /* Error handling for a not connected client: */
%      char	szError [ 256 ];
%      sprintf ( szError, szFormatNoServer, __procedure__ );
%      RPC_CLIENT_CERROR ( szContNoServer, szError );
%    }
%  }
%#endif	/* CLIENT_CREATE_BY_USER */
%
%  /* Copy in the oShortObjIdHeap argument: */
%  InArguments.oShortObjIdHeap	= oShortObjIdHeap;
%  /* Copy in the oShortObjIdBTree argument: */
%  InArguments.oShortObjIdBTree	= oShortObjIdBTree;
%  /* Copy in the fKeyLower argument: */
%  InArguments.fKeyLower	= fKeyLower;
%  /* Copy in the eCompareLower argument: */
%  InArguments.eCompareLower	= eCompareLower;
%  /* Copy in the nTypeTagKeyLower argument: */
%  InArguments.nTypeTagKeyLower	= nTypeTagKeyLower;
%  /* Copy in the fKeyUpper argument: */
%  InArguments.fKeyUpper	= fKeyUpper;
%  /* Copy in the nTypeTagKeyUpper argument: */
%  InArguments.nTypeTagKeyUpper	= nTypeTagKeyUpper;
%  /* Copy in the eCompareUpper argument: */
%  InArguments.eCompareUpper	= eCompareUpper;
%  /* Copy in the bDescending argument: */
%  InArguments.bDescending	= bDescending;
%  /* Copy in the nMap argument: */
%  InArguments.nMap	= nMap;
%  InArguments.pnValueKeySize	= nMap;
%  InArguments.pnTypeTagKeySize	= nMap;
%  InArguments.pnValueDataSize	= nMap;
%  InArguments.pnTypeTagDataSize	= nMap;
%
%  pResult	=
%#ifdef MULTITHREAD
%    (
%#else
%    (fnServerBtreemapFirstByDouble_rets *)
%#endif
%    fnrpc_fnserverbtreemapfirstbydouble_1 (
%	&InArguments,
%#ifdef MULTITHREAD
%	&Result,
%#endif
%	__pClient__ )
%#ifdef MULTITHREAD
%	== RPC_SUCCESS ) ? &Result : NULL
%#endif
%	;
%
%  if ( pResult == NULL ) {
%    /* Error handling for a failed RPC call, */
%    /* i.e. the server did not respond: */
%    char	szError [ 256 ];
%    sprintf ( szError, szFormatRpcFailed, __procedure__,
%              clnt_sperror ( __pClient__, __szHost__ ) );
%    __pClient__	= RPC_CLIENT_DESTROY ( __pClient__ );
%    RPC_CLIENT_CERROR ( szContRpcFailed, szError );
%    Result	= ZeroResult;
%    return Result.ReturnValue;
%  }
%#ifndef MULTITHREAD
%  Result	= * pResult;
%#endif
%
%  /* Copy out the lpoShortObjIdMapper argument: */
%  if ( ! ( 
%       lpoShortObjIdMapper == NULL ) ) {
%    *lpoShortObjIdMapper	= pResult->lpoShortObjIdMapper;
%  }
%  /* Copy out the pnValueKey argument: */
%  if ( ! ( 
%       pResult->pnValueKey.int_vector_t_len != 0 &&
%       pnValueKey == NULL ) ) {
%    memcpy ( pnValueKey,
%             pResult->pnValueKey.int_vector_t_val,
%             MIN ( pResult->pnValueKey.int_vector_t_len,
%                   nMap ) *
%             SIZEOF ( *(pResult->pnValueKey.int_vector_t_val) ) );
%  }
%  /* Copy out the pnTypeTagKey argument: */
%  if ( ! ( 
%       pResult->pnTypeTagKey.u_int_vector_t_len != 0 &&
%       pnTypeTagKey == NULL ) ) {
%    memcpy ( pnTypeTagKey,
%             pResult->pnTypeTagKey.u_int_vector_t_val,
%             MIN ( pResult->pnTypeTagKey.u_int_vector_t_len,
%                   nMap ) *
%             SIZEOF ( *(pResult->pnTypeTagKey.u_int_vector_t_val) ) );
%  }
%  /* Copy out the pnValueData argument: */
%  if ( ! ( 
%       pResult->pnValueData.int_vector_t_len != 0 &&
%       pnValueData == NULL ) ) {
%    memcpy ( pnValueData,
%             pResult->pnValueData.int_vector_t_val,
%             MIN ( pResult->pnValueData.int_vector_t_len,
%                   nMap ) *
%             SIZEOF ( *(pResult->pnValueData.int_vector_t_val) ) );
%  }
%  /* Copy out the pnTypeTagData argument: */
%  if ( ! ( 
%       pResult->pnTypeTagData.u_int_vector_t_len != 0 &&
%       pnTypeTagData == NULL ) ) {
%    memcpy ( pnTypeTagData,
%             pResult->pnTypeTagData.u_int_vector_t_val,
%             MIN ( pResult->pnTypeTagData.u_int_vector_t_len,
%                   nMap ) *
%             SIZEOF ( *(pResult->pnTypeTagData.u_int_vector_t_val) ) );
%  }
%
%  if ( pResult && pResult->nErrorLvl ) {
%    /* Server returned a user error message: */
%    char	szErrorMsg [ 1024 ];
%    strncpy ( szErrorMsg,
%              ( pResult->pszErrorMsg && pResult->pszErrorMsg [ 0 ] ) ?
%              (LPCSTR) pResult->pszErrorMsg : (LPCSTR) szEmpty,
%              sizeof ( szErrorMsg ) );
%    szErrorMsg [ sizeof ( szErrorMsg ) - 1 ]	= (char) 0;
%    xdr_free ( (xdrproc_t) xdr_fnServerBtreemapFirstByDouble_rets, (char *) pResult );
%    RPC_CLIENT_SERROR ( pResult->nErrorLvl, __procedure__,
%                        szErrorMsg );
%  } else {
%    xdr_free ( (xdrproc_t) xdr_fnServerBtreemapFirstByDouble_rets, (char *) pResult );
%  }
%  if ( 
%       lpoShortObjIdMapper == NULL ) {
%    /* Error handling for passing a NULL pointer on */
%    /* out argument: */
%    char	szError [ 256 ];
%    sprintf ( szError, szFormatNullPassed,
%              __procedure__, "lpoShortObjIdMapper" );
%    RPC_CLIENT_CERROR ( szContNullOutPassed, szError );
%  }
%  if ( 
%       pResult->pnValueKey.int_vector_t_len != 0 &&
%       pnValueKey == NULL ) {
%    /* Error handling for passing a NULL pointer on */
%    /* out argument: */
%    char	szError [ 256 ];
%    sprintf ( szError, szFormatNullPassed,
%              __procedure__, "pnValueKey" );
%    RPC_CLIENT_CERROR ( szContNullOutPassed, szError );
%  } else if ( pResult->pnValueKey.int_vector_t_len > nMap ) {
%      /* Error handling for an output buffer overflow, */
%      /* i.e. the buffer size passed is too small: */
%      /* For example, signal a CERROR here ... */
%      char	szError [ 256 ];
%      sprintf ( szError, szFormatBufferOverflow,
%                __procedure__, "pnValueKey", 
%                nMap, 
%                pResult->pnValueKey.int_vector_t_len );
%      RPC_CLIENT_CERROR ( szContBufferOverflow, szError );
%  }
%  if ( 
%       pResult->pnTypeTagKey.u_int_vector_t_len != 0 &&
%       pnTypeTagKey == NULL ) {
%    /* Error handling for passing a NULL pointer on */
%    /* out argument: */
%    char	szError [ 256 ];
%    sprintf ( szError, szFormatNullPassed,
%              __procedure__, "pnTypeTagKey" );
%    RPC_CLIENT_CERROR ( szContNullOutPassed, szError );
%  } else if ( pResult->pnTypeTagKey.u_int_vector_t_len > nMap ) {
%      /* Error handling for an output buffer overflow, */
%      /* i.e. the buffer size passed is too small: */
%      /* For example, signal a CERROR here ... */
%      char	szError [ 256 ];
%      sprintf ( szError, szFormatBufferOverflow,
%                __procedure__, "pnTypeTagKey", 
%                nMap, 
%                pResult->pnTypeTagKey.u_int_vector_t_len );
%      RPC_CLIENT_CERROR ( szContBufferOverflow, szError );
%  }
%  if ( 
%       pResult->pnValueData.int_vector_t_len != 0 &&
%       pnValueData == NULL ) {
%    /* Error handling for passing a NULL pointer on */
%    /* out argument: */
%    char	szError [ 256 ];
%    sprintf ( szError, szFormatNullPassed,
%              __procedure__, "pnValueData" );
%    RPC_CLIENT_CERROR ( szContNullOutPassed, szError );
%  } else if ( pResult->pnValueData.int_vector_t_len > nMap ) {
%      /* Error handling for an output buffer overflow, */
%      /* i.e. the buffer size passed is too small: */
%      /* For example, signal a CERROR here ... */
%      char	szError [ 256 ];
%      sprintf ( szError, szFormatBufferOverflow,
%                __procedure__, "pnValueData", 
%                nMap, 
%                pResult->pnValueData.int_vector_t_len );
%      RPC_CLIENT_CERROR ( szContBufferOverflow, szError );
%  }
%  if ( 
%       pResult->pnTypeTagData.u_int_vector_t_len != 0 &&
%       pnTypeTagData == NULL ) {
%    /* Error handling for passing a NULL pointer on */
%    /* out argument: */
%    char	szError [ 256 ];
%    sprintf ( szError, szFormatNullPassed,
%              __procedure__, "pnTypeTagData" );
%    RPC_CLIENT_CERROR ( szContNullOutPassed, szError );
%  } else if ( pResult->pnTypeTagData.u_int_vector_t_len > nMap ) {
%      /* Error handling for an output buffer overflow, */
%      /* i.e. the buffer size passed is too small: */
%      /* For example, signal a CERROR here ... */
%      char	szError [ 256 ];
%      sprintf ( szError, szFormatBufferOverflow,
%                __procedure__, "pnTypeTagData", 
%                nMap, 
%                pResult->pnTypeTagData.u_int_vector_t_len );
%      RPC_CLIENT_CERROR ( szContBufferOverflow, szError );
%  }
%
%  return Result.ReturnValue;
%
%} /* fnServerBtreemapFirstByDouble */
#endif	/* RPC_CLNT */
%
  fnServerBtreemapFirstByString_rets fnRpc_fnServerBtreemapFirstByString ( fnServerBtreemapFirstByString_args ) =  97 ;
%
#if RPC_SVC
%
%extern int fnServerBtreemapFirstByString
%	(SHORTOBJID * lpoShortObjIdMapper ,
%	  SHORTOBJID oShortObjIdHeap ,
%	  SHORTOBJID oShortObjIdBTree ,
%	  string_t /* string_t<@conststring@> */ szKeyLower ,
%	  SHTYPETAG nTypeTagKeyLower ,
%	  COMPARETAG eCompareLower ,
%	  string_t /* string_t<@conststring@> */ szKeyUpper ,
%	  SHTYPETAG nTypeTagKeyUpper ,
%	  COMPARETAG eCompareUpper ,
%	  bool_t bDescending ,
%	  int nMap ,
%	  int * /* _vector_t<nMap> */  pnValueKey ,
%	  u_int * /* _vector_t<nMap> */  pnTypeTagKey ,
%	  int * /* _vector_t<nMap> */  pnValueData ,
%	  u_int * /* _vector_t<nMap> */  pnTypeTagData);
%
%#ifdef MULTITHREAD
%bool_t
%#else
%fnServerBtreemapFirstByString_rets *
%#endif
%	PASTE2(fnrpc_fnserverbtreemapfirstbystring_1,_SVCSUFFIX)
%		( fnServerBtreemapFirstByString_args * pArguments,
%#ifdef MULTITHREAD
%		  fnServerBtreemapFirstByString_rets * pResult,
%#endif
%		  struct svc_req * pRequest )
%{
%  static const char	__procedure__[]	= "server:fnrpc_fnserverbtreemapfirstbystring_1";
%#ifdef MULTITHREAD
%  typedef bool_t RESULTTYPE;
%#else
%  typedef fnServerBtreemapFirstByString_rets * RESULTTYPE;
%#endif
%#ifndef MULTITHREAD
%  static fnServerBtreemapFirstByString_rets	Result;
%  RESULTTYPE			pResult = &Result;
%#endif
%  LPCSTR	pszErrorMsg;
%
%  __pRequest__	= pRequest;
%
%  RPC_SERVER_ENTRY();
%
%#ifndef MULTITHREAD
%  if ( pResult->pszErrorMsg == szEmpty ) {
%    pResult->pszErrorMsg	= NULL;
%  }
%  xdr_free ( (xdrproc_t) xdr_fnServerBtreemapFirstByString_rets, (char *) pResult );
%#endif
%  pResult->nErrorLvl		= 0;
%
%  pResult->pnValueKey.int_vector_t_len	= pArguments->pnValueKeySize;
%  if ( pArguments->pnValueKeySize == 0 ) {
%    pResult->pnValueKey.int_vector_t_val	= NULL;
%  } else {
%    pResult->pnValueKey.int_vector_t_val	=
%      (int*) malloc ( pArguments->pnValueKeySize *
%               SIZEOF ( *(pResult->pnValueKey.int_vector_t_val) ) );
%    if ( pResult->pnValueKey.int_vector_t_val == NULL ) {
%      char	szError [ 256 ];
%      sprintf ( szError, szFormatMallocFailed,
%                __procedure__, pArguments->pnValueKeySize,
%                "pnValueKey" );
%      RPC_SERVER_ERROR ( szError );
%      return (RESULTTYPE) NULL;
%    }
%  }
%  pResult->pnTypeTagKey.u_int_vector_t_len	= pArguments->pnTypeTagKeySize;
%  if ( pArguments->pnTypeTagKeySize == 0 ) {
%    pResult->pnTypeTagKey.u_int_vector_t_val	= NULL;
%  } else {
%    pResult->pnTypeTagKey.u_int_vector_t_val	=
%      (u_int*) malloc ( pArguments->pnTypeTagKeySize *
%               SIZEOF ( *(pResult->pnTypeTagKey.u_int_vector_t_val) ) );
%    if ( pResult->pnTypeTagKey.u_int_vector_t_val == NULL ) {
%      char	szError [ 256 ];
%      sprintf ( szError, szFormatMallocFailed,
%                __procedure__, pArguments->pnTypeTagKeySize,
%                "pnTypeTagKey" );
%      RPC_SERVER_ERROR ( szError );
%      return (RESULTTYPE) NULL;
%    }
%  }
%  pResult->pnValueData.int_vector_t_len	= pArguments->pnValueDataSize;
%  if ( pArguments->pnValueDataSize == 0 ) {
%    pResult->pnValueData.int_vector_t_val	= NULL;
%  } else {
%    pResult->pnValueData.int_vector_t_val	=
%      (int*) malloc ( pArguments->pnValueDataSize *
%               SIZEOF ( *(pResult->pnValueData.int_vector_t_val) ) );
%    if ( pResult->pnValueData.int_vector_t_val == NULL ) {
%      char	szError [ 256 ];
%      sprintf ( szError, szFormatMallocFailed,
%                __procedure__, pArguments->pnValueDataSize,
%                "pnValueData" );
%      RPC_SERVER_ERROR ( szError );
%      return (RESULTTYPE) NULL;
%    }
%  }
%  pResult->pnTypeTagData.u_int_vector_t_len	= pArguments->pnTypeTagDataSize;
%  if ( pArguments->pnTypeTagDataSize == 0 ) {
%    pResult->pnTypeTagData.u_int_vector_t_val	= NULL;
%  } else {
%    pResult->pnTypeTagData.u_int_vector_t_val	=
%      (u_int*) malloc ( pArguments->pnTypeTagDataSize *
%               SIZEOF ( *(pResult->pnTypeTagData.u_int_vector_t_val) ) );
%    if ( pResult->pnTypeTagData.u_int_vector_t_val == NULL ) {
%      char	szError [ 256 ];
%      sprintf ( szError, szFormatMallocFailed,
%                __procedure__, pArguments->pnTypeTagDataSize,
%                "pnTypeTagData" );
%      RPC_SERVER_ERROR ( szError );
%      return (RESULTTYPE) NULL;
%    }
%  }
%  Reply.bAnswered		= FALSE;
%  Reply.pfnCalled		= (void(*)()) fnServerBtreemapFirstByString;
%  Reply.pfnXdrResult		= (bool_t(*)()) xdr_fnServerBtreemapFirstByString_rets;
%  Reply.pnErrorLvl		= &pResult->nErrorLvl;
%  Reply.ppszErrorMsg		= (LPCSTR *) &pResult->pszErrorMsg;
%  Reply.pResult		= pResult;
%  Reply.pReturnValue		= &pResult->ReturnValue;
%  Reply.nReturnValueSize	= sizeof ( pResult->ReturnValue );
%
%  pResult->ReturnValue		=
%  fnServerBtreemapFirstByString (
%	&pResult->lpoShortObjIdMapper,
%	pArguments->oShortObjIdHeap,
%	pArguments->oShortObjIdBTree,
%	pArguments->szKeyLower,
%	pArguments->nTypeTagKeyLower,
%	pArguments->eCompareLower,
%	pArguments->szKeyUpper,
%	pArguments->nTypeTagKeyUpper,
%	pArguments->eCompareUpper,
%	pArguments->bDescending,
%	pArguments->nMap,
%	pResult->pnValueKey.int_vector_t_val,
%	pResult->pnTypeTagKey.u_int_vector_t_val,
%	pResult->pnValueData.int_vector_t_val,
%	pResult->pnTypeTagData.u_int_vector_t_val );
%
%  if ( Reply.bAnswered ) {
%    __pRequest__	= NULL;
%    return (RESULTTYPE) NULL;
%  }
%
%  pResult->nErrorLvl	= RPC_SERVER_ERRLVL();
%  if ( pResult->nErrorLvl > 0 ) {
%    pszErrorMsg		= RPC_SERVER_ERRMSG();
%    if ( pszErrorMsg && *pszErrorMsg ) {
%      pResult->pszErrorMsg	= strdup ( pszErrorMsg );
%    }
%  }
%  if ( pResult->pszErrorMsg == NULL ) {
%#ifdef MULTITHREAD
%    pResult->pszErrorMsg	= strdup ( szEmpty );
%#else
%    pResult->pszErrorMsg	= (LPSTR) szEmpty;
%#endif
%  }
%  __pRequest__	= NULL;
%  return (RESULTTYPE) pResult;
%} /* fnrpc_fnserverbtreemapfirstbystring_1 */
#endif	/* RPC_SVC */
%
#if RPC_CLNT
%int DLLEXPORT fnServerBtreemapFirstByString
%	(SHORTOBJID * lpoShortObjIdMapper ,
%	  SHORTOBJID oShortObjIdHeap ,
%	  SHORTOBJID oShortObjIdBTree ,
%	  string_t /* string_t<@conststring@> */ szKeyLower ,
%	  SHTYPETAG nTypeTagKeyLower ,
%	  COMPARETAG eCompareLower ,
%	  string_t /* string_t<@conststring@> */ szKeyUpper ,
%	  SHTYPETAG nTypeTagKeyUpper ,
%	  COMPARETAG eCompareUpper ,
%	  bool_t bDescending ,
%	  int nMap ,
%	  int * /* _vector_t<nMap> */  pnValueKey ,
%	  u_int * /* _vector_t<nMap> */  pnTypeTagKey ,
%	  int * /* _vector_t<nMap> */  pnValueData ,
%	  u_int * /* _vector_t<nMap> */  pnTypeTagData)
%{
%  static const char	__procedure__[]	= "client:fnServerBtreemapFirstByString";
%  static fnServerBtreemapFirstByString_rets	ZeroResult;
%  fnServerBtreemapFirstByString_rets		* pResult = NULL;
%  fnServerBtreemapFirstByString_rets		Result = ZeroResult;
%  fnServerBtreemapFirstByString_args	InArguments;
%
%  /* Client initialization: */
%  if ( __bClientInitialize__ ) {
%    __bClientInitialize__	= FALSE;
%    RPC_CLIENT_INITIALIZE();
%  }
%
%#if	CLIENT_CREATE_BY_USER
%  if ( __pClient__ == NULL ) {
%    __pClient__	= RPC_CLIENT_CREATE ( __szHost__, __szTransport__ );
%    if ( __pClient__ == NULL ) {
%      /* Error handling for a not connected client: */
%      char	szError [ 256 ];
%      sprintf ( szError, szFormatNoServer, __procedure__ );
%      RPC_CLIENT_ERROR ( szError );
%      return Result.ReturnValue;
%    }
%  }
%#else
%  while ( __pClient__ == NULL ) {
%    __pClient__	= RPC_CLIENT_CREATE ( __szHost__, __szTransport__ );
%    if ( __pClient__ == NULL ) {
%      /* Error handling for a not connected client: */
%      char	szError [ 256 ];
%      sprintf ( szError, szFormatNoServer, __procedure__ );
%      RPC_CLIENT_CERROR ( szContNoServer, szError );
%    }
%  }
%#endif	/* CLIENT_CREATE_BY_USER */
%
%  /* Copy in the oShortObjIdHeap argument: */
%  InArguments.oShortObjIdHeap	= oShortObjIdHeap;
%  /* Copy in the oShortObjIdBTree argument: */
%  InArguments.oShortObjIdBTree	= oShortObjIdBTree;
%  /* Copy in the szKeyLower argument: */
%  InArguments.szKeyLower	= szKeyLower;
%  if ( szKeyLower == NULL ) {
%    /* Error handling for passing a NULL string pointer: */
%    char	szError [ 256 ];
%    InArguments.szKeyLower	= (LPSTR) szEmpty;
%    sprintf ( szError, szFormatNullString,
%              __procedure__, "szKeyLower" );
%    RPC_CLIENT_CERROR ( szContNullString, szError );
%  }
%  /* Copy in the nTypeTagKeyLower argument: */
%  InArguments.nTypeTagKeyLower	= nTypeTagKeyLower;
%  /* Copy in the eCompareLower argument: */
%  InArguments.eCompareLower	= eCompareLower;
%  /* Copy in the szKeyUpper argument: */
%  InArguments.szKeyUpper	= szKeyUpper;
%  if ( szKeyUpper == NULL ) {
%    /* Error handling for passing a NULL string pointer: */
%    char	szError [ 256 ];
%    InArguments.szKeyUpper	= (LPSTR) szEmpty;
%    sprintf ( szError, szFormatNullString,
%              __procedure__, "szKeyUpper" );
%    RPC_CLIENT_CERROR ( szContNullString, szError );
%  }
%  /* Copy in the nTypeTagKeyUpper argument: */
%  InArguments.nTypeTagKeyUpper	= nTypeTagKeyUpper;
%  /* Copy in the eCompareUpper argument: */
%  InArguments.eCompareUpper	= eCompareUpper;
%  /* Copy in the bDescending argument: */
%  InArguments.bDescending	= bDescending;
%  /* Copy in the nMap argument: */
%  InArguments.nMap	= nMap;
%  InArguments.pnValueKeySize	= nMap;
%  InArguments.pnTypeTagKeySize	= nMap;
%  InArguments.pnValueDataSize	= nMap;
%  InArguments.pnTypeTagDataSize	= nMap;
%
%  pResult	=
%#ifdef MULTITHREAD
%    (
%#else
%    (fnServerBtreemapFirstByString_rets *)
%#endif
%    fnrpc_fnserverbtreemapfirstbystring_1 (
%	&InArguments,
%#ifdef MULTITHREAD
%	&Result,
%#endif
%	__pClient__ )
%#ifdef MULTITHREAD
%	== RPC_SUCCESS ) ? &Result : NULL
%#endif
%	;
%
%  if ( pResult == NULL ) {
%    /* Error handling for a failed RPC call, */
%    /* i.e. the server did not respond: */
%    char	szError [ 256 ];
%    sprintf ( szError, szFormatRpcFailed, __procedure__,
%              clnt_sperror ( __pClient__, __szHost__ ) );
%    __pClient__	= RPC_CLIENT_DESTROY ( __pClient__ );
%    RPC_CLIENT_CERROR ( szContRpcFailed, szError );
%    Result	= ZeroResult;
%    return Result.ReturnValue;
%  }
%#ifndef MULTITHREAD
%  Result	= * pResult;
%#endif
%
%  /* Copy out the lpoShortObjIdMapper argument: */
%  if ( ! ( 
%       lpoShortObjIdMapper == NULL ) ) {
%    *lpoShortObjIdMapper	= pResult->lpoShortObjIdMapper;
%  }
%  /* Copy out the pnValueKey argument: */
%  if ( ! ( 
%       pResult->pnValueKey.int_vector_t_len != 0 &&
%       pnValueKey == NULL ) ) {
%    memcpy ( pnValueKey,
%             pResult->pnValueKey.int_vector_t_val,
%             MIN ( pResult->pnValueKey.int_vector_t_len,
%                   nMap ) *
%             SIZEOF ( *(pResult->pnValueKey.int_vector_t_val) ) );
%  }
%  /* Copy out the pnTypeTagKey argument: */
%  if ( ! ( 
%       pResult->pnTypeTagKey.u_int_vector_t_len != 0 &&
%       pnTypeTagKey == NULL ) ) {
%    memcpy ( pnTypeTagKey,
%             pResult->pnTypeTagKey.u_int_vector_t_val,
%             MIN ( pResult->pnTypeTagKey.u_int_vector_t_len,
%                   nMap ) *
%             SIZEOF ( *(pResult->pnTypeTagKey.u_int_vector_t_val) ) );
%  }
%  /* Copy out the pnValueData argument: */
%  if ( ! ( 
%       pResult->pnValueData.int_vector_t_len != 0 &&
%       pnValueData == NULL ) ) {
%    memcpy ( pnValueData,
%             pResult->pnValueData.int_vector_t_val,
%             MIN ( pResult->pnValueData.int_vector_t_len,
%                   nMap ) *
%             SIZEOF ( *(pResult->pnValueData.int_vector_t_val) ) );
%  }
%  /* Copy out the pnTypeTagData argument: */
%  if ( ! ( 
%       pResult->pnTypeTagData.u_int_vector_t_len != 0 &&
%       pnTypeTagData == NULL ) ) {
%    memcpy ( pnTypeTagData,
%             pResult->pnTypeTagData.u_int_vector_t_val,
%             MIN ( pResult->pnTypeTagData.u_int_vector_t_len,
%                   nMap ) *
%             SIZEOF ( *(pResult->pnTypeTagData.u_int_vector_t_val) ) );
%  }
%
%  if ( pResult && pResult->nErrorLvl ) {
%    /* Server returned a user error message: */
%    char	szErrorMsg [ 1024 ];
%    strncpy ( szErrorMsg,
%              ( pResult->pszErrorMsg && pResult->pszErrorMsg [ 0 ] ) ?
%              (LPCSTR) pResult->pszErrorMsg : (LPCSTR) szEmpty,
%              sizeof ( szErrorMsg ) );
%    szErrorMsg [ sizeof ( szErrorMsg ) - 1 ]	= (char) 0;
%    xdr_free ( (xdrproc_t) xdr_fnServerBtreemapFirstByString_rets, (char *) pResult );
%    RPC_CLIENT_SERROR ( pResult->nErrorLvl, __procedure__,
%                        szErrorMsg );
%  } else {
%    xdr_free ( (xdrproc_t) xdr_fnServerBtreemapFirstByString_rets, (char *) pResult );
%  }
%  if ( 
%       lpoShortObjIdMapper == NULL ) {
%    /* Error handling for passing a NULL pointer on */
%    /* out argument: */
%    char	szError [ 256 ];
%    sprintf ( szError, szFormatNullPassed,
%              __procedure__, "lpoShortObjIdMapper" );
%    RPC_CLIENT_CERROR ( szContNullOutPassed, szError );
%  }
%  if ( 
%       pResult->pnValueKey.int_vector_t_len != 0 &&
%       pnValueKey == NULL ) {
%    /* Error handling for passing a NULL pointer on */
%    /* out argument: */
%    char	szError [ 256 ];
%    sprintf ( szError, szFormatNullPassed,
%              __procedure__, "pnValueKey" );
%    RPC_CLIENT_CERROR ( szContNullOutPassed, szError );
%  } else if ( pResult->pnValueKey.int_vector_t_len > nMap ) {
%      /* Error handling for an output buffer overflow, */
%      /* i.e. the buffer size passed is too small: */
%      /* For example, signal a CERROR here ... */
%      char	szError [ 256 ];
%      sprintf ( szError, szFormatBufferOverflow,
%                __procedure__, "pnValueKey", 
%                nMap, 
%                pResult->pnValueKey.int_vector_t_len );
%      RPC_CLIENT_CERROR ( szContBufferOverflow, szError );
%  }
%  if ( 
%       pResult->pnTypeTagKey.u_int_vector_t_len != 0 &&
%       pnTypeTagKey == NULL ) {
%    /* Error handling for passing a NULL pointer on */
%    /* out argument: */
%    char	szError [ 256 ];
%    sprintf ( szError, szFormatNullPassed,
%              __procedure__, "pnTypeTagKey" );
%    RPC_CLIENT_CERROR ( szContNullOutPassed, szError );
%  } else if ( pResult->pnTypeTagKey.u_int_vector_t_len > nMap ) {
%      /* Error handling for an output buffer overflow, */
%      /* i.e. the buffer size passed is too small: */
%      /* For example, signal a CERROR here ... */
%      char	szError [ 256 ];
%      sprintf ( szError, szFormatBufferOverflow,
%                __procedure__, "pnTypeTagKey", 
%                nMap, 
%                pResult->pnTypeTagKey.u_int_vector_t_len );
%      RPC_CLIENT_CERROR ( szContBufferOverflow, szError );
%  }
%  if ( 
%       pResult->pnValueData.int_vector_t_len != 0 &&
%       pnValueData == NULL ) {
%    /* Error handling for passing a NULL pointer on */
%    /* out argument: */
%    char	szError [ 256 ];
%    sprintf ( szError, szFormatNullPassed,
%              __procedure__, "pnValueData" );
%    RPC_CLIENT_CERROR ( szContNullOutPassed, szError );
%  } else if ( pResult->pnValueData.int_vector_t_len > nMap ) {
%      /* Error handling for an output buffer overflow, */
%      /* i.e. the buffer size passed is too small: */
%      /* For example, signal a CERROR here ... */
%      char	szError [ 256 ];
%      sprintf ( szError, szFormatBufferOverflow,
%                __procedure__, "pnValueData", 
%                nMap, 
%                pResult->pnValueData.int_vector_t_len );
%      RPC_CLIENT_CERROR ( szContBufferOverflow, szError );
%  }
%  if ( 
%       pResult->pnTypeTagData.u_int_vector_t_len != 0 &&
%       pnTypeTagData == NULL ) {
%    /* Error handling for passing a NULL pointer on */
%    /* out argument: */
%    char	szError [ 256 ];
%    sprintf ( szError, szFormatNullPassed,
%              __procedure__, "pnTypeTagData" );
%    RPC_CLIENT_CERROR ( szContNullOutPassed, szError );
%  } else if ( pResult->pnTypeTagData.u_int_vector_t_len > nMap ) {
%      /* Error handling for an output buffer overflow, */
%      /* i.e. the buffer size passed is too small: */
%      /* For example, signal a CERROR here ... */
%      char	szError [ 256 ];
%      sprintf ( szError, szFormatBufferOverflow,
%                __procedure__, "pnTypeTagData", 
%                nMap, 
%                pResult->pnTypeTagData.u_int_vector_t_len );
%      RPC_CLIENT_CERROR ( szContBufferOverflow, szError );
%  }
%
%  return Result.ReturnValue;
%
%} /* fnServerBtreemapFirstByString */
#endif	/* RPC_CLNT */
%
  fnClientBtreemapNext_rets fnRpc_fnClientBtreemapNext ( fnClientBtreemapNext_args ) =  98 ;
%
#if RPC_SVC
%
%extern int fnClientBtreemapNext
%	(SHORTOBJID oShortObjIdMapper ,
%	  SHORTOBJID oShortObjIdHeap ,
%	  int nMap ,
%	  int * /* _vector_t<nMap> */  pnValueKey ,
%	  u_int * /* _vector_t<nMap> */  pnTypeTagKey ,
%	  int * /* _vector_t<nMap> */  pnValueData ,
%	  u_int * /* _vector_t<nMap> */  pnTypeTagData);
%
%#ifdef MULTITHREAD
%bool_t
%#else
%fnClientBtreemapNext_rets *
%#endif
%	PASTE2(fnrpc_fnclientbtreemapnext_1,_SVCSUFFIX)
%		( fnClientBtreemapNext_args * pArguments,
%#ifdef MULTITHREAD
%		  fnClientBtreemapNext_rets * pResult,
%#endif
%		  struct svc_req * pRequest )
%{
%  static const char	__procedure__[]	= "server:fnrpc_fnclientbtreemapnext_1";
%#ifdef MULTITHREAD
%  typedef bool_t RESULTTYPE;
%#else
%  typedef fnClientBtreemapNext_rets * RESULTTYPE;
%#endif
%#ifndef MULTITHREAD
%  static fnClientBtreemapNext_rets	Result;
%  RESULTTYPE			pResult = &Result;
%#endif
%  LPCSTR	pszErrorMsg;
%
%  __pRequest__	= pRequest;
%
%  RPC_SERVER_ENTRY();
%
%#ifndef MULTITHREAD
%  if ( pResult->pszErrorMsg == szEmpty ) {
%    pResult->pszErrorMsg	= NULL;
%  }
%  xdr_free ( (xdrproc_t) xdr_fnClientBtreemapNext_rets, (char *) pResult );
%#endif
%  pResult->nErrorLvl		= 0;
%
%  pResult->pnValueKey.int_vector_t_len	= pArguments->pnValueKeySize;
%  if ( pArguments->pnValueKeySize == 0 ) {
%    pResult->pnValueKey.int_vector_t_val	= NULL;
%  } else {
%    pResult->pnValueKey.int_vector_t_val	=
%      (int*) malloc ( pArguments->pnValueKeySize *
%               SIZEOF ( *(pResult->pnValueKey.int_vector_t_val) ) );
%    if ( pResult->pnValueKey.int_vector_t_val == NULL ) {
%      char	szError [ 256 ];
%      sprintf ( szError, szFormatMallocFailed,
%                __procedure__, pArguments->pnValueKeySize,
%                "pnValueKey" );
%      RPC_SERVER_ERROR ( szError );
%      return (RESULTTYPE) NULL;
%    }
%  }
%  pResult->pnTypeTagKey.u_int_vector_t_len	= pArguments->pnTypeTagKeySize;
%  if ( pArguments->pnTypeTagKeySize == 0 ) {
%    pResult->pnTypeTagKey.u_int_vector_t_val	= NULL;
%  } else {
%    pResult->pnTypeTagKey.u_int_vector_t_val	=
%      (u_int*) malloc ( pArguments->pnTypeTagKeySize *
%               SIZEOF ( *(pResult->pnTypeTagKey.u_int_vector_t_val) ) );
%    if ( pResult->pnTypeTagKey.u_int_vector_t_val == NULL ) {
%      char	szError [ 256 ];
%      sprintf ( szError, szFormatMallocFailed,
%                __procedure__, pArguments->pnTypeTagKeySize,
%                "pnTypeTagKey" );
%      RPC_SERVER_ERROR ( szError );
%      return (RESULTTYPE) NULL;
%    }
%  }
%  pResult->pnValueData.int_vector_t_len	= pArguments->pnValueDataSize;
%  if ( pArguments->pnValueDataSize == 0 ) {
%    pResult->pnValueData.int_vector_t_val	= NULL;
%  } else {
%    pResult->pnValueData.int_vector_t_val	=
%      (int*) malloc ( pArguments->pnValueDataSize *
%               SIZEOF ( *(pResult->pnValueData.int_vector_t_val) ) );
%    if ( pResult->pnValueData.int_vector_t_val == NULL ) {
%      char	szError [ 256 ];
%      sprintf ( szError, szFormatMallocFailed,
%                __procedure__, pArguments->pnValueDataSize,
%                "pnValueData" );
%      RPC_SERVER_ERROR ( szError );
%      return (RESULTTYPE) NULL;
%    }
%  }
%  pResult->pnTypeTagData.u_int_vector_t_len	= pArguments->pnTypeTagDataSize;
%  if ( pArguments->pnTypeTagDataSize == 0 ) {
%    pResult->pnTypeTagData.u_int_vector_t_val	= NULL;
%  } else {
%    pResult->pnTypeTagData.u_int_vector_t_val	=
%      (u_int*) malloc ( pArguments->pnTypeTagDataSize *
%               SIZEOF ( *(pResult->pnTypeTagData.u_int_vector_t_val) ) );
%    if ( pResult->pnTypeTagData.u_int_vector_t_val == NULL ) {
%      char	szError [ 256 ];
%      sprintf ( szError, szFormatMallocFailed,
%                __procedure__, pArguments->pnTypeTagDataSize,
%                "pnTypeTagData" );
%      RPC_SERVER_ERROR ( szError );
%      return (RESULTTYPE) NULL;
%    }
%  }
%  Reply.bAnswered		= FALSE;
%  Reply.pfnCalled		= (void(*)()) fnClientBtreemapNext;
%  Reply.pfnXdrResult		= (bool_t(*)()) xdr_fnClientBtreemapNext_rets;
%  Reply.pnErrorLvl		= &pResult->nErrorLvl;
%  Reply.ppszErrorMsg		= (LPCSTR *) &pResult->pszErrorMsg;
%  Reply.pResult		= pResult;
%  Reply.pReturnValue		= &pResult->ReturnValue;
%  Reply.nReturnValueSize	= sizeof ( pResult->ReturnValue );
%
%  pResult->ReturnValue		=
%  fnClientBtreemapNext (
%	pArguments->oShortObjIdMapper,
%	pArguments->oShortObjIdHeap,
%	pArguments->nMap,
%	pResult->pnValueKey.int_vector_t_val,
%	pResult->pnTypeTagKey.u_int_vector_t_val,
%	pResult->pnValueData.int_vector_t_val,
%	pResult->pnTypeTagData.u_int_vector_t_val );
%
%  if ( Reply.bAnswered ) {
%    __pRequest__	= NULL;
%    return (RESULTTYPE) NULL;
%  }
%
%  pResult->nErrorLvl	= RPC_SERVER_ERRLVL();
%  if ( pResult->nErrorLvl > 0 ) {
%    pszErrorMsg		= RPC_SERVER_ERRMSG();
%    if ( pszErrorMsg && *pszErrorMsg ) {
%      pResult->pszErrorMsg	= strdup ( pszErrorMsg );
%    }
%  }
%  if ( pResult->pszErrorMsg == NULL ) {
%#ifdef MULTITHREAD
%    pResult->pszErrorMsg	= strdup ( szEmpty );
%#else
%    pResult->pszErrorMsg	= (LPSTR) szEmpty;
%#endif
%  }
%  __pRequest__	= NULL;
%  return (RESULTTYPE) pResult;
%} /* fnrpc_fnclientbtreemapnext_1 */
#endif	/* RPC_SVC */
%
#if RPC_CLNT
%int DLLEXPORT fnClientBtreemapNext
%	(SHORTOBJID oShortObjIdMapper ,
%	  SHORTOBJID oShortObjIdHeap ,
%	  int nMap ,
%	  int * /* _vector_t<nMap> */  pnValueKey ,
%	  u_int * /* _vector_t<nMap> */  pnTypeTagKey ,
%	  int * /* _vector_t<nMap> */  pnValueData ,
%	  u_int * /* _vector_t<nMap> */  pnTypeTagData)
%{
%  static const char	__procedure__[]	= "client:fnClientBtreemapNext";
%  static fnClientBtreemapNext_rets	ZeroResult;
%  fnClientBtreemapNext_rets		* pResult = NULL;
%  fnClientBtreemapNext_rets		Result = ZeroResult;
%  fnClientBtreemapNext_args	InArguments;
%
%  /* Client initialization: */
%  if ( __bClientInitialize__ ) {
%    __bClientInitialize__	= FALSE;
%    RPC_CLIENT_INITIALIZE();
%  }
%
%#if	CLIENT_CREATE_BY_USER
%  if ( __pClient__ == NULL ) {
%    __pClient__	= RPC_CLIENT_CREATE ( __szHost__, __szTransport__ );
%    if ( __pClient__ == NULL ) {
%      /* Error handling for a not connected client: */
%      char	szError [ 256 ];
%      sprintf ( szError, szFormatNoServer, __procedure__ );
%      RPC_CLIENT_ERROR ( szError );
%      return Result.ReturnValue;
%    }
%  }
%#else
%  while ( __pClient__ == NULL ) {
%    __pClient__	= RPC_CLIENT_CREATE ( __szHost__, __szTransport__ );
%    if ( __pClient__ == NULL ) {
%      /* Error handling for a not connected client: */
%      char	szError [ 256 ];
%      sprintf ( szError, szFormatNoServer, __procedure__ );
%      RPC_CLIENT_CERROR ( szContNoServer, szError );
%    }
%  }
%#endif	/* CLIENT_CREATE_BY_USER */
%
%  /* Copy in the oShortObjIdMapper argument: */
%  InArguments.oShortObjIdMapper	= oShortObjIdMapper;
%  /* Copy in the oShortObjIdHeap argument: */
%  InArguments.oShortObjIdHeap	= oShortObjIdHeap;
%  /* Copy in the nMap argument: */
%  InArguments.nMap	= nMap;
%  InArguments.pnValueKeySize	= nMap;
%  InArguments.pnTypeTagKeySize	= nMap;
%  InArguments.pnValueDataSize	= nMap;
%  InArguments.pnTypeTagDataSize	= nMap;
%
%  pResult	=
%#ifdef MULTITHREAD
%    (
%#else
%    (fnClientBtreemapNext_rets *)
%#endif
%    fnrpc_fnclientbtreemapnext_1 (
%	&InArguments,
%#ifdef MULTITHREAD
%	&Result,
%#endif
%	__pClient__ )
%#ifdef MULTITHREAD
%	== RPC_SUCCESS ) ? &Result : NULL
%#endif
%	;
%
%  if ( pResult == NULL ) {
%    /* Error handling for a failed RPC call, */
%    /* i.e. the server did not respond: */
%    char	szError [ 256 ];
%    sprintf ( szError, szFormatRpcFailed, __procedure__,
%              clnt_sperror ( __pClient__, __szHost__ ) );
%    __pClient__	= RPC_CLIENT_DESTROY ( __pClient__ );
%    RPC_CLIENT_CERROR ( szContRpcFailed, szError );
%    Result	= ZeroResult;
%    return Result.ReturnValue;
%  }
%#ifndef MULTITHREAD
%  Result	= * pResult;
%#endif
%
%  /* Copy out the pnValueKey argument: */
%  if ( ! ( 
%       pResult->pnValueKey.int_vector_t_len != 0 &&
%       pnValueKey == NULL ) ) {
%    memcpy ( pnValueKey,
%             pResult->pnValueKey.int_vector_t_val,
%             MIN ( pResult->pnValueKey.int_vector_t_len,
%                   nMap ) *
%             SIZEOF ( *(pResult->pnValueKey.int_vector_t_val) ) );
%  }
%  /* Copy out the pnTypeTagKey argument: */
%  if ( ! ( 
%       pResult->pnTypeTagKey.u_int_vector_t_len != 0 &&
%       pnTypeTagKey == NULL ) ) {
%    memcpy ( pnTypeTagKey,
%             pResult->pnTypeTagKey.u_int_vector_t_val,
%             MIN ( pResult->pnTypeTagKey.u_int_vector_t_len,
%                   nMap ) *
%             SIZEOF ( *(pResult->pnTypeTagKey.u_int_vector_t_val) ) );
%  }
%  /* Copy out the pnValueData argument: */
%  if ( ! ( 
%       pResult->pnValueData.int_vector_t_len != 0 &&
%       pnValueData == NULL ) ) {
%    memcpy ( pnValueData,
%             pResult->pnValueData.int_vector_t_val,
%             MIN ( pResult->pnValueData.int_vector_t_len,
%                   nMap ) *
%             SIZEOF ( *(pResult->pnValueData.int_vector_t_val) ) );
%  }
%  /* Copy out the pnTypeTagData argument: */
%  if ( ! ( 
%       pResult->pnTypeTagData.u_int_vector_t_len != 0 &&
%       pnTypeTagData == NULL ) ) {
%    memcpy ( pnTypeTagData,
%             pResult->pnTypeTagData.u_int_vector_t_val,
%             MIN ( pResult->pnTypeTagData.u_int_vector_t_len,
%                   nMap ) *
%             SIZEOF ( *(pResult->pnTypeTagData.u_int_vector_t_val) ) );
%  }
%
%  if ( pResult && pResult->nErrorLvl ) {
%    /* Server returned a user error message: */
%    char	szErrorMsg [ 1024 ];
%    strncpy ( szErrorMsg,
%              ( pResult->pszErrorMsg && pResult->pszErrorMsg [ 0 ] ) ?
%              (LPCSTR) pResult->pszErrorMsg : (LPCSTR) szEmpty,
%              sizeof ( szErrorMsg ) );
%    szErrorMsg [ sizeof ( szErrorMsg ) - 1 ]	= (char) 0;
%    xdr_free ( (xdrproc_t) xdr_fnClientBtreemapNext_rets, (char *) pResult );
%    RPC_CLIENT_SERROR ( pResult->nErrorLvl, __procedure__,
%                        szErrorMsg );
%  } else {
%    xdr_free ( (xdrproc_t) xdr_fnClientBtreemapNext_rets, (char *) pResult );
%  }
%  if ( 
%       pResult->pnValueKey.int_vector_t_len != 0 &&
%       pnValueKey == NULL ) {
%    /* Error handling for passing a NULL pointer on */
%    /* out argument: */
%    char	szError [ 256 ];
%    sprintf ( szError, szFormatNullPassed,
%              __procedure__, "pnValueKey" );
%    RPC_CLIENT_CERROR ( szContNullOutPassed, szError );
%  } else if ( pResult->pnValueKey.int_vector_t_len > nMap ) {
%      /* Error handling for an output buffer overflow, */
%      /* i.e. the buffer size passed is too small: */
%      /* For example, signal a CERROR here ... */
%      char	szError [ 256 ];
%      sprintf ( szError, szFormatBufferOverflow,
%                __procedure__, "pnValueKey", 
%                nMap, 
%                pResult->pnValueKey.int_vector_t_len );
%      RPC_CLIENT_CERROR ( szContBufferOverflow, szError );
%  }
%  if ( 
%       pResult->pnTypeTagKey.u_int_vector_t_len != 0 &&
%       pnTypeTagKey == NULL ) {
%    /* Error handling for passing a NULL pointer on */
%    /* out argument: */
%    char	szError [ 256 ];
%    sprintf ( szError, szFormatNullPassed,
%              __procedure__, "pnTypeTagKey" );
%    RPC_CLIENT_CERROR ( szContNullOutPassed, szError );
%  } else if ( pResult->pnTypeTagKey.u_int_vector_t_len > nMap ) {
%      /* Error handling for an output buffer overflow, */
%      /* i.e. the buffer size passed is too small: */
%      /* For example, signal a CERROR here ... */
%      char	szError [ 256 ];
%      sprintf ( szError, szFormatBufferOverflow,
%                __procedure__, "pnTypeTagKey", 
%                nMap, 
%                pResult->pnTypeTagKey.u_int_vector_t_len );
%      RPC_CLIENT_CERROR ( szContBufferOverflow, szError );
%  }
%  if ( 
%       pResult->pnValueData.int_vector_t_len != 0 &&
%       pnValueData == NULL ) {
%    /* Error handling for passing a NULL pointer on */
%    /* out argument: */
%    char	szError [ 256 ];
%    sprintf ( szError, szFormatNullPassed,
%              __procedure__, "pnValueData" );
%    RPC_CLIENT_CERROR ( szContNullOutPassed, szError );
%  } else if ( pResult->pnValueData.int_vector_t_len > nMap ) {
%      /* Error handling for an output buffer overflow, */
%      /* i.e. the buffer size passed is too small: */
%      /* For example, signal a CERROR here ... */
%      char	szError [ 256 ];
%      sprintf ( szError, szFormatBufferOverflow,
%                __procedure__, "pnValueData", 
%                nMap, 
%                pResult->pnValueData.int_vector_t_len );
%      RPC_CLIENT_CERROR ( szContBufferOverflow, szError );
%  }
%  if ( 
%       pResult->pnTypeTagData.u_int_vector_t_len != 0 &&
%       pnTypeTagData == NULL ) {
%    /* Error handling for passing a NULL pointer on */
%    /* out argument: */
%    char	szError [ 256 ];
%    sprintf ( szError, szFormatNullPassed,
%              __procedure__, "pnTypeTagData" );
%    RPC_CLIENT_CERROR ( szContNullOutPassed, szError );
%  } else if ( pResult->pnTypeTagData.u_int_vector_t_len > nMap ) {
%      /* Error handling for an output buffer overflow, */
%      /* i.e. the buffer size passed is too small: */
%      /* For example, signal a CERROR here ... */
%      char	szError [ 256 ];
%      sprintf ( szError, szFormatBufferOverflow,
%                __procedure__, "pnTypeTagData", 
%                nMap, 
%                pResult->pnTypeTagData.u_int_vector_t_len );
%      RPC_CLIENT_CERROR ( szContBufferOverflow, szError );
%  }
%
%  return Result.ReturnValue;
%
%} /* fnClientBtreemapNext */
#endif	/* RPC_CLNT */
%
  fnClientBtreemapLast_rets fnRpc_fnClientBtreemapLast ( fnClientBtreemapLast_args ) =  99 ;
%
#if RPC_SVC
%
%extern SHORTOBJID fnClientBtreemapLast
%	(SHORTOBJID oShortObjIdMapper ,
%	  SHORTOBJID oShortObjIdHeap);
%
%#ifdef MULTITHREAD
%bool_t
%#else
%fnClientBtreemapLast_rets *
%#endif
%	PASTE2(fnrpc_fnclientbtreemaplast_1,_SVCSUFFIX)
%		( fnClientBtreemapLast_args * pArguments,
%#ifdef MULTITHREAD
%		  fnClientBtreemapLast_rets * pResult,
%#endif
%		  struct svc_req * pRequest )
%{
%  static const char	__procedure__[]	= "server:fnrpc_fnclientbtreemaplast_1";
%#ifdef MULTITHREAD
%  typedef bool_t RESULTTYPE;
%#else
%  typedef fnClientBtreemapLast_rets * RESULTTYPE;
%#endif
%#ifndef MULTITHREAD
%  static fnClientBtreemapLast_rets	Result;
%  RESULTTYPE			pResult = &Result;
%#endif
%  LPCSTR	pszErrorMsg;
%
%  __pRequest__	= pRequest;
%
%  RPC_SERVER_ENTRY();
%
%#ifndef MULTITHREAD
%  if ( pResult->pszErrorMsg == szEmpty ) {
%    pResult->pszErrorMsg	= NULL;
%  }
%  xdr_free ( (xdrproc_t) xdr_fnClientBtreemapLast_rets, (char *) pResult );
%#endif
%  pResult->nErrorLvl		= 0;
%
%  Reply.bAnswered		= FALSE;
%  Reply.pfnCalled		= (void(*)()) fnClientBtreemapLast;
%  Reply.pfnXdrResult		= (bool_t(*)()) xdr_fnClientBtreemapLast_rets;
%  Reply.pnErrorLvl		= &pResult->nErrorLvl;
%  Reply.ppszErrorMsg		= (LPCSTR *) &pResult->pszErrorMsg;
%  Reply.pResult		= pResult;
%  Reply.pReturnValue		= &pResult->ReturnValue;
%  Reply.nReturnValueSize	= sizeof ( pResult->ReturnValue );
%
%  pResult->ReturnValue		=
%  fnClientBtreemapLast (
%	pArguments->oShortObjIdMapper,
%	pArguments->oShortObjIdHeap );
%
%  if ( Reply.bAnswered ) {
%    __pRequest__	= NULL;
%    return (RESULTTYPE) NULL;
%  }
%
%  pResult->nErrorLvl	= RPC_SERVER_ERRLVL();
%  if ( pResult->nErrorLvl > 0 ) {
%    pszErrorMsg		= RPC_SERVER_ERRMSG();
%    if ( pszErrorMsg && *pszErrorMsg ) {
%      pResult->pszErrorMsg	= strdup ( pszErrorMsg );
%    }
%  }
%  if ( pResult->pszErrorMsg == NULL ) {
%#ifdef MULTITHREAD
%    pResult->pszErrorMsg	= strdup ( szEmpty );
%#else
%    pResult->pszErrorMsg	= (LPSTR) szEmpty;
%#endif
%  }
%  __pRequest__	= NULL;
%  return (RESULTTYPE) pResult;
%} /* fnrpc_fnclientbtreemaplast_1 */
#endif	/* RPC_SVC */
%
#if RPC_CLNT
%SHORTOBJID DLLEXPORT fnClientBtreemapLast
%	(SHORTOBJID oShortObjIdMapper ,
%	  SHORTOBJID oShortObjIdHeap)
%{
%  static const char	__procedure__[]	= "client:fnClientBtreemapLast";
%  static fnClientBtreemapLast_rets	ZeroResult;
%  fnClientBtreemapLast_rets		* pResult = NULL;
%  fnClientBtreemapLast_rets		Result = ZeroResult;
%  fnClientBtreemapLast_args	InArguments;
%
%  /* Client initialization: */
%  if ( __bClientInitialize__ ) {
%    __bClientInitialize__	= FALSE;
%    RPC_CLIENT_INITIALIZE();
%  }
%
%#if	CLIENT_CREATE_BY_USER
%  if ( __pClient__ == NULL ) {
%    __pClient__	= RPC_CLIENT_CREATE ( __szHost__, __szTransport__ );
%    if ( __pClient__ == NULL ) {
%      /* Error handling for a not connected client: */
%      char	szError [ 256 ];
%      sprintf ( szError, szFormatNoServer, __procedure__ );
%      RPC_CLIENT_ERROR ( szError );
%      return Result.ReturnValue;
%    }
%  }
%#else
%  while ( __pClient__ == NULL ) {
%    __pClient__	= RPC_CLIENT_CREATE ( __szHost__, __szTransport__ );
%    if ( __pClient__ == NULL ) {
%      /* Error handling for a not connected client: */
%      char	szError [ 256 ];
%      sprintf ( szError, szFormatNoServer, __procedure__ );
%      RPC_CLIENT_CERROR ( szContNoServer, szError );
%    }
%  }
%#endif	/* CLIENT_CREATE_BY_USER */
%
%  /* Copy in the oShortObjIdMapper argument: */
%  InArguments.oShortObjIdMapper	= oShortObjIdMapper;
%  /* Copy in the oShortObjIdHeap argument: */
%  InArguments.oShortObjIdHeap	= oShortObjIdHeap;
%
%  pResult	=
%#ifdef MULTITHREAD
%    (
%#else
%    (fnClientBtreemapLast_rets *)
%#endif
%    fnrpc_fnclientbtreemaplast_1 (
%	&InArguments,
%#ifdef MULTITHREAD
%	&Result,
%#endif
%	__pClient__ )
%#ifdef MULTITHREAD
%	== RPC_SUCCESS ) ? &Result : NULL
%#endif
%	;
%
%  if ( pResult == NULL ) {
%    /* Error handling for a failed RPC call, */
%    /* i.e. the server did not respond: */
%    char	szError [ 256 ];
%    sprintf ( szError, szFormatRpcFailed, __procedure__,
%              clnt_sperror ( __pClient__, __szHost__ ) );
%    __pClient__	= RPC_CLIENT_DESTROY ( __pClient__ );
%    RPC_CLIENT_CERROR ( szContRpcFailed, szError );
%    Result	= ZeroResult;
%    return Result.ReturnValue;
%  }
%#ifndef MULTITHREAD
%  Result	= * pResult;
%#endif
%
%
%  if ( pResult && pResult->nErrorLvl ) {
%    /* Server returned a user error message: */
%    char	szErrorMsg [ 1024 ];
%    strncpy ( szErrorMsg,
%              ( pResult->pszErrorMsg && pResult->pszErrorMsg [ 0 ] ) ?
%              (LPCSTR) pResult->pszErrorMsg : (LPCSTR) szEmpty,
%              sizeof ( szErrorMsg ) );
%    szErrorMsg [ sizeof ( szErrorMsg ) - 1 ]	= (char) 0;
%    xdr_free ( (xdrproc_t) xdr_fnClientBtreemapLast_rets, (char *) pResult );
%    RPC_CLIENT_SERROR ( pResult->nErrorLvl, __procedure__,
%                        szErrorMsg );
%  } else {
%    xdr_free ( (xdrproc_t) xdr_fnClientBtreemapLast_rets, (char *) pResult );
%  }
%
%  return Result.ReturnValue;
%
%} /* fnClientBtreemapLast */
#endif	/* RPC_CLNT */
%
  fnClientBtreePrint_rets fnRpc_fnClientBtreePrint ( fnClientBtreePrint_args ) =  100 ;
%
#if RPC_SVC
%
%extern int fnClientBtreePrint
%	(SHORTOBJID oShortObjIdHeap ,
%	  SHORTOBJID oShortObjIdBTree ,
%	  NUMERICSTDSTREAM nStdStream);
%
%#ifdef MULTITHREAD
%bool_t
%#else
%fnClientBtreePrint_rets *
%#endif
%	PASTE2(fnrpc_fnclientbtreeprint_1,_SVCSUFFIX)
%		( fnClientBtreePrint_args * pArguments,
%#ifdef MULTITHREAD
%		  fnClientBtreePrint_rets * pResult,
%#endif
%		  struct svc_req * pRequest )
%{
%  static const char	__procedure__[]	= "server:fnrpc_fnclientbtreeprint_1";
%#ifdef MULTITHREAD
%  typedef bool_t RESULTTYPE;
%#else
%  typedef fnClientBtreePrint_rets * RESULTTYPE;
%#endif
%#ifndef MULTITHREAD
%  static fnClientBtreePrint_rets	Result;
%  RESULTTYPE			pResult = &Result;
%#endif
%  LPCSTR	pszErrorMsg;
%
%  __pRequest__	= pRequest;
%
%  RPC_SERVER_ENTRY();
%
%#ifndef MULTITHREAD
%  if ( pResult->pszErrorMsg == szEmpty ) {
%    pResult->pszErrorMsg	= NULL;
%  }
%  xdr_free ( (xdrproc_t) xdr_fnClientBtreePrint_rets, (char *) pResult );
%#endif
%  pResult->nErrorLvl		= 0;
%
%  Reply.bAnswered		= FALSE;
%  Reply.pfnCalled		= (void(*)()) fnClientBtreePrint;
%  Reply.pfnXdrResult		= (bool_t(*)()) xdr_fnClientBtreePrint_rets;
%  Reply.pnErrorLvl		= &pResult->nErrorLvl;
%  Reply.ppszErrorMsg		= (LPCSTR *) &pResult->pszErrorMsg;
%  Reply.pResult		= pResult;
%  Reply.pReturnValue		= &pResult->ReturnValue;
%  Reply.nReturnValueSize	= sizeof ( pResult->ReturnValue );
%
%  pResult->ReturnValue		=
%  fnClientBtreePrint (
%	pArguments->oShortObjIdHeap,
%	pArguments->oShortObjIdBTree,
%	pArguments->nStdStream );
%
%  if ( Reply.bAnswered ) {
%    __pRequest__	= NULL;
%    return (RESULTTYPE) NULL;
%  }
%
%  pResult->nErrorLvl	= RPC_SERVER_ERRLVL();
%  if ( pResult->nErrorLvl > 0 ) {
%    pszErrorMsg		= RPC_SERVER_ERRMSG();
%    if ( pszErrorMsg && *pszErrorMsg ) {
%      pResult->pszErrorMsg	= strdup ( pszErrorMsg );
%    }
%  }
%  if ( pResult->pszErrorMsg == NULL ) {
%#ifdef MULTITHREAD
%    pResult->pszErrorMsg	= strdup ( szEmpty );
%#else
%    pResult->pszErrorMsg	= (LPSTR) szEmpty;
%#endif
%  }
%  __pRequest__	= NULL;
%  return (RESULTTYPE) pResult;
%} /* fnrpc_fnclientbtreeprint_1 */
#endif	/* RPC_SVC */
%
#if RPC_CLNT
%int DLLEXPORT fnClientBtreePrint
%	(SHORTOBJID oShortObjIdHeap ,
%	  SHORTOBJID oShortObjIdBTree ,
%	  NUMERICSTDSTREAM nStdStream)
%{
%  static const char	__procedure__[]	= "client:fnClientBtreePrint";
%  static fnClientBtreePrint_rets	ZeroResult;
%  fnClientBtreePrint_rets		* pResult = NULL;
%  fnClientBtreePrint_rets		Result = ZeroResult;
%  fnClientBtreePrint_args	InArguments;
%
%  /* Client initialization: */
%  if ( __bClientInitialize__ ) {
%    __bClientInitialize__	= FALSE;
%    RPC_CLIENT_INITIALIZE();
%  }
%
%#if	CLIENT_CREATE_BY_USER
%  if ( __pClient__ == NULL ) {
%    __pClient__	= RPC_CLIENT_CREATE ( __szHost__, __szTransport__ );
%    if ( __pClient__ == NULL ) {
%      /* Error handling for a not connected client: */
%      char	szError [ 256 ];
%      sprintf ( szError, szFormatNoServer, __procedure__ );
%      RPC_CLIENT_ERROR ( szError );
%      return Result.ReturnValue;
%    }
%  }
%#else
%  while ( __pClient__ == NULL ) {
%    __pClient__	= RPC_CLIENT_CREATE ( __szHost__, __szTransport__ );
%    if ( __pClient__ == NULL ) {
%      /* Error handling for a not connected client: */
%      char	szError [ 256 ];
%      sprintf ( szError, szFormatNoServer, __procedure__ );
%      RPC_CLIENT_CERROR ( szContNoServer, szError );
%    }
%  }
%#endif	/* CLIENT_CREATE_BY_USER */
%
%  /* Copy in the oShortObjIdHeap argument: */
%  InArguments.oShortObjIdHeap	= oShortObjIdHeap;
%  /* Copy in the oShortObjIdBTree argument: */
%  InArguments.oShortObjIdBTree	= oShortObjIdBTree;
%  /* Copy in the nStdStream argument: */
%  InArguments.nStdStream	= nStdStream;
%
%  pResult	=
%#ifdef MULTITHREAD
%    (
%#else
%    (fnClientBtreePrint_rets *)
%#endif
%    fnrpc_fnclientbtreeprint_1 (
%	&InArguments,
%#ifdef MULTITHREAD
%	&Result,
%#endif
%	__pClient__ )
%#ifdef MULTITHREAD
%	== RPC_SUCCESS ) ? &Result : NULL
%#endif
%	;
%
%  if ( pResult == NULL ) {
%    /* Error handling for a failed RPC call, */
%    /* i.e. the server did not respond: */
%    char	szError [ 256 ];
%    sprintf ( szError, szFormatRpcFailed, __procedure__,
%              clnt_sperror ( __pClient__, __szHost__ ) );
%    __pClient__	= RPC_CLIENT_DESTROY ( __pClient__ );
%    RPC_CLIENT_CERROR ( szContRpcFailed, szError );
%    Result	= ZeroResult;
%    return Result.ReturnValue;
%  }
%#ifndef MULTITHREAD
%  Result	= * pResult;
%#endif
%
%
%  if ( pResult && pResult->nErrorLvl ) {
%    /* Server returned a user error message: */
%    char	szErrorMsg [ 1024 ];
%    strncpy ( szErrorMsg,
%              ( pResult->pszErrorMsg && pResult->pszErrorMsg [ 0 ] ) ?
%              (LPCSTR) pResult->pszErrorMsg : (LPCSTR) szEmpty,
%              sizeof ( szErrorMsg ) );
%    szErrorMsg [ sizeof ( szErrorMsg ) - 1 ]	= (char) 0;
%    xdr_free ( (xdrproc_t) xdr_fnClientBtreePrint_rets, (char *) pResult );
%    RPC_CLIENT_SERROR ( pResult->nErrorLvl, __procedure__,
%                        szErrorMsg );
%  } else {
%    xdr_free ( (xdrproc_t) xdr_fnClientBtreePrint_rets, (char *) pResult );
%  }
%
%  return Result.ReturnValue;
%
%} /* fnClientBtreePrint */
#endif	/* RPC_CLNT */
%
  fnServerBtreeSearch_rets fnRpc_fnServerBtreeSearch ( fnServerBtreeSearch_args ) =  101 ;
%
#if RPC_SVC
%
%extern BTREERESULT fnServerBtreeSearch
%	(SHORTOBJID oShortObjIdHeap ,
%	  SHORTOBJID oShortObjIdBTree ,
%	  int nValueKey ,
%	  SHTYPETAG nTypeTagKey ,
%	  int * pnValueKey ,
%	  SHTYPETAG * pnTypeTagKey ,
%	  int * pnValueData ,
%	  SHTYPETAG * pnTypeTagData);
%
%#ifdef MULTITHREAD
%bool_t
%#else
%fnServerBtreeSearch_rets *
%#endif
%	PASTE2(fnrpc_fnserverbtreesearch_1,_SVCSUFFIX)
%		( fnServerBtreeSearch_args * pArguments,
%#ifdef MULTITHREAD
%		  fnServerBtreeSearch_rets * pResult,
%#endif
%		  struct svc_req * pRequest )
%{
%  static const char	__procedure__[]	= "server:fnrpc_fnserverbtreesearch_1";
%#ifdef MULTITHREAD
%  typedef bool_t RESULTTYPE;
%#else
%  typedef fnServerBtreeSearch_rets * RESULTTYPE;
%#endif
%#ifndef MULTITHREAD
%  static fnServerBtreeSearch_rets	Result;
%  RESULTTYPE			pResult = &Result;
%#endif
%  LPCSTR	pszErrorMsg;
%
%  __pRequest__	= pRequest;
%
%  RPC_SERVER_ENTRY();
%
%#ifndef MULTITHREAD
%  if ( pResult->pszErrorMsg == szEmpty ) {
%    pResult->pszErrorMsg	= NULL;
%  }
%  xdr_free ( (xdrproc_t) xdr_fnServerBtreeSearch_rets, (char *) pResult );
%#endif
%  pResult->nErrorLvl		= 0;
%
%  Reply.bAnswered		= FALSE;
%  Reply.pfnCalled		= (void(*)()) fnServerBtreeSearch;
%  Reply.pfnXdrResult		= (bool_t(*)()) xdr_fnServerBtreeSearch_rets;
%  Reply.pnErrorLvl		= &pResult->nErrorLvl;
%  Reply.ppszErrorMsg		= (LPCSTR *) &pResult->pszErrorMsg;
%  Reply.pResult		= pResult;
%  Reply.pReturnValue		= &pResult->ReturnValue;
%  Reply.nReturnValueSize	= sizeof ( pResult->ReturnValue );
%
%  pResult->ReturnValue		=
%  fnServerBtreeSearch (
%	pArguments->oShortObjIdHeap,
%	pArguments->oShortObjIdBTree,
%	pArguments->nValueKey,
%	pArguments->nTypeTagKey,
%	&pResult->pnValueKey,
%	&pResult->pnTypeTagKey,
%	&pResult->pnValueData,
%	&pResult->pnTypeTagData );
%
%  if ( Reply.bAnswered ) {
%    __pRequest__	= NULL;
%    return (RESULTTYPE) NULL;
%  }
%
%  pResult->nErrorLvl	= RPC_SERVER_ERRLVL();
%  if ( pResult->nErrorLvl > 0 ) {
%    pszErrorMsg		= RPC_SERVER_ERRMSG();
%    if ( pszErrorMsg && *pszErrorMsg ) {
%      pResult->pszErrorMsg	= strdup ( pszErrorMsg );
%    }
%  }
%  if ( pResult->pszErrorMsg == NULL ) {
%#ifdef MULTITHREAD
%    pResult->pszErrorMsg	= strdup ( szEmpty );
%#else
%    pResult->pszErrorMsg	= (LPSTR) szEmpty;
%#endif
%  }
%  __pRequest__	= NULL;
%  return (RESULTTYPE) pResult;
%} /* fnrpc_fnserverbtreesearch_1 */
#endif	/* RPC_SVC */
%
#if RPC_CLNT
%BTREERESULT DLLEXPORT fnServerBtreeSearch
%	(SHORTOBJID oShortObjIdHeap ,
%	  SHORTOBJID oShortObjIdBTree ,
%	  int nValueKey ,
%	  SHTYPETAG nTypeTagKey ,
%	  int * pnValueKey ,
%	  SHTYPETAG * pnTypeTagKey ,
%	  int * pnValueData ,
%	  SHTYPETAG * pnTypeTagData)
%{
%  static const char	__procedure__[]	= "client:fnServerBtreeSearch";
%  static fnServerBtreeSearch_rets	ZeroResult;
%  fnServerBtreeSearch_rets		* pResult = NULL;
%  fnServerBtreeSearch_rets		Result = ZeroResult;
%  fnServerBtreeSearch_args	InArguments;
%
%  /* Client initialization: */
%  if ( __bClientInitialize__ ) {
%    __bClientInitialize__	= FALSE;
%    RPC_CLIENT_INITIALIZE();
%  }
%
%#if	CLIENT_CREATE_BY_USER
%  if ( __pClient__ == NULL ) {
%    __pClient__	= RPC_CLIENT_CREATE ( __szHost__, __szTransport__ );
%    if ( __pClient__ == NULL ) {
%      /* Error handling for a not connected client: */
%      char	szError [ 256 ];
%      sprintf ( szError, szFormatNoServer, __procedure__ );
%      RPC_CLIENT_ERROR ( szError );
%      return Result.ReturnValue;
%    }
%  }
%#else
%  while ( __pClient__ == NULL ) {
%    __pClient__	= RPC_CLIENT_CREATE ( __szHost__, __szTransport__ );
%    if ( __pClient__ == NULL ) {
%      /* Error handling for a not connected client: */
%      char	szError [ 256 ];
%      sprintf ( szError, szFormatNoServer, __procedure__ );
%      RPC_CLIENT_CERROR ( szContNoServer, szError );
%    }
%  }
%#endif	/* CLIENT_CREATE_BY_USER */
%
%  /* Copy in the oShortObjIdHeap argument: */
%  InArguments.oShortObjIdHeap	= oShortObjIdHeap;
%  /* Copy in the oShortObjIdBTree argument: */
%  InArguments.oShortObjIdBTree	= oShortObjIdBTree;
%  /* Copy in the nValueKey argument: */
%  InArguments.nValueKey	= nValueKey;
%  /* Copy in the nTypeTagKey argument: */
%  InArguments.nTypeTagKey	= nTypeTagKey;
%
%  pResult	=
%#ifdef MULTITHREAD
%    (
%#else
%    (fnServerBtreeSearch_rets *)
%#endif
%    fnrpc_fnserverbtreesearch_1 (
%	&InArguments,
%#ifdef MULTITHREAD
%	&Result,
%#endif
%	__pClient__ )
%#ifdef MULTITHREAD
%	== RPC_SUCCESS ) ? &Result : NULL
%#endif
%	;
%
%  if ( pResult == NULL ) {
%    /* Error handling for a failed RPC call, */
%    /* i.e. the server did not respond: */
%    char	szError [ 256 ];
%    sprintf ( szError, szFormatRpcFailed, __procedure__,
%              clnt_sperror ( __pClient__, __szHost__ ) );
%    __pClient__	= RPC_CLIENT_DESTROY ( __pClient__ );
%    RPC_CLIENT_CERROR ( szContRpcFailed, szError );
%    Result	= ZeroResult;
%    return Result.ReturnValue;
%  }
%#ifndef MULTITHREAD
%  Result	= * pResult;
%#endif
%
%  /* Copy out the pnValueKey argument: */
%  if ( ! ( 
%       pnValueKey == NULL ) ) {
%    *pnValueKey	= pResult->pnValueKey;
%  }
%  /* Copy out the pnTypeTagKey argument: */
%  if ( ! ( 
%       pnTypeTagKey == NULL ) ) {
%    *pnTypeTagKey	= pResult->pnTypeTagKey;
%  }
%  /* Copy out the pnValueData argument: */
%  if ( ! ( 
%       pnValueData == NULL ) ) {
%    *pnValueData	= pResult->pnValueData;
%  }
%  /* Copy out the pnTypeTagData argument: */
%  if ( ! ( 
%       pnTypeTagData == NULL ) ) {
%    *pnTypeTagData	= pResult->pnTypeTagData;
%  }
%
%  if ( pResult && pResult->nErrorLvl ) {
%    /* Server returned a user error message: */
%    char	szErrorMsg [ 1024 ];
%    strncpy ( szErrorMsg,
%              ( pResult->pszErrorMsg && pResult->pszErrorMsg [ 0 ] ) ?
%              (LPCSTR) pResult->pszErrorMsg : (LPCSTR) szEmpty,
%              sizeof ( szErrorMsg ) );
%    szErrorMsg [ sizeof ( szErrorMsg ) - 1 ]	= (char) 0;
%    xdr_free ( (xdrproc_t) xdr_fnServerBtreeSearch_rets, (char *) pResult );
%    RPC_CLIENT_SERROR ( pResult->nErrorLvl, __procedure__,
%                        szErrorMsg );
%  } else {
%    xdr_free ( (xdrproc_t) xdr_fnServerBtreeSearch_rets, (char *) pResult );
%  }
%  if ( 
%       pnValueKey == NULL ) {
%    /* Error handling for passing a NULL pointer on */
%    /* out argument: */
%    char	szError [ 256 ];
%    sprintf ( szError, szFormatNullPassed,
%              __procedure__, "pnValueKey" );
%    RPC_CLIENT_CERROR ( szContNullOutPassed, szError );
%  }
%  if ( 
%       pnTypeTagKey == NULL ) {
%    /* Error handling for passing a NULL pointer on */
%    /* out argument: */
%    char	szError [ 256 ];
%    sprintf ( szError, szFormatNullPassed,
%              __procedure__, "pnTypeTagKey" );
%    RPC_CLIENT_CERROR ( szContNullOutPassed, szError );
%  }
%  if ( 
%       pnValueData == NULL ) {
%    /* Error handling for passing a NULL pointer on */
%    /* out argument: */
%    char	szError [ 256 ];
%    sprintf ( szError, szFormatNullPassed,
%              __procedure__, "pnValueData" );
%    RPC_CLIENT_CERROR ( szContNullOutPassed, szError );
%  }
%  if ( 
%       pnTypeTagData == NULL ) {
%    /* Error handling for passing a NULL pointer on */
%    /* out argument: */
%    char	szError [ 256 ];
%    sprintf ( szError, szFormatNullPassed,
%              __procedure__, "pnTypeTagData" );
%    RPC_CLIENT_CERROR ( szContNullOutPassed, szError );
%  }
%
%  return Result.ReturnValue;
%
%} /* fnServerBtreeSearch */
#endif	/* RPC_CLNT */
%
  fnServerBtreeSearchByFloat_rets fnRpc_fnServerBtreeSearchByFloat ( fnServerBtreeSearchByFloat_args ) =  102 ;
%
#if RPC_SVC
%
%extern BTREERESULT fnServerBtreeSearchByFloat
%	(SHORTOBJID oShortObjIdHeap ,
%	  SHORTOBJID oShortObjIdBTree ,
%	  float fKey ,
%	  SHTYPETAG nTypeTagKey ,
%	  int * pnValueKey ,
%	  SHTYPETAG * pnTypeTagKey ,
%	  int * pnValueData ,
%	  SHTYPETAG * pnTypeTagData);
%
%#ifdef MULTITHREAD
%bool_t
%#else
%fnServerBtreeSearchByFloat_rets *
%#endif
%	PASTE2(fnrpc_fnserverbtreesearchbyfloat_1,_SVCSUFFIX)
%		( fnServerBtreeSearchByFloat_args * pArguments,
%#ifdef MULTITHREAD
%		  fnServerBtreeSearchByFloat_rets * pResult,
%#endif
%		  struct svc_req * pRequest )
%{
%  static const char	__procedure__[]	= "server:fnrpc_fnserverbtreesearchbyfloat_1";
%#ifdef MULTITHREAD
%  typedef bool_t RESULTTYPE;
%#else
%  typedef fnServerBtreeSearchByFloat_rets * RESULTTYPE;
%#endif
%#ifndef MULTITHREAD
%  static fnServerBtreeSearchByFloat_rets	Result;
%  RESULTTYPE			pResult = &Result;
%#endif
%  LPCSTR	pszErrorMsg;
%
%  __pRequest__	= pRequest;
%
%  RPC_SERVER_ENTRY();
%
%#ifndef MULTITHREAD
%  if ( pResult->pszErrorMsg == szEmpty ) {
%    pResult->pszErrorMsg	= NULL;
%  }
%  xdr_free ( (xdrproc_t) xdr_fnServerBtreeSearchByFloat_rets, (char *) pResult );
%#endif
%  pResult->nErrorLvl		= 0;
%
%  Reply.bAnswered		= FALSE;
%  Reply.pfnCalled		= (void(*)()) fnServerBtreeSearchByFloat;
%  Reply.pfnXdrResult		= (bool_t(*)()) xdr_fnServerBtreeSearchByFloat_rets;
%  Reply.pnErrorLvl		= &pResult->nErrorLvl;
%  Reply.ppszErrorMsg		= (LPCSTR *) &pResult->pszErrorMsg;
%  Reply.pResult		= pResult;
%  Reply.pReturnValue		= &pResult->ReturnValue;
%  Reply.nReturnValueSize	= sizeof ( pResult->ReturnValue );
%
%  pResult->ReturnValue		=
%  fnServerBtreeSearchByFloat (
%	pArguments->oShortObjIdHeap,
%	pArguments->oShortObjIdBTree,
%	pArguments->fKey,
%	pArguments->nTypeTagKey,
%	&pResult->pnValueKey,
%	&pResult->pnTypeTagKey,
%	&pResult->pnValueData,
%	&pResult->pnTypeTagData );
%
%  if ( Reply.bAnswered ) {
%    __pRequest__	= NULL;
%    return (RESULTTYPE) NULL;
%  }
%
%  pResult->nErrorLvl	= RPC_SERVER_ERRLVL();
%  if ( pResult->nErrorLvl > 0 ) {
%    pszErrorMsg		= RPC_SERVER_ERRMSG();
%    if ( pszErrorMsg && *pszErrorMsg ) {
%      pResult->pszErrorMsg	= strdup ( pszErrorMsg );
%    }
%  }
%  if ( pResult->pszErrorMsg == NULL ) {
%#ifdef MULTITHREAD
%    pResult->pszErrorMsg	= strdup ( szEmpty );
%#else
%    pResult->pszErrorMsg	= (LPSTR) szEmpty;
%#endif
%  }
%  __pRequest__	= NULL;
%  return (RESULTTYPE) pResult;
%} /* fnrpc_fnserverbtreesearchbyfloat_1 */
#endif	/* RPC_SVC */
%
#if RPC_CLNT
%BTREERESULT DLLEXPORT fnServerBtreeSearchByFloat
%	(SHORTOBJID oShortObjIdHeap ,
%	  SHORTOBJID oShortObjIdBTree ,
%	  float fKey ,
%	  SHTYPETAG nTypeTagKey ,
%	  int * pnValueKey ,
%	  SHTYPETAG * pnTypeTagKey ,
%	  int * pnValueData ,
%	  SHTYPETAG * pnTypeTagData)
%{
%  static const char	__procedure__[]	= "client:fnServerBtreeSearchByFloat";
%  static fnServerBtreeSearchByFloat_rets	ZeroResult;
%  fnServerBtreeSearchByFloat_rets		* pResult = NULL;
%  fnServerBtreeSearchByFloat_rets		Result = ZeroResult;
%  fnServerBtreeSearchByFloat_args	InArguments;
%
%  /* Client initialization: */
%  if ( __bClientInitialize__ ) {
%    __bClientInitialize__	= FALSE;
%    RPC_CLIENT_INITIALIZE();
%  }
%
%#if	CLIENT_CREATE_BY_USER
%  if ( __pClient__ == NULL ) {
%    __pClient__	= RPC_CLIENT_CREATE ( __szHost__, __szTransport__ );
%    if ( __pClient__ == NULL ) {
%      /* Error handling for a not connected client: */
%      char	szError [ 256 ];
%      sprintf ( szError, szFormatNoServer, __procedure__ );
%      RPC_CLIENT_ERROR ( szError );
%      return Result.ReturnValue;
%    }
%  }
%#else
%  while ( __pClient__ == NULL ) {
%    __pClient__	= RPC_CLIENT_CREATE ( __szHost__, __szTransport__ );
%    if ( __pClient__ == NULL ) {
%      /* Error handling for a not connected client: */
%      char	szError [ 256 ];
%      sprintf ( szError, szFormatNoServer, __procedure__ );
%      RPC_CLIENT_CERROR ( szContNoServer, szError );
%    }
%  }
%#endif	/* CLIENT_CREATE_BY_USER */
%
%  /* Copy in the oShortObjIdHeap argument: */
%  InArguments.oShortObjIdHeap	= oShortObjIdHeap;
%  /* Copy in the oShortObjIdBTree argument: */
%  InArguments.oShortObjIdBTree	= oShortObjIdBTree;
%  /* Copy in the fKey argument: */
%  InArguments.fKey	= fKey;
%  /* Copy in the nTypeTagKey argument: */
%  InArguments.nTypeTagKey	= nTypeTagKey;
%
%  pResult	=
%#ifdef MULTITHREAD
%    (
%#else
%    (fnServerBtreeSearchByFloat_rets *)
%#endif
%    fnrpc_fnserverbtreesearchbyfloat_1 (
%	&InArguments,
%#ifdef MULTITHREAD
%	&Result,
%#endif
%	__pClient__ )
%#ifdef MULTITHREAD
%	== RPC_SUCCESS ) ? &Result : NULL
%#endif
%	;
%
%  if ( pResult == NULL ) {
%    /* Error handling for a failed RPC call, */
%    /* i.e. the server did not respond: */
%    char	szError [ 256 ];
%    sprintf ( szError, szFormatRpcFailed, __procedure__,
%              clnt_sperror ( __pClient__, __szHost__ ) );
%    __pClient__	= RPC_CLIENT_DESTROY ( __pClient__ );
%    RPC_CLIENT_CERROR ( szContRpcFailed, szError );
%    Result	= ZeroResult;
%    return Result.ReturnValue;
%  }
%#ifndef MULTITHREAD
%  Result	= * pResult;
%#endif
%
%  /* Copy out the pnValueKey argument: */
%  if ( ! ( 
%       pnValueKey == NULL ) ) {
%    *pnValueKey	= pResult->pnValueKey;
%  }
%  /* Copy out the pnTypeTagKey argument: */
%  if ( ! ( 
%       pnTypeTagKey == NULL ) ) {
%    *pnTypeTagKey	= pResult->pnTypeTagKey;
%  }
%  /* Copy out the pnValueData argument: */
%  if ( ! ( 
%       pnValueData == NULL ) ) {
%    *pnValueData	= pResult->pnValueData;
%  }
%  /* Copy out the pnTypeTagData argument: */
%  if ( ! ( 
%       pnTypeTagData == NULL ) ) {
%    *pnTypeTagData	= pResult->pnTypeTagData;
%  }
%
%  if ( pResult && pResult->nErrorLvl ) {
%    /* Server returned a user error message: */
%    char	szErrorMsg [ 1024 ];
%    strncpy ( szErrorMsg,
%              ( pResult->pszErrorMsg && pResult->pszErrorMsg [ 0 ] ) ?
%              (LPCSTR) pResult->pszErrorMsg : (LPCSTR) szEmpty,
%              sizeof ( szErrorMsg ) );
%    szErrorMsg [ sizeof ( szErrorMsg ) - 1 ]	= (char) 0;
%    xdr_free ( (xdrproc_t) xdr_fnServerBtreeSearchByFloat_rets, (char *) pResult );
%    RPC_CLIENT_SERROR ( pResult->nErrorLvl, __procedure__,
%                        szErrorMsg );
%  } else {
%    xdr_free ( (xdrproc_t) xdr_fnServerBtreeSearchByFloat_rets, (char *) pResult );
%  }
%  if ( 
%       pnValueKey == NULL ) {
%    /* Error handling for passing a NULL pointer on */
%    /* out argument: */
%    char	szError [ 256 ];
%    sprintf ( szError, szFormatNullPassed,
%              __procedure__, "pnValueKey" );
%    RPC_CLIENT_CERROR ( szContNullOutPassed, szError );
%  }
%  if ( 
%       pnTypeTagKey == NULL ) {
%    /* Error handling for passing a NULL pointer on */
%    /* out argument: */
%    char	szError [ 256 ];
%    sprintf ( szError, szFormatNullPassed,
%              __procedure__, "pnTypeTagKey" );
%    RPC_CLIENT_CERROR ( szContNullOutPassed, szError );
%  }
%  if ( 
%       pnValueData == NULL ) {
%    /* Error handling for passing a NULL pointer on */
%    /* out argument: */
%    char	szError [ 256 ];
%    sprintf ( szError, szFormatNullPassed,
%              __procedure__, "pnValueData" );
%    RPC_CLIENT_CERROR ( szContNullOutPassed, szError );
%  }
%  if ( 
%       pnTypeTagData == NULL ) {
%    /* Error handling for passing a NULL pointer on */
%    /* out argument: */
%    char	szError [ 256 ];
%    sprintf ( szError, szFormatNullPassed,
%              __procedure__, "pnTypeTagData" );
%    RPC_CLIENT_CERROR ( szContNullOutPassed, szError );
%  }
%
%  return Result.ReturnValue;
%
%} /* fnServerBtreeSearchByFloat */
#endif	/* RPC_CLNT */
%
  fnServerBtreeSearchByDouble_rets fnRpc_fnServerBtreeSearchByDouble ( fnServerBtreeSearchByDouble_args ) =  103 ;
%
#if RPC_SVC
%
%extern BTREERESULT fnServerBtreeSearchByDouble
%	(SHORTOBJID oShortObjIdHeap ,
%	  SHORTOBJID oShortObjIdBTree ,
%	  double fKey ,
%	  SHTYPETAG nTypeTagKey ,
%	  int * pnValueKey ,
%	  SHTYPETAG * pnTypeTagKey ,
%	  int * pnValueData ,
%	  SHTYPETAG * pnTypeTagData);
%
%#ifdef MULTITHREAD
%bool_t
%#else
%fnServerBtreeSearchByDouble_rets *
%#endif
%	PASTE2(fnrpc_fnserverbtreesearchbydouble_1,_SVCSUFFIX)
%		( fnServerBtreeSearchByDouble_args * pArguments,
%#ifdef MULTITHREAD
%		  fnServerBtreeSearchByDouble_rets * pResult,
%#endif
%		  struct svc_req * pRequest )
%{
%  static const char	__procedure__[]	= "server:fnrpc_fnserverbtreesearchbydouble_1";
%#ifdef MULTITHREAD
%  typedef bool_t RESULTTYPE;
%#else
%  typedef fnServerBtreeSearchByDouble_rets * RESULTTYPE;
%#endif
%#ifndef MULTITHREAD
%  static fnServerBtreeSearchByDouble_rets	Result;
%  RESULTTYPE			pResult = &Result;
%#endif
%  LPCSTR	pszErrorMsg;
%
%  __pRequest__	= pRequest;
%
%  RPC_SERVER_ENTRY();
%
%#ifndef MULTITHREAD
%  if ( pResult->pszErrorMsg == szEmpty ) {
%    pResult->pszErrorMsg	= NULL;
%  }
%  xdr_free ( (xdrproc_t) xdr_fnServerBtreeSearchByDouble_rets, (char *) pResult );
%#endif
%  pResult->nErrorLvl		= 0;
%
%  Reply.bAnswered		= FALSE;
%  Reply.pfnCalled		= (void(*)()) fnServerBtreeSearchByDouble;
%  Reply.pfnXdrResult		= (bool_t(*)()) xdr_fnServerBtreeSearchByDouble_rets;
%  Reply.pnErrorLvl		= &pResult->nErrorLvl;
%  Reply.ppszErrorMsg		= (LPCSTR *) &pResult->pszErrorMsg;
%  Reply.pResult		= pResult;
%  Reply.pReturnValue		= &pResult->ReturnValue;
%  Reply.nReturnValueSize	= sizeof ( pResult->ReturnValue );
%
%  pResult->ReturnValue		=
%  fnServerBtreeSearchByDouble (
%	pArguments->oShortObjIdHeap,
%	pArguments->oShortObjIdBTree,
%	pArguments->fKey,
%	pArguments->nTypeTagKey,
%	&pResult->pnValueKey,
%	&pResult->pnTypeTagKey,
%	&pResult->pnValueData,
%	&pResult->pnTypeTagData );
%
%  if ( Reply.bAnswered ) {
%    __pRequest__	= NULL;
%    return (RESULTTYPE) NULL;
%  }
%
%  pResult->nErrorLvl	= RPC_SERVER_ERRLVL();
%  if ( pResult->nErrorLvl > 0 ) {
%    pszErrorMsg		= RPC_SERVER_ERRMSG();
%    if ( pszErrorMsg && *pszErrorMsg ) {
%      pResult->pszErrorMsg	= strdup ( pszErrorMsg );
%    }
%  }
%  if ( pResult->pszErrorMsg == NULL ) {
%#ifdef MULTITHREAD
%    pResult->pszErrorMsg	= strdup ( szEmpty );
%#else
%    pResult->pszErrorMsg	= (LPSTR) szEmpty;
%#endif
%  }
%  __pRequest__	= NULL;
%  return (RESULTTYPE) pResult;
%} /* fnrpc_fnserverbtreesearchbydouble_1 */
#endif	/* RPC_SVC */
%
#if RPC_CLNT
%BTREERESULT DLLEXPORT fnServerBtreeSearchByDouble
%	(SHORTOBJID oShortObjIdHeap ,
%	  SHORTOBJID oShortObjIdBTree ,
%	  double fKey ,
%	  SHTYPETAG nTypeTagKey ,
%	  int * pnValueKey ,
%	  SHTYPETAG * pnTypeTagKey ,
%	  int * pnValueData ,
%	  SHTYPETAG * pnTypeTagData)
%{
%  static const char	__procedure__[]	= "client:fnServerBtreeSearchByDouble";
%  static fnServerBtreeSearchByDouble_rets	ZeroResult;
%  fnServerBtreeSearchByDouble_rets		* pResult = NULL;
%  fnServerBtreeSearchByDouble_rets		Result = ZeroResult;
%  fnServerBtreeSearchByDouble_args	InArguments;
%
%  /* Client initialization: */
%  if ( __bClientInitialize__ ) {
%    __bClientInitialize__	= FALSE;
%    RPC_CLIENT_INITIALIZE();
%  }
%
%#if	CLIENT_CREATE_BY_USER
%  if ( __pClient__ == NULL ) {
%    __pClient__	= RPC_CLIENT_CREATE ( __szHost__, __szTransport__ );
%    if ( __pClient__ == NULL ) {
%      /* Error handling for a not connected client: */
%      char	szError [ 256 ];
%      sprintf ( szError, szFormatNoServer, __procedure__ );
%      RPC_CLIENT_ERROR ( szError );
%      return Result.ReturnValue;
%    }
%  }
%#else
%  while ( __pClient__ == NULL ) {
%    __pClient__	= RPC_CLIENT_CREATE ( __szHost__, __szTransport__ );
%    if ( __pClient__ == NULL ) {
%      /* Error handling for a not connected client: */
%      char	szError [ 256 ];
%      sprintf ( szError, szFormatNoServer, __procedure__ );
%      RPC_CLIENT_CERROR ( szContNoServer, szError );
%    }
%  }
%#endif	/* CLIENT_CREATE_BY_USER */
%
%  /* Copy in the oShortObjIdHeap argument: */
%  InArguments.oShortObjIdHeap	= oShortObjIdHeap;
%  /* Copy in the oShortObjIdBTree argument: */
%  InArguments.oShortObjIdBTree	= oShortObjIdBTree;
%  /* Copy in the fKey argument: */
%  InArguments.fKey	= fKey;
%  /* Copy in the nTypeTagKey argument: */
%  InArguments.nTypeTagKey	= nTypeTagKey;
%
%  pResult	=
%#ifdef MULTITHREAD
%    (
%#else
%    (fnServerBtreeSearchByDouble_rets *)
%#endif
%    fnrpc_fnserverbtreesearchbydouble_1 (
%	&InArguments,
%#ifdef MULTITHREAD
%	&Result,
%#endif
%	__pClient__ )
%#ifdef MULTITHREAD
%	== RPC_SUCCESS ) ? &Result : NULL
%#endif
%	;
%
%  if ( pResult == NULL ) {
%    /* Error handling for a failed RPC call, */
%    /* i.e. the server did not respond: */
%    char	szError [ 256 ];
%    sprintf ( szError, szFormatRpcFailed, __procedure__,
%              clnt_sperror ( __pClient__, __szHost__ ) );
%    __pClient__	= RPC_CLIENT_DESTROY ( __pClient__ );
%    RPC_CLIENT_CERROR ( szContRpcFailed, szError );
%    Result	= ZeroResult;
%    return Result.ReturnValue;
%  }
%#ifndef MULTITHREAD
%  Result	= * pResult;
%#endif
%
%  /* Copy out the pnValueKey argument: */
%  if ( ! ( 
%       pnValueKey == NULL ) ) {
%    *pnValueKey	= pResult->pnValueKey;
%  }
%  /* Copy out the pnTypeTagKey argument: */
%  if ( ! ( 
%       pnTypeTagKey == NULL ) ) {
%    *pnTypeTagKey	= pResult->pnTypeTagKey;
%  }
%  /* Copy out the pnValueData argument: */
%  if ( ! ( 
%       pnValueData == NULL ) ) {
%    *pnValueData	= pResult->pnValueData;
%  }
%  /* Copy out the pnTypeTagData argument: */
%  if ( ! ( 
%       pnTypeTagData == NULL ) ) {
%    *pnTypeTagData	= pResult->pnTypeTagData;
%  }
%
%  if ( pResult && pResult->nErrorLvl ) {
%    /* Server returned a user error message: */
%    char	szErrorMsg [ 1024 ];
%    strncpy ( szErrorMsg,
%              ( pResult->pszErrorMsg && pResult->pszErrorMsg [ 0 ] ) ?
%              (LPCSTR) pResult->pszErrorMsg : (LPCSTR) szEmpty,
%              sizeof ( szErrorMsg ) );
%    szErrorMsg [ sizeof ( szErrorMsg ) - 1 ]	= (char) 0;
%    xdr_free ( (xdrproc_t) xdr_fnServerBtreeSearchByDouble_rets, (char *) pResult );
%    RPC_CLIENT_SERROR ( pResult->nErrorLvl, __procedure__,
%                        szErrorMsg );
%  } else {
%    xdr_free ( (xdrproc_t) xdr_fnServerBtreeSearchByDouble_rets, (char *) pResult );
%  }
%  if ( 
%       pnValueKey == NULL ) {
%    /* Error handling for passing a NULL pointer on */
%    /* out argument: */
%    char	szError [ 256 ];
%    sprintf ( szError, szFormatNullPassed,
%              __procedure__, "pnValueKey" );
%    RPC_CLIENT_CERROR ( szContNullOutPassed, szError );
%  }
%  if ( 
%       pnTypeTagKey == NULL ) {
%    /* Error handling for passing a NULL pointer on */
%    /* out argument: */
%    char	szError [ 256 ];
%    sprintf ( szError, szFormatNullPassed,
%              __procedure__, "pnTypeTagKey" );
%    RPC_CLIENT_CERROR ( szContNullOutPassed, szError );
%  }
%  if ( 
%       pnValueData == NULL ) {
%    /* Error handling for passing a NULL pointer on */
%    /* out argument: */
%    char	szError [ 256 ];
%    sprintf ( szError, szFormatNullPassed,
%              __procedure__, "pnValueData" );
%    RPC_CLIENT_CERROR ( szContNullOutPassed, szError );
%  }
%  if ( 
%       pnTypeTagData == NULL ) {
%    /* Error handling for passing a NULL pointer on */
%    /* out argument: */
%    char	szError [ 256 ];
%    sprintf ( szError, szFormatNullPassed,
%              __procedure__, "pnTypeTagData" );
%    RPC_CLIENT_CERROR ( szContNullOutPassed, szError );
%  }
%
%  return Result.ReturnValue;
%
%} /* fnServerBtreeSearchByDouble */
#endif	/* RPC_CLNT */
%
  fnServerBtreeSearchByString_rets fnRpc_fnServerBtreeSearchByString ( fnServerBtreeSearchByString_args ) =  104 ;
%
#if RPC_SVC
%
%extern BTREERESULT fnServerBtreeSearchByString
%	(SHORTOBJID oShortObjIdHeap ,
%	  SHORTOBJID oShortObjIdBTree ,
%	  string_t /* string_t<@conststring@> */ szKey ,
%	  SHTYPETAG nTypeTagKey ,
%	  int * pnValueKey ,
%	  SHTYPETAG * pnTypeTagKey ,
%	  int * pnValueData ,
%	  SHTYPETAG * pnTypeTagData);
%
%#ifdef MULTITHREAD
%bool_t
%#else
%fnServerBtreeSearchByString_rets *
%#endif
%	PASTE2(fnrpc_fnserverbtreesearchbystring_1,_SVCSUFFIX)
%		( fnServerBtreeSearchByString_args * pArguments,
%#ifdef MULTITHREAD
%		  fnServerBtreeSearchByString_rets * pResult,
%#endif
%		  struct svc_req * pRequest )
%{
%  static const char	__procedure__[]	= "server:fnrpc_fnserverbtreesearchbystring_1";
%#ifdef MULTITHREAD
%  typedef bool_t RESULTTYPE;
%#else
%  typedef fnServerBtreeSearchByString_rets * RESULTTYPE;
%#endif
%#ifndef MULTITHREAD
%  static fnServerBtreeSearchByString_rets	Result;
%  RESULTTYPE			pResult = &Result;
%#endif
%  LPCSTR	pszErrorMsg;
%
%  __pRequest__	= pRequest;
%
%  RPC_SERVER_ENTRY();
%
%#ifndef MULTITHREAD
%  if ( pResult->pszErrorMsg == szEmpty ) {
%    pResult->pszErrorMsg	= NULL;
%  }
%  xdr_free ( (xdrproc_t) xdr_fnServerBtreeSearchByString_rets, (char *) pResult );
%#endif
%  pResult->nErrorLvl		= 0;
%
%  Reply.bAnswered		= FALSE;
%  Reply.pfnCalled		= (void(*)()) fnServerBtreeSearchByString;
%  Reply.pfnXdrResult		= (bool_t(*)()) xdr_fnServerBtreeSearchByString_rets;
%  Reply.pnErrorLvl		= &pResult->nErrorLvl;
%  Reply.ppszErrorMsg		= (LPCSTR *) &pResult->pszErrorMsg;
%  Reply.pResult		= pResult;
%  Reply.pReturnValue		= &pResult->ReturnValue;
%  Reply.nReturnValueSize	= sizeof ( pResult->ReturnValue );
%
%  pResult->ReturnValue		=
%  fnServerBtreeSearchByString (
%	pArguments->oShortObjIdHeap,
%	pArguments->oShortObjIdBTree,
%	pArguments->szKey,
%	pArguments->nTypeTagKey,
%	&pResult->pnValueKey,
%	&pResult->pnTypeTagKey,
%	&pResult->pnValueData,
%	&pResult->pnTypeTagData );
%
%  if ( Reply.bAnswered ) {
%    __pRequest__	= NULL;
%    return (RESULTTYPE) NULL;
%  }
%
%  pResult->nErrorLvl	= RPC_SERVER_ERRLVL();
%  if ( pResult->nErrorLvl > 0 ) {
%    pszErrorMsg		= RPC_SERVER_ERRMSG();
%    if ( pszErrorMsg && *pszErrorMsg ) {
%      pResult->pszErrorMsg	= strdup ( pszErrorMsg );
%    }
%  }
%  if ( pResult->pszErrorMsg == NULL ) {
%#ifdef MULTITHREAD
%    pResult->pszErrorMsg	= strdup ( szEmpty );
%#else
%    pResult->pszErrorMsg	= (LPSTR) szEmpty;
%#endif
%  }
%  __pRequest__	= NULL;
%  return (RESULTTYPE) pResult;
%} /* fnrpc_fnserverbtreesearchbystring_1 */
#endif	/* RPC_SVC */
%
#if RPC_CLNT
%BTREERESULT DLLEXPORT fnServerBtreeSearchByString
%	(SHORTOBJID oShortObjIdHeap ,
%	  SHORTOBJID oShortObjIdBTree ,
%	  string_t /* string_t<@conststring@> */ szKey ,
%	  SHTYPETAG nTypeTagKey ,
%	  int * pnValueKey ,
%	  SHTYPETAG * pnTypeTagKey ,
%	  int * pnValueData ,
%	  SHTYPETAG * pnTypeTagData)
%{
%  static const char	__procedure__[]	= "client:fnServerBtreeSearchByString";
%  static fnServerBtreeSearchByString_rets	ZeroResult;
%  fnServerBtreeSearchByString_rets		* pResult = NULL;
%  fnServerBtreeSearchByString_rets		Result = ZeroResult;
%  fnServerBtreeSearchByString_args	InArguments;
%
%  /* Client initialization: */
%  if ( __bClientInitialize__ ) {
%    __bClientInitialize__	= FALSE;
%    RPC_CLIENT_INITIALIZE();
%  }
%
%#if	CLIENT_CREATE_BY_USER
%  if ( __pClient__ == NULL ) {
%    __pClient__	= RPC_CLIENT_CREATE ( __szHost__, __szTransport__ );
%    if ( __pClient__ == NULL ) {
%      /* Error handling for a not connected client: */
%      char	szError [ 256 ];
%      sprintf ( szError, szFormatNoServer, __procedure__ );
%      RPC_CLIENT_ERROR ( szError );
%      return Result.ReturnValue;
%    }
%  }
%#else
%  while ( __pClient__ == NULL ) {
%    __pClient__	= RPC_CLIENT_CREATE ( __szHost__, __szTransport__ );
%    if ( __pClient__ == NULL ) {
%      /* Error handling for a not connected client: */
%      char	szError [ 256 ];
%      sprintf ( szError, szFormatNoServer, __procedure__ );
%      RPC_CLIENT_CERROR ( szContNoServer, szError );
%    }
%  }
%#endif	/* CLIENT_CREATE_BY_USER */
%
%  /* Copy in the oShortObjIdHeap argument: */
%  InArguments.oShortObjIdHeap	= oShortObjIdHeap;
%  /* Copy in the oShortObjIdBTree argument: */
%  InArguments.oShortObjIdBTree	= oShortObjIdBTree;
%  /* Copy in the szKey argument: */
%  InArguments.szKey	= szKey;
%  if ( szKey == NULL ) {
%    /* Error handling for passing a NULL string pointer: */
%    char	szError [ 256 ];
%    InArguments.szKey	= (LPSTR) szEmpty;
%    sprintf ( szError, szFormatNullString,
%              __procedure__, "szKey" );
%    RPC_CLIENT_CERROR ( szContNullString, szError );
%  }
%  /* Copy in the nTypeTagKey argument: */
%  InArguments.nTypeTagKey	= nTypeTagKey;
%
%  pResult	=
%#ifdef MULTITHREAD
%    (
%#else
%    (fnServerBtreeSearchByString_rets *)
%#endif
%    fnrpc_fnserverbtreesearchbystring_1 (
%	&InArguments,
%#ifdef MULTITHREAD
%	&Result,
%#endif
%	__pClient__ )
%#ifdef MULTITHREAD
%	== RPC_SUCCESS ) ? &Result : NULL
%#endif
%	;
%
%  if ( pResult == NULL ) {
%    /* Error handling for a failed RPC call, */
%    /* i.e. the server did not respond: */
%    char	szError [ 256 ];
%    sprintf ( szError, szFormatRpcFailed, __procedure__,
%              clnt_sperror ( __pClient__, __szHost__ ) );
%    __pClient__	= RPC_CLIENT_DESTROY ( __pClient__ );
%    RPC_CLIENT_CERROR ( szContRpcFailed, szError );
%    Result	= ZeroResult;
%    return Result.ReturnValue;
%  }
%#ifndef MULTITHREAD
%  Result	= * pResult;
%#endif
%
%  /* Copy out the pnValueKey argument: */
%  if ( ! ( 
%       pnValueKey == NULL ) ) {
%    *pnValueKey	= pResult->pnValueKey;
%  }
%  /* Copy out the pnTypeTagKey argument: */
%  if ( ! ( 
%       pnTypeTagKey == NULL ) ) {
%    *pnTypeTagKey	= pResult->pnTypeTagKey;
%  }
%  /* Copy out the pnValueData argument: */
%  if ( ! ( 
%       pnValueData == NULL ) ) {
%    *pnValueData	= pResult->pnValueData;
%  }
%  /* Copy out the pnTypeTagData argument: */
%  if ( ! ( 
%       pnTypeTagData == NULL ) ) {
%    *pnTypeTagData	= pResult->pnTypeTagData;
%  }
%
%  if ( pResult && pResult->nErrorLvl ) {
%    /* Server returned a user error message: */
%    char	szErrorMsg [ 1024 ];
%    strncpy ( szErrorMsg,
%              ( pResult->pszErrorMsg && pResult->pszErrorMsg [ 0 ] ) ?
%              (LPCSTR) pResult->pszErrorMsg : (LPCSTR) szEmpty,
%              sizeof ( szErrorMsg ) );
%    szErrorMsg [ sizeof ( szErrorMsg ) - 1 ]	= (char) 0;
%    xdr_free ( (xdrproc_t) xdr_fnServerBtreeSearchByString_rets, (char *) pResult );
%    RPC_CLIENT_SERROR ( pResult->nErrorLvl, __procedure__,
%                        szErrorMsg );
%  } else {
%    xdr_free ( (xdrproc_t) xdr_fnServerBtreeSearchByString_rets, (char *) pResult );
%  }
%  if ( 
%       pnValueKey == NULL ) {
%    /* Error handling for passing a NULL pointer on */
%    /* out argument: */
%    char	szError [ 256 ];
%    sprintf ( szError, szFormatNullPassed,
%              __procedure__, "pnValueKey" );
%    RPC_CLIENT_CERROR ( szContNullOutPassed, szError );
%  }
%  if ( 
%       pnTypeTagKey == NULL ) {
%    /* Error handling for passing a NULL pointer on */
%    /* out argument: */
%    char	szError [ 256 ];
%    sprintf ( szError, szFormatNullPassed,
%              __procedure__, "pnTypeTagKey" );
%    RPC_CLIENT_CERROR ( szContNullOutPassed, szError );
%  }
%  if ( 
%       pnValueData == NULL ) {
%    /* Error handling for passing a NULL pointer on */
%    /* out argument: */
%    char	szError [ 256 ];
%    sprintf ( szError, szFormatNullPassed,
%              __procedure__, "pnValueData" );
%    RPC_CLIENT_CERROR ( szContNullOutPassed, szError );
%  }
%  if ( 
%       pnTypeTagData == NULL ) {
%    /* Error handling for passing a NULL pointer on */
%    /* out argument: */
%    char	szError [ 256 ];
%    sprintf ( szError, szFormatNullPassed,
%              __procedure__, "pnTypeTagData" );
%    RPC_CLIENT_CERROR ( szContNullOutPassed, szError );
%  }
%
%  return Result.ReturnValue;
%
%} /* fnServerBtreeSearchByString */
#endif	/* RPC_CLNT */
%
  fnClientBtreeRoot_rets fnRpc_fnClientBtreeRoot ( fnClientBtreeRoot_args ) =  105 ;
%
#if RPC_SVC
%
%extern SHORTOBJID fnClientBtreeRoot
%	(SHORTOBJID oShortObjIdHeap ,
%	  SHORTOBJID oShortObjIdBTree);
%
%#ifdef MULTITHREAD
%bool_t
%#else
%fnClientBtreeRoot_rets *
%#endif
%	PASTE2(fnrpc_fnclientbtreeroot_1,_SVCSUFFIX)
%		( fnClientBtreeRoot_args * pArguments,
%#ifdef MULTITHREAD
%		  fnClientBtreeRoot_rets * pResult,
%#endif
%		  struct svc_req * pRequest )
%{
%  static const char	__procedure__[]	= "server:fnrpc_fnclientbtreeroot_1";
%#ifdef MULTITHREAD
%  typedef bool_t RESULTTYPE;
%#else
%  typedef fnClientBtreeRoot_rets * RESULTTYPE;
%#endif
%#ifndef MULTITHREAD
%  static fnClientBtreeRoot_rets	Result;
%  RESULTTYPE			pResult = &Result;
%#endif
%  LPCSTR	pszErrorMsg;
%
%  __pRequest__	= pRequest;
%
%  RPC_SERVER_ENTRY();
%
%#ifndef MULTITHREAD
%  if ( pResult->pszErrorMsg == szEmpty ) {
%    pResult->pszErrorMsg	= NULL;
%  }
%  xdr_free ( (xdrproc_t) xdr_fnClientBtreeRoot_rets, (char *) pResult );
%#endif
%  pResult->nErrorLvl		= 0;
%
%  Reply.bAnswered		= FALSE;
%  Reply.pfnCalled		= (void(*)()) fnClientBtreeRoot;
%  Reply.pfnXdrResult		= (bool_t(*)()) xdr_fnClientBtreeRoot_rets;
%  Reply.pnErrorLvl		= &pResult->nErrorLvl;
%  Reply.ppszErrorMsg		= (LPCSTR *) &pResult->pszErrorMsg;
%  Reply.pResult		= pResult;
%  Reply.pReturnValue		= &pResult->ReturnValue;
%  Reply.nReturnValueSize	= sizeof ( pResult->ReturnValue );
%
%  pResult->ReturnValue		=
%  fnClientBtreeRoot (
%	pArguments->oShortObjIdHeap,
%	pArguments->oShortObjIdBTree );
%
%  if ( Reply.bAnswered ) {
%    __pRequest__	= NULL;
%    return (RESULTTYPE) NULL;
%  }
%
%  pResult->nErrorLvl	= RPC_SERVER_ERRLVL();
%  if ( pResult->nErrorLvl > 0 ) {
%    pszErrorMsg		= RPC_SERVER_ERRMSG();
%    if ( pszErrorMsg && *pszErrorMsg ) {
%      pResult->pszErrorMsg	= strdup ( pszErrorMsg );
%    }
%  }
%  if ( pResult->pszErrorMsg == NULL ) {
%#ifdef MULTITHREAD
%    pResult->pszErrorMsg	= strdup ( szEmpty );
%#else
%    pResult->pszErrorMsg	= (LPSTR) szEmpty;
%#endif
%  }
%  __pRequest__	= NULL;
%  return (RESULTTYPE) pResult;
%} /* fnrpc_fnclientbtreeroot_1 */
#endif	/* RPC_SVC */
%
#if RPC_CLNT
%SHORTOBJID DLLEXPORT fnClientBtreeRoot
%	(SHORTOBJID oShortObjIdHeap ,
%	  SHORTOBJID oShortObjIdBTree)
%{
%  static const char	__procedure__[]	= "client:fnClientBtreeRoot";
%  static fnClientBtreeRoot_rets	ZeroResult;
%  fnClientBtreeRoot_rets		* pResult = NULL;
%  fnClientBtreeRoot_rets		Result = ZeroResult;
%  fnClientBtreeRoot_args	InArguments;
%
%  /* Client initialization: */
%  if ( __bClientInitialize__ ) {
%    __bClientInitialize__	= FALSE;
%    RPC_CLIENT_INITIALIZE();
%  }
%
%#if	CLIENT_CREATE_BY_USER
%  if ( __pClient__ == NULL ) {
%    __pClient__	= RPC_CLIENT_CREATE ( __szHost__, __szTransport__ );
%    if ( __pClient__ == NULL ) {
%      /* Error handling for a not connected client: */
%      char	szError [ 256 ];
%      sprintf ( szError, szFormatNoServer, __procedure__ );
%      RPC_CLIENT_ERROR ( szError );
%      return Result.ReturnValue;
%    }
%  }
%#else
%  while ( __pClient__ == NULL ) {
%    __pClient__	= RPC_CLIENT_CREATE ( __szHost__, __szTransport__ );
%    if ( __pClient__ == NULL ) {
%      /* Error handling for a not connected client: */
%      char	szError [ 256 ];
%      sprintf ( szError, szFormatNoServer, __procedure__ );
%      RPC_CLIENT_CERROR ( szContNoServer, szError );
%    }
%  }
%#endif	/* CLIENT_CREATE_BY_USER */
%
%  /* Copy in the oShortObjIdHeap argument: */
%  InArguments.oShortObjIdHeap	= oShortObjIdHeap;
%  /* Copy in the oShortObjIdBTree argument: */
%  InArguments.oShortObjIdBTree	= oShortObjIdBTree;
%
%  pResult	=
%#ifdef MULTITHREAD
%    (
%#else
%    (fnClientBtreeRoot_rets *)
%#endif
%    fnrpc_fnclientbtreeroot_1 (
%	&InArguments,
%#ifdef MULTITHREAD
%	&Result,
%#endif
%	__pClient__ )
%#ifdef MULTITHREAD
%	== RPC_SUCCESS ) ? &Result : NULL
%#endif
%	;
%
%  if ( pResult == NULL ) {
%    /* Error handling for a failed RPC call, */
%    /* i.e. the server did not respond: */
%    char	szError [ 256 ];
%    sprintf ( szError, szFormatRpcFailed, __procedure__,
%              clnt_sperror ( __pClient__, __szHost__ ) );
%    __pClient__	= RPC_CLIENT_DESTROY ( __pClient__ );
%    RPC_CLIENT_CERROR ( szContRpcFailed, szError );
%    Result	= ZeroResult;
%    return Result.ReturnValue;
%  }
%#ifndef MULTITHREAD
%  Result	= * pResult;
%#endif
%
%
%  if ( pResult && pResult->nErrorLvl ) {
%    /* Server returned a user error message: */
%    char	szErrorMsg [ 1024 ];
%    strncpy ( szErrorMsg,
%              ( pResult->pszErrorMsg && pResult->pszErrorMsg [ 0 ] ) ?
%              (LPCSTR) pResult->pszErrorMsg : (LPCSTR) szEmpty,
%              sizeof ( szErrorMsg ) );
%    szErrorMsg [ sizeof ( szErrorMsg ) - 1 ]	= (char) 0;
%    xdr_free ( (xdrproc_t) xdr_fnClientBtreeRoot_rets, (char *) pResult );
%    RPC_CLIENT_SERROR ( pResult->nErrorLvl, __procedure__,
%                        szErrorMsg );
%  } else {
%    xdr_free ( (xdrproc_t) xdr_fnClientBtreeRoot_rets, (char *) pResult );
%  }
%
%  return Result.ReturnValue;
%
%} /* fnClientBtreeRoot */
#endif	/* RPC_CLNT */
%
  fnClientBtreeSize_rets fnRpc_fnClientBtreeSize ( fnClientBtreeSize_args ) =  106 ;
%
#if RPC_SVC
%
%extern int fnClientBtreeSize
%	(SHORTOBJID oShortObjIdHeap ,
%	  SHORTOBJID oShortObjIdBTree);
%
%#ifdef MULTITHREAD
%bool_t
%#else
%fnClientBtreeSize_rets *
%#endif
%	PASTE2(fnrpc_fnclientbtreesize_1,_SVCSUFFIX)
%		( fnClientBtreeSize_args * pArguments,
%#ifdef MULTITHREAD
%		  fnClientBtreeSize_rets * pResult,
%#endif
%		  struct svc_req * pRequest )
%{
%  static const char	__procedure__[]	= "server:fnrpc_fnclientbtreesize_1";
%#ifdef MULTITHREAD
%  typedef bool_t RESULTTYPE;
%#else
%  typedef fnClientBtreeSize_rets * RESULTTYPE;
%#endif
%#ifndef MULTITHREAD
%  static fnClientBtreeSize_rets	Result;
%  RESULTTYPE			pResult = &Result;
%#endif
%  LPCSTR	pszErrorMsg;
%
%  __pRequest__	= pRequest;
%
%  RPC_SERVER_ENTRY();
%
%#ifndef MULTITHREAD
%  if ( pResult->pszErrorMsg == szEmpty ) {
%    pResult->pszErrorMsg	= NULL;
%  }
%  xdr_free ( (xdrproc_t) xdr_fnClientBtreeSize_rets, (char *) pResult );
%#endif
%  pResult->nErrorLvl		= 0;
%
%  Reply.bAnswered		= FALSE;
%  Reply.pfnCalled		= (void(*)()) fnClientBtreeSize;
%  Reply.pfnXdrResult		= (bool_t(*)()) xdr_fnClientBtreeSize_rets;
%  Reply.pnErrorLvl		= &pResult->nErrorLvl;
%  Reply.ppszErrorMsg		= (LPCSTR *) &pResult->pszErrorMsg;
%  Reply.pResult		= pResult;
%  Reply.pReturnValue		= &pResult->ReturnValue;
%  Reply.nReturnValueSize	= sizeof ( pResult->ReturnValue );
%
%  pResult->ReturnValue		=
%  fnClientBtreeSize (
%	pArguments->oShortObjIdHeap,
%	pArguments->oShortObjIdBTree );
%
%  if ( Reply.bAnswered ) {
%    __pRequest__	= NULL;
%    return (RESULTTYPE) NULL;
%  }
%
%  pResult->nErrorLvl	= RPC_SERVER_ERRLVL();
%  if ( pResult->nErrorLvl > 0 ) {
%    pszErrorMsg		= RPC_SERVER_ERRMSG();
%    if ( pszErrorMsg && *pszErrorMsg ) {
%      pResult->pszErrorMsg	= strdup ( pszErrorMsg );
%    }
%  }
%  if ( pResult->pszErrorMsg == NULL ) {
%#ifdef MULTITHREAD
%    pResult->pszErrorMsg	= strdup ( szEmpty );
%#else
%    pResult->pszErrorMsg	= (LPSTR) szEmpty;
%#endif
%  }
%  __pRequest__	= NULL;
%  return (RESULTTYPE) pResult;
%} /* fnrpc_fnclientbtreesize_1 */
#endif	/* RPC_SVC */
%
#if RPC_CLNT
%int DLLEXPORT fnClientBtreeSize
%	(SHORTOBJID oShortObjIdHeap ,
%	  SHORTOBJID oShortObjIdBTree)
%{
%  static const char	__procedure__[]	= "client:fnClientBtreeSize";
%  static fnClientBtreeSize_rets	ZeroResult;
%  fnClientBtreeSize_rets		* pResult = NULL;
%  fnClientBtreeSize_rets		Result = ZeroResult;
%  fnClientBtreeSize_args	InArguments;
%
%  /* Client initialization: */
%  if ( __bClientInitialize__ ) {
%    __bClientInitialize__	= FALSE;
%    RPC_CLIENT_INITIALIZE();
%  }
%
%#if	CLIENT_CREATE_BY_USER
%  if ( __pClient__ == NULL ) {
%    __pClient__	= RPC_CLIENT_CREATE ( __szHost__, __szTransport__ );
%    if ( __pClient__ == NULL ) {
%      /* Error handling for a not connected client: */
%      char	szError [ 256 ];
%      sprintf ( szError, szFormatNoServer, __procedure__ );
%      RPC_CLIENT_ERROR ( szError );
%      return Result.ReturnValue;
%    }
%  }
%#else
%  while ( __pClient__ == NULL ) {
%    __pClient__	= RPC_CLIENT_CREATE ( __szHost__, __szTransport__ );
%    if ( __pClient__ == NULL ) {
%      /* Error handling for a not connected client: */
%      char	szError [ 256 ];
%      sprintf ( szError, szFormatNoServer, __procedure__ );
%      RPC_CLIENT_CERROR ( szContNoServer, szError );
%    }
%  }
%#endif	/* CLIENT_CREATE_BY_USER */
%
%  /* Copy in the oShortObjIdHeap argument: */
%  InArguments.oShortObjIdHeap	= oShortObjIdHeap;
%  /* Copy in the oShortObjIdBTree argument: */
%  InArguments.oShortObjIdBTree	= oShortObjIdBTree;
%
%  pResult	=
%#ifdef MULTITHREAD
%    (
%#else
%    (fnClientBtreeSize_rets *)
%#endif
%    fnrpc_fnclientbtreesize_1 (
%	&InArguments,
%#ifdef MULTITHREAD
%	&Result,
%#endif
%	__pClient__ )
%#ifdef MULTITHREAD
%	== RPC_SUCCESS ) ? &Result : NULL
%#endif
%	;
%
%  if ( pResult == NULL ) {
%    /* Error handling for a failed RPC call, */
%    /* i.e. the server did not respond: */
%    char	szError [ 256 ];
%    sprintf ( szError, szFormatRpcFailed, __procedure__,
%              clnt_sperror ( __pClient__, __szHost__ ) );
%    __pClient__	= RPC_CLIENT_DESTROY ( __pClient__ );
%    RPC_CLIENT_CERROR ( szContRpcFailed, szError );
%    Result	= ZeroResult;
%    return Result.ReturnValue;
%  }
%#ifndef MULTITHREAD
%  Result	= * pResult;
%#endif
%
%
%  if ( pResult && pResult->nErrorLvl ) {
%    /* Server returned a user error message: */
%    char	szErrorMsg [ 1024 ];
%    strncpy ( szErrorMsg,
%              ( pResult->pszErrorMsg && pResult->pszErrorMsg [ 0 ] ) ?
%              (LPCSTR) pResult->pszErrorMsg : (LPCSTR) szEmpty,
%              sizeof ( szErrorMsg ) );
%    szErrorMsg [ sizeof ( szErrorMsg ) - 1 ]	= (char) 0;
%    xdr_free ( (xdrproc_t) xdr_fnClientBtreeSize_rets, (char *) pResult );
%    RPC_CLIENT_SERROR ( pResult->nErrorLvl, __procedure__,
%                        szErrorMsg );
%  } else {
%    xdr_free ( (xdrproc_t) xdr_fnClientBtreeSize_rets, (char *) pResult );
%  }
%
%  return Result.ReturnValue;
%
%} /* fnClientBtreeSize */
#endif	/* RPC_CLNT */
%
  fnClientBtreeTestMode_rets fnRpc_fnClientBtreeTestMode ( fnClientBtreeTestMode_args ) =  107 ;
%
#if RPC_SVC
%
%extern COMPARETAG fnClientBtreeTestMode
%	(SHORTOBJID oShortObjIdHeap ,
%	  SHORTOBJID oShortObjIdBTree ,
%	  COMPARETAG nNewTestMode);
%
%#ifdef MULTITHREAD
%bool_t
%#else
%fnClientBtreeTestMode_rets *
%#endif
%	PASTE2(fnrpc_fnclientbtreetestmode_1,_SVCSUFFIX)
%		( fnClientBtreeTestMode_args * pArguments,
%#ifdef MULTITHREAD
%		  fnClientBtreeTestMode_rets * pResult,
%#endif
%		  struct svc_req * pRequest )
%{
%  static const char	__procedure__[]	= "server:fnrpc_fnclientbtreetestmode_1";
%#ifdef MULTITHREAD
%  typedef bool_t RESULTTYPE;
%#else
%  typedef fnClientBtreeTestMode_rets * RESULTTYPE;
%#endif
%#ifndef MULTITHREAD
%  static fnClientBtreeTestMode_rets	Result;
%  RESULTTYPE			pResult = &Result;
%#endif
%  LPCSTR	pszErrorMsg;
%
%  __pRequest__	= pRequest;
%
%  RPC_SERVER_ENTRY();
%
%#ifndef MULTITHREAD
%  if ( pResult->pszErrorMsg == szEmpty ) {
%    pResult->pszErrorMsg	= NULL;
%  }
%  xdr_free ( (xdrproc_t) xdr_fnClientBtreeTestMode_rets, (char *) pResult );
%#endif
%  pResult->nErrorLvl		= 0;
%
%  Reply.bAnswered		= FALSE;
%  Reply.pfnCalled		= (void(*)()) fnClientBtreeTestMode;
%  Reply.pfnXdrResult		= (bool_t(*)()) xdr_fnClientBtreeTestMode_rets;
%  Reply.pnErrorLvl		= &pResult->nErrorLvl;
%  Reply.ppszErrorMsg		= (LPCSTR *) &pResult->pszErrorMsg;
%  Reply.pResult		= pResult;
%  Reply.pReturnValue		= &pResult->ReturnValue;
%  Reply.nReturnValueSize	= sizeof ( pResult->ReturnValue );
%
%  pResult->ReturnValue		=
%  fnClientBtreeTestMode (
%	pArguments->oShortObjIdHeap,
%	pArguments->oShortObjIdBTree,
%	pArguments->nNewTestMode );
%
%  if ( Reply.bAnswered ) {
%    __pRequest__	= NULL;
%    return (RESULTTYPE) NULL;
%  }
%
%  pResult->nErrorLvl	= RPC_SERVER_ERRLVL();
%  if ( pResult->nErrorLvl > 0 ) {
%    pszErrorMsg		= RPC_SERVER_ERRMSG();
%    if ( pszErrorMsg && *pszErrorMsg ) {
%      pResult->pszErrorMsg	= strdup ( pszErrorMsg );
%    }
%  }
%  if ( pResult->pszErrorMsg == NULL ) {
%#ifdef MULTITHREAD
%    pResult->pszErrorMsg	= strdup ( szEmpty );
%#else
%    pResult->pszErrorMsg	= (LPSTR) szEmpty;
%#endif
%  }
%  __pRequest__	= NULL;
%  return (RESULTTYPE) pResult;
%} /* fnrpc_fnclientbtreetestmode_1 */
#endif	/* RPC_SVC */
%
#if RPC_CLNT
%COMPARETAG DLLEXPORT fnClientBtreeTestMode
%	(SHORTOBJID oShortObjIdHeap ,
%	  SHORTOBJID oShortObjIdBTree ,
%	  COMPARETAG nNewTestMode)
%{
%  static const char	__procedure__[]	= "client:fnClientBtreeTestMode";
%  static fnClientBtreeTestMode_rets	ZeroResult;
%  fnClientBtreeTestMode_rets		* pResult = NULL;
%  fnClientBtreeTestMode_rets		Result = ZeroResult;
%  fnClientBtreeTestMode_args	InArguments;
%
%  /* Client initialization: */
%  if ( __bClientInitialize__ ) {
%    __bClientInitialize__	= FALSE;
%    RPC_CLIENT_INITIALIZE();
%  }
%
%#if	CLIENT_CREATE_BY_USER
%  if ( __pClient__ == NULL ) {
%    __pClient__	= RPC_CLIENT_CREATE ( __szHost__, __szTransport__ );
%    if ( __pClient__ == NULL ) {
%      /* Error handling for a not connected client: */
%      char	szError [ 256 ];
%      sprintf ( szError, szFormatNoServer, __procedure__ );
%      RPC_CLIENT_ERROR ( szError );
%      return Result.ReturnValue;
%    }
%  }
%#else
%  while ( __pClient__ == NULL ) {
%    __pClient__	= RPC_CLIENT_CREATE ( __szHost__, __szTransport__ );
%    if ( __pClient__ == NULL ) {
%      /* Error handling for a not connected client: */
%      char	szError [ 256 ];
%      sprintf ( szError, szFormatNoServer, __procedure__ );
%      RPC_CLIENT_CERROR ( szContNoServer, szError );
%    }
%  }
%#endif	/* CLIENT_CREATE_BY_USER */
%
%  /* Copy in the oShortObjIdHeap argument: */
%  InArguments.oShortObjIdHeap	= oShortObjIdHeap;
%  /* Copy in the oShortObjIdBTree argument: */
%  InArguments.oShortObjIdBTree	= oShortObjIdBTree;
%  /* Copy in the nNewTestMode argument: */
%  InArguments.nNewTestMode	= nNewTestMode;
%
%  pResult	=
%#ifdef MULTITHREAD
%    (
%#else
%    (fnClientBtreeTestMode_rets *)
%#endif
%    fnrpc_fnclientbtreetestmode_1 (
%	&InArguments,
%#ifdef MULTITHREAD
%	&Result,
%#endif
%	__pClient__ )
%#ifdef MULTITHREAD
%	== RPC_SUCCESS ) ? &Result : NULL
%#endif
%	;
%
%  if ( pResult == NULL ) {
%    /* Error handling for a failed RPC call, */
%    /* i.e. the server did not respond: */
%    char	szError [ 256 ];
%    sprintf ( szError, szFormatRpcFailed, __procedure__,
%              clnt_sperror ( __pClient__, __szHost__ ) );
%    __pClient__	= RPC_CLIENT_DESTROY ( __pClient__ );
%    RPC_CLIENT_CERROR ( szContRpcFailed, szError );
%    Result	= ZeroResult;
%    return Result.ReturnValue;
%  }
%#ifndef MULTITHREAD
%  Result	= * pResult;
%#endif
%
%
%  if ( pResult && pResult->nErrorLvl ) {
%    /* Server returned a user error message: */
%    char	szErrorMsg [ 1024 ];
%    strncpy ( szErrorMsg,
%              ( pResult->pszErrorMsg && pResult->pszErrorMsg [ 0 ] ) ?
%              (LPCSTR) pResult->pszErrorMsg : (LPCSTR) szEmpty,
%              sizeof ( szErrorMsg ) );
%    szErrorMsg [ sizeof ( szErrorMsg ) - 1 ]	= (char) 0;
%    xdr_free ( (xdrproc_t) xdr_fnClientBtreeTestMode_rets, (char *) pResult );
%    RPC_CLIENT_SERROR ( pResult->nErrorLvl, __procedure__,
%                        szErrorMsg );
%  } else {
%    xdr_free ( (xdrproc_t) xdr_fnClientBtreeTestMode_rets, (char *) pResult );
%  }
%
%  return Result.ReturnValue;
%
%} /* fnClientBtreeTestMode */
#endif	/* RPC_CLNT */
%
  fnClientBtreePageSize_rets fnRpc_fnClientBtreePageSize ( fnClientBtreePageSize_args ) =  108 ;
%
#if RPC_SVC
%
%extern int fnClientBtreePageSize
%	(SHORTOBJID oShortObjIdHeap ,
%	  SHORTOBJID oShortObjIdBTree ,
%	  int nNewPageSize);
%
%#ifdef MULTITHREAD
%bool_t
%#else
%fnClientBtreePageSize_rets *
%#endif
%	PASTE2(fnrpc_fnclientbtreepagesize_1,_SVCSUFFIX)
%		( fnClientBtreePageSize_args * pArguments,
%#ifdef MULTITHREAD
%		  fnClientBtreePageSize_rets * pResult,
%#endif
%		  struct svc_req * pRequest )
%{
%  static const char	__procedure__[]	= "server:fnrpc_fnclientbtreepagesize_1";
%#ifdef MULTITHREAD
%  typedef bool_t RESULTTYPE;
%#else
%  typedef fnClientBtreePageSize_rets * RESULTTYPE;
%#endif
%#ifndef MULTITHREAD
%  static fnClientBtreePageSize_rets	Result;
%  RESULTTYPE			pResult = &Result;
%#endif
%  LPCSTR	pszErrorMsg;
%
%  __pRequest__	= pRequest;
%
%  RPC_SERVER_ENTRY();
%
%#ifndef MULTITHREAD
%  if ( pResult->pszErrorMsg == szEmpty ) {
%    pResult->pszErrorMsg	= NULL;
%  }
%  xdr_free ( (xdrproc_t) xdr_fnClientBtreePageSize_rets, (char *) pResult );
%#endif
%  pResult->nErrorLvl		= 0;
%
%  Reply.bAnswered		= FALSE;
%  Reply.pfnCalled		= (void(*)()) fnClientBtreePageSize;
%  Reply.pfnXdrResult		= (bool_t(*)()) xdr_fnClientBtreePageSize_rets;
%  Reply.pnErrorLvl		= &pResult->nErrorLvl;
%  Reply.ppszErrorMsg		= (LPCSTR *) &pResult->pszErrorMsg;
%  Reply.pResult		= pResult;
%  Reply.pReturnValue		= &pResult->ReturnValue;
%  Reply.nReturnValueSize	= sizeof ( pResult->ReturnValue );
%
%  pResult->ReturnValue		=
%  fnClientBtreePageSize (
%	pArguments->oShortObjIdHeap,
%	pArguments->oShortObjIdBTree,
%	pArguments->nNewPageSize );
%
%  if ( Reply.bAnswered ) {
%    __pRequest__	= NULL;
%    return (RESULTTYPE) NULL;
%  }
%
%  pResult->nErrorLvl	= RPC_SERVER_ERRLVL();
%  if ( pResult->nErrorLvl > 0 ) {
%    pszErrorMsg		= RPC_SERVER_ERRMSG();
%    if ( pszErrorMsg && *pszErrorMsg ) {
%      pResult->pszErrorMsg	= strdup ( pszErrorMsg );
%    }
%  }
%  if ( pResult->pszErrorMsg == NULL ) {
%#ifdef MULTITHREAD
%    pResult->pszErrorMsg	= strdup ( szEmpty );
%#else
%    pResult->pszErrorMsg	= (LPSTR) szEmpty;
%#endif
%  }
%  __pRequest__	= NULL;
%  return (RESULTTYPE) pResult;
%} /* fnrpc_fnclientbtreepagesize_1 */
#endif	/* RPC_SVC */
%
#if RPC_CLNT
%int DLLEXPORT fnClientBtreePageSize
%	(SHORTOBJID oShortObjIdHeap ,
%	  SHORTOBJID oShortObjIdBTree ,
%	  int nNewPageSize)
%{
%  static const char	__procedure__[]	= "client:fnClientBtreePageSize";
%  static fnClientBtreePageSize_rets	ZeroResult;
%  fnClientBtreePageSize_rets		* pResult = NULL;
%  fnClientBtreePageSize_rets		Result = ZeroResult;
%  fnClientBtreePageSize_args	InArguments;
%
%  /* Client initialization: */
%  if ( __bClientInitialize__ ) {
%    __bClientInitialize__	= FALSE;
%    RPC_CLIENT_INITIALIZE();
%  }
%
%#if	CLIENT_CREATE_BY_USER
%  if ( __pClient__ == NULL ) {
%    __pClient__	= RPC_CLIENT_CREATE ( __szHost__, __szTransport__ );
%    if ( __pClient__ == NULL ) {
%      /* Error handling for a not connected client: */
%      char	szError [ 256 ];
%      sprintf ( szError, szFormatNoServer, __procedure__ );
%      RPC_CLIENT_ERROR ( szError );
%      return Result.ReturnValue;
%    }
%  }
%#else
%  while ( __pClient__ == NULL ) {
%    __pClient__	= RPC_CLIENT_CREATE ( __szHost__, __szTransport__ );
%    if ( __pClient__ == NULL ) {
%      /* Error handling for a not connected client: */
%      char	szError [ 256 ];
%      sprintf ( szError, szFormatNoServer, __procedure__ );
%      RPC_CLIENT_CERROR ( szContNoServer, szError );
%    }
%  }
%#endif	/* CLIENT_CREATE_BY_USER */
%
%  /* Copy in the oShortObjIdHeap argument: */
%  InArguments.oShortObjIdHeap	= oShortObjIdHeap;
%  /* Copy in the oShortObjIdBTree argument: */
%  InArguments.oShortObjIdBTree	= oShortObjIdBTree;
%  /* Copy in the nNewPageSize argument: */
%  InArguments.nNewPageSize	= nNewPageSize;
%
%  pResult	=
%#ifdef MULTITHREAD
%    (
%#else
%    (fnClientBtreePageSize_rets *)
%#endif
%    fnrpc_fnclientbtreepagesize_1 (
%	&InArguments,
%#ifdef MULTITHREAD
%	&Result,
%#endif
%	__pClient__ )
%#ifdef MULTITHREAD
%	== RPC_SUCCESS ) ? &Result : NULL
%#endif
%	;
%
%  if ( pResult == NULL ) {
%    /* Error handling for a failed RPC call, */
%    /* i.e. the server did not respond: */
%    char	szError [ 256 ];
%    sprintf ( szError, szFormatRpcFailed, __procedure__,
%              clnt_sperror ( __pClient__, __szHost__ ) );
%    __pClient__	= RPC_CLIENT_DESTROY ( __pClient__ );
%    RPC_CLIENT_CERROR ( szContRpcFailed, szError );
%    Result	= ZeroResult;
%    return Result.ReturnValue;
%  }
%#ifndef MULTITHREAD
%  Result	= * pResult;
%#endif
%
%
%  if ( pResult && pResult->nErrorLvl ) {
%    /* Server returned a user error message: */
%    char	szErrorMsg [ 1024 ];
%    strncpy ( szErrorMsg,
%              ( pResult->pszErrorMsg && pResult->pszErrorMsg [ 0 ] ) ?
%              (LPCSTR) pResult->pszErrorMsg : (LPCSTR) szEmpty,
%              sizeof ( szErrorMsg ) );
%    szErrorMsg [ sizeof ( szErrorMsg ) - 1 ]	= (char) 0;
%    xdr_free ( (xdrproc_t) xdr_fnClientBtreePageSize_rets, (char *) pResult );
%    RPC_CLIENT_SERROR ( pResult->nErrorLvl, __procedure__,
%                        szErrorMsg );
%  } else {
%    xdr_free ( (xdrproc_t) xdr_fnClientBtreePageSize_rets, (char *) pResult );
%  }
%
%  return Result.ReturnValue;
%
%} /* fnClientBtreePageSize */
#endif	/* RPC_CLNT */
%
  fnClientBtreepageParent_rets fnRpc_fnClientBtreepageParent ( fnClientBtreepageParent_args ) =  109 ;
%
#if RPC_SVC
%
%extern OBJID fnClientBtreepageParent
%	(SHORTOBJID oShortObjIdHeap ,
%	  SHORTOBJID oShortObjIdBTreePage);
%
%#ifdef MULTITHREAD
%bool_t
%#else
%fnClientBtreepageParent_rets *
%#endif
%	PASTE2(fnrpc_fnclientbtreepageparent_1,_SVCSUFFIX)
%		( fnClientBtreepageParent_args * pArguments,
%#ifdef MULTITHREAD
%		  fnClientBtreepageParent_rets * pResult,
%#endif
%		  struct svc_req * pRequest )
%{
%  static const char	__procedure__[]	= "server:fnrpc_fnclientbtreepageparent_1";
%#ifdef MULTITHREAD
%  typedef bool_t RESULTTYPE;
%#else
%  typedef fnClientBtreepageParent_rets * RESULTTYPE;
%#endif
%#ifndef MULTITHREAD
%  static fnClientBtreepageParent_rets	Result;
%  RESULTTYPE			pResult = &Result;
%#endif
%  LPCSTR	pszErrorMsg;
%
%  __pRequest__	= pRequest;
%
%  RPC_SERVER_ENTRY();
%
%#ifndef MULTITHREAD
%  if ( pResult->pszErrorMsg == szEmpty ) {
%    pResult->pszErrorMsg	= NULL;
%  }
%  xdr_free ( (xdrproc_t) xdr_fnClientBtreepageParent_rets, (char *) pResult );
%#endif
%  pResult->nErrorLvl		= 0;
%
%  Reply.bAnswered		= FALSE;
%  Reply.pfnCalled		= (void(*)()) fnClientBtreepageParent;
%  Reply.pfnXdrResult		= (bool_t(*)()) xdr_fnClientBtreepageParent_rets;
%  Reply.pnErrorLvl		= &pResult->nErrorLvl;
%  Reply.ppszErrorMsg		= (LPCSTR *) &pResult->pszErrorMsg;
%  Reply.pResult		= pResult;
%  Reply.pReturnValue		= &pResult->ReturnValue;
%  Reply.nReturnValueSize	= sizeof ( pResult->ReturnValue );
%
%  pResult->ReturnValue		=
%  fnClientBtreepageParent (
%	pArguments->oShortObjIdHeap,
%	pArguments->oShortObjIdBTreePage );
%
%  if ( Reply.bAnswered ) {
%    __pRequest__	= NULL;
%    return (RESULTTYPE) NULL;
%  }
%
%  pResult->nErrorLvl	= RPC_SERVER_ERRLVL();
%  if ( pResult->nErrorLvl > 0 ) {
%    pszErrorMsg		= RPC_SERVER_ERRMSG();
%    if ( pszErrorMsg && *pszErrorMsg ) {
%      pResult->pszErrorMsg	= strdup ( pszErrorMsg );
%    }
%  }
%  if ( pResult->pszErrorMsg == NULL ) {
%#ifdef MULTITHREAD
%    pResult->pszErrorMsg	= strdup ( szEmpty );
%#else
%    pResult->pszErrorMsg	= (LPSTR) szEmpty;
%#endif
%  }
%  __pRequest__	= NULL;
%  return (RESULTTYPE) pResult;
%} /* fnrpc_fnclientbtreepageparent_1 */
#endif	/* RPC_SVC */
%
#if RPC_CLNT
%OBJID DLLEXPORT fnClientBtreepageParent
%	(SHORTOBJID oShortObjIdHeap ,
%	  SHORTOBJID oShortObjIdBTreePage)
%{
%  static const char	__procedure__[]	= "client:fnClientBtreepageParent";
%  static fnClientBtreepageParent_rets	ZeroResult;
%  fnClientBtreepageParent_rets		* pResult = NULL;
%  fnClientBtreepageParent_rets		Result = ZeroResult;
%  fnClientBtreepageParent_args	InArguments;
%
%  /* Client initialization: */
%  if ( __bClientInitialize__ ) {
%    __bClientInitialize__	= FALSE;
%    RPC_CLIENT_INITIALIZE();
%  }
%
%#if	CLIENT_CREATE_BY_USER
%  if ( __pClient__ == NULL ) {
%    __pClient__	= RPC_CLIENT_CREATE ( __szHost__, __szTransport__ );
%    if ( __pClient__ == NULL ) {
%      /* Error handling for a not connected client: */
%      char	szError [ 256 ];
%      sprintf ( szError, szFormatNoServer, __procedure__ );
%      RPC_CLIENT_ERROR ( szError );
%      return Result.ReturnValue;
%    }
%  }
%#else
%  while ( __pClient__ == NULL ) {
%    __pClient__	= RPC_CLIENT_CREATE ( __szHost__, __szTransport__ );
%    if ( __pClient__ == NULL ) {
%      /* Error handling for a not connected client: */
%      char	szError [ 256 ];
%      sprintf ( szError, szFormatNoServer, __procedure__ );
%      RPC_CLIENT_CERROR ( szContNoServer, szError );
%    }
%  }
%#endif	/* CLIENT_CREATE_BY_USER */
%
%  /* Copy in the oShortObjIdHeap argument: */
%  InArguments.oShortObjIdHeap	= oShortObjIdHeap;
%  /* Copy in the oShortObjIdBTreePage argument: */
%  InArguments.oShortObjIdBTreePage	= oShortObjIdBTreePage;
%
%  pResult	=
%#ifdef MULTITHREAD
%    (
%#else
%    (fnClientBtreepageParent_rets *)
%#endif
%    fnrpc_fnclientbtreepageparent_1 (
%	&InArguments,
%#ifdef MULTITHREAD
%	&Result,
%#endif
%	__pClient__ )
%#ifdef MULTITHREAD
%	== RPC_SUCCESS ) ? &Result : NULL
%#endif
%	;
%
%  if ( pResult == NULL ) {
%    /* Error handling for a failed RPC call, */
%    /* i.e. the server did not respond: */
%    char	szError [ 256 ];
%    sprintf ( szError, szFormatRpcFailed, __procedure__,
%              clnt_sperror ( __pClient__, __szHost__ ) );
%    __pClient__	= RPC_CLIENT_DESTROY ( __pClient__ );
%    RPC_CLIENT_CERROR ( szContRpcFailed, szError );
%    Result	= ZeroResult;
%    return Result.ReturnValue;
%  }
%#ifndef MULTITHREAD
%  Result	= * pResult;
%#endif
%
%
%  if ( pResult && pResult->nErrorLvl ) {
%    /* Server returned a user error message: */
%    char	szErrorMsg [ 1024 ];
%    strncpy ( szErrorMsg,
%              ( pResult->pszErrorMsg && pResult->pszErrorMsg [ 0 ] ) ?
%              (LPCSTR) pResult->pszErrorMsg : (LPCSTR) szEmpty,
%              sizeof ( szErrorMsg ) );
%    szErrorMsg [ sizeof ( szErrorMsg ) - 1 ]	= (char) 0;
%    xdr_free ( (xdrproc_t) xdr_fnClientBtreepageParent_rets, (char *) pResult );
%    RPC_CLIENT_SERROR ( pResult->nErrorLvl, __procedure__,
%                        szErrorMsg );
%  } else {
%    xdr_free ( (xdrproc_t) xdr_fnClientBtreepageParent_rets, (char *) pResult );
%  }
%
%  return Result.ReturnValue;
%
%} /* fnClientBtreepageParent */
#endif	/* RPC_CLNT */
%
  fnClientBtreepageCount_rets fnRpc_fnClientBtreepageCount ( fnClientBtreepageCount_args ) =  110 ;
%
#if RPC_SVC
%
%extern int fnClientBtreepageCount
%	(SHORTOBJID oShortObjIdHeap ,
%	  SHORTOBJID oShortObjIdBTreePage);
%
%#ifdef MULTITHREAD
%bool_t
%#else
%fnClientBtreepageCount_rets *
%#endif
%	PASTE2(fnrpc_fnclientbtreepagecount_1,_SVCSUFFIX)
%		( fnClientBtreepageCount_args * pArguments,
%#ifdef MULTITHREAD
%		  fnClientBtreepageCount_rets * pResult,
%#endif
%		  struct svc_req * pRequest )
%{
%  static const char	__procedure__[]	= "server:fnrpc_fnclientbtreepagecount_1";
%#ifdef MULTITHREAD
%  typedef bool_t RESULTTYPE;
%#else
%  typedef fnClientBtreepageCount_rets * RESULTTYPE;
%#endif
%#ifndef MULTITHREAD
%  static fnClientBtreepageCount_rets	Result;
%  RESULTTYPE			pResult = &Result;
%#endif
%  LPCSTR	pszErrorMsg;
%
%  __pRequest__	= pRequest;
%
%  RPC_SERVER_ENTRY();
%
%#ifndef MULTITHREAD
%  if ( pResult->pszErrorMsg == szEmpty ) {
%    pResult->pszErrorMsg	= NULL;
%  }
%  xdr_free ( (xdrproc_t) xdr_fnClientBtreepageCount_rets, (char *) pResult );
%#endif
%  pResult->nErrorLvl		= 0;
%
%  Reply.bAnswered		= FALSE;
%  Reply.pfnCalled		= (void(*)()) fnClientBtreepageCount;
%  Reply.pfnXdrResult		= (bool_t(*)()) xdr_fnClientBtreepageCount_rets;
%  Reply.pnErrorLvl		= &pResult->nErrorLvl;
%  Reply.ppszErrorMsg		= (LPCSTR *) &pResult->pszErrorMsg;
%  Reply.pResult		= pResult;
%  Reply.pReturnValue		= &pResult->ReturnValue;
%  Reply.nReturnValueSize	= sizeof ( pResult->ReturnValue );
%
%  pResult->ReturnValue		=
%  fnClientBtreepageCount (
%	pArguments->oShortObjIdHeap,
%	pArguments->oShortObjIdBTreePage );
%
%  if ( Reply.bAnswered ) {
%    __pRequest__	= NULL;
%    return (RESULTTYPE) NULL;
%  }
%
%  pResult->nErrorLvl	= RPC_SERVER_ERRLVL();
%  if ( pResult->nErrorLvl > 0 ) {
%    pszErrorMsg		= RPC_SERVER_ERRMSG();
%    if ( pszErrorMsg && *pszErrorMsg ) {
%      pResult->pszErrorMsg	= strdup ( pszErrorMsg );
%    }
%  }
%  if ( pResult->pszErrorMsg == NULL ) {
%#ifdef MULTITHREAD
%    pResult->pszErrorMsg	= strdup ( szEmpty );
%#else
%    pResult->pszErrorMsg	= (LPSTR) szEmpty;
%#endif
%  }
%  __pRequest__	= NULL;
%  return (RESULTTYPE) pResult;
%} /* fnrpc_fnclientbtreepagecount_1 */
#endif	/* RPC_SVC */
%
#if RPC_CLNT
%int DLLEXPORT fnClientBtreepageCount
%	(SHORTOBJID oShortObjIdHeap ,
%	  SHORTOBJID oShortObjIdBTreePage)
%{
%  static const char	__procedure__[]	= "client:fnClientBtreepageCount";
%  static fnClientBtreepageCount_rets	ZeroResult;
%  fnClientBtreepageCount_rets		* pResult = NULL;
%  fnClientBtreepageCount_rets		Result = ZeroResult;
%  fnClientBtreepageCount_args	InArguments;
%
%  /* Client initialization: */
%  if ( __bClientInitialize__ ) {
%    __bClientInitialize__	= FALSE;
%    RPC_CLIENT_INITIALIZE();
%  }
%
%#if	CLIENT_CREATE_BY_USER
%  if ( __pClient__ == NULL ) {
%    __pClient__	= RPC_CLIENT_CREATE ( __szHost__, __szTransport__ );
%    if ( __pClient__ == NULL ) {
%      /* Error handling for a not connected client: */
%      char	szError [ 256 ];
%      sprintf ( szError, szFormatNoServer, __procedure__ );
%      RPC_CLIENT_ERROR ( szError );
%      return Result.ReturnValue;
%    }
%  }
%#else
%  while ( __pClient__ == NULL ) {
%    __pClient__	= RPC_CLIENT_CREATE ( __szHost__, __szTransport__ );
%    if ( __pClient__ == NULL ) {
%      /* Error handling for a not connected client: */
%      char	szError [ 256 ];
%      sprintf ( szError, szFormatNoServer, __procedure__ );
%      RPC_CLIENT_CERROR ( szContNoServer, szError );
%    }
%  }
%#endif	/* CLIENT_CREATE_BY_USER */
%
%  /* Copy in the oShortObjIdHeap argument: */
%  InArguments.oShortObjIdHeap	= oShortObjIdHeap;
%  /* Copy in the oShortObjIdBTreePage argument: */
%  InArguments.oShortObjIdBTreePage	= oShortObjIdBTreePage;
%
%  pResult	=
%#ifdef MULTITHREAD
%    (
%#else
%    (fnClientBtreepageCount_rets *)
%#endif
%    fnrpc_fnclientbtreepagecount_1 (
%	&InArguments,
%#ifdef MULTITHREAD
%	&Result,
%#endif
%	__pClient__ )
%#ifdef MULTITHREAD
%	== RPC_SUCCESS ) ? &Result : NULL
%#endif
%	;
%
%  if ( pResult == NULL ) {
%    /* Error handling for a failed RPC call, */
%    /* i.e. the server did not respond: */
%    char	szError [ 256 ];
%    sprintf ( szError, szFormatRpcFailed, __procedure__,
%              clnt_sperror ( __pClient__, __szHost__ ) );
%    __pClient__	= RPC_CLIENT_DESTROY ( __pClient__ );
%    RPC_CLIENT_CERROR ( szContRpcFailed, szError );
%    Result	= ZeroResult;
%    return Result.ReturnValue;
%  }
%#ifndef MULTITHREAD
%  Result	= * pResult;
%#endif
%
%
%  if ( pResult && pResult->nErrorLvl ) {
%    /* Server returned a user error message: */
%    char	szErrorMsg [ 1024 ];
%    strncpy ( szErrorMsg,
%              ( pResult->pszErrorMsg && pResult->pszErrorMsg [ 0 ] ) ?
%              (LPCSTR) pResult->pszErrorMsg : (LPCSTR) szEmpty,
%              sizeof ( szErrorMsg ) );
%    szErrorMsg [ sizeof ( szErrorMsg ) - 1 ]	= (char) 0;
%    xdr_free ( (xdrproc_t) xdr_fnClientBtreepageCount_rets, (char *) pResult );
%    RPC_CLIENT_SERROR ( pResult->nErrorLvl, __procedure__,
%                        szErrorMsg );
%  } else {
%    xdr_free ( (xdrproc_t) xdr_fnClientBtreepageCount_rets, (char *) pResult );
%  }
%
%  return Result.ReturnValue;
%
%} /* fnClientBtreepageCount */
#endif	/* RPC_CLNT */
%
  fnClientBtreepageGetSize_rets fnRpc_fnClientBtreepageGetSize ( fnClientBtreepageGetSize_args ) =  111 ;
%
#if RPC_SVC
%
%extern int fnClientBtreepageGetSize
%	(SHORTOBJID oShortObjIdHeap ,
%	  SHORTOBJID oShortObjIdBTreePage);
%
%#ifdef MULTITHREAD
%bool_t
%#else
%fnClientBtreepageGetSize_rets *
%#endif
%	PASTE2(fnrpc_fnclientbtreepagegetsize_1,_SVCSUFFIX)
%		( fnClientBtreepageGetSize_args * pArguments,
%#ifdef MULTITHREAD
%		  fnClientBtreepageGetSize_rets * pResult,
%#endif
%		  struct svc_req * pRequest )
%{
%  static const char	__procedure__[]	= "server:fnrpc_fnclientbtreepagegetsize_1";
%#ifdef MULTITHREAD
%  typedef bool_t RESULTTYPE;
%#else
%  typedef fnClientBtreepageGetSize_rets * RESULTTYPE;
%#endif
%#ifndef MULTITHREAD
%  static fnClientBtreepageGetSize_rets	Result;
%  RESULTTYPE			pResult = &Result;
%#endif
%  LPCSTR	pszErrorMsg;
%
%  __pRequest__	= pRequest;
%
%  RPC_SERVER_ENTRY();
%
%#ifndef MULTITHREAD
%  if ( pResult->pszErrorMsg == szEmpty ) {
%    pResult->pszErrorMsg	= NULL;
%  }
%  xdr_free ( (xdrproc_t) xdr_fnClientBtreepageGetSize_rets, (char *) pResult );
%#endif
%  pResult->nErrorLvl		= 0;
%
%  Reply.bAnswered		= FALSE;
%  Reply.pfnCalled		= (void(*)()) fnClientBtreepageGetSize;
%  Reply.pfnXdrResult		= (bool_t(*)()) xdr_fnClientBtreepageGetSize_rets;
%  Reply.pnErrorLvl		= &pResult->nErrorLvl;
%  Reply.ppszErrorMsg		= (LPCSTR *) &pResult->pszErrorMsg;
%  Reply.pResult		= pResult;
%  Reply.pReturnValue		= &pResult->ReturnValue;
%  Reply.nReturnValueSize	= sizeof ( pResult->ReturnValue );
%
%  pResult->ReturnValue		=
%  fnClientBtreepageGetSize (
%	pArguments->oShortObjIdHeap,
%	pArguments->oShortObjIdBTreePage );
%
%  if ( Reply.bAnswered ) {
%    __pRequest__	= NULL;
%    return (RESULTTYPE) NULL;
%  }
%
%  pResult->nErrorLvl	= RPC_SERVER_ERRLVL();
%  if ( pResult->nErrorLvl > 0 ) {
%    pszErrorMsg		= RPC_SERVER_ERRMSG();
%    if ( pszErrorMsg && *pszErrorMsg ) {
%      pResult->pszErrorMsg	= strdup ( pszErrorMsg );
%    }
%  }
%  if ( pResult->pszErrorMsg == NULL ) {
%#ifdef MULTITHREAD
%    pResult->pszErrorMsg	= strdup ( szEmpty );
%#else
%    pResult->pszErrorMsg	= (LPSTR) szEmpty;
%#endif
%  }
%  __pRequest__	= NULL;
%  return (RESULTTYPE) pResult;
%} /* fnrpc_fnclientbtreepagegetsize_1 */
#endif	/* RPC_SVC */
%
#if RPC_CLNT
%int DLLEXPORT fnClientBtreepageGetSize
%	(SHORTOBJID oShortObjIdHeap ,
%	  SHORTOBJID oShortObjIdBTreePage)
%{
%  static const char	__procedure__[]	= "client:fnClientBtreepageGetSize";
%  static fnClientBtreepageGetSize_rets	ZeroResult;
%  fnClientBtreepageGetSize_rets		* pResult = NULL;
%  fnClientBtreepageGetSize_rets		Result = ZeroResult;
%  fnClientBtreepageGetSize_args	InArguments;
%
%  /* Client initialization: */
%  if ( __bClientInitialize__ ) {
%    __bClientInitialize__	= FALSE;
%    RPC_CLIENT_INITIALIZE();
%  }
%
%#if	CLIENT_CREATE_BY_USER
%  if ( __pClient__ == NULL ) {
%    __pClient__	= RPC_CLIENT_CREATE ( __szHost__, __szTransport__ );
%    if ( __pClient__ == NULL ) {
%      /* Error handling for a not connected client: */
%      char	szError [ 256 ];
%      sprintf ( szError, szFormatNoServer, __procedure__ );
%      RPC_CLIENT_ERROR ( szError );
%      return Result.ReturnValue;
%    }
%  }
%#else
%  while ( __pClient__ == NULL ) {
%    __pClient__	= RPC_CLIENT_CREATE ( __szHost__, __szTransport__ );
%    if ( __pClient__ == NULL ) {
%      /* Error handling for a not connected client: */
%      char	szError [ 256 ];
%      sprintf ( szError, szFormatNoServer, __procedure__ );
%      RPC_CLIENT_CERROR ( szContNoServer, szError );
%    }
%  }
%#endif	/* CLIENT_CREATE_BY_USER */
%
%  /* Copy in the oShortObjIdHeap argument: */
%  InArguments.oShortObjIdHeap	= oShortObjIdHeap;
%  /* Copy in the oShortObjIdBTreePage argument: */
%  InArguments.oShortObjIdBTreePage	= oShortObjIdBTreePage;
%
%  pResult	=
%#ifdef MULTITHREAD
%    (
%#else
%    (fnClientBtreepageGetSize_rets *)
%#endif
%    fnrpc_fnclientbtreepagegetsize_1 (
%	&InArguments,
%#ifdef MULTITHREAD
%	&Result,
%#endif
%	__pClient__ )
%#ifdef MULTITHREAD
%	== RPC_SUCCESS ) ? &Result : NULL
%#endif
%	;
%
%  if ( pResult == NULL ) {
%    /* Error handling for a failed RPC call, */
%    /* i.e. the server did not respond: */
%    char	szError [ 256 ];
%    sprintf ( szError, szFormatRpcFailed, __procedure__,
%              clnt_sperror ( __pClient__, __szHost__ ) );
%    __pClient__	= RPC_CLIENT_DESTROY ( __pClient__ );
%    RPC_CLIENT_CERROR ( szContRpcFailed, szError );
%    Result	= ZeroResult;
%    return Result.ReturnValue;
%  }
%#ifndef MULTITHREAD
%  Result	= * pResult;
%#endif
%
%
%  if ( pResult && pResult->nErrorLvl ) {
%    /* Server returned a user error message: */
%    char	szErrorMsg [ 1024 ];
%    strncpy ( szErrorMsg,
%              ( pResult->pszErrorMsg && pResult->pszErrorMsg [ 0 ] ) ?
%              (LPCSTR) pResult->pszErrorMsg : (LPCSTR) szEmpty,
%              sizeof ( szErrorMsg ) );
%    szErrorMsg [ sizeof ( szErrorMsg ) - 1 ]	= (char) 0;
%    xdr_free ( (xdrproc_t) xdr_fnClientBtreepageGetSize_rets, (char *) pResult );
%    RPC_CLIENT_SERROR ( pResult->nErrorLvl, __procedure__,
%                        szErrorMsg );
%  } else {
%    xdr_free ( (xdrproc_t) xdr_fnClientBtreepageGetSize_rets, (char *) pResult );
%  }
%
%  return Result.ReturnValue;
%
%} /* fnClientBtreepageGetSize */
#endif	/* RPC_CLNT */
%
  fnClientBtreepageItem_rets fnRpc_fnClientBtreepageItem ( fnClientBtreepageItem_args ) =  112 ;
%
#if RPC_SVC
%
%extern int fnClientBtreepageItem
%	(SHORTOBJID oShortObjIdHeap ,
%	  SHORTOBJID oShortObjIdBTreePage ,
%	  int nIndex ,
%	  int nItems ,
%	  int * /* _vector_t<nItems> */  pnValueKey ,
%	  u_int * /* _vector_t<nItems> */  pnTypeTagKey ,
%	  int * /* _vector_t<nItems> */  pnValueData ,
%	  u_int * /* _vector_t<nItems> */  pnTypeTagData ,
%	  u_int * /* _vector_t<nItems> */  poNext);
%
%#ifdef MULTITHREAD
%bool_t
%#else
%fnClientBtreepageItem_rets *
%#endif
%	PASTE2(fnrpc_fnclientbtreepageitem_1,_SVCSUFFIX)
%		( fnClientBtreepageItem_args * pArguments,
%#ifdef MULTITHREAD
%		  fnClientBtreepageItem_rets * pResult,
%#endif
%		  struct svc_req * pRequest )
%{
%  static const char	__procedure__[]	= "server:fnrpc_fnclientbtreepageitem_1";
%#ifdef MULTITHREAD
%  typedef bool_t RESULTTYPE;
%#else
%  typedef fnClientBtreepageItem_rets * RESULTTYPE;
%#endif
%#ifndef MULTITHREAD
%  static fnClientBtreepageItem_rets	Result;
%  RESULTTYPE			pResult = &Result;
%#endif
%  LPCSTR	pszErrorMsg;
%
%  __pRequest__	= pRequest;
%
%  RPC_SERVER_ENTRY();
%
%#ifndef MULTITHREAD
%  if ( pResult->pszErrorMsg == szEmpty ) {
%    pResult->pszErrorMsg	= NULL;
%  }
%  xdr_free ( (xdrproc_t) xdr_fnClientBtreepageItem_rets, (char *) pResult );
%#endif
%  pResult->nErrorLvl		= 0;
%
%  pResult->pnValueKey.int_vector_t_len	= pArguments->pnValueKeySize;
%  if ( pArguments->pnValueKeySize == 0 ) {
%    pResult->pnValueKey.int_vector_t_val	= NULL;
%  } else {
%    pResult->pnValueKey.int_vector_t_val	=
%      (int*) malloc ( pArguments->pnValueKeySize *
%               SIZEOF ( *(pResult->pnValueKey.int_vector_t_val) ) );
%    if ( pResult->pnValueKey.int_vector_t_val == NULL ) {
%      char	szError [ 256 ];
%      sprintf ( szError, szFormatMallocFailed,
%                __procedure__, pArguments->pnValueKeySize,
%                "pnValueKey" );
%      RPC_SERVER_ERROR ( szError );
%      return (RESULTTYPE) NULL;
%    }
%  }
%  pResult->pnTypeTagKey.u_int_vector_t_len	= pArguments->pnTypeTagKeySize;
%  if ( pArguments->pnTypeTagKeySize == 0 ) {
%    pResult->pnTypeTagKey.u_int_vector_t_val	= NULL;
%  } else {
%    pResult->pnTypeTagKey.u_int_vector_t_val	=
%      (u_int*) malloc ( pArguments->pnTypeTagKeySize *
%               SIZEOF ( *(pResult->pnTypeTagKey.u_int_vector_t_val) ) );
%    if ( pResult->pnTypeTagKey.u_int_vector_t_val == NULL ) {
%      char	szError [ 256 ];
%      sprintf ( szError, szFormatMallocFailed,
%                __procedure__, pArguments->pnTypeTagKeySize,
%                "pnTypeTagKey" );
%      RPC_SERVER_ERROR ( szError );
%      return (RESULTTYPE) NULL;
%    }
%  }
%  pResult->pnValueData.int_vector_t_len	= pArguments->pnValueDataSize;
%  if ( pArguments->pnValueDataSize == 0 ) {
%    pResult->pnValueData.int_vector_t_val	= NULL;
%  } else {
%    pResult->pnValueData.int_vector_t_val	=
%      (int*) malloc ( pArguments->pnValueDataSize *
%               SIZEOF ( *(pResult->pnValueData.int_vector_t_val) ) );
%    if ( pResult->pnValueData.int_vector_t_val == NULL ) {
%      char	szError [ 256 ];
%      sprintf ( szError, szFormatMallocFailed,
%                __procedure__, pArguments->pnValueDataSize,
%                "pnValueData" );
%      RPC_SERVER_ERROR ( szError );
%      return (RESULTTYPE) NULL;
%    }
%  }
%  pResult->pnTypeTagData.u_int_vector_t_len	= pArguments->pnTypeTagDataSize;
%  if ( pArguments->pnTypeTagDataSize == 0 ) {
%    pResult->pnTypeTagData.u_int_vector_t_val	= NULL;
%  } else {
%    pResult->pnTypeTagData.u_int_vector_t_val	=
%      (u_int*) malloc ( pArguments->pnTypeTagDataSize *
%               SIZEOF ( *(pResult->pnTypeTagData.u_int_vector_t_val) ) );
%    if ( pResult->pnTypeTagData.u_int_vector_t_val == NULL ) {
%      char	szError [ 256 ];
%      sprintf ( szError, szFormatMallocFailed,
%                __procedure__, pArguments->pnTypeTagDataSize,
%                "pnTypeTagData" );
%      RPC_SERVER_ERROR ( szError );
%      return (RESULTTYPE) NULL;
%    }
%  }
%  pResult->poNext.u_int_vector_t_len	= pArguments->poNextSize;
%  if ( pArguments->poNextSize == 0 ) {
%    pResult->poNext.u_int_vector_t_val	= NULL;
%  } else {
%    pResult->poNext.u_int_vector_t_val	=
%      (u_int*) malloc ( pArguments->poNextSize *
%               SIZEOF ( *(pResult->poNext.u_int_vector_t_val) ) );
%    if ( pResult->poNext.u_int_vector_t_val == NULL ) {
%      char	szError [ 256 ];
%      sprintf ( szError, szFormatMallocFailed,
%                __procedure__, pArguments->poNextSize,
%                "poNext" );
%      RPC_SERVER_ERROR ( szError );
%      return (RESULTTYPE) NULL;
%    }
%  }
%  Reply.bAnswered		= FALSE;
%  Reply.pfnCalled		= (void(*)()) fnClientBtreepageItem;
%  Reply.pfnXdrResult		= (bool_t(*)()) xdr_fnClientBtreepageItem_rets;
%  Reply.pnErrorLvl		= &pResult->nErrorLvl;
%  Reply.ppszErrorMsg		= (LPCSTR *) &pResult->pszErrorMsg;
%  Reply.pResult		= pResult;
%  Reply.pReturnValue		= &pResult->ReturnValue;
%  Reply.nReturnValueSize	= sizeof ( pResult->ReturnValue );
%
%  pResult->ReturnValue		=
%  fnClientBtreepageItem (
%	pArguments->oShortObjIdHeap,
%	pArguments->oShortObjIdBTreePage,
%	pArguments->nIndex,
%	pArguments->nItems,
%	pResult->pnValueKey.int_vector_t_val,
%	pResult->pnTypeTagKey.u_int_vector_t_val,
%	pResult->pnValueData.int_vector_t_val,
%	pResult->pnTypeTagData.u_int_vector_t_val,
%	pResult->poNext.u_int_vector_t_val );
%
%  if ( Reply.bAnswered ) {
%    __pRequest__	= NULL;
%    return (RESULTTYPE) NULL;
%  }
%
%  pResult->nErrorLvl	= RPC_SERVER_ERRLVL();
%  if ( pResult->nErrorLvl > 0 ) {
%    pszErrorMsg		= RPC_SERVER_ERRMSG();
%    if ( pszErrorMsg && *pszErrorMsg ) {
%      pResult->pszErrorMsg	= strdup ( pszErrorMsg );
%    }
%  }
%  if ( pResult->pszErrorMsg == NULL ) {
%#ifdef MULTITHREAD
%    pResult->pszErrorMsg	= strdup ( szEmpty );
%#else
%    pResult->pszErrorMsg	= (LPSTR) szEmpty;
%#endif
%  }
%  __pRequest__	= NULL;
%  return (RESULTTYPE) pResult;
%} /* fnrpc_fnclientbtreepageitem_1 */
#endif	/* RPC_SVC */
%
#if RPC_CLNT
%int DLLEXPORT fnClientBtreepageItem
%	(SHORTOBJID oShortObjIdHeap ,
%	  SHORTOBJID oShortObjIdBTreePage ,
%	  int nIndex ,
%	  int nItems ,
%	  int * /* _vector_t<nItems> */  pnValueKey ,
%	  u_int * /* _vector_t<nItems> */  pnTypeTagKey ,
%	  int * /* _vector_t<nItems> */  pnValueData ,
%	  u_int * /* _vector_t<nItems> */  pnTypeTagData ,
%	  u_int * /* _vector_t<nItems> */  poNext)
%{
%  static const char	__procedure__[]	= "client:fnClientBtreepageItem";
%  static fnClientBtreepageItem_rets	ZeroResult;
%  fnClientBtreepageItem_rets		* pResult = NULL;
%  fnClientBtreepageItem_rets		Result = ZeroResult;
%  fnClientBtreepageItem_args	InArguments;
%
%  /* Client initialization: */
%  if ( __bClientInitialize__ ) {
%    __bClientInitialize__	= FALSE;
%    RPC_CLIENT_INITIALIZE();
%  }
%
%#if	CLIENT_CREATE_BY_USER
%  if ( __pClient__ == NULL ) {
%    __pClient__	= RPC_CLIENT_CREATE ( __szHost__, __szTransport__ );
%    if ( __pClient__ == NULL ) {
%      /* Error handling for a not connected client: */
%      char	szError [ 256 ];
%      sprintf ( szError, szFormatNoServer, __procedure__ );
%      RPC_CLIENT_ERROR ( szError );
%      return Result.ReturnValue;
%    }
%  }
%#else
%  while ( __pClient__ == NULL ) {
%    __pClient__	= RPC_CLIENT_CREATE ( __szHost__, __szTransport__ );
%    if ( __pClient__ == NULL ) {
%      /* Error handling for a not connected client: */
%      char	szError [ 256 ];
%      sprintf ( szError, szFormatNoServer, __procedure__ );
%      RPC_CLIENT_CERROR ( szContNoServer, szError );
%    }
%  }
%#endif	/* CLIENT_CREATE_BY_USER */
%
%  /* Copy in the oShortObjIdHeap argument: */
%  InArguments.oShortObjIdHeap	= oShortObjIdHeap;
%  /* Copy in the oShortObjIdBTreePage argument: */
%  InArguments.oShortObjIdBTreePage	= oShortObjIdBTreePage;
%  /* Copy in the nIndex argument: */
%  InArguments.nIndex	= nIndex;
%  /* Copy in the nItems argument: */
%  InArguments.nItems	= nItems;
%  InArguments.pnValueKeySize	= nItems;
%  InArguments.pnTypeTagKeySize	= nItems;
%  InArguments.pnValueDataSize	= nItems;
%  InArguments.pnTypeTagDataSize	= nItems;
%  InArguments.poNextSize	= nItems;
%
%  pResult	=
%#ifdef MULTITHREAD
%    (
%#else
%    (fnClientBtreepageItem_rets *)
%#endif
%    fnrpc_fnclientbtreepageitem_1 (
%	&InArguments,
%#ifdef MULTITHREAD
%	&Result,
%#endif
%	__pClient__ )
%#ifdef MULTITHREAD
%	== RPC_SUCCESS ) ? &Result : NULL
%#endif
%	;
%
%  if ( pResult == NULL ) {
%    /* Error handling for a failed RPC call, */
%    /* i.e. the server did not respond: */
%    char	szError [ 256 ];
%    sprintf ( szError, szFormatRpcFailed, __procedure__,
%              clnt_sperror ( __pClient__, __szHost__ ) );
%    __pClient__	= RPC_CLIENT_DESTROY ( __pClient__ );
%    RPC_CLIENT_CERROR ( szContRpcFailed, szError );
%    Result	= ZeroResult;
%    return Result.ReturnValue;
%  }
%#ifndef MULTITHREAD
%  Result	= * pResult;
%#endif
%
%  /* Copy out the pnValueKey argument: */
%  if ( ! ( 
%       pResult->pnValueKey.int_vector_t_len != 0 &&
%       pnValueKey == NULL ) ) {
%    memcpy ( pnValueKey,
%             pResult->pnValueKey.int_vector_t_val,
%             MIN ( pResult->pnValueKey.int_vector_t_len,
%                   nItems ) *
%             SIZEOF ( *(pResult->pnValueKey.int_vector_t_val) ) );
%  }
%  /* Copy out the pnTypeTagKey argument: */
%  if ( ! ( 
%       pResult->pnTypeTagKey.u_int_vector_t_len != 0 &&
%       pnTypeTagKey == NULL ) ) {
%    memcpy ( pnTypeTagKey,
%             pResult->pnTypeTagKey.u_int_vector_t_val,
%             MIN ( pResult->pnTypeTagKey.u_int_vector_t_len,
%                   nItems ) *
%             SIZEOF ( *(pResult->pnTypeTagKey.u_int_vector_t_val) ) );
%  }
%  /* Copy out the pnValueData argument: */
%  if ( ! ( 
%       pResult->pnValueData.int_vector_t_len != 0 &&
%       pnValueData == NULL ) ) {
%    memcpy ( pnValueData,
%             pResult->pnValueData.int_vector_t_val,
%             MIN ( pResult->pnValueData.int_vector_t_len,
%                   nItems ) *
%             SIZEOF ( *(pResult->pnValueData.int_vector_t_val) ) );
%  }
%  /* Copy out the pnTypeTagData argument: */
%  if ( ! ( 
%       pResult->pnTypeTagData.u_int_vector_t_len != 0 &&
%       pnTypeTagData == NULL ) ) {
%    memcpy ( pnTypeTagData,
%             pResult->pnTypeTagData.u_int_vector_t_val,
%             MIN ( pResult->pnTypeTagData.u_int_vector_t_len,
%                   nItems ) *
%             SIZEOF ( *(pResult->pnTypeTagData.u_int_vector_t_val) ) );
%  }
%  /* Copy out the poNext argument: */
%  if ( ! ( 
%       pResult->poNext.u_int_vector_t_len != 0 &&
%       poNext == NULL ) ) {
%    memcpy ( poNext,
%             pResult->poNext.u_int_vector_t_val,
%             MIN ( pResult->poNext.u_int_vector_t_len,
%                   nItems ) *
%             SIZEOF ( *(pResult->poNext.u_int_vector_t_val) ) );
%  }
%
%  if ( pResult && pResult->nErrorLvl ) {
%    /* Server returned a user error message: */
%    char	szErrorMsg [ 1024 ];
%    strncpy ( szErrorMsg,
%              ( pResult->pszErrorMsg && pResult->pszErrorMsg [ 0 ] ) ?
%              (LPCSTR) pResult->pszErrorMsg : (LPCSTR) szEmpty,
%              sizeof ( szErrorMsg ) );
%    szErrorMsg [ sizeof ( szErrorMsg ) - 1 ]	= (char) 0;
%    xdr_free ( (xdrproc_t) xdr_fnClientBtreepageItem_rets, (char *) pResult );
%    RPC_CLIENT_SERROR ( pResult->nErrorLvl, __procedure__,
%                        szErrorMsg );
%  } else {
%    xdr_free ( (xdrproc_t) xdr_fnClientBtreepageItem_rets, (char *) pResult );
%  }
%  if ( 
%       pResult->pnValueKey.int_vector_t_len != 0 &&
%       pnValueKey == NULL ) {
%    /* Error handling for passing a NULL pointer on */
%    /* out argument: */
%    char	szError [ 256 ];
%    sprintf ( szError, szFormatNullPassed,
%              __procedure__, "pnValueKey" );
%    RPC_CLIENT_CERROR ( szContNullOutPassed, szError );
%  } else if ( pResult->pnValueKey.int_vector_t_len > nItems ) {
%      /* Error handling for an output buffer overflow, */
%      /* i.e. the buffer size passed is too small: */
%      /* For example, signal a CERROR here ... */
%      char	szError [ 256 ];
%      sprintf ( szError, szFormatBufferOverflow,
%                __procedure__, "pnValueKey", 
%                nItems, 
%                pResult->pnValueKey.int_vector_t_len );
%      RPC_CLIENT_CERROR ( szContBufferOverflow, szError );
%  }
%  if ( 
%       pResult->pnTypeTagKey.u_int_vector_t_len != 0 &&
%       pnTypeTagKey == NULL ) {
%    /* Error handling for passing a NULL pointer on */
%    /* out argument: */
%    char	szError [ 256 ];
%    sprintf ( szError, szFormatNullPassed,
%              __procedure__, "pnTypeTagKey" );
%    RPC_CLIENT_CERROR ( szContNullOutPassed, szError );
%  } else if ( pResult->pnTypeTagKey.u_int_vector_t_len > nItems ) {
%      /* Error handling for an output buffer overflow, */
%      /* i.e. the buffer size passed is too small: */
%      /* For example, signal a CERROR here ... */
%      char	szError [ 256 ];
%      sprintf ( szError, szFormatBufferOverflow,
%                __procedure__, "pnTypeTagKey", 
%                nItems, 
%                pResult->pnTypeTagKey.u_int_vector_t_len );
%      RPC_CLIENT_CERROR ( szContBufferOverflow, szError );
%  }
%  if ( 
%       pResult->pnValueData.int_vector_t_len != 0 &&
%       pnValueData == NULL ) {
%    /* Error handling for passing a NULL pointer on */
%    /* out argument: */
%    char	szError [ 256 ];
%    sprintf ( szError, szFormatNullPassed,
%              __procedure__, "pnValueData" );
%    RPC_CLIENT_CERROR ( szContNullOutPassed, szError );
%  } else if ( pResult->pnValueData.int_vector_t_len > nItems ) {
%      /* Error handling for an output buffer overflow, */
%      /* i.e. the buffer size passed is too small: */
%      /* For example, signal a CERROR here ... */
%      char	szError [ 256 ];
%      sprintf ( szError, szFormatBufferOverflow,
%                __procedure__, "pnValueData", 
%                nItems, 
%                pResult->pnValueData.int_vector_t_len );
%      RPC_CLIENT_CERROR ( szContBufferOverflow, szError );
%  }
%  if ( 
%       pResult->pnTypeTagData.u_int_vector_t_len != 0 &&
%       pnTypeTagData == NULL ) {
%    /* Error handling for passing a NULL pointer on */
%    /* out argument: */
%    char	szError [ 256 ];
%    sprintf ( szError, szFormatNullPassed,
%              __procedure__, "pnTypeTagData" );
%    RPC_CLIENT_CERROR ( szContNullOutPassed, szError );
%  } else if ( pResult->pnTypeTagData.u_int_vector_t_len > nItems ) {
%      /* Error handling for an output buffer overflow, */
%      /* i.e. the buffer size passed is too small: */
%      /* For example, signal a CERROR here ... */
%      char	szError [ 256 ];
%      sprintf ( szError, szFormatBufferOverflow,
%                __procedure__, "pnTypeTagData", 
%                nItems, 
%                pResult->pnTypeTagData.u_int_vector_t_len );
%      RPC_CLIENT_CERROR ( szContBufferOverflow, szError );
%  }
%  if ( 
%       pResult->poNext.u_int_vector_t_len != 0 &&
%       poNext == NULL ) {
%    /* Error handling for passing a NULL pointer on */
%    /* out argument: */
%    char	szError [ 256 ];
%    sprintf ( szError, szFormatNullPassed,
%              __procedure__, "poNext" );
%    RPC_CLIENT_CERROR ( szContNullOutPassed, szError );
%  } else if ( pResult->poNext.u_int_vector_t_len > nItems ) {
%      /* Error handling for an output buffer overflow, */
%      /* i.e. the buffer size passed is too small: */
%      /* For example, signal a CERROR here ... */
%      char	szError [ 256 ];
%      sprintf ( szError, szFormatBufferOverflow,
%                __procedure__, "poNext", 
%                nItems, 
%                pResult->poNext.u_int_vector_t_len );
%      RPC_CLIENT_CERROR ( szContBufferOverflow, szError );
%  }
%
%  return Result.ReturnValue;
%
%} /* fnClientBtreepageItem */
#endif	/* RPC_CLNT */
%
  } = 1;
} = 0x20506E62;
#ifdef RPC_SVC
%int fnMain ();
%int main (int argc, char * argv [] )
%{
%  static const char	__procedure__[]	 = "main";
%
%  RPC_SERVER_INITIALIZE ( argc, argv );
%
%  fnMain ();
%
%  return 0;
%} /* main */
%#define main fnMain
#endif	/* RPC_SVC */
%
%/* ------------------------------------------------------------------------
%| End of plobd.x
% ----------------------------------------------------------------------- */
